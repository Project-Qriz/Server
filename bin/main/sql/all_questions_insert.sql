-- --------------------------------------------------------
-- 호스트:                          127.0.0.1
-- 서버 버전:                        8.0.33 - MySQL Community Server - GPL
-- 서버 OS:                        Win64
-- HeidiSQL 버전:                  11.3.0.6295
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!50503 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


-- 테이블 데이터 qriz.question:~1,320 rows (대략적) 내보내기
/*!40000 ALTER TABLE `question` DISABLE KEYS */;
INSERT INTO `question` (`question_id`, `category`, `description`, `difficulty`, `exam_session`, `question`, `solution`, `time_limit`, `skill_id`) VALUES
	(1, 2, NULL, 1, NULL, '다음 중 데이터 모델링의 특징으로 가장 부적절한 것은?', '데이터 모델은 물리적인 저장 구조와 독립적이어야 합니다. 이는 논리적 데이터 모델과 물리적 데이터 모델의 분리를 통해 유연성을 확보할 수 있게 합니다.', 60, 1),
	(2, 2, NULL, 2, NULL, '다음 중 ERD(Entity Relationship Diagram)에서 사용되는 관계 차수의 표현으로 올바른 것은?', '1:1 관계는 한 개체의 하나의 인스턴스가 다른 개체의 하나의 인스턴스와 관계를 갖는 것을 의미합니다. 예를 들어, 한 사람이 하나의 주민등록번호를 갖는 관계가 있습니다.', 120, 1),
	(3, 2, NULL, 2, NULL, '다음 중 엔터티(Entity)의 특징으로 가장 적절하지 않은 것은?', '엔터티는 다른 엔터티와 반드시 관계를 가질 필요는 없습니다. 독립적으로 존재할 수 있는 엔터티도 있을 수 있습니다. 중요한 것은 해당 엔터티가 업무적으로 의미가 있고, 식별이 가능하며, 속성을 가져야 한다는 점입니다.', 120, 1),
	(4, 2, NULL, 3, NULL, '다음 중 정규화에 대한 설명으로 가장 올바른 것은?', '제1정규형(1NF)은 테이블의 모든 속성이 원자값을 가지도록 하는 것입니다. 이는 복합 속성을 분해하고 반복 속성을 제거하는 과정을 포함합니다.', 180, 1),
	(5, 2, '[상황]\n대학교 수강신청 시스템에서 수강신청 테이블을 설계하려고 합니다.\n- 한 학생은 여러 과목을 신청할 수 있습니다.\n- 한 과목은 여러 학생이 신청할 수 있습니다.\n- 동일한 과목이라도 분반이 다를 수 있습니다.\n- 한 학생이 동일한 과목을 중복 신청할 수 없습니다.', 3, NULL, '다음 상황에서 가장 적절한 식별자 선정 방식은?', '학번과 과목코드를 복합키로 설정하는 것이 가장 적절합니다. 분반은 과목코드에 포함될 수 있으며, 한 학생이 동일한 과목을 중복 신청할 수 없다는 요구사항을 만족시키기 위해서는 학번과 과목코드의 조합으로 유일성을 보장해야 합니다.', 180, 1),
	(6, 2, NULL, 1, NULL, '데이터 모델에서 \'속성(Attribute)\'에 대한 설명으로 옳은 것은?', '속성은 업무에서 관리하고자 하는 항목으로, 엔터티가 가지는 항목이나 성질을 의미합니다. 속성은 엔터티에 종속적이며, 하나의 엔터티 내에서 같은 이름으로 중복될 수 없습니다.', 60, 1),
	(7, 2, NULL, 1, NULL, '다음 중 개념적 데이터 모델링 단계에서 수행하는 작업이 아닌 것은?', '인덱스 정의는 물리적 데이터 모델링 단계에서 수행하는 작업입니다. 개념적 데이터 모델링에서는 업무 분석을 통한 핵심 엔터티 도출, 엔터티 간의 관계 설정, 주요 속성 식별 등을 수행합니다.', 60, 1),
	(8, 2, NULL, 2, NULL, '다음 중 슈퍼타입/서브타입 관계에 대한 설명으로 올바른 것은?', '서브타입 엔터티는 슈퍼타입 엔터티의 인스턴스와 1:1 관계를 가집니다. 서브타입은 슈퍼타입의 속성을 상속받으며, 한 엔터티는 다중 상속이 가능하고, 서브타입 간의 관계도 설정할 수 있습니다.', 120, 1),
	(9, 2, NULL, 2, NULL, '다음 중 반정규화(Denormalization)를 고려해야 하는 상황으로 가장 적절한 것은?', '반정규화는 성능 향상을 위해 정규화된 데이터 모델을 의도적으로 통합하거나 중복을 허용하는 것입니다. 특히 조인이 자주 발생하는 테이블의 조회 성능 개선이 필요한 경우 반정규화를 고려할 수 있습니다.', 120, 1),
	(10, 2, '[상황]\n회사의 조직도를 데이터 모델로 설계하려고 합니다.\n- 모든 부서는 상위 부서를 가질 수 있습니다.\n- 최상위 부서는 상위 부서가 없습니다.\n- 부서는 여러 개의 하위 부서를 가질 수 있습니다.\n- 부서의 계층 구조는 언제든지 변경될 수 있습니다.', 3, NULL, '다음과 같은 상황에서 가장 적절한 모델링 방식은?', '이러한 계층 구조는 자기참조 관계를 사용하여 설계하는 것이 가장 적절합니다. 부서 테이블에 상위부서ID를 외래키로 설정하면 유연한 계층 구조를 표현할 수 있으며, 구조 변경에도 용이합니다.', 180, 1),
	(11, 2, NULL, 1, NULL, '다음 중 엔터티(Entity)의 특징으로 가장 부적절한 것은?', '엔터티가 되기 위한 필수 조건은:\n1. 업무적으로 관리가 필요한 정보\n2. 유일한 식별자로 식별 가능\n3. 두 개 이상의 인스턴스의 존재\n\n속성을 반드시 가질 필요는 없으며, 관계 엔터티의 경우 식별자만으로 구성될 수도 있습니다.', 60, 2),
	(12, 2, NULL, 2, NULL, '다음 중 엔터티 분류에 대한 설명으로 가장 올바른 것은?', '엔터티 유형별 특징:\n1. 기본 엔터티: 독립적으로 생성 가능한 엔터티\n2. 중심 엔터티: 기본 엔터티로부터 발생하고 행위 엔터티의 부모가 되는 엔터티\n3. 행위 엔터티: 두 개 이상의 엔터티간 행위로 발생하는 엔터티\n4. 코드 엔터티: 각종 코드성 데이터를 관리하는 엔터티', 120, 2),
	(13, 2, '[업무 상황]\n1. 고객이 상품을 주문한다\n2. 한 번의 주문에 여러 상품을 담을 수 있다\n3. 상품의 재고는 실시간으로 관리되어야 한다\n4. 주문 상태는 \'주문\', \'결제\', \'배송\', \'완료\' 로 관리된다', 2, NULL, '다음과 같은 상황에서 적절한 엔터티 도출 방식은?', '엔터티 도출 분석:\n1. 기본 엔터티\n   - 고객: 독립적으로 생성되는 마스터 데이터\n   - 상품: 독립적으로 생성되는 마스터 데이터\n2. 중심 엔터티\n   - 주문: 고객으로부터 발생하는 중심 데이터\n3. 행위 엔터티\n   - 주문상품: 주문과 상품의 관계에서 발생\n4. 코드 엔터티\n   - 주문상태: 상태 값을 관리하는 코드성 데이터', 120, 2),
	(14, 2, '[현재 설계]\n1. 회원(회원ID, 회원명, 등급, 포인트)\n2. 등급(등급코드, 등급명, 최소포인트, 최대포인트)\n3. 주문(주문ID, 회원ID, 주문금액, 적립포인트, 등급할인율)', 3, NULL, '다음의 엔터티 설계에서 잘못된 부분을 찾고, 가장 적절한 해결 방안은?', '엔터티 설계의 문제점과 해결방안:\n1. 문제점:\n   - 회원의 등급 정보가 독립 엔터티로 관리되지 않음\n   - 등급 정보의 일관성 유지가 어려움\n2. 해결방안:\n   - 회원 엔터티의 등급을 등급코드(FK)로 변경\n   - 등급 관련 정보는 등급 엔터티에서 통합 관리\n3. 기대효과:\n   - 데이터 정합성 향상\n   - 등급 정보 변경 시 용이한 관리\n   - 확장성 확보', 180, 2),
	(15, 2, '[요구사항]\n1. 사용자는 게시글을 작성할 수 있다\n2. 게시글에는 여러 개의 첨부파일을 등록할 수 있다\n3. 사용자는 게시글에 댓글을 달 수 있다\n4. 댓글에 대한 답글(대댓글)도 가능하다\n5. 게시글과 댓글에 대한 좋아요 기능이 있다', 3, NULL, '다음과 같은 시스템 요구사항에서 가장 적절한 엔터티 설계는?', '요구사항 분석과 엔터티 도출:\n1. 기본 엔터티\n   - 사용자: 독립적으로 존재하는 마스터 데이터\n2. 중심 엔터티\n   - 게시글: 사용자로부터 발생하는 주요 데이터\n   - 댓글: 게시글에 종속적이지만 독자적인 특성을 가짐\n3. 행위 엔터티\n   - 게시글첨부파일: 게시글과 파일의 관계\n   - 게시글좋아요: 사용자와 게시글의 행위\n   - 댓글좋아요: 사용자와 댓글의 행위', 180, 2),
	(16, 2, NULL, 1, NULL, '다음 중 엔터티를 도출하는 방법으로 가장 적절하지 않은 것은?', '엔터티 도출 시 중요한 것은 해당 업무에서 필요한 정보이며, 속성의 개수는 엔터티 도출의 판단 기준이 되지 않습니다.\n\n영속적인 정보여야 하고, 업무적으로 관리가 필요하며, 식별 가능하고, 두 개 이상의 인스턴스가 존재해야 합니다.', 60, 2),
	(17, 2, NULL, 2, NULL, '다음 중 파생 엔터티(Derived Entity)에 대한 설명으로 가장 올바른 것은?', '파생 엔터티는 다른 엔터티의 부분집합으로 생성되는 엔터티로, 상위 엔터티의 식별자를 상속받아 식별자로 사용합니다.\n\n독립적인 식별자를 가질 필요는 없으며, M:N 관계 해결을 위한 것만은 아닙니다.', 120, 2),
	(18, 2, '[상황]\n1. 직원 정보를 관리하는 시스템을 구축한다\n2. 직원은 부서에 소속되며, 부서 이동이 가능하다\n3. 직원의 부서 이동 이력을 관리해야 한다\n4. 이력 관리 시 해당 기간의 직급도 함께 관리한다', 2, NULL, '다음 상황에서 올바른 엔터티 식별자 지정 방식은?', '직원 이력 관리를 위한 식별자 지정 시:\n1. 이력번호를 주식별자로 지정하여 각 이력을 고유하게 식별\n2. 직원번호를 외래키로 지정하여 직원과의 관계 표현\n3. 시작일자는 이력관리를 위한 속성으로 처리\n4. 이를 통해 동일 직원의 여러 이력을 효과적으로 관리 가능', 120, 2),
	(19, 2, '[현재 설계]\n1. 프로젝트(프로젝트ID, 프로젝트명, PM사원번호)\n2. 프로젝트인력(프로젝트ID, 사원번호, 역할, 참여시작일자)\n3. 사원(사원번호, 사원명, 소속부서, 직급)\n4. PM정보(PM사원번호, PM등급, 수행프로젝트수)', 3, NULL, '다음 엔터티 설계의 문제점을 찾고, 가장 적절한 해결 방안은?', '현재 설계의 분석:\n1. PM은 사원의 특수한 형태로, 추가적인 정보가 필요\n2. PM정보는 사원 정보에 종속적이지만 독립적인 특성을 가짐\n\n해결방안:\n- PM정보를 별도 엔터티로 유지\n- 사원 엔터티와 1:1 관계 설정\n- PM의 특수 속성을 독립적으로 관리\n\n기대효과:\n- PM 관련 정보의 무결성 확보\n- 유연한 확장성 제공', 180, 2),
	(20, 2, '[요구사항]\n1. 병원의 진료 예약 시스템을 구축한다\n2. 환자는 여러 진료과에 예약할 수 있다\n3. 한 진료과에는 여러 의사가 있다\n4. 의사는 요일별로 진료 시간이 다르다\n5. 예약은 30분 단위로 관리된다\n6. 예약 취소 시 취소 사유를 관리한다', 3, NULL, '다음 요구사항에 따른 엔터티 설계 시 고려사항으로 가장 적절한 것은?', '요구사항 분석 및 설계 방향:\n1. 기본 엔터티:\n   - 환자, 진료과, 의사\n2. 중심 엔터티:\n   - 예약\n3. 행위 엔터티:\n   - 의사일정: 의사의 요일별 진료시간 관리\n   - 예약취소: 취소 사유 관리\n\n고려사항:\n- 의사일정을 별도 엔터티로 관리하여 유연성 확보\n- 시간대별 예약 관리를 위한 구조 필요\n- 취소 이력 관리를 위한 구조 필요', 180, 2),
	(21, 2, NULL, 1, NULL, '다음 중 속성(Attribute)의 특징으로 가장 부적절한 것은?', '속성은 반드시 특정 엔터티에 포함될 필요는 없습니다. 속성은 독립적으로 존재할 수 있으며, 어떤 속성은 여러 엔터티에서 공통으로 사용될 수도 있고, 특정 엔터티에만 속할 수도 있습니다.', 60, 3),
	(22, 2, NULL, 2, NULL, '다음 중 속성의 종류를 설명한 것으로 가장 올바른 것은?', '- 기본속성: 업무로부터 직접 생성되는 속성(이름, 주민번호 등)\n- 설계속성: 업무를 위해 설계자가 추가한 속성(상품코드 등)\n- 파생속성: 다른 속성에서 계산되거나 변형된 속성(나이, 총합 등)\n- 복합속성: 여러 속성이 모여 구성된 속성(주소 = 시/군/구/동/번지)', 120, 3),
	(23, 2, '[주문] 엔터티\n- 주문번호\n- 주문일자\n- 배송비\n- 주문총액 (상품구매금액 + 배송비)\n- 적립포인트 (주문총액의 1%)\n- 회원ID', 2, NULL, '다음은 쇼핑몰 데이터베이스의 일부입니다. 속성의 유형이 다른 하나는?', '적립포인트는 파생속성입니다. 주문총액의 1%로 계산되는 값으로, 다른 속성으로부터 도출됩니다. 나머지는 모두 기본속성으로, 업무로부터 직접 생성되는 속성입니다.', 120, 3),
	(24, 2, '[상황]\n대학교 학사관리 시스템에서 \'학생\' 엔터티를 설계하려고 합니다.\n- 학생의 주소는 도로명주소와 지번주소를 모두 저장해야 합니다.\n- 주소 변경 이력을 관리해야 합니다.\n- 학생의 평균평점은 매 학기 성적이 입력될 때마다 갱신되어야 합니다.', 3, NULL, '다음 상황에서 가장 적절한 속성 설계는?', '주소 정보의 이력 관리를 위해서는 별도의 엔터티로 분리하고 시작일자, 종료일자 속성을 추가하는 것이 적절합니다. 평균평점은 파생속성으로 설계해야 하며, 주소 정보는 이력관리를 위해 별도 엔터티로 관리하는 것이 바람직합니다.', 180, 3),
	(25, 2, '[속성 예시]\n1. 회원등급: VIP, Gold, Silver, Bronze\n2. 성별: 남성/여성\n3. 재직여부: Y/N\n4. 부서코드: 영업부(S), 관리부(M), 개발부(D)', 3, NULL, '다음 중 속성의 데이터 표현 방법으로 가장 부적절한 것은?', '코드성 속성은 반드시 숫자형으로 정의할 필요가 없습니다. 부서코드의 경우 업무적 의미를 담은 문자형으로 정의하는 것이 가독성과 유지보수 측면에서 더 유리할 수 있습니다. 중요한 것은 일관성 있는 규칙을 적용하는 것입니다.', 180, 3),
	(26, 2, NULL, 1, NULL, '다음 중 단일값 속성(Single Value Attribute)에 대한 설명으로 가장 적절한 것은?', '단일값 속성은 하나의 속성이 한 개의 값만을 가질 수 있는 속성을 의미합니다. 예를 들어 주민등록번호, 직원번호 등이 이에 해당합니다.', 60, 3),
	(27, 2, '[상황]\n온라인 서점의 \'도서\' 엔터티에서 다음 정보를 관리하려고 합니다.\n- 도서의 저자는 1명 이상이 될 수 있음\n- 도서는 여러 개의 카테고리에 속할 수 있음\n- 도서의 평점은 독자들의 별점 평균값임\n- ISBN은 국제표준도서번호임', 2, NULL, '다음 중 가장 적절한 속성 설계는?', '저자, 카테고리는 다중값을 가지므로 별도의 엔터티로 설계해야 합니다.\nISBN은 업무로부터 직접 생성되는 기본속성입니다.\n평점은 별점의 평균이므로 파생속성으로 설계해야 합니다.', 120, 3),
	(28, 2, NULL, 2, NULL, '다음 중 속성의 도메인(Domain)을 정의한 것으로 가장 부적절한 것은?', '나이의 도메인 정의에서 0은 적절하지 않습니다. 일반적으로 나이는 1 이상의 값을 가지며, 150이라는 상한값도 현실적이지 않을 수 있습니다. 도메인 정의 시에는 업무 규칙과 현실적인 제약을 고려해야 합니다.', 120, 3),
	(29, 2, '[현재 설계]\n주문(\n  주문번호(PK),\n  주문일시,\n  회원ID(FK),\n  배송주소_도로명,\n  배송주소_지번,\n  배송주소_우편번호,\n  수령자명,\n  수령자전화번호1,\n  수령자전화번호2,\n  수령자전화번호3,\n  주문상태(1:주문,2:결제,3:배송,4:완료),\n  주문금액,\n  할인금액,\n  결제금액,\n  적립포인트\n)', 3, NULL, '다음과 같은 \'주문\' 엔터티의 속성 설계에서 개선이 필요한 부분을 찾고, 가장 적절한 해결 방안은?', '현재 설계의 문제점:\n- 배송지 정보가 주문 엔터티에 직접 포함됨\n- 동일 배송지 정보의 중복 가능성\n- 배송지 이력 관리 어려움\n\n개선 방안:\n- 배송지 정보를 별도 엔터티로 분리\n- 배송지 정보의 재사용성 확보\n- 배송지 이력 관리 가능', 180, 3),
	(30, 2, '[요구사항]\n1. 고객의 보유 포인트는 실시간으로 갱신되어야 한다\n2. 포인트 적립/사용 내역을 기간별로 조회할 수 있어야 한다\n3. 포인트 만료일은 적립일로부터 1년이다\n4. 포인트는 먼저 적립된 것부터 사용된다\n5. 고객별 포인트 사용 통계를 월별로 집계해야 한다', 3, NULL, '다음 요구사항에 따른 속성 설계 시 고려사항으로 가장 적절한 것은?', '설계 고려사항:\n- 실시간 포인트 관리 필요\n- 이력 관리 필요\n- 만료일 자동 계산\n- FIFO 방식의 포인트 사용\n\n해결방안:\n- 포인트 이력 테이블 별도 생성\n- 고객의 보유 포인트는 이력의 합계로 계산\n- 만료일은 적립일 기준 자동 계산\n\n기대효과:\n- 정확한 포인트 관리\n- 유연한 통계 집계\n- 명확한 이력 관리', 180, 3),
	(31, 2, NULL, 1, NULL, '다음 중 식별자의 특성으로 가장 부적절한 것은?', '식별자의 최소성은 식별자를 구성하는 속성의 수가 최소가 되어야 함을 의미합니다. 불필요하게 많은 속성으로 식별자를 구성하면 관리가 복잡해지고 성능에도 영향을 미칠 수 있습니다.', 60, 4),
	(32, 2, '[학생 테이블]\n- 학번\n- 주민등록번호\n- 이름\n- 전화번호\n- 학과코드\n- 입학일자\n- 학년', 2, NULL, '다음 중 후보키(Candidate Key)가 될 수 있는 것은?', '후보키의 조건:\n1. 유일성: 중복된 값이 없어야 함\n2. 최소성: 불필요한 속성이 포함되지 않아야 함\n\n분석:\n- 학번: 유일성과 최소성 모두 만족\n- 주민등록번호: 유일성과 최소성 모두 만족 (후보키 가능)\n- 기타 조합: 유일성을 보장할 수 없음', 120, 4),
	(33, 2, '[상황]\n온라인 쇼핑몰의 주문 관리 시스템\n1. 하나의 주문에 여러 상품이 포함될 수 있다\n2. 동일한 상품을 여러 번 주문할 수 있다\n3. 주문 취소 시 이력 관리가 필요하다\n4. 주문 상품의 가격은 시점에 따라 다를 수 있다', 2, NULL, '다음과 같은 상황에서 가장 적절한 식별자 선정 방식은?', '적절한 식별자 선정 이유:\n1. 주문(orders) 테이블:\n   - 인조식별자(order_id) 사용으로 안정성 확보\n   - 자연키 사용 시 발생할 수 있는 변경 위험 회피\n\n2. 주문상품(order_items) 테이블:\n   - 개별 식별자(order_item_id) 부여로 이력 관리 용이\n   - 복합키 사용 시 발생할 수 있는 참조 무결성 제약 회피', 120, 4),
	(34, 2, '[게시판]        [게시글]        [첨부파일]\nBOARD_ID       POST_ID         FILE_ID\nBOARD_NAME     BOARD_ID        POST_ID\n              TITLE           FILE_NAME\n              CONTENT         FILE_PATH', 3, NULL, '다음과 같은 ERD에서 가장 적절한 식별자 관계 설정은?', '비식별관계를 선택한 이유:\n1. 유연성:\n   - 게시글이나 파일의 독립적인 관리 가능\n   - 게시판 이동이나 구조 변경 시 유연한 대응\n\n2. 성능:\n   - 단순한 키 구조로 인한 조인 성능 향상\n   - 인덱스 크기 감소\n\n3. 관리 용이성:\n   - 단순한 참조 구조\n   - 데이터 이관이나 백업이 용이', 180, 4),
	(35, 2, '[요구사항]\n1. 직원은 여러 프로젝트에 참여할 수 있다\n2. 프로젝트별로 직원의 역할이 다를 수 있다\n3. 직원의 역할은 시작일자와 종료일자를 가진다\n4. 동일 프로젝트에서 직원의 역할은 기간별로 변경될 수 있다\n5. 이력 관리가 필요하다', 3, NULL, '다음과 같은 시스템 요구사항에서 가장 적절한 식별자 설계는?', '요구사항을 만족하는 이유:\n1. 이력관리를 위한 독립적인 식별자(MEMBER_ID) 사용\n2. 동일 프로젝트/직원의 역할 변경 이력 관리 가능\n3. 기간 중첩 체크 가능\n4. 참조 무결성 제약조건 설정 용이\n5. 조회 성능 향상', 180, 4),
	(36, 2, NULL, 1, NULL, '다음 중 대체식별자(Surrogate Key)의 특징으로 가장 적절하지 않은 것은?', '대체식별자가 자연식별자보다 항상 더 나은 것은 아닙니다. 상황에 따라 적절한 식별자를 선택해야 합니다. 예를 들어, 주민등록번호나 사업자등록번호처럼 업무적으로 중요하고 변경이 거의 없는 경우에는 자연식별자가 더 적절할 수 있습니다.', 60, 4),
	(37, 2, '[상황]\n회사의 조직도 관리 시스템\n- 부서는 부서코드(3자리)와 부서명을 가진다\n- 직원은 사번(5자리)을 부여받는다\n- 직원은 하나의 부서에 소속된다\n- 부서별 직원의 이력 관리가 필요하다', 2, NULL, '다음의 식별자 선정 방식 중 가장 적절한 것은?', '이력 관리를 위해서는 별도의 식별자(HISTORY_ID)를 사용하는 것이 가장 적절합니다. \n1. 유연성: 부서 이동 이력을 자유롭게 관리 가능\n2. 성능: 단순한 키 구조로 인한 조회 성능 향상\n3. 이력 관리: 시간의 흐름에 따른 모든 변경 사항 추적 가능', 120, 4),
	(38, 2, NULL, 2, NULL, '다음 중 식별관계 적용이 가장 적절한 경우는?', '식별관계는 부모 테이블의 기본키가 자식 테이블의 기본키이자 외래키가 되는 관계입니다.\n공통코드와 상세코드의 관계에서는:\n1. 상세코드가 공통코드에 종속적\n2. 공통코드 없이 상세코드가 존재할 수 없음\n3. 계층적 구조를 명확하게 표현 가능\n따라서 식별관계 적용이 가장 적절합니다.', 120, 4),
	(39, 2, '[현재 설계]\n```sql\nCREATE TABLE PRODUCTS (\n    CATEGORY_ID VARCHAR2(10),\n    PRODUCT_CODE VARCHAR2(10),\n    PRODUCT_NAME VARCHAR2(100),\n    PRICE NUMBER,\n    PRIMARY KEY (CATEGORY_ID, PRODUCT_CODE)\n);\n\nCREATE TABLE ORDERS (\n    ORDER_ID NUMBER,\n    ORDER_DATE DATE,\n    CATEGORY_ID VARCHAR2(10),\n    PRODUCT_CODE VARCHAR2(10),\n    QUANTITY NUMBER,\n    PRIMARY KEY (ORDER_ID),\n    FOREIGN KEY (CATEGORY_ID, PRODUCT_CODE) \n        REFERENCES PRODUCTS(CATEGORY_ID, PRODUCT_CODE)\n);\n```', 3, NULL, '다음과 같은 테이블 설계에서 발생할 수 있는 문제점과 가장 적절한 해결 방안은?', '현재 설계의 문제점:\n1. 복잡한 참조 관계로 인한 성능 저하\n2. 카테고리 변경 시 제약조건으로 인한 어려움\n3. 외래키 관리의 복잡성\n\n해결방안:\n1. PRODUCTS 테이블에 PRODUCT_ID라는 대체키 도입\n2. ORDERS 테이블은 PRODUCT_ID만 참조\n3. 카테고리 정보는 비식별관계로 유지', 180, 4),
	(40, 2, '[요구사항]\n1. 고객은 여러 개의 배송지를 등록할 수 있다\n2. 배송지는 기본 배송지를 설정할 수 있다\n3. 주문 시 등록된 배송지 중 하나를 선택할 수 있다\n4. 주문 시점의 배송지 정보가 보존되어야 한다\n5. 배송지 변경 이력 관리가 필요하다', 3, NULL, '다음과 같은 요구사항에서 가장 적절한 식별자 설계 방식은?', '적절한 설계 방식:\n1. 배송지 마스터 테이블:\n   - 인조식별자(DELIVERY_ADDR_ID) 사용\n   - 고객ID는 외래키로 참조\n   - 기본 배송지 여부 표시\n\n2. 배송지 이력 테이블:\n   - 이력ID를 인조식별자로 사용\n   - 배송지ID를 외래키로 참조\n   - 변경일자 및 이력 관리\n\n3. 주문 테이블:\n   - 배송지ID를 외래키로 참조\n   - 주문 시점의 배송지 정보 스냅샷 보관', 180, 4),
	(41, 2, NULL, 1, NULL, '다음 중 데이터베이스의 관계(Relationship)에 대한 설명으로 틀린 것은?', '1:1 관계에서는 외래키를 양쪽 테이블 모두에 둘 필요는 없습니다. 일반적으로 업무적 특성이나 데이터 접근 빈도를 고려하여 한쪽 테이블에만 외래키를 둡니다. 양쪽에 모두 두는 것은 중복과 관리 비용을 증가시킬 수 있습니다.', 60, 5),
	(42, 2, '[상황]\n1. 직원은 하나의 부서에만 소속될 수 있다\n2. 한 부서에는 여러 직원이 소속될 수 있다\n3. 부서는 직원이 없어도 존재할 수 있다\n4. 모든 직원은 반드시 부서에 소속되어야 한다', 2, NULL, '다음과 같은 업무 상황에서 가장 적절한 관계 유형은?', '주어진 상황 분석:\n1. 1:N 관계 (한 부서 : 여러 직원)\n2. 필수/선택 관계 (직원->부서: 필수, 부서->직원: 선택)\n3. 부서는 독립적으로 존재 가능\n4. 직원은 부서에 의존적이지만 식별자로 부서를 사용하지는 않음\n따라서 비식별 관계를 가진 1:N 관계가 적절합니다.', 120, 5),
	(43, 2, '[직원]                [프로젝트]\n+------------+        +------------+\n|직원ID(PK)   |<------>|프로젝트ID(PK)|\n|직원명       |  N:M   |프로젝트명   |\n|부서ID       |        |시작일      |\n+------------+        |종료일      |\n                     +------------+', 2, NULL, '다음과 같은 ERD에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'N:M 관계의 문제점과 해결방안:\n1. 직원과 프로젝트는 다대다 관계\n2. 현재 구조에서는 참여 이력(기간, 역할 등) 관리 불가\n3. 해결방안: 교차 엔터티 생성\n```sql\n[직원_프로젝트]\n+---------------+\n|직원ID(FK)      |\n|프로젝트ID(FK)   |\n|참여시작일      |\n|참여종료일      |\n|역할           |\n+---------------+\n```', 120, 5),
	(44, 2, NULL, 3, NULL, '다음 중 식별관계와 비식별관계에 대한 설명으로 가장 적절한 것은?', '식별/비식별관계의 특징:\n1. 식별관계\n   - 부모 테이블의 PK가 자식 테이블의 PK 일부로 사용\n   - 강한 종속성\n   - 부모가 없으면 자식도 존재 불가\n2. 비식별관계\n   - 부모 테이블의 PK가 자식 테이블의 일반 컬럼으로 사용\n   - 약한 종속성\n   - 필수/선택 여부 선택 가능', 180, 5),
	(45, 2, '[요구사항]\n1. 주문은 여러 개의 상품을 포함할 수 있다\n2. 상품은 여러 주문에 포함될 수 있다\n3. 주문별로 상품의 수량과 금액이 다르다\n4. 상품의 가격은 시간에 따라 변경될 수 있다\n5. 주문 시점의 상품 가격이 보존되어야 한다', 3, NULL, '다음과 같은 상황에서 가장 적절한 설계 방식은?', '요구사항을 만족하는 이유:\n1. ORDER_ITEMS 테이블로 N:M 관계 해소\n2. UNIT_PRICE로 주문 시점의 가격 보존\n3. AMOUNT를 계산 컬럼으로 설정하여 데이터 정합성 보장\n4. ORDER_ITEM_ID를 별도로 두어 향후 확장성 고려\n5. 참조 무결성 제약조건 설정', 180, 5),
	(46, 2, NULL, 1, NULL, '다음 중 참조무결성 제약조건(Reference Integrity)에 대한 설명으로 가장 부적절한 것은?', '부모 테이블의 기본키가 변경될 때 자식 테이블의 외래키가 자동으로 변경되지는 않습니다. 이는 별도의 옵션(ON UPDATE CASCADE)을 설정해야 하며, 많은 DBMS에서 이 기능을 지원하지 않거나 권장하지 않습니다.', 60, 5),
	(47, 2, '[상황]\n1. 카테고리는 계층 구조를 가진다 (대분류-중분류-소분류)\n2. 각 카테고리는 하위 카테고리를 여러 개 가질 수 있다\n3. 최하위 카테고리에만 상품을 등록할 수 있다\n4. 카테고리의 depth는 3단계로 고정되어 있다', 2, NULL, '다음과 같은 상황에서 가장 적절한 관계 설정은?', '카테고리 레벨이 고정된 3단계이므로, 각 레벨별로 테이블을 생성하는 것이 가장 적절합니다.\n1. 명확한 구조 표현 가능\n2. 각 레벨별 속성 관리 용이\n3. 참조 무결성 보장\n4. 레벨별 조회 성능 향상', 120, 5),
	(48, 2, '[상황]\n회원(Member) 엔터티\n- 일반회원(Normal)\n- 기업회원(Corporate)\n- VIP회원(VIP)\n\n특징:\n1. 회원 유형별로 속성이 다르다\n2. 회원 유형 변경이 가능하다\n3. 전체 회원을 대상으로 한 조회가 빈번하다\n4. 각 회원 유형별 특화 기능이 있다', 2, NULL, '다음 중 슈퍼타입-서브타입 관계를 물리적 모델로 구현할 때 가장 적절한 방식은?', '주어진 상황에서는 단일 테이블 전략이 가장 적합합니다.\n1. 전체 조회가 빈번한 경우 조인 없이 조회 가능\n2. 회원 유형 변경 시 데이터 이동 없이 처리 가능\n3. 약간의 저장 공간 낭비는 있으나 성능상 이점이 큼', 120, 5),
	(49, 2, '[현재 설계]\n```sql\nCREATE TABLE EMPLOYEES (\n    EMP_ID NUMBER PRIMARY KEY,\n    MANAGER_ID NUMBER,\n    FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEES(EMP_ID)\n);\n\nCREATE TABLE PROJECTS (\n    PROJECT_ID NUMBER PRIMARY KEY,\n    MANAGER_ID NUMBER,\n    FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEES(EMP_ID)\n);\n```', 3, NULL, '다음과 같은 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '재귀적 관계를 포함한 참조 관계에서:\n1. 문제점:\n   - 직원 삭제 시 순환 참조로 인한 제약조건 위배 가능\n   - 관련 데이터 삭제 순서 결정 어려움\n2. 해결방안:\n   - ON DELETE SET NULL 옵션 사용\n   - 삭제 전 참조 관계 정리 프로시저 구현\n   - 논리적 삭제(삭제 플래그) 도입 고려', 180, 5),
	(50, 2, '[요구사항]\n1. 고객은 여러 보험 상품에 가입할 수 있다\n2. 보험 상품별로 보장 내용이 다르다\n3. 고객별로 보험료와 보장 금액이 다르게 책정된다\n4. 보험 계약은 갱신될 수 있으며, 갱신 시 보험료가 변경될 수 있다\n5. 계약 이력과 보험료 변경 이력이 모두 관리되어야 한다', 3, NULL, '다음 요구사항에 대한 가장 적절한 관계 모델링은?', '주어진 요구사항을 가장 잘 만족하는 모델입니다.\n1. 계약 기본 정보와 보험료 정보를 분리하여 관리\n2. 계약별 보험료 이력을 효과적으로 관리 가능\n3. 기간별 보험료 변경 이력 추적 가능\n4. 계약 갱신과 보험료 변경을 유연하게 처리 가능\n5. 기본키와 외래키를 통한 참조 무결성 보장', 180, 5),
	(51, 2, NULL, 1, NULL, '다음 중 관계와 조인에 대한 설명으로 가장 부적절한 것은?', 'N:M 관계는 반드시 교차 테이블로 해소할 필요는 없습니다. 업무 요구사항과 시스템 특성에 따라 다른 방식으로도 구현 가능합니다. 예를 들어, JSON이나 배열 타입을 사용하거나, 특정 DBMS의 고유 기능을 활용할 수도 있습니다.', 60, 6),
	(52, 2, '[학생]              [수강신청]         [과목]\n학번(PK)            학번(FK)           과목코드(PK)\n이름                과목코드(FK)       과목명\n학과                신청일자           담당교수\n                   성적', 2, NULL, '다음과 같은 관계를 가진 테이블에서 적절한 조인 방식은?', '가장 적절한 조인 방식 선택 이유:\n1. 모든 학생 정보 포함 필요:\n   - LEFT JOIN으로 학생 테이블 기준\n   - 수강신청이 없는 학생도 포함\n\n2. 조인 순서의 최적화:\n   - 기준 테이블(학생)부터 시작\n   - 관계의 방향성 고려\n   - 1:N 관계 순서로 조인', 120, 6),
	(53, 2, '[Query 1]\n```sql\nSELECT d.dept_name, COUNT(e.emp_id) as emp_count\nFROM departments d, employees e\nWHERE d.dept_id = e.dept_id\nGROUP BY d.dept_name;\n```\n\n[Query 2]\n```sql\nSELECT d.dept_name, COUNT(e.emp_id) as emp_count\nFROM departments d\nLEFT OUTER JOIN employees e ON d.dept_id = e.dept_id\nGROUP BY d.dept_name;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', '두 쿼리의 차이점:\n1. Query 1 (일반 조인):\n   - 매칭되는 데이터만 조회\n   - 직원이 없는 부서는 제외\n\n2. Query 2 (LEFT OUTER JOIN):\n   - 모든 부서 포함\n   - 직원이 없는 부서도 포함(emp_count = 0)', 120, 6),
	(54, 2, '[요구사항]\n1. 부서별 평균 급여 계산\n2. 부서가 없는 직원도 포함\n3. 직원이 없는 부서도 포함\n4. 평균 급여가 NULL인 경우 0으로 표시\n5. 부서명 기준으로 정렬', 3, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '요구사항을 만족하는 이유:\n1. FULL OUTER JOIN:\n   - 양쪽 테이블의 모든 데이터 포함\n   - 부서 없는 직원과 직원 없는 부서 모두 포함\n\n2. NULL 처리:\n   - COALESCE로 부서명 NULL 처리\n   - NVL로 평균 급여 NULL 처리\n\n3. 정렬:\n   - 부서명 기준 정렬\n   - NULLS LAST로 NULL 처리', 180, 6),
	(55, 2, '[주문]              [주문상품]         [상품]\n주문ID(PK)          주문ID(FK)         상품ID(PK)\n고객ID              상품ID(FK)         상품명\n주문일자            수량               가격\n                   금액               재고', 3, NULL, '다음과 같은 다중 테이블 관계에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '다중 테이블 조인 시 고려사항:\n1. 명시적 조인 조건:\n   - 모든 테이블 간 관계 명확히 정의\n   - 카테시안 곱 방지\n   - 성능 향상\n\n2. 조인 순서 최적화:\n   - 1:N 관계 순서 고려\n   - 인덱스 활용\n   - 데이터 양 고려\n\n3. 적절한 조인 유형:\n   - INNER JOIN vs OUTER JOIN\n   - 업무 요구사항 반영\n   - 불필요한 OUTER JOIN 제거\n\n4. 성능 고려사항:\n   - 조인 조건의 인덱스 활용\n   - 조인 칼럼의 데이터 타입 일치\n   - 불필요한 조인 제거', 180, 6),
	(56, 2, NULL, 1, NULL, '다음 중 SELF JOIN에 대한 설명으로 가장 부적절한 것은?', 'SELF JOIN이 반드시 성능을 저하시키는 것은 아닙니다. 적절한 인덱스와 조인 조건이 있다면 다른 테이블 간의 조인과 비슷한 성능을 보일 수 있습니다. 오히려 계층 구조 등을 표현할 때는 SELF JOIN이 가장 효율적인 방법일 수 있습니다.', 60, 6),
	(57, 2, '[직원 테이블]\n```sql\nCREATE TABLE EMPLOYEE (\n    EMP_ID NUMBER PRIMARY KEY,\n    EMP_NAME VARCHAR2(100),\n    MANAGER_ID NUMBER\n);\n```', 2, NULL, '다음과 같은 테이블에서 각 직원의 이름과 직속 상사의 이름을 조회하는 가장 적절한 SQL문은?', 'LEFT OUTER JOIN을 사용하는 것이 가장 적절합니다.\n1. 모든 직원 포함 (상사가 없는 직원도 포함)\n2. 명시적 조인 구문 사용으로 가독성 향상\n3. 결과의 정렬을 통한 데이터 확인 용이\n4. 표준 SQL 문법 준수', 120, 6),
	(58, 2, '[Query 1]\n```sql\nSELECT dept_id, COUNT(*) as emp_count\nFROM employees\nGROUP BY dept_id;\n```\n\n[Query 2]\n```sql\nSELECT d.dept_id, COUNT(e.emp_id) as emp_count\nFROM departments d\nLEFT JOIN employees e ON d.dept_id = e.dept_id\nGROUP BY d.dept_id;\n```\n\n[Query 3]\n```sql\nSELECT d.dept_id, COUNT(1) as emp_count\nFROM departments d\nINNER JOIN employees e ON d.dept_id = e.dept_id\nGROUP BY d.dept_id;\n```', 2, NULL, '다음 SQL문들의 실행 결과가 다른 경우를 고르시오.', '직원이 없는 부서가 있는 경우:\n1. Query 1: 직원이 있는 부서만 집계\n2. Query 2: 모든 부서 포함 (직원이 없는 부서는 0으로 집계)\n3. Query 3: 직원이 있는 부서만 집계', 120, 6),
	(59, 2, '[요구사항]\n1. 부서별 평균 급여보다 많은 급여를 받는 직원 조회\n2. 부서가 없는 직원도 포함하여 전체 평균과 비교\n3. 결과는 부서별, 급여 내림차순 정렬', 3, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '주어진 요구사항을 가장 잘 만족하는 이유:\n1. WITH 절을 사용한 명확한 구조\n2. 부서가 없는 직원 처리 (LEFT JOIN)\n3. 부서별 평균과 NULL 부서 평균 구분 처리\n4. COALESCE를 통한 NULL 처리\n5. 정렬 조건 준수', 180, 6),
	(60, 2, NULL, 3, NULL, '아래와 같은 다중 테이블 조인에서 발생할 수 있는 성능 이슈와 해결방안으로 가장 적절한 것은?', '성능 최적화 방안:\n1. 인라인 뷰로 데이터 축소:\n```sql\nSELECT c.cust_name, p.prod_name, \n       o.order_date, d.quantity\nFROM (\n    SELECT order_id, cust_id, order_date\n    FROM orders\n    WHERE order_date >= \'2024-01-01\'\n) o\nJOIN customers c ON c.cust_id = o.cust_id\nJOIN order_details d ON o.order_id = d.order_id\nJOIN products p ON d.prod_id = p.prod_id;\n```\n2. 장점:\n   - 초기 처리 대상 데이터 감소\n   - 불필요한 조인 연산 제거\n   - 메모리 사용량 감소\n3. 고려사항:\n   - 인덱스 활용 가능성\n   - 데이터 분포도\n   - 조인 순서의 최적화', 180, 6),
	(61, 2, NULL, 1, NULL, '다음 중 정규화에 대한 설명으로 가장 부적절한 것은?', '정규화가 진행될수록 테이블이 분리되어 조인의 필요성이 증가합니다. 이로 인해 조회 시 성능이 저하될 수 있습니다. 이는 정규화와 성능이 서로 상충관계에 있음을 보여주는 대표적인 예입니다.', 60, 7),
	(62, 2, '[학생수강테이블]\n------------------------------------\n학번 | 이름 | 수강과목 | 교수 | 강의실 | 성적\n------------------------------------\n1001 | 김철수 | 데이터베이스 | 박교수 | A동101호 | A\n1001 | 김철수 | 전자계산기 | 이교수 | B동201호 | B\n1002 | 이영희 | 데이터베이스 | 박교수 | A동101호 | B', 2, NULL, '다음 테이블에 대한 정규화 진행 시 적절한 단계는?', '학번과 이름은 부분함수적 종속성을 가집니다. 즉, 복합키(학번, 수강과목)에서 학번에만 종속되므로 제2정규형을 위반합니다. 따라서 학생정보(학번, 이름)를 별도 테이블로 분리해야 합니다.', 120, 7),
	(63, 2, '[후보키 및 함수적 종속성]\n1) 수강신청(학번, 과목코드, 교수번호, 신청일자)\n   - 후보키: (학번, 과목코드)\n   - 교수번호 → 과목코드\n\n2) 직원정보(직원번호, 부서코드, 직원명, 부서명)\n   - 후보키: (직원번호)\n   - 부서코드 → 부서명\n\n3) 강의실배정(강의실번호, 시간대, 교수번호, 과목명)\n   - 후보키: (강의실번호, 시간대)\n   - (교수번호, 시간대) → 강의실번호\n\n4) 학생정보(학번, 주민번호, 이름, 학과코드, 학과명)\n   - 후보키: (학번), (주민번호)\n   - 학과코드 → 학과명', 2, NULL, '다음 중 BCNF(Boyce-Codd Normal Form)를 위반하는 경우는?', 'BCNF는 모든 결정자가 후보키여야 합니다. 수강신청 테이블에서 교수번호는 과목코드를 결정하지만 후보키가 아니므로 BCNF를 위반합니다. 이를 해결하기 위해서는 (교수번호, 과목코드) 테이블을 별도로 분리해야 합니다.', 120, 7),
	(64, 2, '[과목수강테이블]\n-------------------------------------------------\n학번 | 학생명 | 등록학과 | 과목코드 | 과목명 | 강의실\n-------------------------------------------------\n1001 | 김철수 | 컴퓨터공학과 | CS001 | 자료구조 | A101\n1001 | 김철수 | 컴퓨터공학과 | CS002 | 데이터베이스 | B201\n1002 | 이영희 | 전자공학과 | CS001 | 자료구조 | A101\n\n[이상현상]\n1. 새로운 과목을 개설할 때 수강학생이 없으면 등록할 수 없다\n2. 마지막 수강학생이 과목 수강취소 시 과목 정보가 모두 삭제된다', 3, NULL, '다음과 같은 이상현상(Anomaly)이 발생하는 테이블의 정규화 단계와 해결방안으로 가장 적절한 것은?', '과목코드와 과목명, 강의실은 수강학생과 무관하게 독립적으로 존재해야 하는 정보입니다. 이는 제1정규형의 원자성 원칙과 관련이 있으며, 과목정보(과목코드, 과목명, 강의실)를 별도 테이블로 분리함으로써 삽입, 삭제 이상을 해결할 수 있습니다.', 180, 7),
	(65, 2, '[상황]\n1. 주문상세 테이블에서 주문금액 합계를 자주 조회한다\n2. 게시판의 답글 개수를 실시간으로 표시해야 한다\n3. 상품 분류별 재고수량을 일괄 계산한다\n4. 회원의 최근 로그인 시간을 저장한다', 3, NULL, '다음 중 반정규화(Denormalization)가 가장 적절한 경우는?', '게시판의 답글 개수는 실시간 표시가 필요하고 자주 조회되는 정보이며, 매번 COUNT 연산을 수행하면 성능이 저하될 수 있습니다. 이런 경우 답글 개수를 게시글 테이블에 컬럼으로 추가하는 반정규화가 적절합니다. 단, 답글이 추가되거나 삭제될 때마다 개수를 업데이트해야 하는 오버헤드가 있습니다.', 180, 7),
	(66, 2, NULL, 1, NULL, '다음 중 함수적 종속성(Functional Dependency)에 대한 설명으로 가장 부적절한 것은?', '함수적 종속성이 많다는 것은 데이터의 중복과 불일치 가능성이 높다는 것을 의미합니다. 이는 데이터의 일관성을 저해할 수 있으며, 정규화를 통해 적절히 제거되어야 합니다.', 60, 7),
	(67, 2, '[주문(ORDER)]\n----------------------------------------\n주문번호 | 고객ID | 고객등급 | 할인율 | 주문금액\n----------------------------------------\nO001    | C001  | GOLD    | 10%    | 10000\nO002    | C001  | GOLD    | 10%    | 20000\nO003    | C002  | SILVER  | 5%     | 15000', 2, NULL, '다음 테이블에서 제3정규형 위반 사항과 해결방안을 고르시오.', '제3정규형을 위반하는 이행적 함수 종속이 존재합니다:\n1. 고객ID → 고객등급\n2. 고객등급 → 할인율\n따라서 다음과 같이 분리해야 합니다:\n- 주문(주문번호, 고객ID, 주문금액)\n- 고객등급(고객등급, 할인율)\n- 고객(고객ID, 고객등급)', 120, 7),
	(68, 2, '[비정규형]\n학생정보(학번, 이름, 수강과목1, 수강과목2, 수강과목3)\n\n[정규화 단계]\nA: 학생정보(학번, 이름)\n   수강정보(학번, 과목코드)\n   과목정보(과목코드, 과목명)\n\nB: 학생수강(학번, 과목코드, 과목명)\n   학생정보(학번, 이름)\n\nC: 학생수강(학번, 이름, 과목코드)\n   과목정보(과목코드, 과목명)\n\nD: 학생과목(학번, 과목코드)\n   학생정보(학번, 이름)', 2, NULL, '다음 중 정규화 과정이 올바르게 진행된 것은?', '정규화가 올바르게 진행된 이유:\n1. 1NF: 반복 속성(수강과목1,2,3) 제거\n2. 2NF: 부분 종속성 제거 (학번→이름)\n3. 3NF: 이행적 종속성 제거 (과목코드→과목명)\n4. 각 테이블의 기본키와 외래키 관계가 명확함', 120, 7),
	(69, 2, '[요구사항]\n1. 대용량 주문 데이터 처리 시스템\n2. 주문 상태별 조회가 빈번함\n3. 주문 상태 변경 이력 관리 필요\n4. 실시간 통계 집계 필요', 3, NULL, '다음과 같은 상황에서 가장 적절한 정규화 전략은?', '제안된 정규화 전략:\n1. 주문 테이블:\n   - 주문ID, 고객ID, 현재상태코드, 금액\n2. 주문상태 테이블:\n   - 상태코드, 상태명\n3. 주문상태이력 테이블:\n   - 이력ID, 주문ID, 상태코드, 변경일시\n\n장점:\n- 이력 관리 용이\n- 상태별 조회 성능 향상\n- 데이터 정합성 확보', 180, 7),
	(70, 2, NULL, 3, NULL, '다음과 같은 반정규화 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '반정규화된 댓글수 컬럼의 유지보수를 위해 트리거를 사용하여 자동 갱신합니다.', 180, 7),
	(71, 2, NULL, 1, NULL, '다음 중 트랜잭션(Transaction)의 특성으로 가장 부적절한 것은?', '독립성(Isolation)은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리되어야 한다는 의미입니다. 반드시 순차적으로 실행될 필요는 없으며, 적절한 격리 수준에서 동시에 실행될 수 있습니다.', 60, 8),
	(72, 2, '-- Transaction 1\nUPDATE accounts SET balance = balance - 1000 WHERE account_no = \'A001\';\n\n-- Transaction 2\nSELECT balance FROM accounts WHERE account_no = \'A001\';', 2, NULL, '다음과 같은 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제점으로 가장 적절한 것은?', 'Dirty Read 현상 분석:\n1. Transaction 1이 계좌 잔액을 갱신\n2. 아직 COMMIT되지 않은 상태\n3. Transaction 2가 변경된 잔액을 읽음\n4. Transaction 1이 ROLLBACK하면 Transaction 2는 잘못된 데이터를 사용\n\n해결방안:\n- 적절한 트랜잭션 격리 수준 설정\n- READ COMMITTED 이상의 격리 수준 사용', 120, 8),
	(73, 2, '[주문]                [주문상세]\nORDER_ID (PK)        ORDER_ID (FK)\nORDER_DATE           PRODUCT_ID (FK)\nTOTAL_AMOUNT         QUANTITY\n                    AMOUNT', 2, NULL, '다음과 같은 데이터 모델에서 발생할 수 있는 트랜잭션 문제점으로 가장 적절한 것은?', '트랜잭션 관점의 문제점:\n1. 정합성 위험:\n   - 주문 총액과 상세 금액 합계의 불일치\n   - 부분 업데이트 가능성\n\n2. 해결방안:\n   - 트리거 사용\n   - 계산 컬럼 활용\n   - 트랜잭션 범위 적절히 설정\n   - 정합성 체크 로직 구현', 120, 8),
	(74, 2, '[요구사항]\n1. 상품 주문 시 재고 확인 및 차감\n2. 결제 처리\n3. 포인트 적립\n4. 모든 처리가 성공적으로 완료되어야 함\n5. 실패 시 모든 변경사항 롤백', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 트랜잭션 설계는?', '적절한 트랜잭션 처리 방식:\n1. 재고 확인과 차감을 동시에 처리\n2. 모든 처리를 하나의 트랜잭션으로 관리\n3. 예외 발생 시 전체 롤백\n4. 에러 처리와 메시지 전달\n\n다른 방식의 문제점:\n- ①: 예외 처리 누락\n- ②: 부분 커밋으로 인한 일관성 훼손\n- ③: SAVEPOINT 사용이 부적절', 180, 8),
	(75, 2, NULL, 3, NULL, '다음 중 트랜잭션 설계 시 고려사항으로 가장 부적절한 것은?', '트랜잭션 설계 원칙:\n1. 트랜잭션 범위:\n   - 최소화하여 설정\n   - 잠금 시간 최소화\n   - 동시성 향상\n\n2. 고려사항:\n   - 데이터 일관성\n   - 동시성\n   - 성능\n   - 복구 가능성\n\n3. 권장사항:\n   - 짧은 트랜잭션 설계\n   - 장시간 작업 분리\n   - 적절한 격리 수준 선택\n   - 효율적인 잠금 관리', 180, 8),
	(76, 2, NULL, 1, NULL, '다음 중 트랜잭션의 격리 수준(Isolation Level)에 대한 설명으로 가장 올바른 것은?', '트랜잭션 격리 수준별 특징:\n1. READ UNCOMMITTED: 커밋되지 않은 데이터도 읽을 수 있음(Dirty Read 발생)\n2. SERIALIZABLE: 가장 높은 고립성을 제공하지만 성능이 가장 낮음\n3. READ COMMITTED: 커밋된 데이터만 읽을 수 있지만, Non-repeatable Read 발생 가능\n4. REPEATABLE READ: 동일 데이터 반복 읽기 보장, Phantom Read는 발생 가능', 60, 8),
	(77, 2, '-- 포인트 차감 및 적립 프로세스\nUPDATE member_points \nSET point = point - 1000\nWHERE member_id = \'M001\';\n\nINSERT INTO point_history (\n    member_id, point_type, point_amount, description\n) VALUES (\n    \'M001\', \'USE\', -1000, \'포인트 사용\'\n);', 2, NULL, '다음과 같은 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '포인트 처리 시 고려사항:\n1. 동시성 제어 필요\n   ```sql\n   SELECT point FROM member_points \n   WHERE member_id = \'M001\'\n   FOR UPDATE;\n   ```\n2. 장점:\n   - 동시 업데이트 방지\n   - 데이터 일관성 보장\n   - 최소한의 잠금 범위', 120, 8),
	(78, 2, NULL, 2, NULL, '다음 중 낙관적 잠금(Optimistic Lock)이 가장 적절한 경우는?', '낙관적 잠금 적용 기준:\n1. 적절한 경우:\n   - 충돌 가능성이 낮은 경우\n   - 읽기가 많은 경우\n   - 긴 트랜잭션이 필요한 경우\n2. 부적절한 경우:\n   - 실시간 처리가 필요한 경우\n   - 충돌 가능성이 높은 경우\n   - 짧은 트랜잭션의 경우', 120, 8),
	(79, 2, '[요구사항]\n1. 대용량 주문 데이터 일괄 처리\n2. 각 주문별 재고 확인 및 차감\n3. 실패한 주문은 별도 로그 기록\n4. 전체 처리 시간 최소화', 3, NULL, '다음과 같은 업무 요구사항에서 가장 적절한 트랜잭션 처리 방식은?', '배치 처리 최적화 방안:\n1. 적절한 배치 크기 설정\n2. 부분 커밋으로 리소스 관리\n3. 실패 건에 대한 별도 처리\n4. 성능과 안정성 균형', 180, 8),
	(80, 2, '-- Transaction 1\nUPDATE orders SET status = \'PROCESSING\' WHERE order_id = 1;\nUPDATE inventory SET stock = stock - 1 WHERE product_id = 100;\n\n-- Transaction 2\nUPDATE inventory SET stock = stock - 1 WHERE product_id = 100;\nUPDATE orders SET status = \'PROCESSING\' WHERE order_id = 1;', 3, NULL, '다음과 같은 데드락(Deadlock) 상황의 해결방안으로 가장 적절한 것은?', '데드락 방지 전략:\n1. 테이블 접근 순서의 표준화:\n   ```sql\n   -- 모든 트랜잭션에서 동일한 순서 적용\n   UPDATE inventory SET ... ;  -- 항상 먼저\n   UPDATE orders SET ... ;     -- 항상 나중에\n   ```\n2. 장점:\n   - 데드락 원천 방지\n   - 관리 용이성\n   - 성능 저하 없음', 180, 8),
	(81, 2, NULL, 1, NULL, '다음 중 NULL에 대한 설명으로 가장 부적절한 것은?', 'NULL과 숫자 0은 전혀 다른 의미입니다. 0은 정의된 숫자값이지만, NULL은 \'아직 정의되지 않은 값\' 또는 \'알 수 없는 값\'을 의미합니다.', 60, 9),
	(82, 2, '```sql\nSELECT COUNT(*) as cnt1,\n       COUNT(department_id) as cnt2,\n       COUNT(DISTINCT department_id) as cnt3\nFROM employees\nWHERE salary IS NULL;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', '각 COUNT의 의미:\n1. COUNT(*): NULL을 포함한 모든 행의 수\n2. COUNT(department_id): department_id가 NULL이 아닌 행의 수\n3. COUNT(DISTINCT department_id): 중복을 제거한 department_id의 수\n따라서 cnt1 >= cnt2 (department_id가 NULL인 경우 때문)\ncnt2 >= cnt3 (department_id 중복 때문)', 120, 9),
	(83, 2, '```sql\n-- Query 1\nSELECT employee_id, salary\nFROM employees\nWHERE NVL(commission_pct, 0) = 0;\n\n-- Query 2\nSELECT employee_id, salary\nFROM employees\nWHERE commission_pct IS NULL OR commission_pct = 0;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'Query 1은 NULL을 0으로 변환 후 비교하고, Query 2는 NULL과 0을 별도 조건으로 처리합니다. NULL과 0이 모두 있는 경우, 실행 계획과 성능이 다를 수 있습니다.', 120, 9),
	(84, 2, '```sql\n[요구사항]\n1. 부서별 평균 급여 계산\n2. NULL 급여는 0으로 계산\n3. 부서가 없는 직원은 \'미배치\'로 표시\n4. 평균 급여가 NULL이면 0으로 표시\n```', 3, NULL, '다음과 같은 NULL 처리가 필요할 때, 가장 적절한 SQL문은?', 'NVL(salary, 0)로 NULL을 0으로 변환하고, LEFT JOIN을 사용하여 부서 없는 직원도 포함합니다. 또한, NULL 평균을 처리하기 위해 AVG(NVL(salary, 0))를 사용하여 모든 요구사항을 만족합니다.', 180, 9),
	(85, 2, '```sql\n[성능 테스트 결과]\nMethod 1: WHERE column1 IS NULL\nMethod 2: WHERE NVL(column1, \'X\') = \'X\'\nMethod 3: WHERE COALESCE(column1, \'X\') = \'X\'\nMethod 4: WHERE column1 = NULL\n```', 3, NULL, '다음과 같은 NULL 값 비교가 필요할 때, 가장 적절한 방법은?', 'NULL 비교는 IS NULL을 사용하는 것이 가장 효율적이며, 함수(NVL, COALESCE)를 사용하면 모든 행에 대해 함수 연산이 수행되어 성능이 저하될 수 있습니다.', 180, 9),
	(86, 2, NULL, 1, NULL, '다음 중 NULL 관련 함수에 대한 설명으로 가장 올바른 것은?', 'NULLIF(exp1, exp2)는 exp1과 exp2가 같으면 NULL을 반환합니다. 다른 NULL 관련 함수들과 비교하여 각각의 동작을 이해하는 것이 중요합니다.', 60, 9),
	(87, 2, '```sql\nSELECT \n    COUNT(*) as total_count,\n    SUM(CASE WHEN salary IS NULL THEN 1 ELSE 0 END) as null_count,\n    AVG(NVL(salary, 0)) as avg_salary1,\n    AVG(salary) as avg_salary2\nFROM employees\nWHERE department_id = 50;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', 'AVG(NVL(salary, 0))는 NULL을 0으로 변환 후 계산하지만, AVG(salary)는 NULL을 제외하고 계산하기 때문에 avg_salary1이 항상 더 작습니다.', 120, 9),
	(88, 2, '```sql\n-- Method 1\nSELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id\nORDER BY department_id NULLS FIRST;\n\n-- Method 2\nSELECT NVL(department_id, -1) as dept_id, COUNT(*)\nFROM employees\nGROUP BY NVL(department_id, -1)\nORDER BY dept_id;\n\n-- Method 3\nSELECT CASE WHEN department_id IS NULL \n            THEN \'미배치\' \n            ELSE TO_CHAR(department_id) \n       END as dept_id,\n       COUNT(*)\nFROM employees\nGROUP BY department_id;\n```', 2, NULL, '다음과 같은 GROUP BY 절에서 NULL 처리 방식 중 가장 적절한 것은?', 'NULL을 특정 값으로 변환(NVL 사용)하면 인덱스를 활용할 수 있어 성능 최적화가 가능하며, 정렬도 용이해집니다.', 120, 9),
	(89, 2, '```sql\n[테이블 정의]\nCREATE TABLE orders (\n    order_id NUMBER PRIMARY KEY,\n    customer_id NUMBER,\n    status VARCHAR2(10),\n    total_amount NUMBER,\n    CONSTRAINT chk_status CHECK \n    (status IN (\'PENDING\',\'COMPLETED\',\'CANCELLED\'))\n);\n\n[요구사항]\n1. status가 NULL인 경우 \'PENDING\'으로 처리\n2. 데이터 정합성 유지\n3. 성능 최적화\n```', 3, NULL, '다음과 같은 조건에서 NULL 처리가 필요할 때 가장 적절한 방식은?', 'NOT NULL 제약조건과 DEFAULT를 함께 설정하면 데이터 정합성을 보장할 수 있으며, 성능 오버헤드가 없습니다.', 180, 9),
	(90, 2, '```sql\n[테이블 구조]\nORDERS(order_id, customer_id, order_date)\nCUSTOMERS(customer_id, customer_name)\nORDER_ITEMS(order_id, product_id, quantity)\nPRODUCTS(product_id, product_name, price)\n\n[요구사항]\n1. 주문별 총 금액 계산\n2. 주문이 없는 고객도 포함\n3. 상품가격이 NULL인 경우 0으로 계산\n4. 고객명이 NULL인 경우 \'삭제된 고객\'으로 표시\n```', 3, NULL, '다음과 같은 조인 상황에서 발생할 수 있는 NULL 처리 문제의 해결방안으로 가장 적절한 것은?', 'WITH절을 사용하면 복잡한 계산을 단계별로 처리할 수 있으며, 가독성과 성능을 최적화할 수 있습니다.', 180, 9),
	(91, 2, NULL, 1, NULL, '다음 중 본질 식별자와 인조 식별자에 대한 설명으로 가장 부적절한 것은?', '인조 식별자는 숫자뿐만 아니라 문자열 등 다양한 형태로 지정할 수 있습니다. 중요한 것은 인조 식별자가 업무적 의미를 포함하지 않고, 유일성을 보장하며, 변경되지 않는 특성을 가져야 한다는 점입니다.', 60, 10),
	(92, 2, '[상황]\n고객 테이블 설계 시 다음 정보가 있음:\n1. 주민등록번호\n2. 고객번호(시스템 자동생성)\n3. 이메일주소\n4. 휴대폰번호', 2, NULL, '다음과 같은 상황에서 가장 적절한 식별자 선택은?', '고객번호를 인조 식별자로 선택하는 것이 적절한 이유:\n1. 주민등록번호는 개인정보보호로 인한 제약\n2. 이메일주소와 휴대폰번호는 변경 가능성이 높음\n3. 고객번호는:\n   - 시스템에서 자동 생성되어 유일성 보장\n   - 업무적 의미 없어 변경 필요성 없음\n   - 개인정보와 무관\n   - 간단한 구조로 조인 성능 유리', 120, 10),
	(93, 2, '[설계]\nDesign 1: 본질 식별자 사용\nDesign 2: 인조 식별자 사용', 2, NULL, '다음 두 테이블 설계 중 더 적절한 것은?', '인조 식별자 설계가 더 적절한 이유:\n1. 단순한 키 구조:\n   - 외래키 참조가 단순해짐\n   - 인덱스 크기 감소\n   - 조인 성능 향상\n\n2. 본질 식별자 설계의 단점:\n   - 복합키로 인한 참조 복잡성\n   - 더 많은 저장 공간 필요\n   - 인덱스 크기 증가\n   - 조인 조건 복잡', 120, 10),
	(94, 2, '[요구사항]\n1. 게시판별로 게시글 관리\n2. 게시글의 답변 글 관리\n3. 게시글의 첨부파일 관리\n4. 게시글 이동 기능 필요\n5. 답변 글의 계층 구조 표현 필요', 3, NULL, '다음과 같은 요구사항이 있을 때, 가장 적절한 식별자 설계는?', '인조 식별자 설계가 적절한 이유:\n1. 게시글 이동 용이성:\n   - board_id가 변경되어도 post_id는 유지\n   - 참조 무결성 유지 용이\n\n2. 계층 구조 표현:\n   - parent_post_id로 자기참조 관계 명확\n   - 조인 성능 우수\n\n3. 첨부파일 관리:\n   - 단순한 외래키 참조\n   - 일관된 참조 구조', 180, 10),
	(95, 2, NULL, 3, NULL, '다음 중 식별자 선택에 대한 설명으로 가장 적절한 것은?', '식별자 선택 시 고려사항:\n1. 인조 식별자 유리한 경우:\n   - 시스템 확장 예상\n   - 식별자 변경 가능성 존재\n   - 복잡한 관계 구조\n   - 대용량 데이터 처리\n\n2. 본질 식별자 유리한 경우:\n   - 업무적 의미 중요\n   - 간단한 관계 구조\n   - 안정적인 값 존재', 180, 10),
	(96, 2, NULL, 1, NULL, '다음 중 인조 식별자(Surrogate Key)의 장점으로 가장 부적절한 것은?', '인조 식별자는 업무적 의미를 가지지 않는 것이 특징입니다. 오히려 업무적 의미가 없기 때문에 시스템 변경에 유연하게 대응할 수 있고, 이것이 인조 식별자의 주요 장점 중 하나입니다.', 60, 10),
	(97, 2, '[테이블]\nCREATE TABLE employees (\n    emp_no VARCHAR2(10),\n    resident_no VARCHAR2(13),\n    emp_id NUMBER,\n    dept_code VARCHAR2(5),\n    join_date DATE\n);', 2, NULL, '다음과 같은 테이블에서 가장 적절한 식별자 선택은?', 'emp_id를 기본키로 선택하는 것이 가장 적절한 이유:\n1. emp_no의 문제점:\n   - 회사 규칙 변경 가능성\n   - 부서 이동시 변경 가능성\n2. emp_id의 장점:\n   - 시스템에서 자동 생성되어 유일성 보장\n   - 단순한 구조로 조인 성능 향상\n   - 업무 규칙 변경에 영향받지 않음', 120, 10),
	(98, 2, NULL, 2, NULL, '다음 중 본질 식별자를 사용하는 것이 가장 적절한 경우는?', '은행 계좌 테이블에서 본질 식별자가 적절한 이유:\n1. 계좌번호의 특성:\n   - 업무적으로 중요한 의미\n   - 변경되지 않는 특성\n   - 은행 전산시스템의 핵심 데이터', 120, 10),
	(99, 2, '[요구사항]\n1. 직원의 부서 이동 이력 관리\n2. 급여 변경 이력 관리\n3. 직급 변경 이력 관리\n4. 이력 데이터의 장기 보관 필요\n5. 타 시스템과의 데이터 연계 고려', 3, NULL, '다음과 같은 이력 관리 시스템에서 가장 적절한 식별자 설계는?', '인조 식별자를 사용한 이력 관리의 장점:\n1. 데이터 연계 용이성:\n   - 단순한 키 구조로 인한 참조 용이\n   - 시스템 간 데이터 교환 편리\n2. 이력 관리 효율성:\n   - 순차적인 이력 번호 부여\n   - 조회 성능 향상\n3. 확장성:\n   - 새로운 이력 유형 추가 용이\n   - 데이터 구조 변경 유연성', 180, 10),
	(100, 2, '[요구사항]\n1. 계약 원본 문서 관리\n2. 계약별 첨부문서 관리\n3. 계약 변경이력 관리\n4. 문서 이력 추적 필요', 3, NULL, '다음과 같은 마스터-디테일 구조에서 가장 적절한 식별자 설계는?', '최적의 식별자 설계 선정 이유:\n1. 계약 테이블:\n   - 인조식별자(contract_id) 사용으로 안정성 확보\n   - 업무용 계약번호는 UNIQUE 제약조건으로 관리\n2. 문서 테이블:\n   - 독립적인 인조식별자(doc_id) 부여\n   - 단순한 참조 관계\n3. 장점:\n   - 문서 이력 추적 용이\n   - 계약번호 체계 변경 시 유연한 대응\n   - 조인 성능 최적화\n   - 업무적 식별성 유지', 180, 10),
	(101, 2, NULL, 1, NULL, '다음 중 관계형 데이터베이스(RDBMS)의 특징으로 가장 부적절한 것은?', '관계형 데이터베이스에서 테이블 간의 관계는 1:1, 1:N, N:M 등 다양한 형태가 가능합니다. 이러한 다양한 관계를 통해 복잡한 업무 규칙과 데이터 구조를 표현할 수 있습니다.', 60, 11),
	(102, 2, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 무결성 제약조건에 대한 설명으로 가장 올바른 것은?', '각 무결성 제약조건의 의미:\n1. 개체 무결성: 기본키는 NULL이 될 수 없고 중복될 수 없다\n2. 참조 무결성: 외래키는 참조하는 테이블의 기본키 값과 일치하거나 NULL이어야 한다\n3. 도메인 무결성: 컬럼의 값은 해당 도메인에서 정의된 값이어야 한다\n4. 사용자 정의 무결성: 업무 규칙에 따라 정의된 무결성', 120, 11),
	(103, 2, '[상황]\n1. 학생 테이블과 수강신청 테이블이 있음\n2. 학생이 자퇴하여 학생 테이블에서 삭제됨\n3. 해당 학생의 수강신청 기록은 그대로 남아있음', 2, NULL, '다음과 같은 데이터베이스 상황에서 발생할 수 있는 문제점으로 가장 적절한 것은?', '이는 전형적인 참조 무결성 위배 상황입니다:\n1. 수강신청 테이블의 학생 ID(외래키)가 참조하는 학생 테이블의 데이터가 삭제됨\n2. 고아 레코드(Orphan Record) 발생\n3. 해결방안:\n   - CASCADE DELETE 설정\n   - 학생 삭제 전 수강신청 데이터 처리\n   - 논리적 삭제(물리적 삭제 대신 상태 값 변경) 사용', 120, 11),
	(104, 2, NULL, 3, NULL, '다음 중 관계형 데이터베이스의 키(Key)에 대한 설명으로 가장 적절한 것은?', '각 키의 특징:\n1. 후보키: 유일성과 최소성을 만족하는 키(여러 개 가능)\n2. 기본키: 후보키 중 선택된 대표 키(복합키 가능)\n3. 대체키: 후보키 중 기본키로 선택되지 않은 키\n4. 외래키: 다른 테이블의 기본키를 참조하는 키(이름이 달라도 됨)', 180, 11),
	(105, 2, '[상황]\n회원제 쇼핑몰 데이터베이스 설계 중:\n1. 회원은 여러 개의 배송지 주소를 가질 수 있음\n2. 각 배송지는 기본 배송지 여부를 가짐\n3. 회원별로 딱 하나의 기본 배송지만 가질 수 있음\n4. 배송지는 회원 삭제 시 함께 삭제되어야 함', 3, NULL, '다음과 같은 데이터베이스 설계 상황에서 가장 적절한 해결방안은?', '요구사항을 만족하기 위한 제약조건:\n1. ON DELETE CASCADE: 회원 삭제 시 배송지도 삭제\n2. UNIQUE (MEMBER_ID, IS_DEFAULT): 회원별로 하나의 기본 배송지만 허용\n3. FK_MEMBER: 참조 무결성 보장\n4. PRIMARY KEY: 배송지 식별성 보장', 180, 11),
	(106, 2, NULL, 1, NULL, '다음 중 관계형 데이터베이스의 테이블(Table)에 대한 설명으로 가장 부적절한 것은?', '관계형 데이터베이스에서 테이블의 행과 열의 순서는 데이터의 의미에 영향을 주지 않습니다. 이는 관계형 데이터베이스의 중요한 특징 중 하나로, 데이터의 논리적 구조가 물리적 저장구조와 독립적임을 의미합니다.', 60, 11),
	(107, 2, NULL, 2, NULL, '다음 중 릴레이션(Relation)의 특징에 대한 설명으로 가장 올바른 것은?', '릴레이션의 주요 특징:\n1. 카디널리티: 튜플(행)의 수\n2. 차수: 속성(컬럼)의 수\n3. 속성: 서로 다른 이름을 가져야 함\n4. 튜플: 중복될 수 없음 (유일성)', 120, 11),
	(108, 2, '[테이블 정의]\nCREATE TABLE products (\n    product_id NUMBER,\n    category_id NUMBER,\n    product_name VARCHAR2(100),\n    price NUMBER,\n    stock NUMBER,\n    status CHAR(1)\n);', 2, NULL, '다음과 같은 관계형 데이터베이스 설계에서 가장 적절한 제약조건은?', '적절한 제약조건 설정의 근거:\n1. 기본키 설정:\n   - product_id만으로 충분\n   - 단순한 키 구조\n2. CHECK 제약조건:\n   - 가격과 재고는 음수가 될 수 없음\n   - 업무 규칙 반영\n3. 다른 방식의 문제점:\n   - 불필요한 복합키\n   - 과도한 제약조건', 120, 11),
	(109, 2, '[상황]\n1. 고객 포인트 시스템 운영 중\n2. 포인트 적립과 사용이 빈번하게 발생\n3. 포인트 합계가 마이너스가 되면 안 됨\n4. 모든 포인트 변동 이력 관리 필요', 3, NULL, '다음과 같은 데이터베이스 상황에서 가장 적절한 해결방안은?', '저장 프로시저 사용이 적절한 이유:\n1. 데이터 무결성 보장:\n   - 포인트 합계가 마이너스가 되는 경우 차단\n   - 포인트 변동 이력 자동 기록\n2. 트랜잭션 처리 용이', 180, 11),
	(110, 2, '[요구사항]\n1. 상품은 여러 카테고리에 속할 수 있음\n2. 각 카테고리별로 상품의 진열 순서가 다름\n3. 카테고리별 상품 노출 여부 관리\n4. 카테고리 계층 구조 관리', 3, NULL, '다음과 같은 요구사항에서 가장 적절한 데이터베이스 설계는?', '최적의 데이터베이스 설계 선택 이유:\n1. 카테고리 계층 구조:\n   - 재귀적 관계로 표현\n   - 유연한 깊이 지원\n2. 상품-카테고리 관계:\n   - M:N 관계 표현\n   - 진열 정보 포함\n3. 참조 무결성:\n   - 외래키 제약조건으로 보장\n   - 데이터 일관성 유지', 180, 11),
	(111, 2, NULL, 1, NULL, '다음 중 SELECT문의 실행 순서로 올바른 것은?', 'SQL SELECT문의 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다. 이는 논리적 실행 순서이며, 실제 작성 순서와는 다릅니다.', 60, 12),
	(112, 2, '```sql\nSELECT DEPARTMENT_ID, COUNT(*) AS EMP_COUNT\nFROM EMPLOYEES\nWHERE SALARY >= 5000\nGROUP BY DEPARTMENT_ID\nHAVING COUNT(*) >= 3\nORDER BY EMP_COUNT DESC;\n```', 2, NULL, '다음 SQL문의 실행 결과로 알맞은 것은?', 'WHERE 절에서 급여가 5000 이상인 직원만 필터링하고, GROUP BY로 부서별 그룹화한 후, HAVING 절에서 그룹별 카운트가 3 이상인 부서만 선택합니다.', 120, 12),
	(113, 2, '```sql\n-- Query 1\nSELECT DISTINCT DEPARTMENT_ID\nFROM EMPLOYEES;\n\n-- Query 2\nSELECT DEPARTMENT_ID\nFROM EMPLOYEES\nGROUP BY DEPARTMENT_ID;\n```', 2, NULL, '다음 두 SQL문의 결과가 다른 경우는?', '두 쿼리는 기본적으로 같은 결과를 반환하지만, NULL 값의 처리 방식이 약간 다를 수 있습니다. GROUP BY는 NULL을 하나의 그룹으로 처리합니다.', 120, 12),
	(114, 2, '```sql\nSELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SAL\nFROM EMPLOYEES\nWHERE AVG(SALARY) > 5000\nGROUP BY DEPARTMENT_ID;\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'WHERE 절은 개별 행을 필터링하는 용도로 사용되며, 집계 함수를 사용할 수 없습니다. 집계 함수를 이용한 필터링은 HAVING 절을 사용해야 합니다.', 180, 12),
	(115, 2, '```sql\n-- Base Query\nSELECT DEPARTMENT_ID, AVG(SALARY)\nFROM EMPLOYEES\nGROUP BY DEPARTMENT_ID;\n```', 3, NULL, '다음 SQL문의 실행 결과가 다른 것은?', 'ROLLUP은 지정된 컬럼의 소계를 생성하므로, 전체 총계 행이 추가로 생성됩니다. 따라서 기본 쿼리와 결과가 다릅니다. 나머지 쿼리들은 기본적으로 동일한 결과를 반환합니다.', 180, 12),
	(116, 2, NULL, 1, NULL, '다음 중 SELECT문의 ALIAS(별칭) 사용법으로 올바르지 않은 것은?', '하나의 컬럼에 대해 별칭(ALIAS)은 한 번만 지정할 수 있습니다. AS 키워드는 생략 가능하며, 공백이나 특수문자가 포함된 별칭은 큰따옴표로 묶어야 합니다.', 60, 12),
	(117, 2, '```sql\nSELECT department_id, COUNT(*) emp_count,\n       COUNT(DISTINCT job_id) job_count\nFROM employees\nWHERE salary >= 3000\nGROUP BY department_id\nHAVING AVG(salary) > 5000\nORDER BY emp_count DESC;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는:\n1. WHERE로 급여 3000 이상 필터링\n2. GROUP BY로 부서별 그룹화\n3. HAVING으로 평균 급여 5000 초과 필터링\n4. 각 그룹의 직원 수와 고유한 직무 수 계산\n5. 직원 수 기준 내림차순 정렬', 120, 12),
	(118, 2, '```sql\nSELECT COUNT(column1) as cnt FROM table1;\n```', 2, NULL, '다음과 같은 SELECT문에서 실행 결과가 다른 것은?', 'COUNT 함수의 특징:\n1. COUNT(*): NULL을 포함한 모든 행 카운트\n2. COUNT(1) or COUNT(상수): COUNT(*)와 동일\n3. COUNT(컬럼): 해당 컬럼의 NULL이 아닌 값 카운트\n4. COUNT(DISTINCT 컬럼): 중복을 제거한 고유한 값만 카운트', 120, 12),
	(119, 2, '[요구사항]\n1. 부서별 직원수 조회\n2. 직원이 없는 부서도 포함\n3. 직원수가 많은 순서대로 정렬\n4. 부서가 없는 직원은 \'미배치\'로 표시', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 SQL문은?', '요구사항 분석:\n1. LEFT OUTER JOIN으로 모든 부서 포함\n2. COUNT(e.employee_id)로 부서별 직원 수 계산\n3. NVL로 NULL 처리\n4. ORDER BY로 내림차순 정렬', 180, 12),
	(120, 2, '```sql\n-- Query 1\nSELECT *\nFROM employees\nWHERE department_id IN (\n    SELECT department_id\n    FROM departments\n    WHERE location_id = 1700\n);\n\n-- Query 2\nSELECT e.*\nFROM employees e, departments d\nWHERE e.department_id = d.department_id\nAND d.location_id = 1700;\n\n-- Query 3\nSELECT e.*\nFROM employees e\nINNER JOIN departments d \nON e.department_id = d.department_id\nWHERE d.location_id = 1700;\n```', 3, NULL, '다음 SQL문들의 성능상 차이점을 가장 정확하게 설명한 것은?', 'SQL 성능 고려사항:\n1. 데이터 분포도:\n   - 위치별 부서 분포\n   - 부서별 직원 분포\n2. 인덱스 구성:\n   - location_id 인덱스\n   - department_id 인덱스\n3. 실행 계획:\n   - 옵티마이저의 선택\n   - 통계 정보 활용\n4. 조인 방식:\n   - Nested Loop Join\n   - Hash Join\n   - Sort Merge Join', 180, 12),
	(121, 2, NULL, 1, NULL, '다음 중 숫자형 함수에 대한 설명으로 틀린 것은?', 'MOD 함수는 나머지를 구하는 함수입니다. MOD(10, 3)의 결과는 1입니다. 10을 3으로 나눈 나머지가 1이기 때문입니다.', 60, 13),
	(122, 2, '```sql\nSELECT EMPLOYEE_NAME,\n       NVL2(COMMISSION_PCT,\n            SALARY * (1 + COMMISSION_PCT),\n            SALARY) AS TOTAL_SALARY\nFROM EMPLOYEES\nWHERE EMPLOYEE_ID = 100;\n```', 2, NULL, '다음 SQL문의 실행 결과로 옳은 것은?', 'NVL2(expr1, expr2, expr3) 함수는 expr1이 NULL이 아니면 expr2를, NULL이면 expr3을 반환합니다. 따라서 COMMISSION_PCT가 NULL이면 SALARY를 반환합니다.', 120, 13),
	(123, 2, '[현재 날짜가 2024-03-15라고 가정]', 2, NULL, '다음 날짜형 함수의 실행 결과가 다른 것은?', 'ADD_MONTHS는 정확히 3개월을 더하지만(2024-06-15), SYSDATE + 90은 정확히 90일을 더합니다(2024-06-13). 월마다 일수가 다르기 때문에 결과가 다릅니다.', 120, 13),
	(124, 2, '```sql\nSELECT DEPARTMENT_ID,\n       LISTAGG(EMPLOYEE_NAME, \', \') \n       WITHIN GROUP (ORDER BY SALARY DESC) AS EMPLOYEES\nFROM EMPLOYEES\nGROUP BY DEPARTMENT_ID;\n```', 3, NULL, '다음 SQL문의 실행 결과로 적절한 것은?', 'LISTAGG 함수는 GROUP BY로 그룹화된 데이터를 하나의 열에 가로로 나열합니다. WITHIN GROUP (ORDER BY SALARY DESC)로 인해 급여가 높은 순으로 정렬되어 출력됩니다.', 180, 13),
	(125, 2, '```sql\n-- Query 1\nSELECT DECODE(GRADE,\n             \'A\', \'최우수\',\n             \'B\', \'우수\',\n             \'C\', \'보통\',\n             \'미달\') AS RESULT\nFROM SCORES;\n\n-- Query 2\nSELECT CASE GRADE\n         WHEN \'A\' THEN \'최우수\'\n         WHEN \'B\' THEN \'우수\'\n         WHEN \'C\' THEN \'보통\'\n         ELSE \'미달\'\n       END AS RESULT\nFROM SCORES;\n```', 3, NULL, '다음 중 DECODE 함수와 CASE 문을 비교한 설명으로 가장 적절한 것은?', 'DECODE 함수는 등호(=) 비교만 가능하지만, CASE 문은 >, <, >=, <= 등 다양한 비교 연산자를 사용할 수 있습니다. 또한 CASE 문은 BETWEEN, IN, LIKE 등의 조건식도 사용 가능합니다.', 180, 13),
	(126, 2, NULL, 1, NULL, '다음 중 문자형 함수의 실행 결과로 옳지 않은 것은?', 'INSTR 함수는 문자열에서 특정 문자나 문자열의 위치를 찾는 함수입니다. \'ORACLE SQL\'에서 \'SQL\'은 8번째 위치에서 시작하므로 INSTR(\'ORACLE SQL\', \'SQL\')의 결과는 8입니다.', 60, 13),
	(127, 2, '```sql\nSELECT department_id,\n       COUNT(*) as total,\n       SUM(DECODE(gender, \'M\', 1, 0)) as male,\n       SUM(DECODE(gender, \'F\', 1, 0)) as female\nFROM employees\nGROUP BY department_id;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는:\n1. COUNT(*)로 전체 직원 수 계산\n2. DECODE와 SUM으로 성별 별 인원 계산\n   - gender가 \'M\'이면 1, 아니면 0을 합산하여 남성 수 계산\n   - gender가 \'F\'면 1, 아니면 0을 합산하여 여성 수 계산\n3. GROUP BY로 부서별 집계', 120, 13),
	(128, 2, '```\nPHONE_NUMBER\n-------------\n010-1234-5678\n010-2345-6789\n010)3456-7890\n01045678901\n```', 2, NULL, '다음과 같은 데이터가 있을 때, SQL 실행 결과가 다른 것은?', '④번 쿼리는 \'-\'가 있는 경우만 처리하고 \')\'는 처리하지 않습니다. 나머지 쿼리들은 모든 특수문자를 제거하여 숫자만 남깁니다.', 120, 13),
	(129, 2, '[요구사항]\n1. 직원의 근속연수를 계산\n2. 근속연수에 따라 다음과 같이 표시\n   - 10년 이상: \'10년 이상\'\n   - 5년 이상 10년 미만: \'5년 이상\'\n   - 3년 이상 5년 미만: \'3년 이상\'\n   - 3년 미만: \'신입사원\'\n3. 근속연수는 월 단위까지 계산 (예: 3년 2개월)', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 SQL문은?', '요구사항을 가장 정확히 만족하는 이유:\n1. MONTHS_BETWEEN으로 정확한 월수 계산\n2. 년과 월을 분리하여 표시\n3. 개월 수 기준으로 정확한 근속 기간 계산\n4. 결과에 년수와 개월수를 모두 표시', 180, 13),
	(130, 2, '```sql\n-- Query 1\nSELECT ROUND(AVG(NVL(commission_pct, 0)), 2) as avg_comm\nFROM employees;\n\n-- Query 2\nSELECT ROUND(NVL(AVG(commission_pct), 0), 2) as avg_comm\nFROM employees;\n\n-- Query 3\nSELECT COALESCE(ROUND(AVG(commission_pct), 2), 0) as avg_comm\nFROM employees;\n\n-- Query 4\nSELECT ROUND(AVG(COALESCE(commission_pct, 0)), 2) as avg_comm\nFROM employees;\n```', 3, NULL, '다음 SQL문들의 수행 결과가 다른 것을 고르시오.', 'Query 2는 나머지와 다른 결과를 반환할 수 있습니다. 왜냐하면 commission_pct가 모두 NULL인 경우, AVG 함수의 결과가 NULL이 되고, 이를 0으로 변환하기 때문입니다.', 180, 13),
	(131, 2, NULL, 1, NULL, '다음 중 WHERE절에서 사용할 수 있는 연산자에 대한 설명으로 틀린 것은?', 'NULL값을 찾을 때는 반드시 IS NULL을 사용해야 합니다. "=" 연산자로는 NULL값을 찾을 수 없습니다. NULL은 "알 수 없는 값"이므로 비교 연산자로 비교할 수 없습니다.', 60, 14),
	(132, 2, '```sql\nSELECT employee_name\nFROM employees\nWHERE salary BETWEEN 5000 AND 6000\nAND commission_pct IS NOT NULL\nAND department_id NOT IN (10, 20, 30)\nAND hire_date >= \'2020-01-01\';\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'WHERE절의 조건들은 AND로 연결되어 있어 모든 조건을 동시에 만족해야 합니다. BETWEEN은 경계값을 포함하고, NOT IN은 나열된 값을 제외한 결과를 반환합니다.', 120, 14),
	(133, 2, '```sql\n-- Query 1\nSELECT employee_id, employee_name\nFROM employees\nWHERE department_id = 20\nOR job_id = \'SA_REP\'\nAND salary >= 5000;\n\n-- Query 2\nSELECT employee_id, employee_name\nFROM employees\nWHERE (department_id = 20\nOR job_id = \'SA_REP\')\nAND salary >= 5000;\n```', 2, NULL, '다음 두 SQL문의 실행 결과가 다른 경우는?', 'Query 1은 "department_id = 20" 또는 "job_id = \'SA_REP\' AND salary >= 5000"을 만족하는 직원을 찾습니다. Query 2는 "department_id = 20 OR job_id = \'SA_REP\'"를 만족하면서 "salary >= 5000"인 직원을 찾습니다.', 120, 14),
	(134, 2, '```sql\nSELECT employee_id, employee_name\nFROM employees\nWHERE department_id LIKE \'1%\'\nAND job_id = \'SA_REP\'\nAND salary + NVL(commission_pct, 0) > 5000\nAND hire_date BETWEEN \'2020-01-01\' AND \'2020-12-31\';\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', '숫자형 컬럼인 department_id에 LIKE 연산자를 사용하면 암시적 형변환이 발생하여 성능이 저하될 수 있습니다. 숫자형 컬럼은 = 또는 BETWEEN 등의 연산자를 사용하는 것이 바람직합니다.', 180, 14),
	(135, 2, NULL, 3, NULL, '다음 중 WHERE절의 성능과 관련된 설명으로 가장 부적절한 것은?', 'OR 조건을 AND 조건으로 변환하는 것이 항상 좋은 것은 아닙니다. 때로는 OR 조건을 UNION ALL로 변환하거나, 원래의 OR 조건을 그대로 사용하는 것이 더 나은 성능을 보일 수 있습니다. 실행 계획과 데이터 분포를 고려하여 적절한 방식을 선택해야 합니다.', 180, 14),
	(136, 2, NULL, 1, NULL, '다음 WHERE 절의 조건식 중 올바르지 않은 것은?', 'BETWEEN 연산자에는 NULL을 사용할 수 없습니다. NULL과의 비교는 항상 UNKNOWN을 반환하므로, NULL을 포함한 범위 비교는 불가능합니다. NULL 값 비교는 반드시 IS NULL 또는 IS NOT NULL을 사용해야 합니다.', 60, 14),
	(137, 2, '```sql\n-- Query 1\nSELECT employee_name\nFROM employees\nWHERE NVL(commission_pct, 0) != 0;\n\n-- Query 2\nSELECT employee_name\nFROM employees\nWHERE commission_pct IS NOT NULL;\n\n-- Query 3\nSELECT employee_name\nFROM employees\nWHERE COALESCE(commission_pct, 0) > 0;\n\n-- Query 4\nSELECT employee_name\nFROM employees\nWHERE commission_pct > 0;\n```', 2, NULL, '다음 SQL문들의 실행 결과가 다른 것을 고르시오.', 'Query 1, 3, 4는 commission_pct가 0보다 큰 직원을 조회합니다. 하지만 Query 2는 commission_pct가 NULL이 아닌 모든 직원을 조회하므로 값이 0인 경우도 포함됩니다. 따라서 Query 2만 다른 결과를 반환합니다.', 120, 14),
	(138, 2, '```sql\nSELECT *\nFROM employees\nWHERE _______________\n```', 2, NULL, '다음과 같은 WHERE 절에서 인덱스를 효율적으로 사용할 수 있는 조건은?', '인덱스 사용의 효율성:\n1. 함수를 컬럼에 적용하면 인덱스 사용 불가 (①)\n2. 컬럼에 연산을 수행하면 인덱스 사용 불가 (②)\n3. 날짜 형식 변환은 인덱스 사용 가능 (③)\n4. NVL 함수 사용 시 인덱스 사용 불가 (④)', 120, 14),
	(139, 2, '[요구사항]\n1. 2023년에 입사한 직원 중\n2. 급여가 5000 이상이며\n3. 부서가 10, 20, 30 중 하나이고\n4. 이메일이 \'A\'로 시작하는 직원 조회\n5. 인덱스: (hire_date, salary), (department_id), (email)', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 효율적인 WHERE 절은?', '복합 인덱스와 조건절 순서 고려:\n1. hire_date, salary 복합 인덱스를 활용하기 위해 날짜 범위 조건을 먼저 사용\n2. BETWEEN은 내부적으로 >= AND <= 로 변환되어 효율적\n3. department_id는 단일 인덱스로 IN 조건 사용 가능\n4. email은 LIKE \'A%\' 형태로 인덱스 활용 가능', 180, 14),
	(140, 2, '```sql\nSELECT *\nFROM employees\nWHERE (department_id, salary) IN (\n    SELECT department_id, MAX(salary)\n    FROM employees\n    GROUP BY department_id\n)\nAND commission_pct IS NOT NULL;\n```', 3, NULL, '다음 SQL문의 실행 결과와 성능 특성으로 가장 적절한 것은?', '쿼리 분석:\n1. 서브쿼리 특징:\n   - 독립적으로 실행 가능한 비상관 서브쿼리\n   - GROUP BY로 부서별 최대 급여 계산\n2. 메인 쿼리 특징:\n   - (department_id, salary) 쌍으로 비교\n   - commission_pct 조건 추가\n3. 성능 특성:\n   - 서브쿼리는 한 번만 실행\n   - 결과를 해시 테이블로 저장 가능\n   - 효율적인 조인 수행 가능', 180, 14),
	(141, 2, NULL, 1, NULL, '다음 중 GROUP BY, HAVING 절에 대한 설명으로 틀린 것은?', 'HAVING 절은 GROUP BY 절과 함께 사용해야 합니다. GROUP BY로 그룹화된 데이터에 대한 조건을 지정하는 것이 HAVING 절의 역할이므로, GROUP BY 없이는 사용할 수 없습니다.', 60, 15),
	(142, 2, NULL, 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'SQL문의 실행 순서와 조건:\n1. WHERE로 급여 5000 이상 직원 필터링\n2. department_id, job_id로 그룹화\n3. HAVING으로 그룹별 직원 수 2명 이상 필터링\n4. 직원 수 내림차순 정렬', 120, 15),
	(143, 2, NULL, 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'Query 1은 실행 시 에러 발생:\n- WHERE 절에서는 집계 함수를 사용할 수 없음\n- WHERE는 개별 행을 필터링하는 용도\nQuery 2는 정상 실행:\n- HAVING 절에서 집계 함수 사용 가능\n- 그룹화된 결과에 대한 조건 지정 가능', 120, 15),
	(144, 2, '[요구사항]\n1. 부서별, 직급별 평균 급여 계산\n2. 평균 급여가 5000 이상인 그룹만 조회\n3. 부서 내 직원이 3명 이상인 그룹만 대상\n4. 결과는 부서별, 평균 급여 내림차순 정렬\n5. NULL 값은 제외', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 SQL문은?', '요구사항을 만족하는 이유:\n1. NULL 값 제외를 WHERE 절에서 처리\n2. GROUP BY로 부서별, 직급별 그룹화\n3. HAVING 절에서 평균 급여와 직원 수 조건 체크\n4. ORDER BY로 정렬 요건 충족\n5. ROUND 함수로 소수점 처리', 180, 15),
	(145, 2, '[요구사항]\n- 부서별로 급여 구간대 인원 수 계산\n- 급여 구간: 0-5000, 5001-10000, 10001 이상\n- 부서별 전체 인원이 5명 이상인 부서만 조회\n- 구간별 인원수가 0명인 경우도 표시\n- 부서명과 함께 출력', 3, NULL, '다음과 같은 데이터에서 부서별 급여 분포를 조회하려고 할 때, 가장 적절한 SQL문은?', '가장 적절한 해결방안:\n1. CASE WHEN과 SUM을 조합하여 각 구간별 카운트\n2. ELSE 0을 통해 NULL 처리\n3. department_id도 GROUP BY에 포함하여 정확한 그룹화\n4. HAVING으로 전체 인원 5명 이상 필터링\n5. JOIN을 통해 부서명 표시', 180, 15),
	(146, 2, NULL, 1, NULL, '다음 중 GROUP BY 절에서 사용할 수 있는 표현식으로 올바르지 않은 것은?', 'GROUP BY 절에서는 연산식을 직접 사용할 수 없습니다. salary + commission_pct와 같은 산술식은 SELECT 절에서는 사용 가능하지만, GROUP BY 절에서는 사용할 수 없습니다. 함수나 CASE 표현식은 사용 가능합니다.', 60, 15),
	(147, 2, NULL, 2, NULL, '다음 SQL문에서 잘못된 부분을 찾으시오.', 'GROUP BY 절을 사용할 때는 집계 함수를 제외한 SELECT 절의 모든 컬럼이 GROUP BY 절에 포함되어야 합니다. employee_name은 집계 함수로 감싸지 않았으므로 GROUP BY 절에 포함되어야 합니다.', 120, 15),
	(148, 2, '[Employees 테이블]\nHIRE_DATE    DEPARTMENT_ID    SALARY\n2023-01-01   10              5000\n2023-02-01   10              6000\n2023-01-15   20              4500\n2023-03-01   20              5500', 2, NULL, '다음과 같은 데이터에서 적절한 그룹화 방법은?', '①번이 가장 적절한 이유:\n1. TO_CHAR 함수로 년-월 단위 그룹화\n2. GROUP BY 절에 SELECT 절의 모든 비집계 컬럼 포함\n3. 결과의 의미가 명확함\n4. 날짜 데이터를 원하는 형식으로 정확히 그룹화', 120, 15),
	(149, 2, '[요구사항]\n1. 분기별 매출 집계\n2. 전체 매출의 10% 이상인 분기만 조회\n3. 분기별 주문 건수도 함께 표시\n4. 분기별 평균 주문금액이 1000 이상인 경우만 포함', 3, NULL, '다음과 같은 분석 요구사항에 맞는 SQL문은?', '요구사항을 정확히 만족하는 이유:\n1. 분기별 그룹화: TO_CHAR(order_date, \'Q\')\n2. 전체 매출의 10% 조건: 서브쿼리로 비교\n3. 주문 건수: COUNT(*)\n4. 평균 주문금액 조건: AVG(amount) >= 1000\n5. HAVING 절에서 모든 조건을 정확히 체크', 180, 15),
	(150, 2, NULL, 3, NULL, '다음 GROUP BY 절의 성능 개선 방법으로 가장 부적절한 것은?', 'GROUP BY와 DISTINCT는 다른 목적으로 사용됩니다:\n1. GROUP BY:\n   - 집계 함수와 함께 사용\n   - 여러 행을 그룹화하여 요약 정보 생성\n   - 인덱스를 활용한 최적화 가능\n2. DISTINCT:\n   - 단순 중복 제거\n   - 집계 기능 없음\n   - 전체 데이터 스캔 필요\n3. 성능 개선 방안:\n   - 적절한 인덱스 사용\n   - 데이터 필터링\n   - 임시 테이블 활용', 180, 15),
	(151, 2, NULL, 1, NULL, '다음 중 ORDER BY 절에 대한 설명으로 틀린 것은?', 'ORDER BY 절에서는 SELECT 목록에 있는 모든 컬럼과 표현식을 사용할 수 있습니다. GROUP BY 절에 사용한 컬럼으로 제한되지 않습니다. 단, GROUP BY를 사용할 경우 집계함수나 GROUP BY에 사용된 컬럼으로 정렬하는 것이 일반적입니다.', 60, 16),
	(152, 2, '```sql\nSELECT department_id, \n       COUNT(*) as emp_count,\n       AVG(salary) as avg_salary\nFROM employees\nWHERE salary >= 5000\nGROUP BY department_id\nORDER BY 2 DESC, 3;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'ORDER BY 절의 해석:\n1. ORDER BY 2: SELECT 목록의 두 번째 컬럼(emp_count)으로 내림차순\n2. ORDER BY 3: SELECT 목록의 세 번째 컬럼(avg_salary)으로 오름차순\n3. DESC는 앞의 정렬 기준에만 적용\n4. 컬럼 번호 대신 컬럼명을 사용하는 것이 더 명확함', 120, 16),
	(153, 2, '```sql\n-- Query 1\nSELECT employee_id, first_name, salary\nFROM employees\nWHERE department_id = 50\nORDER BY salary DESC NULLS LAST;\n\n-- Query 2\nSELECT employee_id, first_name, salary\nFROM employees\nWHERE department_id = 50\nORDER BY salary DESC;\n```', 2, NULL, '다음 두 SQL문의 실행 결과가 다른 경우는?', 'NULLS LAST와 일반 정렬의 차이:\n1. NULLS LAST: NULL 값을 항상 마지막에 정렬\n2. 일반 정렬(Oracle): NULL 값을 가장 큰 값으로 처리\n3. salary가 NULL인 경우:\n   - Query 1: NULL 값이 결과의 마지막에 위치\n   - Query 2: NULL 값이 결과의 처음에 위치 (DESC 정렬 시)', 120, 16),
	(154, 2, '[요구사항]\n1. 부서별 직원 목록 조회\n2. 부서 내에서 직급별로 그룹화\n3. 같은 직급 내에서는 급여 높은 순\n4. 급여가 같은 경우 입사일이 빠른 순\n5. NULL 값은 마지막에 표시', 3, NULL, '다음과 같은 정렬이 필요할 때, 가장 적절한 SQL문은?', '요구사항을 만족하는 핵심 요소:\n1. department_name으로 첫 번째 정렬\n2. job_title로 두 번째 정렬\n3. salary DESC로 세 번째 정렬\n4. hire_date ASC로 네 번째 정렬\n5. 각 컬럼에 NULLS LAST 지정\n6. 명시적인 컬럼명 사용', 180, 16),
	(155, 2, '[요구사항]\n- 부서별 급여 순위 산출\n- 급여가 같은 경우 같은 순위 부여\n- 다음 순위는 건너뛰기\n- 부서별로 상위 3위까지만 표시', 3, NULL, '다음과 같은 순위 기반 정렬이 필요할 때, 가장 적절한 SQL문은?', '요구사항을 만족하는 이유:\n1. RANK() 함수 사용으로 동일 값 같은 순위\n2. PARTITION BY로 부서별 순위 계산\n3. salary DESC로 급여 내림차순\n4. 서브쿼리와 WHERE절로 상위 3위 필터링\n5. ORDER BY로 부서별, 순위별 정렬', 180, 16),
	(156, 2, NULL, 1, NULL, '다음 중 ORDER BY 절에서 NULL 값을 처리하는 방법으로 올바르지 않은 것은?', 'ORDER BY DESC와 NULLS FIRST를 함께 사용하는 것은 일반적이지 않습니다. DESC 정렬에서는 기본적으로 NULL이 가장 큰 값으로 처리되므로 NULLS FIRST는 정렬 의도와 맞지 않습니다.', 60, 16),
	(157, 2, '```sql\nSELECT * FROM employees\nWHERE department_id = 50\nORDER BY job_id, hire_date DESC, salary;\n```', 2, NULL, '다음과 같은 ORDER BY 절을 사용할 때 가장 효율적인 인덱스 구성은?', '복합 인덱스 구성 시 고려사항:\n1. WHERE 절의 조건이 선두 컬럼(department_id)\n2. ORDER BY의 모든 컬럼 포함\n3. 정렬 순서와 인덱스 구성 순서 일치\n4. 단일 인덱스 스캔으로 결과 도출 가능', 120, 16),
	(158, 2, '```sql\n-- Query 1\nSELECT employee_id, salary\nFROM employees\nORDER BY hire_date DESC;\n\n-- Query 2\nSELECT employee_id, salary\nFROM employees\nWHERE employee_id > 0\nORDER BY hire_date DESC;\n```', 2, NULL, '다음 두 SQL문의 실행 계획이 다른 경우는?', 'employee_id에 인덱스가 있는 경우:\n1. Query 1: hire_date 기준 정렬 필요\n2. Query 2: employee_id 인덱스 스캔 후 정렬 필요\n3. WHERE 조건으로 인해 인덱스 활용 방식이 달라짐\n4. 서로 다른 실행 계획 생성', 120, 16),
	(159, 2, '[요구사항]\n1. 부서별 급여 합계를 구하되\n2. 급여 합계 상위 3개 부서만 조회\n3. 나머지 부서는 \'Others\'로 묶어서 표시\n4. 결과는 급여 합계 내림차순 정렬', 3, NULL, '다음과 같은 복잡한 정렬이 필요할 때, 가장 적절한 SQL문은?', '최적의 해결방안 선택 이유:\n1. 순위 계산: RANK() 함수 사용\n2. 상위 3개 구분: CASE 문으로 처리\n3. Others 그룹화: 추가 GROUP BY로 처리\n4. 정렬: 최종 결과 ORDER BY로 정렬\n5. 서브쿼리로 단계적 처리', 180, 16),
	(160, 2, NULL, 3, NULL, '다음 중 ORDER BY 절의 성능 개선 방안으로 가장 부적절한 것은?', '모든 정렬 컬럼에 대한 인덱스 생성은 부적절:\n1. 과도한 인덱스:\n   - 저장 공간 낭비\n   - DML 성능 저하\n   - 인덱스 관리 비용 증가\n2. 적절한 개선 방안:\n   - 필요한 컬럼만 조회\n   - 데이터 필터링 후 정렬\n   - 복합 인덱스 활용\n   - 실행 계획 분석', 180, 16),
	(161, 2, '```sql\nSELECT * FROM EMP E, DEPT D\nWHERE E.DEPTNO = D.DEPTNO;\n```', 1, NULL, '다음 중 조인(JOIN)에 대한 설명으로 가장 부적절한 것은?', 'OUTER JOIN은 조인 조건에서 NULL 값을 가진 데이터도 출력할 수 있습니다. 이는 OUTER JOIN의 주요 특징 중 하나입니다.', 60, 17),
	(162, 2, '```sql\nSELECT COUNT(*) \nFROM EMPLOYEE E \nLEFT OUTER JOIN DEPARTMENT D\nON E.DEPT_ID = D.DEPT_ID\nWHERE D.DEPT_NAME IS NULL;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'LEFT OUTER JOIN을 수행한 후 D.DEPT_NAME IS NULL 조건은 부서 테이블과 매칭되지 않은 사원, 즉 부서가 없는 사원을 찾는 조건입니다.', 120, 17),
	(163, 2, '```sql\nSELECT *\nFROM TABLE1 T1, TABLE2 T2, TABLE3 T3\nWHERE T1.COL1 = T2.COL1\nAND T2.COL2 = T3.COL2;\n```', 2, NULL, '세 개의 테이블을 조인할 때 다음 SQL문의 실행 결과와 동일한 것은?', '일반적인 WHERE 절을 사용한 조인은 INNER JOIN과 동일한 결과를 반환합니다.', 120, 17),
	(164, 2, '```sql\n-- Query 1\nSELECT E.ENAME, D.DNAME\nFROM EMP E, DEPT D\nWHERE E.DEPTNO = D.DEPTNO;\n\n-- Query 2\nSELECT E.ENAME, D.DNAME\nFROM EMP E LEFT OUTER JOIN DEPT D\nON E.DEPTNO = D.DEPTNO;\n```', 3, NULL, '다음 두 쿼리의 결과가 다른 경우는?', 'EMP 테이블의 DEPTNO가 NULL인 경우, Query 1(INNER JOIN)에서는 해당 데이터가 제외되지만, Query 2(LEFT OUTER JOIN)에서는 포함됩니다.', 180, 17),
	(165, 2, '```sql\nSELECT E.EMPNO, E.ENAME, D.DNAME\nFROM EMP E, DEPT D\nWHERE E.DEPTNO = D.DEPTNO\nAND D.LOC IN (\'NEW YORK\', \'BOSTON\')\nAND E.SAL >= 3000;\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'WHERE 절을 사용한 INNER JOIN은 NULL 값을 가진 데이터를 자동으로 제외하므로, 누락될 수 있는 중요한 데이터가 있다면 OUTER JOIN을 고려해야 합니다.', 180, 17),
	(166, 2, NULL, 1, NULL, '다음 중 SELF JOIN에 대한 설명으로 가장 부적절한 것은?', 'SELF JOIN은 서브쿼리와 함께 사용할 필요가 없습니다. 동일한 테이블을 별칭을 달리하여 조인하는 것만으로도 충분합니다.', 60, 17),
	(167, 2, '```sql\n-- Query 1\nSELECT * FROM employees e\nINNER JOIN departments d\nON e.department_id = d.department_id;\n\n-- Query 2\nSELECT * FROM employees e, departments d\nWHERE e.department_id = d.department_id;\n\n-- Query 3\nSELECT * FROM employees e\nNATURAL JOIN departments d;\n\n-- Query 4\nSELECT * FROM employees e\nJOIN departments d USING (department_id);\n```', 2, NULL, '다음 SQL문들의 실행 결과가 같은 것을 고르시오.', 'Query 1과 Query 2는 동일한 INNER JOIN을 표현하는 다른 문법입니다.\nNATURAL JOIN은 같은 이름을 가진 모든 컬럼을 자동으로 조인합니다.\nUSING은 지정된 컬럼만 조인하며, 조인 컬럼이 결과에 한 번만 표시됩니다.', 120, 17),
	(168, 2, '```sql\n-- 주문(Orders) 테이블의 일부 데이터만 고객(Customers) 정보 필요\n-- 모든 주문은 반드시 고객 정보가 있어야 함\n-- 주문 금액으로 정렬 필요\n```', 2, NULL, '다음과 같은 테이블 구조에서 가장 적절한 조인 방식은?', 'INNER JOIN이 가장 적절한 이유:\n1. 모든 주문에 고객 정보가 필요하고 존재함\n2. 고객 정보가 없는 주문은 불가능함\n3. 고객 테이블의 모든 데이터가 필요하지 않음\n4. INNER JOIN이 성능상 가장 유리함', 120, 17),
	(169, 2, '```sql\n[요구사항]\n1. 부서별 사원 수 조회\n2. 사원이 없는 부서도 포함\n3. 부서가 없는 사원도 포함\n4. 부서 이름 기준 오름차순 정렬\n```', 3, NULL, '다음 요구사항을 만족하는 가장 적절한 SQL문은?', '최적의 해결방안 선택 이유:\n1. FULL OUTER JOIN으로 모든 케이스 포함\n2. NVL로 NULL 부서명 처리\n3. COUNT(employee_id)로 정확한 직원 수 계산\n4. CASE 식으로 NULL 정렬 처리\n5. ORDER BY로 정렬 요건 충족', 180, 17),
	(170, 2, NULL, 3, NULL, '다음 조인 쿼리의 성능 개선 방안으로 가장 부적절한 것은?', 'WHERE 절의 조건을 ON 절로 이동하는 것은:\n1. INNER JOIN의 경우 성능 차이가 없음\n2. OUTER JOIN의 경우 결과가 달라질 수 있음\n3. 가독성이 저하될 수 있음\n4. 쿼리 최적화에 부정적 영향을 줄 수 있음\n\n적절한 성능 개선 방안:\n1. 적절한 인덱스 생성\n2. 조인 테이블 순서 최적화\n3. 불필요한 OUTER JOIN 제거', 180, 17),
	(171, 2, NULL, 1, NULL, '다음 중 표준 SQL의 조인 문법에 대한 설명으로 틀린 것은?', 'CROSS JOIN은 ON 절을 사용하지 않습니다. CROSS JOIN은 두 테이블의 모든 행을 조합하는 카테시안 곱(Cartesian Product)을 생성하며, 조인 조건이 필요하지 않습니다.', 60, 18),
	(172, 2, NULL, 2, NULL, '다음 두 SQL문의 실행 결과가 다른 경우는?', '두 쿼리의 차이점:\n1. Query 1: WHERE 절로 인해 LEFT JOIN의 효과가 사라지고 INNER JOIN처럼 동작\n2. Query 2: ON 절의 조건으로 인해 LEFT JOIN의 효과 유지\n3. 특히 department_id가 NULL인 직원의 경우:\n   - Query 1: 결과에서 제외됨\n   - Query 2: NULL 값으로 포함됨', 120, 18),
	(173, 2, '[ORDERS 테이블]\nORDER_ID    CUSTOMER_ID    ORDER_DATE\n1           A001           2024-01-01\n2           A002           2024-01-02\n3           A003           2024-01-03\n\n[CUSTOMERS 테이블]\nCUSTOMER_ID    NAME        GRADE\nA001           김철수       VIP\nA002           이영희       GOLD\nA004           박지민       SILVER', 2, NULL, '다음과 같은 데이터가 있을 때, 주어진 SQL문의 결과로 올바른 것은?', 'RIGHT OUTER JOIN의 결과:\n1. A001 고객: 주문 있음 (1행)\n2. A002 고객: 주문 있음 (1행)\n3. A004 고객: 주문 없음 (1행, order_id는 NULL)\n4. A003의 주문은 결과에서 제외 (매칭되는 고객 없음)\n따라서 총 3개의 행이 조회됩니다.', 120, 18),
	(174, 2, '[요구사항]\n1. 모든 부서의 정보 출력\n2. 각 부서별 평균 급여 계산\n3. 부서에 직원이 없는 경우 평균 급여를 0으로 표시\n4. 부서명, 직원 수, 평균 급여 출력', 3, NULL, '다음 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '요구사항을 충족하기 위한 핵심 포인트:\n1. LEFT JOIN 또는 RIGHT JOIN으로 모든 부서 정보 포함\n2. COUNT(employee_id)로 정확한 직원 수 계산\n3. NVL(AVG(salary), 0)으로 NULL 처리\n4. GROUP BY에 department_id 포함하여 정확한 그룹화\n5. department_name도 GROUP BY에 포함', 180, 18),
	(175, 2, '[SQL문]\nSELECT e.employee_id, e.employee_name,\n       d.department_name,\n       l.city,\n       j.job_title\nFROM employees e\nLEFT JOIN departments d ON e.department_id = d.department_id\nLEFT JOIN locations l ON d.location_id = l.location_id\nLEFT JOIN jobs j ON e.job_id = j.job_id\nWHERE e.hire_date >= \'2023-01-01\'\nAND d.department_name LIKE \'IT%\';', 3, NULL, '다음과 같은 조인 쿼리의 성능 개선 방안으로 가장 부적절한 것은?', 'LEFT JOIN을 INNER JOIN으로 변경하는 것은 부적절합니다:\n1. 데이터의 의미가 변경될 수 있음\n2. 누락되는 데이터가 발생할 수 있음\n3. 업무 요구사항을 만족하지 못할 수 있음\n\n적절한 성능 개선 방안:\n1. WHERE 조건을 서브쿼리로 먼저 필터링\n2. 조인 순서 최적화\n3. 적절한 인덱스 사용\n4. 불필요한 조인 제거', 180, 18),
	(176, 2, NULL, 1, NULL, '다음 중 NATURAL JOIN에 대한 설명으로 가장 올바른 것은?', 'NATURAL JOIN은 두 테이블 간 동일한 이름을 가진 모든 컬럼을 자동으로 조인 조건으로 사용합니다. ON 절을 사용하지 않으며, 조인 컬럼은 결과에서 한 번만 나타납니다.', 60, 18),
	(177, 2, NULL, 2, NULL, '다음 SQL문들의 실행 결과가 다른 것은?', 'NATURAL JOIN은 동일한 이름을 가진 모든 컬럼을 조인 조건으로 사용합니다. 만약 department_id 외에도 다른 동일한 이름의 컬럼이 있다면, 결과가 다를 수 있습니다. 나머지는 모두 department_id만을 조인 조건으로 사용합니다.', 120, 18),
	(178, 2, '[데이터베이스 구조]\n- 직원은 반드시 하나의 부서에 속함\n- 부서는 반드시 하나의 지역에 속함\n- 직원은 여러 개의 프로젝트에 참여 가능\n- 프로젝트는 여러 명의 직원이 참여 가능', 2, NULL, '다음과 같은 데이터베이스 구조에서 가장 적절한 조인 방식은?', '주어진 상황 분석:\n1. 직원-부서: 필수 관계 → INNER JOIN\n2. 부서-지역: 필수 관계 → INNER JOIN\n3. 직원-프로젝트: M:N 관계 → 중간 테이블 사용한 INNER JOIN\n모든 관계가 필수적이므로 INNER JOIN이 가장 적절합니다.', 120, 18),
	(179, 2, '[요구사항]\n1. 모든 부서의 평균 급여 조회\n2. 직원이 있는 부서는 해당 부서 평균 급여 표시\n3. 직원이 없는 부서는 전체 평균 급여 표시\n4. 부서 없는 직원의 급여는 제외', 3, NULL, '다음 요구사항에 맞는 가장 적절한 SQL문은?', '요구사항을 만족하는 이유:\n1. LEFT JOIN으로 모든 부서 포함\n2. COUNT로 직원 유무 확인\n3. CASE 문으로 조건부 평균 계산\n4. 서브쿼리로 전체 평균 계산\n5. GROUP BY로 정확한 그룹화', 180, 18),
	(180, 2, NULL, 3, NULL, '다음과 같은 CROSS JOIN이 필요한 상황으로 가장 적절한 것은?', 'CROSS JOIN의 적절한 사용 사례:\n1. 모든 가능한 조합이 필요한 경우:\n   - 상품 크기와 색상의 모든 조합\n   - 날짜별 부서 조합\n   - 테스트 데이터 생성\n\n2. 부적절한 사용 사례:\n   - 계층 구조 → SELF JOIN\n   - 누락 데이터 → OUTER JOIN\n   - 집계 → GROUP BY', 180, 18),
	(181, 2, NULL, 1, NULL, '다음 중 서브쿼리에 대한 설명으로 틀린 것은?', '스칼라 서브쿼리는 SELECT절에서 사용되며 반드시 단일 행, 단일 컬럼을 반환해야 합니다. 다중 행을 반환하면 오류가 발생합니다.', 60, 19),
	(182, 2, '```sql\nSELECT employee_name, salary\nFROM employees e\nWHERE salary > (\n    SELECT AVG(salary)\n    FROM employees\n    WHERE department_id = e.department_id\n);\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', '이 쿼리는 상호연관 서브쿼리를 사용하여 각 직원이 속한 부서의 평균 급여와 비교합니다. e.department_id를 통해 메인쿼리의 각 행에 대해 해당 부서의 평균 급여를 계산하여 비교합니다.', 120, 19),
	(183, 2, '```sql\n-- Query 1\nSELECT department_id, department_name\nFROM departments\nWHERE department_id IN (\n    SELECT department_id\n    FROM employees\n    WHERE salary >= 5000\n);\n\n-- Query 2\nSELECT DISTINCT d.department_id, d.department_name\nFROM departments d, employees e\nWHERE d.department_id = e.department_id\nAND e.salary >= 5000;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'department_id가 NULL인 직원의 경우, Query 1에서는 IN 절에 NULL이 포함되어 결과에서 제외되지만, Query 2에서는 조인 조건을 만족하지 않아 처음부터 결과에 포함되지 않습니다.', 120, 19),
	(184, 2, '```sql\nSELECT employee_id, employee_name,\n       (SELECT department_name \n        FROM departments d \n        WHERE d.department_id = e.department_id) as dept_name,\n       (SELECT job_title \n        FROM jobs j \n        WHERE j.job_id = e.job_id) as job_name\nFROM employees e;\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', '이 쿼리는 각 행마다 2개의 스칼라 서브쿼리가 실행되므로, 데이터 양이 많을 경우 성능이 크게 저하될 수 있습니다. 이런 경우 조인을 사용하는 것이 더 효율적일 수 있습니다.', 180, 19),
	(185, 2, '```sql\n-- Original Query\nSELECT *\nFROM employees e\nWHERE salary > (\n    SELECT AVG(salary)\n    FROM employees\n    WHERE department_id = e.department_id\n)\nAND department_id IN (\n    SELECT department_id\n    FROM departments\n    WHERE location_id = 1700\n);\n```', 3, NULL, '다음 중 서브쿼리 성능 개선 방안으로 가장 부적절한 것은?', '모든 서브쿼리를 뷰로 생성하는 것은 적절하지 않습니다. 뷰는 재사용성이 높고 복잡한 로직을 캡슐화할 때 사용하는 것이 좋으며, 단순한 서브쿼리의 경우 오히려 성능 저하를 초래할 수 있습니다.', 180, 19),
	(186, 2, NULL, 1, NULL, '다음 중 인라인 뷰(Inline View)에 대한 설명으로 가장 부적절한 것은?', '인라인 뷰에서도 메인쿼리의 컬럼을 참조할 수 있습니다. 이를 상관관계 서브쿼리(Correlated Subquery)라고 하며, 메인쿼리의 각 행에 대해 서브쿼리가 실행됩니다.', 60, 19),
	(187, 2, '```sql\nSELECT department_id, employee_name, salary\nFROM (\n    SELECT department_id, employee_name, salary,\n           RANK() OVER (PARTITION BY department_id \n                       ORDER BY salary DESC) as rank\n    FROM employees\n)\nWHERE rank <= 2;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는 부서별로 급여 순위를 계산한 후, 순위가 2 이하인 직원만 선택합니다. 따라서 각 부서별로 급여가 가장 높은 2명의 직원이 조회됩니다.', 120, 19),
	(188, 2, '```sql\nSELECT *\nFROM employees\nWHERE (department_id, salary) IN (\n    SELECT department_id, MAX(salary)\n    FROM employees\n    GROUP BY department_id\n);\n```', 2, NULL, '다음과 같은 서브쿼리를 사용할 때 가장 적절한 방식은?', '복합 컬럼 비교를 하는 경우 현재의 방식이 가장 적절합니다. 가독성이 좋고, 의도가 명확하며, 최적화도 잘 됩니다.', 120, 19),
	(189, 2, '[요구사항]\n1. 부서별 평균 급여보다 많은 급여를 받는 직원 조회\n2. 부서가 없는 직원도 전체 평균과 비교하여 포함\n3. 급여 순으로 정렬', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 SQL문은?', 'LEFT JOIN을 사용하여 부서가 없는 직원도 포함하고, NVL을 사용하여 NULL을 처리하며, 상관 서브쿼리로 각 부서별 평균과 비교하여 급여가 높은 직원을 조회합니다.', 180, 19),
	(190, 2, '```sql\nSELECT e.employee_id, e.employee_name,\n       (SELECT department_name \n        FROM departments d \n        WHERE d.department_id = e.department_id) as dept_name,\n       (SELECT COUNT(*) \n        FROM employees \n        WHERE department_id = e.department_id) as dept_count\nFROM employees e\nWHERE salary > (\n    SELECT AVG(salary) \n    FROM employees \n    WHERE department_id = e.department_id\n);\n```', 3, NULL, '다음 서브쿼리의 성능 개선 방안으로 가장 적절한 것은?', 'WITH절을 사용하여 부서별 통계를 한 번만 계산하고 결과를 재사용하면 성능이 향상됩니다.', 180, 19),
	(191, 2, NULL, 1, NULL, '다음 중 집합 연산자에 대한 설명으로 틀린 것은?', 'MINUS는 첫 번째 집합에서 두 번째 집합을 뺀 차집합을 반환합니다. 교집합을 반환하는 것은 INTERSECT입니다.', 60, 20),
	(192, 2, '```sql\nSELECT employee_id, department_id\nFROM employees\nWHERE department_id = 10\nUNION\nSELECT employee_id, department_id\nFROM employees\nWHERE salary >= 5000\nORDER BY employee_id;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'UNION 연산자는 두 SELECT 결과를 합집합으로 반환하고 중복을 제거합니다. ORDER BY는 마지막에만 사용 가능하며 전체 결과를 정렬합니다.', 120, 20),
	(193, 2, '```sql\n-- Query 1\nSELECT department_id FROM employees\nMINUS\nSELECT department_id FROM departments;\n\n-- Query 2\nSELECT DISTINCT department_id \nFROM employees e\nWHERE NOT EXISTS (\n    SELECT 1 FROM departments d\n    WHERE d.department_id = e.department_id\n);\n```', 2, NULL, '다음 두 집합 연산의 결과가 같은 경우는?', '두 쿼리는 employees 테이블에만 존재하는 department_id를 조회하는 동일한 결과를 반환합니다.', 120, 20),
	(194, 2, '[요구사항]\n1. 2023년과 2024년의 월별 매출 비교\n2. 두 기간의 매출이 모두 존재하는 월만 조회\n3. 매출 차이도 함께 표시\n4. 월별로 정렬하여 출력', 3, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '각 연도의 매출을 별도로 집계하고 조인을 통해 두 기간 모두 존재하는 월만 선택하여 차이를 계산합니다.', 180, 20),
	(195, 2, NULL, 3, NULL, '다음 중 집합 연산자의 제약사항으로 가장 부적절한 것은?', '집합 연산자를 사용할 때는 컬럼 개수와 데이터 타입이 일치해야 하지만, 별칭(Alias)은 동일할 필요가 없습니다.', 180, 20),
	(196, 2, NULL, 1, NULL, '다음 중 UNION ALL과 UNION의 차이점으로 가장 적절한 것은?', 'UNION은 중복을 제거하지만, UNION ALL은 중복을 허용합니다. 일반적으로 UNION ALL이 성능이 더 좋습니다.', 60, 20),
	(197, 2, '```sql\n-- Query 1\nSELECT department_id FROM employees\nINTERSECT\nSELECT department_id FROM departments;\n\n-- Query 2\nSELECT DISTINCT department_id\nFROM employees e\nWHERE EXISTS (\n    SELECT 1 FROM departments d\n    WHERE d.department_id = e.department_id\n);\n\n-- Query 3\nSELECT DISTINCT e.department_id\nFROM employees e\nINNER JOIN departments d\nON e.department_id = d.department_id;\n\n-- Query 4\nSELECT department_id FROM employees\nWHERE department_id IN (\n    SELECT department_id FROM departments\n);\n```', 2, NULL, '다음 SQL문들의 실행 결과가 같은 것을 고르시오.', 'INTERSECT, EXISTS, INNER JOIN, IN 연산자는 모두 동일한 결과를 반환합니다.', 120, 20),
	(198, 2, '```sql\n[TABLE1]        [TABLE2]\nID  VALUE       ID  VALUE\n1   A           1   A\n2   B           2   B\n3   C           4   D\nNULL E          NULL F\n\nSELECT * FROM TABLE1\nMINUS\nSELECT * FROM TABLE2;\n```', 2, NULL, '다음과 같은 데이터가 있을 때, SQL문의 결과로 올바른 것은?', 'MINUS 연산 시, 첫 번째 테이블(TABEL1)에는 존재하지만 두 번째 테이블(TABEL2)에는 없는 행이 반환됩니다.', 120, 20),
	(199, 2, '[요구사항]\n1. 2023년과 2024년 모두 주문한 고객 목록\n2. 각 연도의 주문 금액 합계\n3. 주문 금액이 증가한 고객만 조회\n4. 증가액 순으로 정렬', 3, NULL, '다음 요구사항에 맞는 가장 효율적인 SQL문은?', 'HAVING 절과 CASE 문을 활용하여 단일 테이블 조회로 성능을 최적화합니다.', 180, 20),
	(200, 2, '```sql\nSELECT employee_id, first_name \nFROM employees_2023\nUNION\nSELECT employee_id, first_name \nFROM employees_2024;\n```', 3, NULL, '다음 집합 연산의 성능 개선 방안으로 가장 적절한 것은?', 'UNION ALL은 중복 제거를 수행하지 않기 때문에 성능이 향상됩니다. 단, 중복이 필요 없는 경우 UNION을 유지해야 합니다.', 180, 20),
	(201, 2, NULL, 1, NULL, '다음 중 그룹 함수에 대한 설명으로 틀린 것은?', 'AVG 함수는 NULL 값을 제외하고 평균을 계산합니다. NULL을 0으로 처리하지 않습니다. NULL을 0으로 처리하고 싶다면 NVL 함수를 함께 사용해야 합니다. 예: AVG(NVL(column, 0))', 60, 21),
	(202, 2, '```sql\nSELECT department_id,\n       COUNT(*) as total_emp,\n       COUNT(commission_pct) as comm_emp,\n       MAX(salary) as max_sal,\n       MIN(salary) as min_sal,\n       ROUND(AVG(salary), 2) as avg_sal\nFROM employees\nGROUP BY department_id\nHAVING COUNT(*) >= 5\nORDER BY avg_sal DESC;\n```', 2, NULL, '다음 SQL문의 실행 결과로 적절한 것은?', '이 쿼리는 다음과 같은 정보를 제공합니다:\n1. department_id로 그룹화\n2. COUNT(*)로 전체 직원 수 계산\n3. COUNT(commission_pct)로 커미션이 있는 직원 수 계산\n4. MAX/MIN으로 최대/최소 급여 계산\n5. HAVING 절로 직원이 5명 이상인 부서만 필터링\n6. 평균 급여 내림차순으로 정렬', 120, 21),
	(203, 2, '```sql\n-- Query 1\nSELECT department_id, COUNT(employee_id)\nFROM employees\nGROUP BY department_id;\n\n-- Query 2\nSELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'COUNT(컬럼명)은 해당 컬럼의 NULL을 제외한 행의 수를 계산하고, COUNT(*)는 NULL을 포함한 모든 행의 수를 계산합니다. 따라서 employee_id에 NULL이 있는 경우 두 쿼리의 결과가 다릅니다.', 120, 21),
	(204, 2, '```sql\nSELECT department_id,\n       GROUPING(department_id) as dept_grp,\n       job_id,\n       GROUPING(job_id) as job_grp,\n       COUNT(*) as emp_count,\n       SUM(salary) as total_salary\nFROM employees\nGROUP BY ROLLUP(department_id, job_id);\n```', 3, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'ROLLUP은 지정된 컬럼의 계층적 집계를 생성합니다:\n1. (department_id, job_id) 조합별 집계\n2. department_id별 소계\n3. 전체 총계\nGROUPING 함수는 해당 행이 소계나 총계에서 생성된 것인지를 나타냅니다(1: 집계행, 0: 상세행).', 180, 21),
	(205, 2, '[요구사항]\n1. 부서별 급여 통계를 계산해야 함\n2. 급여가 NULL인 직원은 0으로 계산\n3. 커미션이 NULL인 경우는 제외\n4. 부서별로 다음 정보 필요:\n   - 평균 급여(소수점 2자리)\n   - 급여 합계\n   - 최대/최소 급여의 차이', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 그룹 함수 사용 방법은?', '요구사항을 모두 충족하는 쿼리는 ④입니다:\n1. NVL(salary,0)로 NULL 급여를 0으로 처리\n2. WHERE commission_pct IS NOT NULL로 커미션이 NULL인 경우 제외\n3. ROUND(AVG(...),2)로 평균 급여 소수점 2자리 처리\n4. MAX/MIN에도 NVL 적용하여 NULL 처리 일관성 유지\n5. department_id로 그룹화하여 부서별 통계 산출', 180, 21),
	(206, 2, NULL, 1, NULL, '다음 중 ROLLUP과 CUBE의 차이점으로 가장 올바른 것은?', 'ROLLUP은 지정된 컬럼의 계층적 순서로 집계를 생성하지만, CUBE는 가능한 모든 조합의 집계를 생성합니다. 예를 들어, ROLLUP(A,B)는 (A,B), (A), () 순으로 집계하고, CUBE(A,B)는 (A,B), (A), (B), () 모든 조합을 집계합니다.', 60, 21),
	(207, 2, '```sql\n-- Query 1\nSELECT COUNT(DISTINCT salary) FROM employees;\n\n-- Query 2\nSELECT COUNT(*) FROM (\n    SELECT DISTINCT salary FROM employees\n);\n\n-- Query 3\nSELECT COUNT(1) FROM (\n    SELECT salary FROM employees GROUP BY salary\n);\n\n-- Query 4\nSELECT COUNT(*) FROM (\n    SELECT salary FROM employees\n    WHERE salary IS NOT NULL\n    GROUP BY salary\n);\n```', 2, NULL, '다음 SQL문들의 실행 결과가 다른 것은?', '④번 쿼리는 WHERE 절로 NULL을 제외하므로 다른 결과가 나옵니다:\n1. Query 1,2,3: NULL을 포함한 고유한 급여 수 계산\n2. Query 4: NULL을 제외한 고유한 급여 수 계산\nCOUNT(DISTINCT)와 GROUP BY는 NULL 처리 방식이 동일합니다.', 120, 21),
	(208, 2, '[요구사항]\n- 부서별 직원 이름을 쉼표로 구분하여 나열\n- 이름은 알파벳 순으로 정렬\n- 결과가 4000바이트를 초과할 수 있음', 2, NULL, '다음과 같은 LISTAGG 함수 사용 시 가장 적절한 방법은?', 'ON OVERFLOW TRUNCATE를 사용하면서 "..."를 지정하여 결과가 잘린 것을 표시하는 것이 가장 적절합니다:\n1. 결과가 4000바이트 초과 시 자동 처리\n2. 잘린 부분 표시로 사용자에게 정보 제공\n3. 알파벳 순 정렬 유지\n4. 원본 데이터 변경 없음', 120, 21),
	(209, 2, NULL, 3, NULL, '다음과 같은 그룹 함수 사용 시 결과가 다른 것은?', 'NULL 처리 방식의 차이:\n1. ①: commission_pct NULL을 0으로 처리\n2. ②: NULL과의 연산 결과는 NULL\n3. ③: 최종 결과가 NULL이면 0으로 처리\n4. ④: 모든 NULL을 0으로 처리\n이 중 ②번만 NULL 결과를 그대로 사용하므로 다른 결과가 나옵니다.', 180, 21),
	(210, 2, '```sql\n-- Query 1\nSELECT department_id,\n       AVG(salary) OVER (PARTITION BY department_id) as avg_sal\nFROM employees;\n\n-- Query 2\nSELECT department_id, AVG(salary) as avg_sal\nFROM employees\nGROUP BY department_id;\n```', 3, NULL, '다음과 같은 윈도우 함수와 그룹 함수의 결과가 같은 경우는?', '두 쿼리는 다음과 같은 모든 경우에 같은 결과를 반환합니다:\n1. 직원이 한 명씩: 평균값이 동일\n2. 급여가 동일: 모든 평균이 같은 값\n3. 부서가 하나: 하나의 그룹으로 계산\n주요 차이점은 결과 행의 수입니다:\n- Query 1: 원본 테이블의 모든 행 반환\n- Query 2: 그룹별 한 행씩 반환', 180, 21),
	(211, 2, NULL, 1, NULL, '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', 'PARTITION BY는 GROUP BY와 달리 그룹별로 행을 나누지만, 원래의 행을 유지한 상태로 집계를 수행합니다.', 60, 22),
	(212, 2, '```sql\nSELECT department_id, employee_name, salary,\nSUM(salary) OVER (PARTITION BY department_id ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as running_total\nFROM employees\nWHERE department_id = 10\nORDER BY salary;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', '윈도우 함수에서 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW를 사용하면 현재 행까지의 누적 합계를 계산합니다.', 120, 22),
	(213, 2, '```sql\n-- Query 1\nSELECT department_id, employee_name, salary,\nROW_NUMBER() OVER (ORDER BY salary DESC) as rn\nFROM employees;\n\n-- Query 2\nSELECT department_id, employee_name, salary,\nROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn\nFROM employees;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'ROW_NUMBER()는 모든 행에 대해 고유한 순위를 부여하지만, PARTITION BY를 사용하면 부서별로 순위가 부여됩니다.', 120, 22),
	(214, 2, '[요구사항]\n1. 부서별 급여 순위 산출\n2. 급여가 같을 경우 같은 순위 부여\n3. 같은 순위 다음은 건너뛰지 않고 순차적으로 부여\n4. 입사일이 빠른 순으로 정렬', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 윈도우 함수는?', 'DENSE_RANK() 함수는 동일한 값에 대해 같은 순위를 부여하고 다음 순위를 건너뛰지 않으므로 요구사항을 충족합니다.', 180, 22),
	(215, 2, '[요구사항]\n1. 일자별 매출 금액\n2. 전일 대비 증감액\n3. 3일 이동평균\n4. 연초부터의 누적 매출', 3, NULL, '다음과 같은 데이터에서 필요한 분석을 위한 적절한 윈도우 함수 사용은?', 'LAG()를 이용하여 전일 대비 증감액을 계산하고, ROWS BETWEEN을 이용해 3일 이동평균을 구할 수 있습니다.', 180, 22),
	(216, 2, NULL, 1, NULL, '다음 중 LAG와 LEAD 함수의 차이점으로 가장 올바른 것은?', 'LAG()는 이전 행을, LEAD()는 다음 행을 참조하는 함수입니다.', 60, 22),
	(217, 2, '```sql\n-- Query 1\nSELECT employee_id, salary,\nFIRST_VALUE(salary) OVER (ORDER BY salary) as lowest_sal\nFROM employees;\n\n-- Query 2\nSELECT employee_id, salary,\nMIN(salary) OVER () as lowest_sal\nFROM employees;\n\n-- Query 3\nSELECT employee_id, salary,\nMIN(salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as lowest_sal\nFROM employees;\n\n-- Query 4\nSELECT employee_id, salary,\nFIRST_VALUE(salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as lowest_sal\nFROM employees;\n```', 2, NULL, '다음 SQL문의 실행 결과가 다른 것은?', 'ROWS 절을 사용한 MIN() 함수는 누적 최소값을 반환하지만, FIRST_VALUE()나 MIN() OVER ()는 전체 최소값을 반환합니다.', 120, 22),
	(218, 2, '[요구사항]\n- 부서별 급여 중앙값 계산\n- NULL 값 제외\n- 부서별로 정렬된 상태 유지', 2, NULL, '다음과 같은 데이터 분석에 가장 적절한 윈도우 함수는?', 'PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary)는 부서별 급여의 중앙값을 계산할 수 있습니다.', 120, 22),
	(219, 2, '[요구사항]\n- 직원별 급여 비율 계산\n- 부서 내에서의 급여 비중\n- 전체 급여 대비 비율\n- 소수점 2자리까지 표시', 3, NULL, '다음과 같은 계산이 필요할 때 가장 적절한 방법은?', 'RATIO_TO_REPORT() 함수를 사용하면 부서별 및 전체 급여 대비 비율을 쉽게 계산할 수 있습니다.', 180, 22),
	(220, 2, '```sql\nSELECT department_id, employee_name, salary,\nRANK() OVER (\nPARTITION BY department_id\nORDER BY salary DESC\nROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n) as rnk\nFROM employees;\n```', 3, NULL, '다음 윈도우 함수의 실행 결과에 영향을 미치지 않는 것은?', 'RANK() 함수는 PARTITION BY와 ORDER BY의 영향을 받지만, ROWS 절은 무시됩니다.', 180, 22),
	(221, 2, NULL, 1, NULL, '다음 중 TOP N 쿼리에 대한 설명으로 틀린 것은?', 'ROWNUM은 WHERE 절이 실행되기 전에 부여됩니다. 따라서 WHERE 절에서 ROWNUM을 사용할 때는 주의가 필요합니다.', 60, 23),
	(222, 2, NULL, 2, NULL, '다음 SQL문 중 급여가 높은 상위 5명의 직원을 올바르게 조회하는 것은?', '정렬된 결과에서 상위 N개를 추출하기 위해서는:\n1. 내부 쿼리에서 먼저 정렬(ORDER BY)을 수행\n2. 정렬된 결과를 서브쿼리로 감싸기\n3. 외부 쿼리에서 ROWNUM으로 행 수 제한\n이러한 순서로 작성해야 원하는 결과를 얻을 수 있습니다.', 120, 23),
	(223, 2, '[요구사항]\n- 부서별로 급여가 높은 상위 3명의 직원을 조회\n- 같은 급여의 직원이 있을 경우 이름순으로 정렬\n- 직원번호, 이름, 부서명, 급여 정보 출력', 2, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', 'RANK() 함수로 부서별(PARTITION BY) 순위를 부여하고, 급여 내림차순과 이름 오름차순으로 정렬 후 각 부서별 상위 3명만 선택하는 것이 올바른 방식입니다.', 120, 23),
	(224, 2, '```sql\n-- Query 1\nSELECT *\nFROM (\n    SELECT employee_id, name, salary,\n           ROW_NUMBER() OVER (ORDER BY salary DESC) as rn\n    FROM employees\n)\nWHERE rn <= 5;\n\n-- Query 2\nSELECT *\nFROM (\n    SELECT employee_id, name, salary,\n           RANK() OVER (ORDER BY salary DESC) as rn\n    FROM employees\n)\nWHERE rn <= 5;\n```', 3, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'ROW_NUMBER()는 동일한 값에도 고유한 순위를 부여하지만, RANK()는 동일한 값에 동일 순위를 부여하며 다음 순위를 건너뛵니다.', 180, 23),
	(225, 2, '[요구사항]\n- 각 부서별로 급여 상위 20%에 해당하는 직원 목록\n- 급여가 같은 경우 모두 포함\n- 부서명, 직원명, 급여, 상위 백분율 정보 출력', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 SQL문은?', 'CUME_DIST() 함수를 사용하면 부서별 급여의 상위 20%에 해당하는 직원들을 올바르게 조회할 수 있습니다.', 180, 23),
	(226, 2, NULL, 1, NULL, '다음 중 Oracle의 FETCH 절에 대한 설명으로 틀린 것은?', 'FETCH 절은 ORDER BY 없이도 사용할 수 있습니다. 하지만 특정 순서로 정렬된 결과에서 상위 N개를 가져오려면 ORDER BY와 함께 사용하는 것이 좋습니다.', 60, 23),
	(227, 2, '```sql\n-- Query 1\nSELECT *\nFROM (\n    SELECT * FROM employees\n    ORDER BY salary DESC\n)\nWHERE ROWNUM <= 5;\n\n-- Query 2\nSELECT *\nFROM employees\nORDER BY salary DESC\nFETCH FIRST 5 ROWS ONLY;\n\n-- Query 3\nSELECT *\nFROM employees\nWHERE ROWNUM <= 5\nORDER BY salary DESC;\n\n-- Query 4\nSELECT TOP 5 *\nFROM employees\nORDER BY salary DESC;\n```', 2, NULL, '다음 SQL문들의 실행 결과가 같은 것은?', 'Query 1, 2, 4는 동일한 결과를 반환하지만, Query 3은 먼저 ROWNUM으로 5개 행을 선택한 후 정렬하여 다른 결과를 반환합니다.', 120, 23),
	(228, 2, '[요구사항]\n- 급여가 높은 순으로 정렬\n- 한 페이지당 10개의 데이터\n- 3번째 페이지 조회', 2, NULL, '다음과 같은 페이징 쿼리가 필요할 때, 가장 적절한 SQL문은?', 'OFFSET-FETCH 절을 사용하거나, 중첩 서브쿼리에서 ROWNUM을 활용하여 3번째 페이지 데이터를 조회할 수 있습니다.', 120, 23),
	(229, 2, '[요구사항]\n1. 부서별 급여 상위 3명씩 조회\n2. 같은 급여는 모두 포함\n3. 같은 순위가 있을 경우 다음 순위는 건너뛰기\n4. 전체 순위도 함께 표시', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 SQL문은?', 'RANK()를 사용하면 부서별 급여 순위를 부여하고 같은 급여를 가진 직원은 같은 순위를 유지하며, 건너뛴 순위를 방지할 수 있습니다.', 180, 23),
	(230, 2, '```sql\nSELECT *\nFROM (\n    SELECT *\n    FROM employees\n    ORDER BY salary DESC\n)\nWHERE ROWNUM <= :N;\n```', 3, NULL, '다음과 같은 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', 'ORDER BY 절을 포함하면 정렬 비용이 증가할 수 있으며, 인덱스를 활용하거나 병렬 처리 등의 최적화 방법을 고려할 수 있습니다.', 180, 23),
	(231, 2, NULL, 1, NULL, '다음 중 계층형 질의(Hierarchical Query)에 대한 설명으로 가장 부적절한 것은?', '계층형 질의에서 ORDER BY절은 계층형 구조를 무시하고 정렬하면 안 됩니다. 계층형 구조를 유지하면서 정렬하려면 ORDER SIBLINGS BY를 사용해야 합니다. 이는 동일 레벨 내에서만 정렬을 수행합니다.', 60, 24),
	(232, 2, '```sql\nSELECT LEVEL,\n       LPAD(\' \', (LEVEL-1)*2) || employee_name as employee_hierarchy\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id\nORDER SIBLINGS BY employee_name;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는 직원의 상하 관계를 표현하되, 같은 레벨의 직원은 이름순으로 정렬합니다.', 120, 24),
	(233, 2, '```sql\n직원테이블(EMPLOYEE)\n- EMP_ID: 직원ID\n- EMP_NAME: 직원명\n- MANAGER_ID: 관리자ID\n```', 2, NULL, '다음과 같은 조직도를 표현하기 위한 셀프 조인 쿼리 중 옳은 것은?', '직원과 관리자의 관계를 표현하기 위해서는 EMPLOYEE 테이블을 셀프 조인하고, 직원의 MANAGER_ID와 관리자의 EMP_ID를 연결해야 합니다. 외부 조인(+)을 사용하여 관리자가 없는 직원도 출력할 수 있습니다.', 120, 24),
	(234, 2, '```sql\nSELECT CONNECT_BY_ROOT employee_name as root_emp,\n       SYS_CONNECT_BY_PATH(employee_name, \'/\') as emp_path,\n       CONNECT_BY_ISLEAF as is_leaf\nFROM employees\nSTART WITH job_id = \'CEO\'\nCONNECT BY PRIOR employee_id = manager_id\nAND LEVEL <= 3;\n```', 3, NULL, '다음 계층형 쿼리의 실행 결과로 알맞은 것은?', 'CEO부터 시작하여 3레벨까지의 조직도를 표시합니다.', 180, 24),
	(235, 2, '```sql\n-- 현재 쿼리\nSELECT LEVEL,\n       employee_name,\n       (SELECT d.department_name \n        FROM departments d \n        WHERE d.department_id = e.department_id) as dept_name\nFROM employees e\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n```', 3, NULL, '다음 중 계층형 쿼리와 셀프 조인의 성능 개선 방안으로 가장 부적절한 것은?', 'CONNECT BY 절의 조건을 WHERE 절로 이동하면 계층형 구조가 깨질 수 있습니다. CONNECT BY 절은 계층형 구조를 만들기 위한 필수 조건이므로, 이를 WHERE 절로 이동하는 것은 부적절합니다.', 180, 24),
	(236, 2, NULL, 1, NULL, '다음 중 CONNECT_BY_ROOT 연산자와 SYS_CONNECT_BY_PATH 함수의 차이점으로 가장 적절한 것은?', 'CONNECT_BY_ROOT는 계층 구조에서 최상위 노드의 값만을 반환하는 반면, SYS_CONNECT_BY_PATH는 루트 노드부터 현재 노드까지의 전체 경로를 지정된 구분자와 함께 문자열로 반환합니다.', 60, 24),
	(237, 2, '```sql\n-- Query 1\nSELECT LEVEL, employee_name, manager_id\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY NOCYCLE PRIOR employee_id = manager_id;\n\n-- Query 2\nSELECT LEVEL, employee_name, manager_id\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n```', 2, NULL, '다음 두 쿼리의 결과가 다른 경우는?', '순환 참조가 있는 경우에만 결과가 다릅니다. NOCYCLE 있는 경우 순환 참조 발견 시 해당 경로만 중단되지만, 없는 경우 오류가 발생합니다.', 120, 24),
	(238, 2, '```sql\n[요구사항]\n1. 각 직원의 하위 직원 수 계산\n2. 직속 부하직원만 포함\n3. 결과는 하위 직원 수 기준 내림차순 정렬\n```', 2, NULL, '다음과 같은 조직도 데이터를 분석할 때 가장 적절한 SQL문은?', '직속 부하직원 수를 계산하는 가장 효율적인 방법은 셀프 조인을 사용하여 관리자-부하직원 관계를 설정한 후 GROUP BY와 COUNT로 부하직원 수를 계산하는 것입니다.', 120, 24),
	(239, 2, '```sql\n[요구사항]\n1. 조직도를 HTML 형식으로 출력\n2. 레벨별로 들여쓰기 적용\n3. 말단 직원 표시\n4. 각 직원의 레벨 표시\n```', 3, NULL, '다음과 같은 계층형 구조를 표현할 때 가장 적절한 방법은?', 'HTML 태그를 사용하여 계층형 구조를 표현하고, &nbsp;로 들여쓰기하며, CONNECT_BY_ISLEAF로 말단 직원 표시 및 LEVEL로 계층 레벨을 표현하는 것이 적절합니다.', 180, 24),
	(240, 2, '```sql\nSELECT LEVEL, employee_name, department_name\nFROM employees e, departments d\nWHERE e.department_id = d.department_id\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n```', 3, NULL, '다음과 같은 계층형 쿼리의 성능을 개선하기 위한 방법으로 가장 적절한 것은?', '계층형 쿼리를 먼저 실행하여 계층 구조를 최소화한 후 부서 정보를 조인하면 불필요한 조인을 회피하고 성능을 개선할 수 있습니다.', 180, 24),
	(241, 2, NULL, 1, NULL, '다음 중 PIVOT과 UNPIVOT에 대한 설명으로 틀린 것은?', 'UNPIVOT은 열을 행으로 변환할 때 집계함수를 사용하지 않습니다. 반면 PIVOT은 여러 행의 데이터를 열로 변환하면서 집계하기 때문에 반드시 집계함수(SUM, COUNT, AVG 등)가 필요합니다.', 60, 25),
	(242, 2, '[원본 데이터]\nYEAR  QUARTER  SALES\n2023  Q1       1000\n2023  Q2       1200\n2023  Q3       1100\n2023  Q4       1300', 2, NULL, '다음과 같은 데이터를 PIVOT을 사용하여 변환하고자 할 때, 적절한 SQL문은?', 'PIVOT을 사용할 때는 집계함수(SUM), 변환할 컬럼(QUARTER), 변환할 값(Q1~Q4)이 필요합니다.', 120, 25),
	(243, 2, '[원본 데이터]\nDEPT_ID  Q1_SALES  Q2_SALES  Q3_SALES  Q4_SALES\n10       1000      1200      1100      1300\n20       800       900       1000      1100', 2, NULL, '다음과 같은 데이터를 UNPIVOT하려고 할 때, 올바른 SQL문은?', 'UNPIVOT의 올바른 구문은 값으로 변환할 컬럼(SALES), FOR절에서 구분자가 될 컬럼(QUARTER), 변환할 원본 컬럼과 별칭 지정이 필요합니다.', 120, 25),
	(244, 2, '[원본 데이터]\nDEPT_ID  EMP_TYPE  SALARY\n10       정규직    5000\n10       계약직    3000\n20       정규직    4500\n20       계약직    2800\n\n[목표 데이터]\nDEPT_ID  정규직_급여  계약직_급여\n10       5000        3000\n20       4500        2800', 3, NULL, '다음과 같은 데이터 변환이 필요할 때, 가장 적절한 방법은?', 'SUM(SALARY)로 급여 합계를 계산하고, EMP_TYPE을 기준으로 PIVOT을 수행하여 열 변환해야 합니다.', 180, 25),
	(245, 2, NULL, 3, NULL, '다음의 PIVOT, UNPIVOT 사용 시 발생할 수 있는 문제점 중 가장 적절한 것은?', 'WHERE 절의 위치가 중요합니다. PIVOT/UNPIVOT 변환 전에 필터링이 필요한 경우 서브쿼리를 사용해야 합니다.', 180, 25),
	(246, 2, NULL, 1, NULL, '다음 중 PIVOT절에서 사용할 수 없는 집계 함수는?', 'PIVOT절에서는 SUM, COUNT, AVG, MAX, MIN, MEDIAN 등의 집계 함수는 사용 가능하지만 MODE는 사용할 수 없습니다.', 60, 25),
	(247, 2, '[원본 데이터]\nDEPT    JOB     SALARY\nIT      개발    5000\nIT      설계    4000\nHR      인사    3000', 2, NULL, '다음과 같은 데이터를 PIVOT한 후 다시 UNPIVOT 했을 때, 원본과 다른 결과가 나오는 경우는?', 'PIVOT 시 NULL 값은 집계에 포함되지 않으며, UNPIVOT 시 NULL 값은 기본적으로 제외됩니다. 따라서 NULL 값이 있는 데이터를 변환하면 원본과 차이가 발생할 수 있습니다.', 120, 25),
	(248, 2, '[요구사항]\n1. 부서별, 직급별 평균 급여를 매트릭스 형태로 표시\n2. 직급이 없는 경우 \'미지정\'으로 표시\n3. 평균 급여는 천 단위 구분 표시', 2, NULL, '다음과 같은 분석이 필요할 때 가장 적절한 방법은?', 'DECODE를 사용하여 NULL 값을 처리하고 평균 급여를 천 단위로 변환하는 방식이 가장 적절합니다.', 120, 25),
	(249, 2, '-- 동적으로 IN절의 값 목록을 생성해야 함\nSELECT *\nFROM sales_data\nPIVOT (\n    SUM(amount)\n    FOR YYYYMM IN (???)\n);', 3, NULL, '다음과 같은 동적 PIVOT 쿼리가 필요할 때 가장 적절한 방법은?', 'XML을 사용하여 동적으로 IN절의 값을 생성하면 실행 시점에 컬럼을 결정할 수 있습니다.', 180, 25),
	(250, 2, NULL, 3, NULL, 'PIVOT과 UNPIVOT 사용 시 성능상 고려사항으로 가장 적절한 것은?', 'PIVOT/UNPIVOT 성능 최적화를 위해 사전 필터링으로 처리 데이터를 최소화하는 것이 가장 중요합니다.', 180, 25),
	(251, 2, NULL, 1, NULL, '다음 중 정규 표현식의 기본 패턴에 대한 설명으로 틀린 것은?', '`.`는 줄바꿈 문자를 제외한 모든 단일 문자와 매치됩니다. "정확히 한 글자만"이 아니라 "어떤 문자든 한 글자"를 의미합니다. 예를 들어, \'a.c\'는 \'abc\', \'a1c\', \'a#c\' 등과 매치됩니다.', 60, 26),
	(252, 2, '```sql\nSELECT employee_name, phone_number\nFROM employees\nWHERE REGEXP_LIKE(phone_number, \'^(010|011)-[0-9]{4}-[0-9]{4}$\');\n```', 2, NULL, '다음 SQL문의 실행 결과로 적절한 것은?', '해당 정규 표현식은 다음과 같은 패턴을 검색합니다:\n1. ^(010|011): 010 또는 011로 시작\n2. -: 하이픈\n3. [0-9]{4}: 4자리 숫자\n4. -: 하이픈\n5. [0-9]{4}$: 4자리 숫자로 끝남', 120, 26),
	(253, 2, NULL, 2, NULL, '다음 중 이메일 주소를 검증하는 정규 표현식으로 가장 적절한 것은?', '이메일 주소 패턴의 특징은 다음과 같습니다:\n1. 아이디 부분: 영문자, 숫자, 특수문자(._%+-)를 허용\n2. @ 기호\n3. 도메인 부분: 영문자, 숫자, 점(.), 하이픈(-)을 허용\n4. 최상위 도메인: 2자 이상의 영문자\n따라서 ②가 가장 적절한 패턴입니다.', 120, 26),
	(254, 2, '```sql\nSELECT *\nFROM products\nWHERE REGEXP_LIKE(product_code, \'^[A-Z]{2}-[0-9]{4}(R|G|B)?$\');\n```', 3, NULL, '다음 정규 표현식 패턴의 결과로 매치되지 않는 것은?', '이 정규 표현식은 다음 패턴을 검색합니다:\n1. ^[A-Z]{2}: 대문자 2개로 시작\n2. -: 하이픈\n3. [0-9]{4}: 4자리 숫자\n4. (R|G|B)?: R, G, B 중 하나가 있거나 없음\n5. $: 문자열 끝\n\'GH-345G\'는 숫자가 3자리만 있으므로 매치되지 않습니다.', 180, 26),
	(255, 2, '[요구사항]\n- 주민등록번호 형식 검증\n- YYMMDD-1234567 형식\n- 첫 번째 숫자(YYMMDD)는 실제 존재하는 날짜여야 함\n- 두 번째 숫자의 첫 자리는 1,2,3,4 중 하나여야 함', 3, NULL, '다음과 같은 데이터 검증이 필요할 때, 가장 적절한 정규 표현식은?', '가장 정확한 검증을 제공하는 정규 표현식은 ②입니다. 각 부분의 의미는 다음과 같습니다:\n1. [0-9]{2}: 연도 2자리\n2. (0[1-9]|1[0-2]): 월(01~12)\n3. (0[1-9]|[12][0-9]|3[01]): 일(01~31)\n4. -: 하이픈\n5. [1-4]: 성별 구분 숫자(1,2,3,4)\n6. [0-9]{6}: 나머지 6자리', 180, 26),
	(256, 2, NULL, 1, NULL, '다음 중 정규 표현식에서 수량자(Quantifier)에 대한 설명으로 틀린 것은?', '‘*?’는 게으른(lazy) 수량자로, 가능한 적은 문자와 매칭됩니다. 반면 ‘*’는 탐욕적(greedy) 수량자로 가능한 많은 문자와 매칭됩니다.', 60, 26),
	(257, 2, '```sql\nSELECT REGEXP_REPLACE(text, \'([0-9]{3})([0-9]{4})([0-9]{4})\', \'\\1-\\2-\\3\') as formatted_number\nFROM sample_data;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', 'REGEXP_REPLACE를 사용한 이 패턴은:\n1. ([0-9]{3}): 첫 번째 그룹 - 3자리 숫자\n2. ([0-9]{4}): 두 번째 그룹 - 4자리 숫자\n3. ([0-9]{4}): 세 번째 그룹 - 4자리 숫자\n4. \\1-\\2-\\3: 각 그룹 사이에 하이픈 추가', 120, 26),
	(258, 2, '[검색 대상]\n- 파일명.txt\n- 파일명.doc\n- 파일명.docx\n- 파일명.pdf', 2, NULL, '다음과 같은 데이터를 검색하기 위한 정규 표현식으로 가장 적절한 것은?', '‘^\\w+\\.(txt|doc.?|pdf)$’ 패턴이 가장 적절합니다:\n1. ^\\w+: 파일명(영문, 숫자, 언더스코어)\n2. \\.: 점(확장자 구분자)\n3. (txt|doc.?|pdf): 확장자 그룹\n   - txt: txt 확장자\n   - doc.?: doc 또는 docx\n   - pdf: pdf 확장자\n4. $: 문자열 끝', 120, 26),
	(259, 2, '[요구사항]\n- URL 형식 검증\n- http 또는 https로 시작\n- www는 있을 수도 있고 없을 수도 있음\n- 도메인은 영문자와 숫자, 점, 하이픈 허용\n- 최상위 도메인은 2~6자의 영문자', 3, NULL, '다음과 같은 요구사항을 만족하는 정규 표현식으로 가장 적절한 것은?', '요구사항을 만족하는 패턴 분석:\n1. ^https?: http 또는 https로 시작\n2. (www\\.)?: www. 가 있을 수도 있고 없을 수도 있음\n3. [a-zA-Z0-9-]+: 도메인 이름\n4. (\\.[a-zA-Z0-9-]+)*: 서브도메인(여러 개 가능)\n5. \\.[a-zA-Z]{2,6}$: 최상위 도메인', 180, 26),
	(260, 2, NULL, 3, NULL, 'REGEXP_LIKE 사용 시 성능 개선 방안으로 가장 부적절한 것은?', '정규 표현식 성능 최적화:\n1. 여러 개의 REGEXP_LIKE로 분리하면:\n   - 더 많은 처리 시간 필요\n   - 중복 검사 발생\n   - 리소스 낭비\n2. 대신 권장되는 방법:\n   - 하나의 최적화된 패턴 사용\n   - 인덱스 활용 가능한 조건 선처리\n   - 명확한 시작/끝점 지정\n   - 구체적 패턴 사용', 180, 26),
	(261, 2, NULL, 1, NULL, '다음 중 DML(Data Manipulation Language)에 대한 설명으로 가장 부적절한 것은?', 'DROP 문은 DML이 아닌 DDL(Data Definition Language)에 속합니다. DROP은 테이블 구조 자체를 삭제하는 명령어입니다. 테이블의 모든 데이터를 삭제하는 DML 명령어는 TRUNCATE 또는 DELETE입니다.', 60, 27),
	(262, 2, '-- Table: EMPLOYEES\n-- Columns: EMPLOYEE_ID(PK), FIRST_NAME, LAST_NAME, HIRE_DATE, SALARY', 2, NULL, '다음 INSERT 문 중 올바르게 작성된 것은?', 'INSERT 문은 컬럼 목록과 VALUES의 값 개수가 일치해야 하며, 데이터 타입도 일치해야 합니다. ②는 모든 컬럼을 명시하고, 날짜 형식도 올바르게 변환하여 입력하고 있습니다.', 120, 27),
	(263, 2, NULL, 2, NULL, '다음 UPDATE 문의 실행 결과로 적절한 것은?', '이 UPDATE 문은 급여가 3000 미만인 직원을 대상으로, 각 직원이 속한 부서의 평균 급여로 해당 직원의 급여를 변경합니다. 상호연관 서브쿼리를 사용하여 각 직원의 부서별 평균 급여를 계산합니다.', 120, 27),
	(264, 2, NULL, 3, NULL, '다음 중 DELETE 문의 실행 결과가 다른 하나는?', 'NOT IN 연산자와 NULL 값의 처리 방식 때문에 Query 1의 결과가 다릅니다. departments 테이블의 department_id에 NULL이 포함되어 있다면, Query 1은 어떤 행도 삭제하지 않습니다. 나머지 쿼리들은 NULL을 적절히 처리하여 부서가 없는 직원을 삭제합니다.', 180, 27),
	(265, 2, NULL, 3, NULL, '다음과 같은 DML 작업 시 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '대용량 데이터를 한 번에 처리할 경우 다음과 같은 문제가 발생할 수 있습니다:\n1. 트랜잭션 로그 공간 부족\n2. 락(Lock)으로 인한 다른 트랜잭션 대기\n3. 롤백 시 복구 시간 증가\n따라서 데이터를 적절한 크기로 분할하여 처리하는 것이 바람직합니다. 예를 들어 월별이나 특정 건수로 나누어 처리할 수 있습니다.', 180, 27),
	(266, 2, NULL, 1, NULL, '다음 중 MERGE 문의 특징으로 가장 부적절한 것은?', 'MERGE 문은 WHEN MATCHED THEN DELETE 절을 사용하여 DELETE 작업도 수행할 수 있습니다. 한 번의 MERGE 문으로 INSERT, UPDATE, DELETE 작업을 모두 처리할 수 있는 것이 MERGE 문의 장점입니다.', 60, 27),
	(267, 2, NULL, 2, NULL, '다음 MERGE 문의 실행 결과로 가장 적절한 것은?', '이 MERGE 문은:\n1. 동일한 id가 있는 경우(MATCHED): value가 다른 경우만 UPDATE\n2. id가 없는 경우(NOT MATCHED): 새로 INSERT\n3. value가 같은 경우: 아무 작업도 하지 않음', 120, 27),
	(268, 2, NULL, 2, NULL, '다음과 같은 DML 작업의 성능을 개선하는 방법으로 가장 적절한 것은?', 'INSERT /*+ APPEND */ 힌트 사용의 장점:\n1. Direct-path insert 수행\n2. 데이터 버퍼 캐시 우회\n3. REDO 로그 최소화\n4. 대량 데이터 입력 시 성능 향상', 120, 27),
	(269, 2, NULL, 3, NULL, '다음과 같은 트랜잭션이 필요할 때, 가장 적절한 구현 방법은?', '트랜잭션 처리가 적절한 이유:\n1. 모든 작업을 하나의 트랜잭션으로 처리\n2. 예외 발생 시 전체 롤백\n3. BEGIN-END 블록으로 논리적 단위 구성\n4. 원자성(Atomicity) 보장', 180, 27),
	(270, 2, NULL, 3, NULL, '다음 DML 작업의 동시성 제어 방안으로 가장 적절한 것은?', 'SELECT FOR UPDATE 선행 처리의 장점:\n1. 데이터 일관성 보장\n2. Lost Update 방지\n3. 교착상태(Deadlock) 최소화', 180, 27),
	(271, 2, NULL, 1, NULL, '다음 중 TCL(Transaction Control Language)에 대한 설명으로 틀린 것은?', 'COMMIT이 수행되면 해당 트랜잭션의 변경사항은 데이터베이스에 영구적으로 반영되며, ROLLBACK으로도 되돌릴 수 없습니다. ROLLBACK은 마지막 COMMIT 이후의 변경사항만 취소할 수 있습니다.', 60, 28),
	(272, 2, '```sql\nUPDATE accounts SET balance = balance - 1000 WHERE account_no = \'A001\';\nSAVEPOINT sp1;\nUPDATE accounts SET balance = balance + 1000 WHERE account_no = \'A002\';\nSAVEPOINT sp2;\nUPDATE accounts SET balance = balance + 500 WHERE account_no = \'A003\';\nROLLBACK TO sp1;\nCOMMIT;\n```', 2, NULL, '다음 트랜잭션 수행 결과로 올바른 것은?', 'ROLLBACK TO sp1을 수행하면 sp1 이후의 변경사항(A002, A003의 변경)이 취소되고, COMMIT을 수행하면 sp1 이전의 변경사항(A001의 변경)만 영구 반영됩니다.', 120, 28),
	(273, 2, '```sql\n-- Session 1\nUPDATE employees SET salary = salary * 1.1 WHERE department_id = 10;\n\n-- Session 2 (동시 실행)\nSELECT SUM(salary) FROM employees WHERE department_id = 10;\n```', 2, NULL, '다음 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '이 상황에서는 더티 리드가 발생할 수 있습니다. 해결방안으로는 COMMIT 후 SELECT를 실행하거나, 적절한 트랜잭션 격리 수준을 설정해야 합니다.', 120, 28),
	(274, 2, '```sql\n-- Transaction Log\n10:01:00 - INSERT INTO orders VALUES (1, \'A001\', 1000);\n10:01:05 - SAVEPOINT sp1;\n10:01:10 - UPDATE orders SET amount = 2000 WHERE order_id = 1;\n10:01:15 - SAVEPOINT sp2;\n10:01:20 - DELETE FROM orders WHERE order_id = 1;\n10:01:25 - ROLLBACK TO sp2;\n10:01:30 - UPDATE orders SET amount = 3000 WHERE order_id = 1;\n10:01:35 - ROLLBACK TO sp1;\n10:01:40 - COMMIT;\n```', 3, NULL, '다음 트랜잭션 로그의 실행 결과로 옳은 것은?', 'ROLLBACK TO sp1을 수행하면 sp1 이후의 모든 변경사항(UPDATE 2000, UPDATE 3000, DELETE)이 취소되고, 최초 INSERT만 남게 됩니다.', 180, 28),
	(275, 2, '```sql\n[요구사항]\n1. 계좌 A에서 출금\n2. 계좌 B로 입금\n3. 거래 내역 기록\n4. 모든 처리가 실패하면 전체 취소\n5. 부분 실패 시 처리된 내용까지는 유지\n```', 3, NULL, '다음과 같은 뱅킹 시스템의 트랜잭션 처리에서 가장 적절한 구현 방식은?', '계좌 이체와 같은 원자적 처리가 필요한 경우, 모든 작업을 하나의 트랜잭션으로 묶고 실패 시 전체 롤백하는 것이 바람직합니다.', 180, 28),
	(276, 2, NULL, 1, NULL, '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Isolation(고립성)은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리되어야 함을 의미합니다. 반드시 순차적으로 실행될 필요는 없으며, 적절한 격리 수준에서 동시에 실행될 수 있습니다.', 60, 28),
	(277, 2, '```sql\nBEGIN;\n    INSERT INTO table1 VALUES (1);\n    SAVEPOINT sp1;\n    UPDATE table1 SET col1 = 2;\n    SAVEPOINT sp2;\n    DELETE FROM table1;\n    ROLLBACK;\nEND;\n```', 2, NULL, '다음과 같은 트랜잭션에서 ROLLBACK의 범위는?', 'ROLLBACK 명령어가 SAVEPOINT를 지정하지 않고 사용되면, 현재 트랜잭션의 모든 변경사항이 취소됩니다.', 120, 28),
	(278, 2, '```sql\n[요구사항]\n- 대량의 데이터 처리\n- 중간에 오류 발생 시 처리된 데이터는 유지\n- 진행 상황 모니터링 필요\n```', 2, NULL, '다음과 같은 트랜잭션 처리가 필요한 상황에서 가장 적절한 구현 방법은?', '대량 데이터 처리 시 배치 단위로 처리하고 각 배치마다 COMMIT을 수행하여 성능을 최적화할 수 있습니다.', 120, 28),
	(279, 2, '```sql\n-- Session 1\nBEGIN;\n    SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;\n    UPDATE accounts SET balance = balance - 500 WHERE id = 1;\n    COMMIT;\n\n-- Session 2 (동시 실행)\nBEGIN;\n    SELECT balance FROM accounts WHERE id = 1;\n    UPDATE accounts SET balance = balance - 300 WHERE id = 1;\n    COMMIT;\n```', 3, NULL, '다음과 같은 동시 실행 트랜잭션의 문제점과 해결방안으로 가장 적절한 것은?', '이 경우 SELECT FOR UPDATE가 적절한 이유는 데이터 일관성을 보장하고 Lost Update를 방지할 수 있기 때문입니다.', 180, 28),
	(280, 2, '```sql\n-- Transaction 1\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSELECT * FROM products WHERE price < 1000;  -- Time 1\nSELECT * FROM products WHERE price < 1000;  -- Time 3\n\n-- Transaction 2\nUPDATE products SET price = price * 1.1;    -- Time 2\nCOMMIT;\n```', 3, NULL, '다음 트랜잭션의 격리 수준(Isolation Level)에 따른 실행 결과로 가장 적절한 것은?', 'READ COMMITTED 격리 수준에서는 Non-repeatable Read가 발생할 수 있습니다. 즉, 첫 번째 SELECT 이후에 다른 트랜잭션에서 COMMIT된 변경사항이 반영될 수 있습니다.', 180, 28),
	(281, 2, NULL, 1, NULL, '다음 중 DDL(Data Definition Language)에 대한 설명으로 틀린 것은?', 'DDL 명령어는 실행과 동시에 자동으로 COMMIT되며, ROLLBACK이 불가능합니다. 따라서 DROP으로 삭제된 객체는 복구할 수 없습니다.', 60, 29),
	(282, 2, NULL, 2, NULL, '다음 테이블 생성문 중 문제가 있는 것은?', '외래키 제약조건의 문법이 잘못되었습니다. REFERENCES 뒤에 참조할 컬럼을 명시해야 합니다.', 120, 29),
	(283, 2, NULL, 2, NULL, '다음과 같은 테이블 변경 작업 중 실행 결과가 다른 것은?', 'MODIFY 절로 NOT NULL 제약조건을 추가할 때, 이미 NULL 값이 있는 경우 오류가 발생합니다.', 120, 29),
	(284, 2, '[요구사항]\n1. 주문 테이블 생성\n2. 주문번호는 시퀀스를 사용하여 자동 생성\n3. 주문상태는 접수, 처리중, 완료 중 하나\n4. 주문일자는 기본값으로 현재 시간 지정\n5. 삭제된 주문은 이력 테이블에 자동 저장', 3, NULL, '다음과 같은 상황에서 가장 적절한 DDL문은?', '요구사항을 모두 만족하는 트리거를 포함한 테이블 생성문이 가장 적절합니다.', 180, 29),
	(285, 2, NULL, 3, NULL, '다음 중 테이블 생성 후 수정이 불가능한 작업은?', '기본키 구조 변경이 필요한 경우, 기존 테이블을 백업한 후 새로운 구조로 테이블을 재생성해야 합니다.', 180, 29),
	(286, 2, NULL, 1, NULL, '다음 중 CREATE TABLE의 서브쿼리에 대한 설명으로 가장 부적절한 것은?', 'CREATE TABLE의 서브쿼리에서는 ORDER BY 절을 사용할 수 없습니다. ORDER BY는 결과 집합을 정렬하는 용도로만 사용되며, 테이블의 물리적 저장 순서를 결정하지 않습니다.', 60, 29),
	(287, 2, NULL, 2, NULL, '다음과 같은 ALTER TABLE 문의 실행 순서로 가장 적절한 것은?', '제약조건 추가 시, 데이터 무결성과 의존성을 고려하여 올바른 순서로 실행해야 합니다.', 120, 29),
	(288, 2, NULL, 2, NULL, '다음과 같은 데이터가 있을 때, TRUNCATE와 DELETE의 차이점으로 가장 적절한 것은?', 'DELETE는 ROLLBACK이 가능하지만, TRUNCATE는 자동 COMMIT이 발생하며 ROLLBACK이 불가능합니다.', 120, 29),
	(289, 2, '[요구사항]\n1. 파티션 테이블 생성\n2. 년도별로 데이터 분할\n3. 과거 데이터는 자동 삭제\n4. 범위 파티션 사용', 3, NULL, '다음과 같은 테이블을 생성할 때 가장 적절한 DDL문은?', '인터벌 파티션을 사용하면 자동으로 연도별 파티션이 생성되며, 과거 데이터 삭제가 용이합니다.', 180, 29),
	(290, 2, NULL, 3, NULL, 'DDL 실행 시 고려해야 할 성능 관련 사항으로 가장 부적절한 것은?', '파티션 테이블의 성능은 상황에 따라 다르며, 항상 더 나은 성능을 제공하는 것은 아닙니다.', 180, 29),
	(291, 2, NULL, 1, NULL, '다음 중 DCL(Data Control Language)에 대한 설명으로 틀린 것은?', 'CREATE USER는 DCL이 아닌 DDL(Data Definition Language)에 속합니다. DCL의 주요 명령어는 GRANT와 REVOKE입니다. 사용자 생성, 수정, 삭제와 관련된 명령어는 DDL에 속합니다.', 60, 30),
	(292, 2, NULL, 2, NULL, '다음 권한 부여 문장 중 올바르지 않은 것은?', 'GRANT 명령어로는 특정 조건(WHERE절)을 포함한 권한 부여가 불가능합니다. 행 수준의 접근 제어가 필요한 경우에는 뷰(VIEW)를 생성하여 권한을 부여하거나, VPD(Virtual Private Database)와 같은 별도의 보안 메커니즘을 사용해야 합니다.', 120, 30),
	(293, 2, NULL, 2, NULL, '다음과 같은 권한 부여가 순차적으로 실행될 때, 최종적으로 USER3가 가지게 되는 권한으로 올바른 것은?', 'REVOKE는 CASCADE 효과가 있지만, 직접 부여받은 권한은 영향을 받지 않습니다. USER3는 USER1으로부터 권한을 부여받은 것이 아니라 직접 권한을 부여받았으므로, USER1의 권한이 취소되어도 USER3의 SELECT 권한은 유지됩니다.', 120, 30),
	(294, 2, '[상황]\n- 회사의 개발팀에 신입 사원 10명이 입사\n- 각자는 개발 DB의 특정 테이블들에 대해 SELECT, INSERT 권한이 필요\n- 일부 테이블은 UPDATE 권한도 필요\n- 3개월 후 권한을 재검토할 예정', 3, NULL, '다음 상황에서 가장 적절한 권한 관리 방안은?', 'ROLE을 사용하는 것이 가장 효율적인 방법입니다. ROLE의 장점은 다음과 같습니다:\n1. 권한 관리가 용이함\n2. 권한의 일관성 유지 가능\n3. 권한 변경 시 ROLE만 수정하면 됨\n4. 권한 감사(Audit)가 용이함', 180, 30),
	(295, 2, NULL, 3, NULL, '다음 중 데이터베이스 보안 관리와 관련된 설명으로 가장 부적절한 것은?', 'ROLE에 부여된 권한은 해당 ROLE이 부여된 사용자 세션에서 바로 사용할 수 없습니다. 사용자가 새로운 세션을 시작하거나, SET ROLE 명령어를 실행해야 ROLE의 권한을 사용할 수 있습니다.', 180, 30),
	(296, 2, NULL, 1, NULL, '다음 중 데이터베이스 사용자 유형에 대한 설명으로 틀린 것은?', 'PUBLIC은 모든 사용자에게 적용되는 권한입니다. 특정 사용자가 아닌 데이터베이스의 모든 사용자에게 공통적으로 부여되는 권한을 의미합니다.', 60, 30),
	(297, 2, NULL, 2, NULL, '다음의 권한 부여 상황에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'ROLE을 먼저 생성하지 않고 권한을 부여하려 하면 오류가 발생합니다. 올바른 순서는:\n1. ROLE 생성\n2. ROLE에 권한 부여\n3. 사용자에게 ROLE 부여', 120, 30),
	(298, 2, '[요구사항]\n- 개발팀: 테이블 생성, 수정 권한\n- QA팀: 데이터 조회, 수정 권한\n- 운영팀: 데이터 조회만 가능\n- 3개월마다 권한 재검토', 2, NULL, '다음과 같은 권한 관리가 필요할 때 가장 적절한 방식은?', 'ROLE 기반 권한 관리의 장점:\n1. 팀별 권한 그룹화 가능\n2. 권한 변경 시 ROLE만 수정\n3. 권한 관리 용이\n4. 감사(Audit) 용이', 120, 30),
	(299, 2, '[시나리오]\n1. USER1이 테이블 생성 권한을 가짐\n2. USER1이 USER2에게 해당 테이블의 SELECT 권한을 부여\n3. USER2가 USER3에게 같은 권한을 부여 (WITH GRANT OPTION)\n4. USER1의 테이블 생성 권한을 취소해야 하는 상황', 3, NULL, '다음과 같은 권한 취소 시나리오에서 가장 적절한 처리 방법은?', 'CASCADE 옵션을 사용한 REVOKE가 필요한 이유:\n1. 권한의 연쇄적 취소 필요\n2. USER2, USER3에게 부여된 권한도 자동 취소\n3. 권한 관리의 일관성 유지\n4. 누락 없는 권한 취소 보장', 180, 30),
	(300, 2, NULL, 3, NULL, '다음 중 DCL 관련 보안 감사(Audit)를 위한 가장 적절한 설정은?', '효율적인 보안 감사 방안:\n1. ROLE 단위 감사:\n   - 중요 작업 위주 로깅\n   - 저장 공간 효율화\n   - 분석 용이성 확보\n2. 부적절한 방안:\n   - 전체 로깅: 리소스 낭비\n   - DDL만 로깅: 보안 사각지대 발생\n   - 로깅 없음: 추적 불가능', 180, 30),
	(301, 1, NULL, 2, NULL, '다음 중 데이터 모델링의 3단계가 올바르게 나열된 것은?', '개념적 모델링 → 논리적 모델링 → 물리적 모델링', 60, 1),
	(302, 1, NULL, 2, NULL, '데이터 모델링에서 \'추상화\'의 의미로 가장 적절한 것은?', '현실 세계의 복잡한 내용을 정해진 표기법에 의해 표현하는 과정', 60, 1),
	(303, 1, NULL, 1, NULL, '다음 중 데이터 모델링의 특징으로 올바르지 않은 것은?', '복잡화 (Complication)', 50, 1),
	(304, 1, NULL, 1, NULL, '엔터티-관계 모델(Entity-Relationship Model)에서 사용되는 기본 요소가 아닌 것은?', '인덱스 (Index)', 50, 1),
	(305, 1, NULL, 2, NULL, '다음 중 개념적 데이터 모델의 특징으로 가장 적절한 것은?', '업무 중심의 포괄적인 수준의 모델링을 제공한다.', 60, 1),
	(306, 1, NULL, 2, NULL, '다음 중 논리적 데이터 모델링 단계에서 수행되는 작업이 아닌 것은?', '인덱스 설계', 60, 1),
	(307, 1, NULL, 2, NULL, '데이터 모델링에서 \'일관성\'이 의미하는 바로 가장 적절한 것은?', '데이터 모델이 모든 사용자에게 같은 의미로 이해되는 것', 60, 1),
	(308, 1, NULL, 2, NULL, '다음 중 물리적 데이터 모델링의 특징으로 올바른 것은?', '실제 데이터베이스 구현을 위한 스키마를 생성한다.', 60, 1),
	(309, 1, NULL, 2, NULL, '데이터 모델링에서 \'무결성\'이 의미하는 바는?', '데이터가 정확하고 유효한 상태를 유지하는 것', 60, 1),
	(310, 1, NULL, 1, NULL, '다음 중 데이터 모델링의 중요성으로 가장 적절하지 않은 것은?', '파일 구조의 최적화', 50, 1),
	(311, 1, NULL, 2, NULL, '데이터 모델링에서 \'유연성\'이 의미하는 바는?', '데이터 구조를 쉽게 변경하고 확장할 수 있는 능력', 60, 1),
	(312, 1, NULL, 2, NULL, '다음 중 개념적 데이터 모델의 산출물로 가장 적절한 것은?', 'ERD (Entity-Relationship Diagram)', 60, 1),
	(313, 1, NULL, 2, NULL, '데이터 모델링에서 \'재사용성\'이 의미하는 바는?', '이미 정의된 데이터 모델을 다른 영역에서도 사용할 수 있는 것', 60, 1),
	(314, 1, NULL, 2, NULL, '다음 중 데이터 모델링의 절차로 가장 적절한 것은?', '요구사항 수집 → 개념적 모델링 → 논리적 모델링 → 물리적 모델링', 60, 1),
	(315, 1, NULL, 1, NULL, '다음 중 엔터티(Entity)의 정의로 가장 적절한 것은?', '업무에서 관리해야 하는 데이터 단위', 50, 2),
	(316, 1, NULL, 2, NULL, '다음 중 엔터티의 특징으로 올바르지 않은 것은?', '반드시 물리적인 형태로 존재해야 한다', 60, 2),
	(317, 1, NULL, 2, NULL, '다음 중 엔터티 타입(Entity Type)과 엔터티 인스턴스(Entity Instance)의 관계를 가장 잘 설명한 것은?', '엔터티 타입은 클래스이고, 엔터티 인스턴스는 객체이다', 60, 2),
	(318, 1, NULL, 2, NULL, '다음 중 약한 엔터티(Weak Entity)의 특징으로 가장 적절한 것은?', '다른 엔터티의 존재에 의존적이다', 60, 2),
	(319, 1, NULL, 3, NULL, '엔터티를 식별하는 방법으로 가장 적절하지 않은 것은?', '테이블 이름이 명사인가?', 70, 2),
	(320, 1, NULL, 1, NULL, '다음 중 엔터티 관계 다이어그램(ERD)에서 엔터티를 표현하는 일반적인 기호는?', '사각형', 50, 2),
	(321, 1, NULL, 2, NULL, '엔터티의 인스턴스 집합을 무엇이라고 하는가?', '엔터티 셋', 60, 2),
	(322, 1, NULL, 3, NULL, '다음 중 엔터티 타입을 결정하는 기준으로 가장 적절하지 않은 것은?', '테이블의 컬럼 수가 10개 이상인가?', 70, 2),
	(323, 1, NULL, 2, NULL, '다음 중 물리적 엔터티와 논리적 엔터티의 차이점으로 가장 적절한 것은?', '물리적 엔터티는 테이블로 구현되고, 논리적 엔터티는 개념적 모델에서 사용된다', 60, 2),
	(324, 1, NULL, 3, NULL, '다음 중 엔터티의 명명 규칙으로 가장 적절하지 않은 것은?', '반드시 영문으로 작성해야 한다', 70, 2),
	(325, 1, NULL, 2, NULL, '다음 중 엔터티의 분류 기준으로 가장 적절하지 않은 것은?', '스토리지 유형에 따른 분류 (파일 엔터티, 테이블 엔터티)', 60, 2),
	(326, 1, NULL, 2, NULL, '다음 중 행위 엔터티(Action Entity)의 특징으로 가장 적절한 것은?', '두 개 이상의 엔터티로부터 발생되는 엔터티', 60, 2),
	(327, 1, NULL, 2, NULL, '다음 중 슈퍼타입 엔터티(Supertype Entity)와 서브타입 엔터티(Subtype Entity)의 관계를 가장 잘 설명한 것은?', '슈퍼타입은 서브타입의 공통 속성을 가지며, 서브타입은 고유한 속성을 추가로 가진다', 60, 2),
	(328, 1, NULL, 2, NULL, '다음 중 엔터티의 생명주기(Life Cycle)를 올바르게 나열한 것은?', '생성 → 추가 → 수정 → 삭제', 60, 2),
	(329, 1, NULL, 1, NULL, '다음 중 속성(Attribute)의 정의로 가장 적절한 것은?', '엔터티를 구성하는 더 이상 분리되지 않는 최소의 데이터 단위', 50, 3),
	(330, 1, NULL, 2, NULL, '다음 중 기본 속성(Basic Attribute)의 특징으로 가장 적절한 것은?', '업무에서 기본적으로 도출되는 속성', 60, 3),
	(331, 1, NULL, 2, NULL, '다음 중 복합 속성(Composite Attribute)에 대한 설명으로 올바른 것은?', '하나의 의미로 사용되는 여러 개의 속성들의 집합', 60, 3),
	(332, 1, NULL, 2, NULL, '다음 중 단일 값 속성(Single-valued Attribute)과 다중 값 속성(Multi-valued Attribute)의 차이점으로 가장 적절한 것은?', '단일 값 속성은 하나의 값만 가질 수 있고, 다중 값 속성은 여러 개의 값을 가질 수 있다', 60, 3),
	(333, 1, NULL, 1, NULL, '다음 중 유도 속성(Derived Attribute)의 예로 가장 적절한 것은?', '주문의 총액 (단가 * 수량)', 50, 3),
	(334, 1, NULL, 3, NULL, '다음 중 속성의 명명 규칙으로 가장 적절하지 않은 것은?', '반드시 영문으로 작성해야 한다', 70, 3),
	(335, 1, NULL, 2, NULL, '다음 중 null 속성에 대한 설명으로 올바르지 않은 것은?', '모든 속성은 null 값을 가질 수 있다', 60, 3),
	(336, 1, NULL, 2, NULL, '다음 중 속성의 도메인(Domain)에 대한 설명으로 가장 적절한 것은?', '속성이 가질 수 있는 모든 가능한 값들의 집합', 60, 3),
	(337, 1, NULL, 3, NULL, '다음 중 속성의 데이터 타입을 결정할 때 고려해야 할 사항이 아닌 것은?', '속성의 이름', 70, 3),
	(338, 1, NULL, 2, NULL, '다음 중 대체 속성(Alternative Attribute)에 대한 설명으로 가장 적절한 것은?', '다른 속성을 대신하여 엔터티를 식별할 수 있는 속성', 60, 3),
	(339, 1, NULL, 2, NULL, '다음 중 슈퍼타입 엔터티와 서브타입 엔터티 사이의 속성 상속에 대한 설명으로 올바른 것은?', '서브타입 엔터티는 슈퍼타입 엔터티의 속성을 상속받고 추가적인 고유 속성을 가질 수 있다', 60, 3),
	(340, 1, NULL, 2, NULL, '다음 중 외래 식별자 속성(Foreign Identifier Attribute)에 대한 설명으로 가장 적절한 것은?', '다른 엔터티와의 관계에서 부모 엔터티의 주식별자를 자신의 주식별자로 이용하는 속성', 60, 3),
	(341, 1, NULL, 3, NULL, '다음 중 속성의 정규화(Normalization)에 대한 설명으로 올바르지 않은 것은?', '항상 성능을 향상시킨다', 70, 3),
	(342, 1, NULL, 3, NULL, '다음 중 속성의 물리적 설계 시 고려해야 할 사항으로 가장 적절하지 않은 것은?', '엔터티와의 관계', 70, 3),
	(343, 1, NULL, 1, NULL, '다음 중 관계형 데이터베이스에서 \'관계\'의 의미로 가장 적절한 것은?', '데이터베이스 내의 테이블', 60, 4),
	(344, 1, NULL, 1, NULL, '다음 중 INNER JOIN의 특징으로 가장 적절한 것은?', '조인 조건을 만족하는 데이터만 결과에 포함한다', 60, 4),
	(345, 1, NULL, 2, NULL, '다음 중 LEFT OUTER JOIN의 결과에 대한 설명으로 가장 적절한 것은?', '왼쪽 테이블의 모든 행이 결과에 포함된다', 70, 4),
	(346, 1, NULL, 2, NULL, '다음 중 FULL OUTER JOIN의 특징으로 가장 적절한 것은?', '두 테이블의 모든 데이터를 포함하며, 매치되지 않는 행은 NULL로 채운다', 70, 4),
	(347, 1, NULL, 2, NULL, '다음 중 CROSS JOIN의 결과로 가장 적절한 것은?', '두 테이블의 모든 가능한 조합을 만든다 (카테시안 곱)', 70, 4),
	(348, 1, NULL, 1, NULL, '다음 중 SELF JOIN의 정의로 가장 적절한 것은?', '같은 테이블을 자기 자신과 조인하는 것', 60, 4),
	(349, 1, NULL, 2, NULL, '다음 중 NATURAL JOIN의 특징으로 가장 적절한 것은?', '동일한 이름을 가진 모든 열을 기준으로 자동으로 조인한다', 70, 4),
	(350, 1, NULL, 2, NULL, '다음 중 NON-EQUI JOIN에 대한 설명으로 가장 적절한 것은?', '= 연산자가 아닌 다른 비교 연산자를 사용하여 조인 조건을 지정하는 방식', 70, 4),
	(351, 1, NULL, 1, NULL, '다음 중 OUTER JOIN을 사용하는 주된 이유로 가장 적절한 것은?', '조인 조건을 만족하지 않는 데이터도 결과에 포함시키기 위해', 60, 4),
	(352, 1, NULL, 2, NULL, '다음 중 INNER JOIN과 OUTER JOIN의 주요 차이점으로 가장 적절한 것은?', 'INNER JOIN은 조건을 만족하는 행만 반환하고, OUTER JOIN은 조건을 만족하지 않는 행도 포함하여 반환할 수 있다', 70, 4),
	(353, 1, NULL, 2, NULL, '다음 중 조인 연산의 성능에 가장 큰 영향을 미치는 요소는?', '조인되는 테이블의 크기와 인덱스 유무', 70, 4),
	(354, 1, NULL, 2, NULL, '다음 중 ANTI JOIN의 목적으로 가장 적절한 것은?', '첫 번째 테이블에는 있지만 두 번째 테이블에는 없는 데이터를 찾기 위해', 70, 4),
	(355, 1, NULL, 2, NULL, '다음 중 SEMI JOIN의 특징으로 가장 적절한 것은?', '조인 조건을 만족하는 왼쪽 테이블의 데이터만 반환하며, 오른쪽 테이블의 열은 포함하지 않는다', 70, 4),
	(356, 1, NULL, 3, NULL, '다음 중 EQUI JOIN과 NATURAL JOIN의 차이점으로 가장 적절한 것은?', 'EQUI JOIN은 조인 조건을 명시적으로 지정하고, NATURAL JOIN은 같은 이름의 열을 자동으로 조인한다', 80, 4),
	(357, 1, NULL, 1, NULL, '다음 중 식별자(Identifier)의 정의로 가장 적절한 것은?', '엔터티 내에서 인스턴스를 유일하게 구분할 수 있는 속성 또는 속성의 집합', 60, 5),
	(358, 1, NULL, 1, NULL, '다음 중 후보키(Candidate Key)에 대한 설명으로 올바른 것은?', '엔터티를 유일하게 식별할 수 있는 속성들의 집합', 60, 5),
	(359, 1, NULL, 2, NULL, '다음 중 기본키(Primary Key)의 특성으로 가장 적절하지 않은 것은?', '널(NULL) 허용', 70, 5),
	(360, 1, NULL, 1, NULL, '다음 중 대체키(Alternate Key)에 대한 설명으로 가장 적절한 것은?', '기본키로 선택되지 않은 후보키', 60, 5),
	(361, 1, NULL, 1, NULL, '다음 중 복합키(Composite Key)의 정의로 가장 적절한 것은?', '두 개 이상의 속성으로 구성된 키', 60, 5),
	(362, 1, NULL, 2, NULL, '다음 중 외래키(Foreign Key)에 대한 설명으로 올바르지 않은 것은?', '항상 해당 엔터티의 기본키의 일부가 되어야 한다', 70, 5),
	(363, 1, NULL, 1, NULL, '다음 중 인조식별자(Surrogate Key)의 특징으로 가장 적절한 것은?', '인위적으로 생성한 식별자', 60, 5),
	(364, 1, NULL, 2, NULL, '다음 중 식별자 선정 시 고려사항으로 가장 적절하지 않은 것은?', '길이의 최대화', 70, 5),
	(365, 1, NULL, 2, NULL, '다음 중 본질식별자(Natural Key)의 특징으로 가장 적절한 것은?', '업무적으로 의미 있는 식별자', 70, 5),
	(366, 1, NULL, 2, NULL, '다음 중 식별자 관계와 비식별자 관계의 차이점으로 가장 적절한 것은?', '식별자 관계는 부모 엔터티의 키가 자식 엔터티의 키의 일부가 되고, 비식별자 관계는 그렇지 않다', 70, 5),
	(367, 1, NULL, 2, NULL, '다음 중 복합식별자(Composite Identifier)를 사용할 때의 단점으로 가장 적절한 것은?', '인덱스 크기가 커질 수 있다', 70, 5),
	(368, 1, NULL, 2, NULL, '다음 중 식별자의 대체 방법(Identifier Substitution)을 고려해야 하는 경우로 가장 적절하지 않은 것은?', '식별자가 업무적 의미를 가지는 경우', 70, 5),
	(369, 1, NULL, 3, NULL, '다음 중 식별자 선정 시 일반적으로 우선순위가 가장 높은 것은?', '단일식별자', 80, 5),
	(370, 1, NULL, 2, NULL, '다음 중 식별자와 관련된 참조 무결성(Referential Integrity)에 대한 설명으로 가장 적절한 것은?', '외래키는 참조하는 테이블의 기본키에 없는 값을 가질 수 없다', 70, 5),
	(371, 1, NULL, 1, NULL, '다음 중 정규화(Normalization)의 주요 목적으로 가장 적절한 것은?', '데이터의 중복 제거와 일관성 확보', 60, 6),
	(372, 1, NULL, 1, NULL, '다음 중 제1정규형(1NF)의 정의로 가장 적절한 것은?', '모든 속성의 원자값화', 60, 6),
	(373, 1, NULL, 1, NULL, '다음 중 제2정규형(2NF)의 특징으로 가장 적절한 것은?', '모든 비주요 속성이 주요 속성에 완전 함수적 종속', 60, 6),
	(374, 1, NULL, 1, NULL, '다음 중 제3정규형(3NF)의 정의로 가장 적절한 것은?', '이행적 함수 종속 제거', 60, 6),
	(375, 1, NULL, 1, NULL, '다음 중 BCNF(Boyce-Codd Normal Form)의 조건으로 가장 적절한 것은?', '모든 결정자가 후보키인 경우', 60, 6),
	(376, 1, NULL, 1, NULL, '다음 중 함수적 종속성(Functional Dependency)의 정의로 가장 적절한 것은?', 'X의 값에 따라 Y의 값이 유일하게 정해지는 관계', 60, 6),
	(377, 1, NULL, 1, NULL, '다음 중 정규화 과정에서 발생할 수 있는 단점으로 가장 적절한 것은?', '조인 연산의 증가로 인한 성능 저하 가능성', 60, 6),
	(378, 1, NULL, 1, NULL, '다음 중 제4정규형(4NF)이 다루는 주요 이슈는?', '다치 종속(Multi-valued Dependency)', 60, 6),
	(379, 1, NULL, 1, NULL, '다음 중 정규화 과정에서 사용되는 \'결정자\'의 의미로 가장 적절한 것은?', '다른 속성의 값을 유일하게 결정하는 속성', 60, 6),
	(380, 1, NULL, 2, NULL, '다음 중 역정규화(Denormalization)를 고려해야 하는 상황으로 가장 적절한 것은?', '조인으로 인한 성능 저하가 심각할 때', 70, 6),
	(381, 1, NULL, 2, NULL, '다음 중 정규화 과정에서 사용되는 \'이행적 함수 종속\'의 의미로 가장 적절한 것은?', 'A→B이고 B→C일 때, A→C가 성립하는 경우', 70, 6),
	(382, 1, NULL, 2, NULL, '다음 중 제5정규형(5NF)의 주요 목적으로 가장 적절한 것은?', '조인 종속성 제거', 70, 6),
	(383, 1, NULL, 2, NULL, '다음 중 정규화 과정에서 \'함수적 종속성 다이어그램\'을 사용하는 주된 이유는?', '속성 간의 종속 관계를 시각적으로 표현하기 위해', 70, 6),
	(384, 1, NULL, 2, NULL, '다음 중 \'완전 함수적 종속\'과 \'부분 함수적 종속\'을 구분하는 기준으로 가장 적절한 것은?', '복합키의 전체 또는 일부 사용 여부', 70, 6),
	(385, 1, NULL, 1, NULL, '다음 중 관계(Relationship)의 정의로 가장 적절한 것은?', '엔터티의 인스턴스들 사이의 논리적인 연관성', 60, 7),
	(386, 1, NULL, 1, NULL, '다음 중 관계의 차수(Degree)에 대한 설명으로 올바른 것은?', '관계에 참여하는 엔터티의 수', 60, 7),
	(387, 1, NULL, 1, NULL, '다음 중 1:N 관계에 대한 설명으로 가장 적절한 것은?', '한 쪽 엔터티의 하나의 인스턴스가 다른 쪽 엔터티의 여러 인스턴스와 관계를 맺을 수 있다', 60, 7),
	(388, 1, NULL, 1, NULL, '다음 중 M:N 관계를 해소하는 방법으로 가장 적절한 것은?', '중간에 연결 엔터티를 추가한다', 60, 7),
	(389, 1, NULL, 1, NULL, '다음 중 필수적 관계(Mandatory Relationship)와 선택적 관계(Optional Relationship)를 구분하는 기준은?', '관계 참여의 필수 여부', 60, 7),
	(390, 1, NULL, 1, NULL, '다음 중 순환 관계(Recursive Relationship)에 대한 설명으로 가장 적절한 것은?', '하나의 엔터티가 자기 자신과 관계를 맺는 것', 60, 7),
	(391, 1, NULL, 1, NULL, '다음 중 식별 관계(Identifying Relationship)의 특징으로 올바른 것은?', '부모 엔터티의 기본키가 자식 엔터티의 기본키의 일부로 사용된다', 60, 7),
	(392, 1, NULL, 1, NULL, '다음 중 ERD(Entity-Relationship Diagram)에서 관계를 표현하는 일반적인 기호는?', '마름모', 60, 7),
	(393, 1, NULL, 1, NULL, '다음 중 관계의 정의 시 고려해야 할 사항이 아닌 것은?', '관계의 색상', 60, 7),
	(394, 1, NULL, 1, NULL, '다음 중 비식별 관계(Non-Identifying Relationship)의 특징으로 가장 적절한 것은?', '부모 엔터티의 기본키가 자식 엔터티의 일반 속성으로 사용된다', 60, 7),
	(395, 1, NULL, 1, NULL, '다음 중 카디널리티(Cardinality)에 대한 설명으로 가장 적절한 것은?', '관계에 참여하는 각 엔터티의 인스턴스 수의 최대치', 60, 7),
	(396, 1, NULL, 2, NULL, '다음 중 관계의 정규화(Normalization)에 대한 설명으로 올바르지 않은 것은?', '항상 조회 성능을 향상시킨다', 60, 7),
	(397, 1, NULL, 2, NULL, '다음 중 관계의 종속성(Dependency)에 대한 설명으로 가장 적절한 것은?', '한 엔터티의 존재가 다른 엔터티의 존재에 의존하는 것', 60, 7),
	(398, 1, NULL, 1, NULL, '다음 중 관계 모델링 시 주의해야 할 사항으로 가장 적절하지 않은 것은?', '모든 관계는 반드시 M:N으로 설정해야 한다', 60, 7),
	(399, 1, NULL, 2, NULL, '데이터 모델에서 \'트랜잭션\'의 의미로 가장 적절한 것은?', '데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위', 60, 8),
	(400, 1, NULL, 2, NULL, '다음 중 트랜잭션의 특성(ACID)에 포함되지 않는 것은?', '확장성(Scalability)', 60, 8),
	(401, 1, NULL, 2, NULL, '데이터 모델에서 트랜잭션을 표현하는 방법으로 가장 적절하지 않은 것은?', '테이블의 색상 지정', 60, 8),
	(402, 1, NULL, 2, NULL, '다음 중 트랜잭션의 격리 수준(Isolation Level)과 관련이 없는 것은?', 'Distributed Read', 60, 8),
	(403, 1, NULL, 2, NULL, '데이터 모델에서 트랜잭션의 동시성을 고려할 때 가장 중요한 개념은?', '락킹(Locking)', 60, 8),
	(404, 1, NULL, 2, NULL, '다음 중 트랜잭션 모델링 시 고려해야 할 사항으로 가장 적절하지 않은 것은?', '테이블의 물리적 위치', 60, 8),
	(405, 1, NULL, 2, NULL, '트랜잭션의 원자성(Atomicity)을 데이터 모델에서 표현하는 방법으로 가장 적절한 것은?', '롤백(Rollback) 메커니즘 설계', 60, 8),
	(406, 1, NULL, 2, NULL, '다음 중 트랜잭션의 일관성(Consistency)을 유지하기 위한 방법으로 가장 적절한 것은?', '제약조건과 무결성 규칙 정의', 60, 8),
	(407, 1, NULL, 2, NULL, '트랜잭션의 독립성(Isolation)을 데이터 모델에서 고려할 때 중요한 개념은?', '동시성 제어(Concurrency Control)', 60, 8),
	(408, 1, NULL, 2, NULL, '다음 중 트랜잭션의 지속성(Durability)을 보장하기 위한 방법으로 가장 적절한 것은?', '로깅(Logging) 메커니즘 구현', 60, 8),
	(409, 1, NULL, 2, NULL, '데이터 모델에서 동시성 문제를 해결하기 위한 방법으로 가장 적절하지 않은 것은?', '모든 트랜잭션을 순차적으로 실행', 60, 8),
	(410, 1, NULL, 2, NULL, '다음 중 트랜잭션 모델링에서 \'긴 트랜잭션(Long Transaction)\'을 처리하는 방법으로 가장 적절한 것은?', '트랜잭션을 더 작은 단위로 분할', 60, 8),
	(411, 1, NULL, 2, NULL, '다음 중 관계 모델링 시 주의해야 할 사항으로 가장 적절하지 않은 것은?', '모든 관계를 다대다(M:N)로 설정해야 한다', 60, 8),
	(412, 1, NULL, 2, NULL, '다음 중 분산 트랜잭션(Distributed Transaction)을 모델링할 때 고려해야 할 사항으로 가장 적절한 것은?', '2단계 커밋(Two-Phase Commit) 프로토콜', 60, 8),
	(413, 1, NULL, 1, NULL, '다음 중 NULL의 의미로 가장 적절한 것은?', '알 수 없는 값 또는 해당 없음', 60, 9),
	(414, 1, NULL, 2, NULL, 'NULL 값과 관련하여 다음 중 올바른 설명은?', 'NULL과의 모든 비교 연산 결과는 UNKNOWN이다', 70, 9),
	(415, 1, NULL, 2, NULL, '다음 중 NULL을 포함한 열에 대해 집계 함수를 사용할 때의 설명으로 올바른 것은?', 'COUNT(*) 함수는 NULL을 포함한 모든 행을 계산한다', 70, 9),
	(416, 1, NULL, 1, NULL, 'NOT NULL 제약조건에 대한 설명으로 가장 적절한 것은?', '해당 열에 NULL 값을 허용하지 않는다', 60, 9),
	(417, 1, NULL, 2, NULL, 'NULL 값을 다른 값으로 대체하는 함수로 가장 적절한 것은?', 'COALESCE()', 70, 9),
	(418, 1, NULL, 1, NULL, '다음 중 NULL 값과 관련된 3가지 논리값 체계에서 사용되는 값이 아닌 것은?', 'MAYBE', 60, 9),
	(419, 1, NULL, 2, NULL, 'NULL 값이 포함된 열에 대해 DISTINCT를 사용할 때의 결과로 가장 적절한 것은?', 'NULL 값은 하나의 고유한 값으로 취급된다', 70, 9),
	(420, 1, NULL, 2, NULL, '다음 중 NULL 값을 포함한 열에 대한 인덱스 사용에 대해 올바른 설명은?', 'NULL 값의 인덱스 처리는 DBMS에 따라 다를 수 있다', 70, 9),
	(421, 1, NULL, 1, NULL, 'WHERE 절에서 NULL 값을 찾기 위해 사용해야 하는 연산자는?', 'IS NULL', 60, 9),
	(422, 1, NULL, 2, NULL, '다음 중 NULL 값과 관련하여 UNIQUE 제약조건의 동작에 대한 설명으로 가장 적절한 것은?', 'NULL 값은 UNIQUE 제약조건과 관계없이 여러 개 허용될 수 있다', 70, 9),
	(423, 1, NULL, 2, NULL, '복합 기본키(Composite Primary Key)에서 NULL 값 처리에 대한 설명으로 가장 적절한 것은?', '복합 기본키의 어떤 열에도 NULL 값이 허용되지 않는다', 70, 9),
	(424, 1, NULL, 2, NULL, 'NULL 값이 포함된 열에 대해 GROUP BY를 수행할 때의 결과로 가장 적절한 것은?', 'NULL 값은 별도의 그룹으로 처리된다', 70, 9),
	(425, 1, NULL, 3, NULL, '다음 중 NULL 값과 관련하여 외래 키(Foreign Key) 제약조건의 동작에 대한 설명으로 가장 적절한 것은?', '외래 키의 NULL 허용 여부는 설계자가 지정할 수 있다', 80, 9),
	(426, 1, NULL, 2, NULL, 'NULL 값을 포함한 데이터에 대해 UNION 연산을 수행할 때의 결과로 가장 적절한 것은?', 'NULL 값은 하나의 고유한 값으로 취급된다', 70, 9),
	(427, 1, NULL, 1, NULL, '다음 중 본질 식별자(Natural Key)의 정의로 가장 적절한 것은?', '업무적으로 의미 있는 데이터를 식별자로 사용하는 것', 60, 10),
	(428, 1, NULL, 2, NULL, '다음 중 인조 식별자(Surrogate Key)의 특징으로 가장 적절하지 않은 것은?', '업무적 의미를 가지고 있다', 70, 10),
	(429, 1, NULL, 2, NULL, '다음 중 본질 식별자의 장점으로 가장 적절한 것은?', '업무적 의미를 파악하기 쉽다', 70, 10),
	(430, 1, NULL, 2, NULL, '다음 중 인조 식별자를 사용할 때의 단점으로 가장 적절한 것은?', '데이터의 의미를 파악하기 어려울 수 있다', 70, 10),
	(431, 1, NULL, 2, NULL, '다음 중 인조 식별자를 사용하기 적합한 상황은?', '식별자로 사용할 만한 본질적인 속성이 없을 때', 70, 10),
	(432, 1, NULL, 2, NULL, '다음 중 본질 식별자를 사용할 때 주의해야 할 점으로 가장 적절한 것은?', '의미 있는 데이터의 변경 가능성', 70, 10),
	(433, 1, NULL, 1, NULL, '다음 중 인조 식별자의 예로 가장 적절한 것은?', '자동 증가하는 일련번호', 60, 10),
	(434, 1, NULL, 3, NULL, '다음 중 본질 식별자와 인조 식별자를 함께 사용하는 방식의 장점으로 가장 적절한 것은?', '업무적 의미와 시스템 효율성을 모두 고려할 수 있다', 80, 10),
	(435, 1, NULL, 2, NULL, '다음 중 인조 식별자를 생성하는 방법으로 가장 적절하지 않은 것은?', '기본키의 모든 칼럼을 연결하여 사용', 70, 10),
	(436, 1, NULL, 2, NULL, '다음 중 본질 식별자를 사용할 때의 장점으로 가장 적절하지 않은 것은?', '항상 최고의 검색 성능을 보장한다', 70, 10),
	(437, 1, NULL, 3, NULL, '다음 중 인조 식별자 사용이 데이터 모델링에 미치는 영향으로 가장 적절한 것은?', '물리적 모델과 논리적 모델의 차이를 줄일 수 있다', 80, 10),
	(438, 1, NULL, 2, NULL, '다음 중 본질 식별자와 인조 식별자의 선택 기준으로 가장 적절하지 않은 것은?', '개발 팀의 선호도', 70, 10),
	(439, 1, NULL, 2, NULL, '다음 중 인조 식별자 사용이 데이터 조회 성능에 미치는 영향으로 가장 적절한 것은?', '일반적으로 단순한 구조로 인해 성능이 향상될 수 있다', 70, 10),
	(440, 1, NULL, 3, NULL, '다음 중 본질 식별자와 인조 식별자의 병행 사용에 대한 설명으로 가장 적절한 것은?', '업무적 요구사항과 시스템 효율성을 모두 고려할 수 있는 방식이다', 80, 10),
	(441, 1, NULL, 1, NULL, '관계형 데이터베이스의 기본 구성 요소가 아닌 것은?', '포인터(Pointer)', 60, 11),
	(442, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'관계\'의 의미로 가장 적절한 것은?', '테이블 간의 논리적 연관성', 70, 11),
	(443, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 특징이 아닌 것은?', '계층적 구조로 데이터를 저장한다', 70, 11),
	(444, 1, NULL, 2, NULL, '관계형 데이터베이스에서 테이블의 다른 용어로 적절한 것은?', '릴레이션', 70, 11),
	(445, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 키(Key)가 아닌 것은?', '복합키(Composite Key)', 70, 11),
	(446, 1, NULL, 2, NULL, '관계형 데이터베이스의 무결성 제약조건과 가장 관련이 없는 것은?', '병행 무결성', 70, 11),
	(447, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 정규화 과정에서 다루는 주요 이슈가 아닌 것은?', '암호화 이상', 70, 11),
	(448, 1, NULL, 1, NULL, '관계형 데이터베이스에서 \'NULL\'의 의미로 가장 적절한 것은?', '알 수 없거나 해당 없음', 60, 11),
	(449, 1, NULL, 1, NULL, '다음 중 관계형 데이터베이스 관리 시스템(RDBMS)의 예가 아닌 것은?', 'MongoDB', 60, 11),
	(450, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'트랜잭션\'의 특성을 나타내는 약어로 알려진 것은?', 'ACID', 70, 11),
	(451, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 장점이 아닌 것은?', '대용량 비정형 데이터 처리에 최적화', 70, 11),
	(452, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'뷰(View)\'의 주요 목적으로 가장 적절한 것은?', '데이터 접근 제어 및 복잡한 쿼리 단순화', 70, 11),
	(453, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 스키마(Schema)에 대한 설명으로 가장 적절한 것은?', '데이터베이스의 논리적 구조와 제약조건의 정의', 70, 11),
	(454, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'참조 무결성\'을 유지하기 위한 주요 메커니즘은?', '외래키(Foreign Key) 제약조건', 70, 11),
	(455, 1, NULL, 2, NULL, 'SELECT 문의 기본 구조에서 올바른 순서는?', 'SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY', 70, 12),
	(456, 1, NULL, 1, NULL, '다음 중 SELECT 문에서 별칭(Alias)을 지정하는 올바른 방법은?', 'SELECT column_name AS alias_name', 60, 12),
	(457, 1, NULL, 1, NULL, 'SELECT 문에서 중복된 행을 제거하기 위해 사용하는 키워드는?', 'DISTINCT', 60, 12),
	(458, 1, NULL, 2, NULL, '다음 중 WHERE 절에서 사용할 수 없는 연산자는?', 'HAVING', 70, 12),
	(459, 1, NULL, 1, NULL, 'SELECT 문에서 여러 테이블을 조인할 때 사용하는 절은?', 'JOIN', 60, 12),
	(460, 1, NULL, 2, NULL, '다음 중 GROUP BY 절의 특징으로 올바르지 않은 것은?', 'ORDER BY 절 다음에 위치한다', 70, 12),
	(461, 1, NULL, 1, NULL, 'SELECT 문에서 결과를 정렬하기 위해 사용하는 절은?', 'ORDER BY', 60, 12),
	(462, 1, NULL, 2, NULL, '다음 중 HAVING 절의 용도로 가장 적절한 것은?', '그룹화된 결과에 조건을 적용한다', 70, 12),
	(463, 1, NULL, 3, NULL, 'SELECT 문에서 서브쿼리(Subquery)를 사용할 수 있는 위치가 아닌 것은?', 'ORDER BY 절', 80, 12),
	(464, 1, NULL, 2, NULL, '다음 중 SELECT 문에서 사용되는 집계 함수가 아닌 것은?', 'MEDIAN', 70, 12),
	(465, 1, NULL, 2, NULL, 'SELECT 문에서 LIKE 연산자와 함께 사용되는 와일드카드 문자가 아닌 것은?', '*', 70, 12),
	(466, 1, NULL, 3, NULL, '다음 중 SELECT 문의 실행 순서로 올바른 것은?', 'FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY', 80, 12),
	(467, 1, NULL, 1, NULL, 'SELECT 문에서 NULL 값을 찾기 위해 사용하는 올바른 구문은?', 'WHERE column_name IS NULL', 60, 12),
	(468, 1, NULL, 2, NULL, '다음 중 SELECT 문에서 UNION 연산자의 특징으로 올바르지 않은 것은?', '결과를 자동으로 오름차순 정렬한다', 70, 12),
	(469, 1, NULL, 1, NULL, '다음 중 문자열 함수가 아닌 것은?', 'ROUND', 60, 13),
	(470, 1, NULL, 2, NULL, 'NULL 값을 다른 값으로 대체하는 함수는?', 'COALESCE', 70, 13),
	(471, 1, NULL, 2, NULL, '날짜 간의 개월 수 차이를 계산하는 함수는?', 'MONTHS_BETWEEN', 70, 13),
	(472, 1, NULL, 2, NULL, '다음 중 집계 함수가 아닌 것은?', 'DECODE', 70, 13),
	(473, 1, NULL, 2, NULL, '문자열에서 특정 문자의 위치를 찾는 함수는?', '위의 모든 것', 70, 13),
	(474, 1, NULL, 1, NULL, '숫자를 반올림하는 함수는?', 'ROUND', 60, 13),
	(475, 1, NULL, 2, NULL, '현재 날짜와 시간을 반환하는 함수는?', '위의 모든 것 (DBMS에 따라 다름)', 70, 13),
	(476, 1, NULL, 2, NULL, '조건에 따라 다른 결과를 반환하는 함수는?', 'CASE', 70, 13),
	(477, 1, NULL, 2, NULL, '문자열의 길이를 반환하는 함수는?', 'b와 c 모두 (DBMS에 따라 다름)', 70, 13),
	(478, 1, NULL, 2, NULL, '두 값 중 큰 값을 반환하는 함수는?', 'GREATEST', 70, 13),
	(479, 1, NULL, 1, NULL, '숫자의 절대값을 반환하는 함수는?', 'ABS', 60, 13),
	(480, 1, NULL, 2, NULL, '문자열에서 특정 부분을 추출하는 함수는?', 'b와 c 모두 (DBMS에 따라 다름)', 70, 13),
	(481, 1, NULL, 2, NULL, '날짜에 특정 기간을 더하는 함수는?', '위의 모든 것 (DBMS에 따라 다름)', 70, 13),
	(482, 1, NULL, 2, NULL, '다음 중 윈도우 함수(분석 함수)가 아닌 것은?', 'ROUND', 70, 13),
	(483, 1, NULL, 1, NULL, 'WHERE 절의 주요 목적은 무엇인가?', '조건에 맞는 행을 선택한다', 60, 14),
	(484, 1, NULL, 2, NULL, '다음 중 WHERE 절에서 사용할 수 없는 연산자는?', 'HAVING', 70, 14),
	(485, 1, NULL, 2, NULL, 'WHERE 절에서 여러 조건을 결합할 때 사용하는 논리 연산자가 아닌 것은?', 'XOR', 70, 14),
	(486, 1, NULL, 1, NULL, 'NULL 값을 찾기 위해 WHERE 절에서 사용해야 하는 올바른 구문은?', 'WHERE column_name IS NULL', 60, 14),
	(487, 1, NULL, 1, NULL, 'WHERE 절에서 특정 범위의 값을 선택할 때 사용하는 연산자는?', 'BETWEEN', 60, 14),
	(488, 1, NULL, 1, NULL, '다음 중 WHERE 절에서 와일드카드 문자와 함께 사용되는 연산자는?', 'LIKE', 60, 14),
	(489, 1, NULL, 1, NULL, 'WHERE 절에서 여러 값 중 하나와 일치하는지 확인할 때 사용하는 연산자는?', 'IN', 60, 14),
	(490, 1, NULL, 2, NULL, 'WHERE 절에서 부정(NOT)을 표현하는 방법이 아닌 것은?', 'column_name ISNOT value', 70, 14),
	(491, 1, NULL, 2, NULL, 'WHERE 절에서 서브쿼리를 사용할 때, 서브쿼리가 여러 행을 반환하는 경우 사용할 수 없는 연산자는?', '=', 70, 14),
	(492, 1, NULL, 2, NULL, 'WHERE 절에서 날짜를 비교할 때 주의해야 할 점은?', '날짜 형식이 데이터베이스 설정과 일치해야 한다', 70, 14),
	(493, 1, NULL, 2, NULL, 'WHERE 절에서 대소문자를 구분하지 않고 비교하려면 어떻게 해야 하는가?', 'LOWER() 또는 UPPER() 함수를 사용한다', 70, 14),
	(494, 1, NULL, 2, NULL, 'WHERE 절에서 정규 표현식을 사용하기 위한 연산자는? (DBMS에 따라 다를 수 있음)', 'REGEXP 또는 RLIKE', 70, 14),
	(495, 1, NULL, 2, NULL, 'WHERE 절에서 계산된 열(Calculated Column)에 대한 조건을 지정할 때의 올바른 방법은?', '계산식을 그대로 WHERE 절에 사용한다', 70, 14),
	(496, 1, NULL, 2, NULL, 'WHERE 절에서 OR 조건과 AND 조건을 함께 사용할 때 주의해야 할 점은?', '괄호를 사용하여 우선순위를 명확히 해야 한다', 70, 14),
	(497, 1, NULL, 1, NULL, 'GROUP BY 절의 주요 목적은 무엇인가?', '데이터를 그룹화한다', 60, 15),
	(498, 1, NULL, 1, NULL, 'HAVING 절의 주요 목적은 무엇인가?', '그룹화된 결과를 필터링한다', 60, 15),
	(499, 1, NULL, 2, NULL, 'GROUP BY 절과 HAVING 절의 실행 순서로 올바른 것은?', 'GROUP BY → HAVING', 70, 15),
	(500, 1, NULL, 2, NULL, 'GROUP BY 절에서 사용할 수 없는 것은?', '별칭(Alias)', 70, 15),
	(501, 1, NULL, 2, NULL, '다음 중 HAVING 절에서 사용할 수 있는 것은?', '집계 함수', 70, 15),
	(502, 1, NULL, 2, NULL, 'GROUP BY 절을 사용할 때, SELECT 문에서 집계 함수를 사용하지 않은 칼럼은 어떻게 처리해야 하는가?', '반드시 GROUP BY 절에 포함시켜야 한다', 70, 15),
	(503, 1, NULL, 2, NULL, 'GROUP BY 절에서 여러 칼럼을 사용할 때의 결과는?', '모든 칼럼의 조합으로 그룹화된다', 70, 15),
	(504, 1, NULL, 2, NULL, 'HAVING 절과 WHERE 절의 차이점으로 올바른 것은?', 'HAVING은 그룹화 결과, WHERE은 개별 행에 대해 조건을 적용한다', 70, 15),
	(505, 1, NULL, 2, NULL, 'GROUP BY 절에서 NULL 값은 어떻게 처리되는가?', '별도의 그룹으로 처리된다', 70, 15),
	(506, 1, NULL, 1, NULL, '다음 중 GROUP BY 절과 함께 자주 사용되는 집계 함수가 아닌 것은?', 'SUBSTR', 60, 15),
	(507, 1, NULL, 2, NULL, 'GROUP BY 절을 사용하지 않고 HAVING 절을 사용할 수 있는가?', '가능하며, 전체 집합을 하나의 그룹으로 취급한다', 70, 15),
	(508, 1, NULL, 3, NULL, 'GROUP BY 절에서 \'WITH ROLLUP\'의 기능은? (MySQL 기준)', '부분 합계를 생성한다', 80, 15),
	(509, 1, NULL, 2, NULL, 'HAVING 절에서 서브쿼리를 사용할 수 있는가?', '가능하다', 70, 15),
	(510, 1, NULL, 3, NULL, 'GROUP BY 절을 사용할 때 발생할 수 있는 성능 문제를 해결하기 위한 방법으로 적절하지 않은 것은?', 'GROUP BY 절 제거', 80, 15),
	(511, 1, NULL, 1, NULL, 'ORDER BY 절의 주요 목적은 무엇인가?', '결과를 정렬한다', 60, 16),
	(512, 1, NULL, 1, NULL, 'ORDER BY 절의 기본 정렬 순서는?', '오름차순 (ASC)', 60, 16),
	(513, 1, NULL, 2, NULL, '여러 열을 기준으로 정렬할 때, 정렬 우선순위는 어떻게 결정되는가?', 'ORDER BY 절에 나열된 순서대로', 70, 16),
	(514, 1, NULL, 2, NULL, 'NULL 값은 ORDER BY 절에서 어떻게 처리되는가? (기본적으로)', 'DBMS에 따라 다르다', 70, 16),
	(515, 1, NULL, 2, NULL, 'ORDER BY 절에서 별칭(Alias)을 사용할 수 있는가?', '가능하다', 70, 16),
	(516, 1, NULL, 2, NULL, 'ORDER BY 절에서 사용할 수 없는 것은?', 'WHERE 절', 70, 16),
	(517, 1, NULL, 2, NULL, 'ORDER BY 절에서 숫자를 사용하는 것의 의미는?', 'SELECT 문의 칼럼 위치', 70, 16),
	(518, 1, NULL, 2, NULL, '다음 중 대소문자 구분 없이 정렬하는 방법으로 올바른 것은?', 'ORDER BY LOWER(column)', 70, 16),
	(519, 1, NULL, 2, NULL, 'ORDER BY 절에서 함수를 사용할 때의 영향은?', '정렬 속도가 느려질 수 있다', 70, 16),
	(520, 1, NULL, 2, NULL, 'ORDER BY 절의 실행 순서는 SQL 문의 다른 절들과 비교하여 어떠한가?', '가장 마지막에 실행된다', 70, 16),
	(521, 1, NULL, 3, NULL, 'ORDER BY 절에서 서브쿼리를 사용할 수 있는가?', '가능하다', 80, 16),
	(522, 1, NULL, 3, NULL, 'NULLS FIRST 또는 NULLS LAST 구문의 용도는?', 'NULL 값의 정렬 위치를 지정한다', 80, 16),
	(523, 1, NULL, 3, NULL, 'ORDER BY 절을 사용할 때 발생할 수 있는 성능 문제의 원인으로 가장 적절한 것은?', '대용량 데이터를 정렬할 때 메모리 사용량이 증가할 수 있어서', 80, 16),
	(524, 1, NULL, 3, NULL, 'ORDER BY 절에서 CASE 문을 사용하는 주된 목적은?', '조건부 정렬을 수행하기 위해', 80, 16),
	(525, 1, NULL, 1, NULL, '조인(Join)의 주요 목적은 무엇인가?', '여러 테이블의 데이터를 결합한다', 60, 17),
	(526, 1, NULL, 1, NULL, '다음 중 내부 조인(Inner Join)의 특징으로 가장 적절한 것은?', '조인 조건을 만족하는 데이터만 반환한다', 60, 17),
	(527, 1, NULL, 2, NULL, '외부 조인(Outer Join) 중 LEFT OUTER JOIN의 결과에 포함되는 것은?', '왼쪽 테이블의 모든 행', 70, 17),
	(528, 1, NULL, 2, NULL, 'FULL OUTER JOIN의 특징으로 가장 적절한 것은?', '양쪽 테이블의 모든 행을 반환하며, 매치되지 않는 행은 NULL로 채운다', 70, 17),
	(529, 1, NULL, 2, NULL, '셀프 조인(Self Join)의 정의로 가장 적절한 것은?', '동일한 테이블을 두 번 이상 조인하는 것', 70, 17),
	(530, 1, NULL, 2, NULL, '다음 중 비등가 조인(Non-Equi Join)의 예로 가장 적절한 것은?', 'ON A.price BETWEEN B.min_price AND B.max_price', 70, 17),
	(531, 1, NULL, 2, NULL, 'NATURAL JOIN의 특징으로 올바르지 않은 것은?', '동일한 이름을 가진 모든 열을 기준으로 자동으로 조인한다', 70, 17),
	(532, 1, NULL, 2, NULL, '크로스 조인(Cross Join)의 결과로 가장 적절한 것은?', '첫 번째 테이블의 모든 행과 두 번째 테이블의 모든 행을 조합한다 (카테시안 곱)', 70, 17),
	(533, 1, NULL, 2, NULL, '다음 중 조인 성능 최적화 방법으로 가장 적절하지 않은 것은?', '가능한 한 많은 테이블을 조인', 70, 17),
	(534, 1, NULL, 3, NULL, '세 개 이상의 테이블을 조인할 때 주의해야 할 점으로 가장 적절한 것은?', '조인 순서가 결과에 영향을 미칠 수 있다', 80, 17),
	(535, 1, NULL, 2, NULL, 'USING 절을 사용한 조인의 특징으로 올바른 것은?', '조인 칼럼의 이름이 같을 때 사용할 수 있다', 70, 17),
	(536, 1, NULL, 2, NULL, '다음 중 조인 조건이 없는 조인 방식은?', 'CROSS JOIN', 70, 17),
	(537, 1, NULL, 3, NULL, '안티 조인(Anti Join)의 목적으로 가장 적절한 것은?', '첫 번째 테이블에는 있지만 두 번째 테이블에는 없는 데이터를 찾는 것', 80, 17),
	(538, 1, NULL, 3, NULL, '조인을 사용할 때 NULL 값 처리에 대한 설명으로 가장 적절한 것은?', 'NULL 값의 처리는 조인 유형과 조건에 따라 다르다', 80, 17),
	(539, 1, NULL, 1, NULL, 'SQL 표준에서 정의하는 표준 조인 구문은?', 'FROM 절의 INNER JOIN, OUTER JOIN 등', 60, 18),
	(540, 1, NULL, 1, NULL, '다음 중 표준 내부 조인(INNER JOIN) 구문으로 올바른 것은?', 'FROM table1 INNER JOIN table2 ON table1.col = table2.col', 60, 18),
	(541, 1, NULL, 2, NULL, '표준 조인에서 ON 절과 WHERE 절의 차이점으로 가장 적절한 것은?', 'ON 절은 조인 조건을, WHERE 절은 필터 조건을 명시한다', 70, 18),
	(542, 1, NULL, 2, NULL, '표준 SQL의 NATURAL JOIN의 특징으로 올바르지 않은 것은?', '조인 결과에 중복 열이 포함된다', 70, 18),
	(543, 1, NULL, 2, NULL, '표준 SQL에서 USING 절을 사용한 조인의 특징은?', '조인 칼럼의 이름이 같을 때 사용할 수 있다', 70, 18),
	(544, 1, NULL, 2, NULL, '다음 중 표준 SQL의 외부 조인(OUTER JOIN) 구문으로 올바른 것은?', 'FROM table1 LEFT OUTER JOIN table2 ON table1.col = table2.col', 70, 18),
	(545, 1, NULL, 3, NULL, '표준 SQL에서 FULL OUTER JOIN이 지원되지 않을 때, 이를 구현하는 방법은?', 'LEFT OUTER JOIN과 RIGHT OUTER JOIN의 UNION을 사용한다', 80, 18),
	(546, 1, NULL, 2, NULL, '표준 SQL의 CROSS JOIN의 특징으로 가장 적절한 것은?', '두 테이블의 곱집합(Cartesian Product)을 반환한다', 70, 18),
	(547, 1, NULL, 2, NULL, '다음 중 표준 SQL의 셀프 조인(Self Join)을 설명한 것으로 가장 적절한 것은?', '동일한 테이블을 두 번 이상 조인하는 것', 70, 18),
	(548, 1, NULL, 2, NULL, '표준 SQL에서 비등가 조인(Non-Equi Join)을 구현하는 방법은?', 'ON 절에서 범위 조건 등을 사용한다', 70, 18),
	(549, 1, NULL, 2, NULL, '표준 SQL의 조인에서 ON 절과 USING 절을 동시에 사용할 수 있는가?', '불가능하다', 70, 18),
	(550, 1, NULL, 2, NULL, '다음 중 표준 SQL의 조인에서 지원하지 않는 기능은?', 'CONNECT BY', 70, 18),
	(551, 1, NULL, 3, NULL, '표준 SQL의 NATURAL JOIN과 USING 절을 사용한 조인의 차이점은?', 'NATURAL JOIN은 모든 공통 열을 사용하고, USING은 특정 열만 지정할 수 있다', 80, 18),
	(552, 1, NULL, 2, NULL, '표준 SQL 조인에서 여러 테이블을 조인할 때의 올바른 방법은?', '여러 개의 JOIN 키워드를 연속해서 사용한다', 70, 18),
	(553, 1, NULL, 1, NULL, '서브 쿼리(Subquery)의 정의로 가장 적절한 것은?', '메인 쿼리 내에 포함된 또 다른 쿼리', 60, 19),
	(554, 1, NULL, 2, NULL, '다음 중 서브 쿼리를 사용할 수 있는 위치가 아닌 것은?', 'CREATE TABLE 문', 70, 19),
	(555, 1, NULL, 2, NULL, '단일 행 서브 쿼리와 함께 사용할 수 있는 연산자는?', '=', 70, 19),
	(556, 1, NULL, 2, NULL, '다중 행 서브 쿼리와 함께 사용할 수 없는 연산자는?', '=', 70, 19),
	(557, 1, NULL, 3, NULL, '상관 서브 쿼리(Correlated Subquery)의 특징으로 가장 적절한 것은?', '메인 쿼리의 각 행마다 서브 쿼리가 실행된다', 80, 19),
	(558, 1, NULL, 2, NULL, '인라인 뷰(Inline View)의 정의로 가장 적절한 것은?', 'FROM 절에 사용된 서브 쿼리', 70, 19),
	(559, 1, NULL, 2, NULL, '스칼라 서브 쿼리(Scalar Subquery)의 특징으로 올바른 것은?', '단일 값을 반환한다', 70, 19),
	(560, 1, NULL, 2, NULL, '다음 중 서브 쿼리의 성능을 향상시키는 방법으로 가장 적절하지 않은 것은?', '모든 쿼리를 서브 쿼리로 변환한다', 70, 19),
	(561, 1, NULL, 2, NULL, 'EXISTS 연산자를 사용한 서브 쿼리의 특징으로 가장 적절한 것은?', '서브 쿼리의 결과가 존재하는지 여부만 확인한다', 70, 19),
	(562, 1, NULL, 2, NULL, '다음 중 서브 쿼리를 사용할 때의 장점이 아닌 것은?', '항상 쿼리의 성능을 향상시킨다', 70, 19),
	(563, 1, NULL, 3, NULL, '서브 쿼리에서 UNION을 사용할 수 있는 위치로 가장 적절한 것은?', 'FROM 절', 80, 19),
	(564, 1, NULL, 3, NULL, '다음 중 중첩 서브 쿼리(Nested Subquery)의 특징으로 가장 적절한 것은?', '서브 쿼리 안에 또 다른 서브 쿼리가 포함되어 있다', 80, 19),
	(565, 1, NULL, 3, NULL, '서브 쿼리에서 ORDER BY 절을 사용할 수 있는 경우는?', '인라인 뷰에서만 사용 가능하다', 80, 19),
	(566, 1, NULL, 3, NULL, '다음 중 서브 쿼리와 조인의 선택 기준으로 가장 적절한 것은?', '데이터의 특성과 쿼리의 목적에 따라 선택해야 한다', 80, 19),
	(567, 1, NULL, 1, NULL, 'SQL에서 사용되는 집합 연산자가 아닌 것은?', 'JOIN', 60, 20),
	(568, 1, NULL, 1, NULL, 'UNION 연산자의 특징으로 가장 적절한 것은?', '두 쿼리 결과의 합집합을 반환하며, 중복을 제거한다', 60, 20),
	(569, 1, NULL, 2, NULL, '다음 중 UNION ALL 연산자의 특징으로 올바른 것은?', '중복을 허용한다', 70, 20),
	(570, 1, NULL, 2, NULL, 'INTERSECT 연산자의 기능은?', '두 쿼리 결과의 교집합을 반환한다', 70, 20),
	(571, 1, NULL, 2, NULL, 'Oracle에서 MINUS 연산자와 동일한 기능을 하는 SQL Server의 연산자는?', 'EXCEPT', 70, 20),
	(572, 1, NULL, 2, NULL, '집합 연산자를 사용할 때 주의해야 할 점으로 가장 적절한 것은?', '연산 대상이 되는 쿼리들의 SELECT 절의 칼럼 개수가 동일해야 한다', 70, 20),
	(573, 1, NULL, 2, NULL, '다음 중 집합 연산자를 사용한 쿼리의 ORDER BY 절에 대한 설명으로 올바른 것은?', '맨 마지막 쿼리에만 ORDER BY를 사용할 수 있다', 70, 20),
	(574, 1, NULL, 1, NULL, 'UNION 연산자와 UNION ALL 연산자의 주요 차이점은?', 'UNION은 중복을 제거하고, UNION ALL은 중복을 허용한다', 60, 20),
	(575, 1, NULL, 2, NULL, '다음 중 집합 연산자의 성능 특성으로 가장 적절한 것은?', 'UNION ALL이 UNION보다 일반적으로 빠르다', 70, 20),
	(576, 1, NULL, 2, NULL, '집합 연산자를 사용할 때 데이터 타입에 관한 규칙으로 올바른 것은?', '대응되는 칼럼의 데이터 타입이 반드시 같을 필요는 없지만 호환 가능해야 한다', 70, 20),
	(577, 1, NULL, 2, NULL, '다음 중 MINUS 연산자(또는 EXCEPT)의 특징으로 올바른 것은?', '첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 뺀 차집합을 반환한다', 70, 20),
	(578, 1, NULL, 2, NULL, '집합 연산자를 사용한 쿼리에서 ALIAS를 지정할 때의 규칙으로 올바른 것은?', '첫 번째 쿼리의 ALIAS만 사용된다', 70, 20),
	(579, 1, NULL, 3, NULL, '다음 중 여러 개의 집합 연산자를 함께 사용할 때의 실행 순서로 올바른 것은?', '왼쪽에서 오른쪽으로 순차적으로 실행된다', 80, 20),
	(580, 1, NULL, 3, NULL, '집합 연산자를 사용할 때 NULL 값 처리 방식으로 올바른 것은?', 'NULL 값 처리는 DBMS와 연산자에 따라 다를 수 있다', 80, 20),
	(581, 1, NULL, 1, NULL, '다음 중 그룹 함수가 아닌 것은?', 'SUBSTR', 60, 21),
	(582, 1, NULL, 2, NULL, 'COUNT 함수에 대한 설명으로 옳지 않은 것은?', 'COUNT()는 항상 NULL을 반환한다', 70, 21),
	(583, 1, NULL, 2, NULL, '다음 중 NULL 값을 포함하여 계산하는 그룹 함수는?', 'COUNT(*)', 70, 21),
	(584, 1, NULL, 3, NULL, 'GROUP BY 절을 사용할 때 다음 중 옳은 설명은?', 'GROUP BY 절에 지정되지 않은 열이라도 SELECT 절에 사용할 수 있다', 80, 21),
	(585, 1, NULL, 2, NULL, 'HAVING 절의 용도로 가장 적절한 것은?', '그룹화된 결과에 조건을 적용한다', 70, 21),
	(586, 1, NULL, 2, NULL, '다음 중 그룹 함수를 중첩해서 사용할 수 있는 것은?', '그룹 함수는 중첩해서 사용할 수 없다', 70, 21),
	(587, 1, NULL, 2, NULL, 'ROLLUP 함수의 주요 용도는?', '소계와 총계를 계산', 70, 21),
	(588, 1, NULL, 3, NULL, '다음 중 CUBE 함수와 ROLLUP 함수의 차이점으로 가장 적절한 것은?', 'CUBE는 다차원 소계를 생성하고, ROLLUP은 계층적 소계를 생성한다', 80, 21),
	(589, 1, NULL, 3, NULL, 'GROUP BY 절에서 GROUPING SETS의 주요 기능은?', '여러 개의 GROUP BY 쿼리를 UNION ALL로 수행한 결과와 동일한 결과 생성', 80, 21),
	(590, 1, NULL, 2, NULL, '다음 중 DISTINCT 키워드를 사용할 수 있는 그룹 함수는?', 'COUNT', 70, 21),
	(591, 1, NULL, 2, NULL, '그룹 함수를 사용할 때 NULL 값 처리 방식으로 옳은 것은?', 'COUNT(*)는 NULL 값을 포함하여 계산한다', 70, 21),
	(592, 1, NULL, 3, NULL, '다음 중 LISTAGG 함수의 주요 용도는?', '그룹별로 데이터를 연결하여 하나의 열로 표시', 80, 21),
	(593, 1, NULL, 2, NULL, 'GROUP BY 절을 사용하지 않고 그룹 함수를 사용할 경우 결과는?', '전체 데이터에 대한 하나의 결과만 반환된다', 70, 21),
	(594, 1, NULL, 3, NULL, '다음 중 그룹 함수의 성능 최적화 방법으로 가장 적절하지 않은 것은?', '가능한 한 많은 열을 GROUP BY에 포함', 80, 21),
	(595, 1, NULL, 1, NULL, '윈도우 함수의 일반적인 구문 형식은?', '함수명() OVER (PARTITION BY 열 ORDER BY 열)', 60, 22),
	(596, 1, NULL, 1, NULL, '다음 중 순위 관련 윈도우 함수가 아닌 것은?', 'CONCAT()', 60, 22),
	(597, 1, NULL, 2, NULL, 'PARTITION BY 절의 주요 목적은?', '윈도우를 그룹화한다', 70, 22),
	(598, 1, NULL, 2, NULL, 'ROW_NUMBER()와 RANK() 함수의 주요 차이점은?', 'ROW_NUMBER()는 중복 값에 대해 다른 번호를 부여하고, RANK()는 같은 순위를 부여한다', 70, 22),
	(599, 1, NULL, 2, NULL, 'LEAD() 함수의 주요 용도는?', '현재 행을 기준으로 다음 행의 값을 참조한다', 70, 22),
	(600, 1, NULL, 3, NULL, '다음 중 윈도우 함수에서 사용할 수 없는 프레임 지정 옵션은?', 'COLUMNS', 80, 22),
	(601, 1, NULL, 2, NULL, 'FIRST_VALUE() 함수의 기능으로 가장 적절한 것은?', '윈도우의 첫 번째 행 값을 반환한다', 70, 22),
	(602, 1, NULL, 3, NULL, '윈도우 함수와 GROUP BY 절의 주요 차이점으로 가장 적절한 것은?', '윈도우 함수는 행 수를 줄이지 않고 계산을 수행하며, GROUP BY는 행 수를 줄인다', 80, 22),
	(603, 1, NULL, 2, NULL, 'NTILE() 함수의 주요 용도는?', '데이터를 지정된 수의 그룹으로 나눈다', 70, 22),
	(604, 1, NULL, 2, NULL, '다음 중 집계 윈도우 함수로 사용할 수 없는 것은?', 'SUBSTR()', 70, 22),
	(605, 1, NULL, 3, NULL, 'CUME_DIST() 함수의 반환 값 범위로 올바른 것은?', '0 초과 1 이하', 80, 22),
	(606, 1, NULL, 3, NULL, '윈도우 함수에서 ROWS와 RANGE의 차이점으로 가장 적절한 것은?', 'ROWS는 물리적 행 기준, RANGE는 논리적 값 기준으로 행을 지정한다', 80, 22),
	(607, 1, NULL, 2, NULL, 'LAG() 함수와 LEAD() 함수를 동시에 사용하는 주된 목적은?', '현재 행과 이전 행, 다음 행의 값을 한 번에 비교하기 위해', 70, 22),
	(608, 1, NULL, 3, NULL, '윈도우 함수의 성능 최적화 방법으로 가장 적절하지 않은 것은?', '모든 쿼리에 윈도우 함수 적용', 80, 22),
	(609, 1, NULL, 1, NULL, 'Oracle에서 Top N 쿼리를 구현하는 가장 일반적인 방법은?', 'ROWNUM 사용', 60, 23),
	(610, 1, NULL, 1, NULL, 'SQL Server에서 Top N 쿼리를 구현하는 가장 일반적인 방법은?', 'TOP 절 사용', 60, 23),
	(611, 1, NULL, 1, NULL, 'MySQL에서 Top N 쿼리를 구현하는 가장 일반적인 방법은?', 'LIMIT 절 사용', 60, 23),
	(612, 1, NULL, 2, NULL, '다음 중 Top N 쿼리의 일반적인 용도가 아닌 것은?', '모든 데이터의 평균 계산', 70, 23),
	(613, 1, NULL, 2, NULL, 'Oracle에서 ROWNUM을 사용한 Top N 쿼리의 주의사항으로 가장 적절한 것은?', 'ORDER BY 절과 함께 사용할 때 서브쿼리가 필요할 수 있다', 70, 23),
	(614, 1, NULL, 2, NULL, '다음 중 Top N 쿼리 최적화 방법으로 가장 적절하지 않은 것은?', '가능한 많은 데이터 추출', 70, 23),
	(615, 1, NULL, 3, NULL, 'Top N 쿼리에서 동점자 처리 방법으로 가장 적절한 것은?', 'a와 b 모두 가능', 80, 23),
	(616, 1, NULL, 3, NULL, '다음 중 페이지네이션(Pagination)을 구현하는데 사용될 수 있는 Top N 쿼리 기법은?', '모든 답변이 정확하다', 80, 23),
	(617, 1, NULL, 2, NULL, 'Top N 쿼리에서 WITH TIES 옵션(SQL Server)의 역할은?', '동점인 경우 추가 행을 포함한다', 70, 23),
	(618, 1, NULL, 2, NULL, '다음 중 Top N 쿼리와 관련이 없는 함수는?', 'CONCAT()', 70, 23),
	(619, 1, NULL, 2, NULL, 'Oracle에서 Top N 쿼리 결과의 범위를 지정할 때 사용하는 절은?', 'FETCH FIRST ROWS ONLY', 70, 23),
	(620, 1, NULL, 2, NULL, 'Top N 쿼리에서 윈도우 함수(Window Function)를 사용할 때의 장점은?', '복잡한 순위 지정 로직을 간단히 구현할 수 있다', 70, 23),
	(621, 1, NULL, 3, NULL, 'Top N 쿼리의 성능에 가장 큰 영향을 미치는 요소는?', 'ORDER BY 절의 존재 여부와 정렬 기준 열의 인덱스', 80, 23),
	(622, 1, NULL, 2, NULL, 'Top N 쿼리에서 PERCENT 옵션(SQL Server)의 역할은?', '전체 결과 중 상위 N%를 반환한다', 70, 23),
	(623, 1, NULL, 1, NULL, 'Oracle에서 계층형 질의를 작성할 때 사용하는 키워드는?', 'CONNECT BY', 60, 24),
	(624, 1, NULL, 1, NULL, '셀프 조인(Self Join)의 정의로 가장 적절한 것은?', '같은 테이블을 자기 자신과 조인하는 것', 60, 24),
	(625, 1, NULL, 2, NULL, '계층형 질의에서 CONNECT_BY_ISLEAF 의사 열(Pseudo Column)의 역할은?', '현재 행이 리프 노드인지 확인한다', 70, 24),
	(626, 1, NULL, 2, NULL, '다음 중 셀프 조인의 일반적인 사용 사례가 아닌 것은?', '테이블의 행 개수 계산', 70, 24),
	(627, 1, NULL, 2, NULL, 'Oracle의 계층형 질의에서 CONNECT_BY_ROOT 연산자의 기능은?', '현재 행의 루트 노드 값을 반환한다', 70, 24),
	(628, 1, NULL, 2, NULL, '계층형 질의에서 순환 관계(Cycle)를 방지하기 위해 사용하는 옵션은?', 'NOCYCLE', 70, 24),
	(629, 1, NULL, 2, NULL, '셀프 조인을 사용할 때 주의해야 할 점으로 가장 적절한 것은?', '같은 테이블의 별칭을 다르게 지정해야 한다', 70, 24),
	(630, 1, NULL, 2, NULL, 'Oracle의 계층형 질의에서 START WITH 절의 역할은?', '계층 구조의 시작점을 지정한다', 70, 24),
	(631, 1, NULL, 2, NULL, '다음 중 계층형 질의의 결과를 정렬하는 데 사용되는 함수는?', 'ORDER SIBLINGS BY', 70, 24),
	(632, 1, NULL, 3, NULL, '셀프 조인과 계층형 질의의 주요 차이점으로 가장 적절한 것은?', '셀프 조인은 모든 DBMS에서 지원하지만, 계층형 질의는 일부 DBMS에서만 지원한다', 80, 24),
	(633, 1, NULL, 3, NULL, 'Oracle의 계층형 질의에서 CONNECT_BY_ISCYCLE 의사 열의 용도는?', '현재 행이 사이클을 형성하는지 확인한다', 80, 24),
	(634, 1, NULL, 2, NULL, '다음 중 셀프 조인을 사용하여 구현할 수 있는 기능으로 가장 적절하지 않은 것은?', '테이블 백업', 70, 24),
	(635, 1, NULL, 3, NULL, 'Oracle의 SYS_CONNECT_BY_PATH 함수의 주요 용도는?', '계층 구조의 전체 경로를 문자열로 표현한다', 80, 24),
	(636, 1, NULL, 3, NULL, '다음 중 계층형 질의의 성능을 향상시키는 방법으로 가장 적절하지 않은 것은?', '가능한 한 깊은 레벨까지 탐색하도록 설정', 80, 24),
	(637, 1, NULL, 1, NULL, 'PIVOT 연산의 주요 목적은 무엇인가?', '행 데이터를 열 데이터로 변환한다', 60, 25),
	(638, 1, NULL, 1, NULL, 'UNPIVOT 연산의 주요 목적은 무엇인가?', '열 데이터를 행 데이터로 변환한다', 60, 25),
	(639, 1, NULL, 2, NULL, 'PIVOT 절을 사용할 때 반드시 필요한 것은?', '집계 함수', 70, 25),
	(640, 1, NULL, 2, NULL, '다음 중 PIVOT 절에서 사용할 수 없는 집계 함수는?', 'RANK', 70, 25),
	(641, 1, NULL, 2, NULL, 'UNPIVOT 절을 사용할 때 NULL 값 처리 방법으로 옳은 것은?', 'INCLUDE NULLS 옵션을 사용하면 NULL 값을 포함할 수 있다', 70, 25),
	(642, 1, NULL, 2, NULL, 'PIVOT 절의 일반적인 사용 사례가 아닌 것은?', '데이터 정규화', 70, 25),
	(643, 1, NULL, 2, NULL, 'PIVOT 절을 사용할 때 FOR 절의 역할은?', '피벗할 열을 지정한다', 70, 25),
	(644, 1, NULL, 2, NULL, 'UNPIVOT 절에서 IN 절의 역할은?', '언피벗할 열을 지정한다', 70, 25),
	(645, 1, NULL, 3, NULL, 'PIVOT 절을 사용할 때 동적으로 열을 생성하는 방법은?', 'PIVOT XML 사용', 80, 25),
	(646, 1, NULL, 3, NULL, 'UNPIVOT 절을 사용할 때 여러 열을 동시에 언피벗하는 방법은?', '괄호로 열 이름을 그룹화', 80, 25),
	(647, 1, NULL, 3, NULL, 'PIVOT 절의 성능을 향상시키는 방법으로 가장 적절한 것은?', '피벗하기 전에 데이터를 미리 집계한다', 80, 25),
	(648, 1, NULL, 3, NULL, 'UNPIVOT 절과 CROSS JOIN의 관계로 가장 적절한 설명은?', 'UNPIVOT과 CROSS JOIN은 완전히 다른 연산이다', 80, 25),
	(649, 1, NULL, 3, NULL, 'PIVOT 절을 지원하지 않는 DBMS에서 유사한 결과를 얻는 방법은?', 'CASE 문과 집계 함수 조합 사용', 80, 25),
	(650, 1, NULL, 3, NULL, 'PIVOT과 UNPIVOT을 연속해서 사용할 때의 결과로 가장 적절한 것은?', '원본 데이터와 다른 형태가 될 수 있으며, 사용 방식에 따라 결과가 달라진다', 80, 25),
	(651, 1, NULL, 1, NULL, '정규 표현식에서 \'.\'(점)의 의미는?', '정확히 한 개의 문자와 일치', 60, 26),
	(652, 1, NULL, 2, NULL, '정규 표현식 패턴 \'[0-9]+\'의 의미로 가장 적절한 것은?', '0에서 9까지의 숫자가 한 번 이상 반복', 70, 26),
	(653, 1, NULL, 1, NULL, 'Oracle에서 정규 표현식을 지원하는 함수는?', 'REGEXP_LIKE', 60, 26),
	(654, 1, NULL, 1, NULL, '정규 표현식에서 \'^\'의 의미는?', '문자열의 시작', 60, 26),
	(655, 1, NULL, 2, NULL, '정규 표현식 \'\\d\'와 동일한 의미를 가진 것은?', '[0-9]', 70, 26),
	(656, 1, NULL, 2, NULL, '정규 표현식에서 \'?\'의 의미는?', '0번 또는 1번 일치', 70, 26),
	(657, 1, NULL, 3, NULL, '이메일 주소를 검증하는 정규 표현식으로 가장 적절한 것은?', '^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$', 80, 26),
	(658, 1, NULL, 2, NULL, 'SQL에서 정규 표현식을 사용할 때의 장점이 아닌 것은?', '항상 LIKE 연산자보다 빠른 성능을 제공한다', 70, 26),
	(659, 1, NULL, 2, NULL, '정규 표현식 \'[^0-9]\'의 의미로 가장 적절한 것은?', '0에서 9까지의 숫자가 아닌 문자', 70, 26),
	(660, 1, NULL, 2, NULL, '정규 표현식에서 \'\\b\'의 의미는?', '단어 경계', 70, 26),
	(661, 1, NULL, 2, NULL, 'Oracle에서 정규 표현식을 사용한 문자열 치환에 사용되는 함수는?', 'REGEXP_REPLACE', 70, 26),
	(662, 1, NULL, 2, NULL, '정규 표현식 \'(ab)+\'의 의미로 가장 적절한 것은?', '\'ab\'가 한 번 이상 반복', 70, 26),
	(663, 1, NULL, 3, NULL, 'SQL Server에서 정규 표현식과 유사한 기능을 제공하는 것은?', 'PATINDEX 함수', 80, 26),
	(664, 1, NULL, 3, NULL, '정규 표현식 사용 시 성능 최적화 방법으로 가장 적절하지 않은 것은?', '모든 문자열에 대해 항상 정규 표현식 사용', 80, 26),
	(665, 1, NULL, 1, NULL, '다음 중 DML(Data Manipulation Language)에 해당하지 않는 명령어는?', 'CREATE', 60, 27),
	(666, 1, NULL, 2, NULL, 'INSERT 문에서 VALUES 절을 사용하지 않고 데이터를 삽입하는 방법은?', 'INSERT INTO 테이블명 SELECT 문;', 70, 27),
	(667, 1, NULL, 2, NULL, 'UPDATE 문에서 서브쿼리를 사용할 수 있는 위치가 아닌 곳은?', 'ORDER BY 절', 70, 27),
	(668, 1, NULL, 2, NULL, 'DELETE 문과 TRUNCATE 문의 차이점으로 올바른 것은?', 'DELETE는 DML이고, TRUNCATE는 DDL이다', 70, 27),
	(669, 1, NULL, 2, NULL, 'MERGE 문의 주요 용도로 가장 적절한 것은?', '조건에 따라 INSERT, UPDATE, DELETE를 한 번에 수행', 70, 27),
	(670, 1, NULL, 2, NULL, 'INSERT 문에서 여러 행을 한 번에 삽입하는 방법으로 올바른 것은?', 'INSERT INTO 테이블명 VALUES (값1, 값2), (값3, 값4);', 70, 27),
	(671, 1, NULL, 3, NULL, 'UPDATE 문에서 다른 테이블의 데이터를 참조하여 업데이트하는 방법으로 가장 적절한 것은?', 'a, b, c 모두 가능 (DBMS에 따라 다를 수 있음)', 80, 27),
	(672, 1, NULL, 2, NULL, 'DELETE 문을 실행한 후 삭제된 행의 수를 확인하는 방법으로 가장 적절한 것은?', 'a와 b 모두 가능 (DBMS에 따라 다름)', 70, 27),
	(673, 1, NULL, 2, NULL, 'INSERT 문에서 AUTO INCREMENT 열(또는 시퀀스)에 명시적으로 값을 지정하는 것의 영향으로 가장 적절한 것은?', '지정한 값이 이미 존재하면 오류가 발생할 수 있다', 70, 27),
	(674, 1, NULL, 2, NULL, 'UPDATE 문에서 WHERE 절을 생략했을 때 발생하는 결과로 가장 적절한 것은?', '테이블의 모든 행이 업데이트된다', 70, 27),
	(675, 1, NULL, 2, NULL, 'MERGE 문에서 WHEN NOT MATCHED THEN 절의 역할은?', '조건에 일치하는 데이터가 없을 때 INSERT를 수행', 70, 27),
	(676, 1, NULL, 3, NULL, 'DML 문 실행 시 암시적 트랜잭션(Implicit Transaction)의 의미로 가장 적절한 것은?', '각 DML 문이 자동으로 하나의 트랜잭션으로 처리된다', 80, 27),
	(677, 1, NULL, 3, NULL, 'INSERT 문에서 ON CONFLICT(PostgreSQL) 또는 ON DUPLICATE KEY UPDATE(MySQL) 절의 주요 용도는?', '중복 키 발생 시 오류를 방지하고 대체 작업을 수행', 80, 27),
	(678, 1, NULL, 3, NULL, 'DML 문의 실행 속도를 향상시키는 방법으로 가장 적절하지 않은 것은?', '모든 DML 문을 트랜잭션으로 묶어 실행한다', 80, 27),
	(679, 1, NULL, 1, NULL, '다음 중 TCL(Transaction Control Language)에 해당하는 명령어가 아닌 것은?', 'UPDATE', 60, 27),
	(680, 1, NULL, 2, NULL, '트랜잭션의 특성을 나타내는 ACID에서 \'A\'가 의미하는 것은?', 'Atomicity', 70, 27),
	(681, 1, NULL, 1, NULL, 'COMMIT 명령어의 주요 기능으로 가장 적절한 것은?', '트랜잭션의 변경사항을 영구적으로 반영한다', 60, 27),
	(682, 1, NULL, 2, NULL, 'ROLLBACK 명령어를 실행했을 때 발생하는 결과로 가장 적절한 것은?', '마지막 COMMIT 이후의 모든 변경사항이 취소된다', 70, 27),
	(683, 1, NULL, 2, NULL, 'SAVEPOINT의 주요 용도로 가장 적절한 것은?', '트랜잭션 내의 중간 지점 표시', 70, 27),
	(684, 1, NULL, 2, NULL, '암시적 트랜잭션 종료가 발생하는 경우가 아닌 것은?', 'SELECT 문 실행', 70, 27),
	(685, 1, NULL, 2, NULL, '트랜잭션 격리 수준 중 가장 낮은 수준은?', 'READ UNCOMMITTED', 70, 27),
	(686, 1, NULL, 3, NULL, '다음 중 ROLLBACK TO SAVEPOINT 명령어의 영향으로 가장 적절한 것은?', '지정된 SAVEPOINT 이후의 변경사항만 취소한다', 80, 27),
	(687, 1, NULL, 3, NULL, '트랜잭션의 ACID 특성 중 \'Isolation\'이 보장하는 것은?', '동시에 실행되는 트랜잭션 간의 상호 영향 방지', 80, 27),
	(688, 1, NULL, 2, NULL, 'AUTO COMMIT 모드에서 다음 중 자동으로 커밋되지 않는 명령은?', 'BEGIN TRANSACTION', 70, 27),
	(689, 1, NULL, 3, NULL, '장기 트랜잭션(Long Transaction)의 문제점으로 가장 적절하지 않은 것은?', '데이터의 일관성 향상', 80, 27),
	(690, 1, NULL, 3, NULL, '분산 트랜잭션에서 사용되는 프로토콜로 가장 적절한 것은?', 'Two-Phase Commit', 80, 27),
	(691, 1, NULL, 3, NULL, 'READ COMMITTED 격리 수준에서 방지할 수 있는 현상은?', 'Dirty Read', 80, 27),
	(692, 1, NULL, 3, NULL, '트랜잭션 처리 시 데드락(Deadlock)을 방지하기 위한 방법으로 가장 적절하지 않은 것은?', '트랜잭션의 크기를 가능한 한 크게 유지', 80, 27),
	(693, 1, NULL, 1, NULL, '다음 중 DDL(Data Definition Language)에 해당하는 명령어가 아닌 것은?', 'INSERT', 60, 29),
	(694, 1, NULL, 2, NULL, '테이블 생성 시 기본키(Primary Key)를 지정하는 올바른 문법은?', 'a와 b 모두 가능', 70, 29),
	(695, 1, NULL, 2, NULL, 'ALTER TABLE 명령어로 수행할 수 없는 작업은?', '테이블의 모든 데이터 삭제', 70, 29),
	(696, 1, NULL, 2, NULL, '인덱스를 생성하는 명령어로 올바른 것은?', 'a와 b 모두 가능 (DBMS에 따라 다름)', 70, 29),
	(697, 1, NULL, 2, NULL, 'TRUNCATE 명령어의 특징으로 가장 적절하지 않은 것은?', '롤백이 가능하다', 70, 29),
	(698, 1, NULL, 2, NULL, '뷰(View)를 생성하는 올바른 문법은?', 'CREATE VIEW view_name AS SELECT 문;', 70, 29),
	(699, 1, NULL, 2, NULL, '다음 중 제약조건(Constraint)이 아닌 것은?', 'INDEX', 70, 29),
	(700, 1, NULL, 2, NULL, '테이블 스페이스(Tablespace)를 생성하는 명령어로 가장 적절한 것은?', 'CREATE TABLESPACE', 70, 29),
	(701, 1, NULL, 2, NULL, 'DROP TABLE 명령 실행 시 발생하는 결과로 가장 적절한 것은?', '테이블의 데이터와 구조 모두 삭제된다', 70, 29),
	(702, 1, NULL, 2, NULL, '시퀀스(Sequence) 객체의 주요 용도로 가장 적절한 것은?', '유일한 숫자 값 자동 생성', 70, 29),
	(703, 1, NULL, 3, NULL, 'ALTER TABLE 명령으로 수행할 수 있는 작업이 아닌 것은?', '테이블의 모든 행 복제', 80, 29),
	(704, 1, NULL, 2, NULL, 'COMMENT ON 명령어의 주요 용도는?', '데이터베이스 객체에 주석 추가', 70, 29),
	(705, 1, NULL, 3, NULL, '파티션(Partition) 테이블 생성 시 고려해야 할 사항으로 가장 적절하지 않은 것은?', '파티션 테이블의 인덱스 생성 불가능', 80, 29),
	(706, 1, NULL, 2, NULL, 'DDL 문 실행 시 발생하는 암시적 동작으로 가장 적절한 것은?', '자동 커밋(Auto Commit)', 70, 29),
	(707, 1, NULL, 1, NULL, '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'GRANT', 60, 30),
	(708, 1, NULL, 2, NULL, '사용자에게 특정 테이블에 대한 SELECT 권한을 부여하는 올바른 문법은?', 'GRANT SELECT ON table_name TO user_name;', 70, 30),
	(709, 1, NULL, 1, NULL, 'REVOKE 명령어의 주요 목적은?', '사용자로부터 권한을 제거한다', 60, 30),
	(710, 1, NULL, 2, NULL, '다음 중 시스템 권한이 아닌 것은?', 'INSERT ON employees', 70, 30),
	(711, 1, NULL, 2, NULL, '역할(Role)의 주요 용도로 가장 적절한 것은?', '권한들의 집합을 관리', 70, 30),
	(712, 1, NULL, 2, NULL, 'WITH GRANT OPTION의 의미로 가장 적절한 것은?', '부여받은 권한을 다른 사용자에게 부여할 수 있는 권한', 70, 30),
	(713, 1, NULL, 3, NULL, '데이터베이스 관리자(DBA) 권한에 일반적으로 포함되지 않는 것은?', '일반 사용자의 비밀번호 확인', 80, 30),
	(714, 1, NULL, 2, NULL, 'GRANT 명령어로 부여할 수 없는 권한은?', 'COMMENT', 70, 30),
	(715, 1, NULL, 2, NULL, 'public 역할(Role)의 특징으로 가장 적절한 것은?', '모든 사용자에게 자동으로 부여되는 역할', 70, 30),
	(716, 1, NULL, 3, NULL, '객체 권한을 취소할 때 CASCADE 옵션의 효과는?', '해당 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소한다', 80, 30),
	(717, 1, NULL, 2, NULL, '다음 중 DCL 명령어 실행 시 자동 커밋(Auto Commit)이 발생하는 DBMS는?', '모든 DBMS에서 자동 커밋이 발생한다', 70, 30),
	(718, 1, NULL, 2, NULL, '사용자에게 여러 개의 권한을 한 번에 부여하는 방법으로 가장 적절한 것은?', 'a와 b 모두 가능', 70, 30),
	(719, 1, NULL, 2, NULL, '데이터베이스 보안에서 \'권한의 최소화 원칙\'이 의미하는 바는?', '사용자에게 필요한 최소한의 권한만 부여한다', 70, 30),
	(720, 1, NULL, 3, NULL, 'REVOKE 명령어 실행 시 주의해야 할 점으로 가장 적절한 것은?', '잘못된 REVOKE 실행 시 의도치 않게 다른 사용자의 권한도 제거될 수 있다', 80, 30),
	(721, 3, NULL, 2, '1회차', '다음은 A사의 제품 리뷰 시스템 개발 프로젝트에서 도출된 엔터티들이다. 이 중 실무적으로 개선이 필요한 엔터티 설계는?', '리뷰내용변경이력 테이블이 복합키(리뷰번호, 변경일자)로 설계되어 있는데, 이는 이력 관리의 정확성을 보장하기 어렵습니다. 별도의 이력번호를 추가하여 기본키로 사용하는 것이 더 적절합니다.', NULL, 2),
	(722, 3, NULL, 2, '1회차', '다음 중 트랜잭션의 특성을 고려할 때 제약조건(Constraint) 설계가 잘못된 것은?', '계좌잔고는 트랜잭션의 일관성(Consistency)을 보장해야 하는 중요한 속성입니다. DEFAULT 제약조건만으로는 부적절하며, CHECK 제약조건으로 잔액이 0 이상이 되도록 보장해야 합니다.', NULL, 8),
	(723, 3, '고객은 여러 번 주문할 수 있으며, 한 번 주문 시 여러 상품을 주문할 수 있다. 각 상품의 주문수량과 주문 당시의 단가를 반드시 기록해야 하며, 주문이 취소될 경우 취소 사유와 취소 시각을 기록해야 한다.', 3, '1회차', '다음 요구사항에 대한 가장 적절한 모델링 방식은?', '이력 관리가 필요한 데이터는 별도 엔터티로 분리하는 것이 좋습니다. 주문상세와 주문취소이력을 분리함으로써 취소 이력의 독립적인 관리가 가능하고, 취소되지 않은 주문의 데이터 구조가 단순해지며, 향후 취소 관련 요구사항 변경 시 유연한 대응이 가능합니다.', NULL, 3),
	(724, 3, '배송지관리\n  - 회원번호: 숫자(10)\n  - 배송지명: 문자(50)\n  - 우편번호: 문자(5)\n  - 기본주소: 문자(200)\n  - 상세주소: 문자(200)\n  - 연락처: 문자(20)\n  - 기본배송지여부: 문자(1)', 2, '1회차', '배송지관리 테이블에서 기본키를 가장 적절하게 지정한 것은?', '배송지관리 테이블에서는 한 회원이 여러 배송지를 가질 수 있고, 배송지명은 사용자가 변경할 수 있어 식별자로 부적절하며, 주소 정보는 길이가 길고 변경 가능성이 있어 식별자로 부적절합니다. 따라서 별도의 배송지번호를 추가하여 기본키로 사용하는 것이 가장 적절합니다.', NULL, 5),
	(725, 3, '진료예약(예약번호, 환자번호, 진료과코드, 진료과명, 의사번호, 의사명, 진료일자, 진료시간)\n환자(환자번호, 환자명, 생년월일, 연락처, 최근진료일자, 누적진료횟수)\n진료과(진료과코드, 진료과명, 층수, 전화번호, 과장의사번호)', 3, '1회차', 'H병원의 진료 예약 시스템에서 제3정규형 관점에서 가장 문제가 되는 것은?', '제3정규형은 이행적 종속을 제거해야 합니다. 진료예약 테이블의 진료과명은 진료과코드에 종속되고, 진료과코드는 예약번호에 종속되는 이행적 종속관계가 존재합니다. 이는 진료과 테이블에서 관리되어야 할 정보입니다.', NULL, 6),
	(726, 3, '고객 ----0<---- 주문 ----0<---- 주문상품\n  ㅣ             ㅣ              ㅣ\n  ㅣ             ㅣ              ㅣ\n  >-------- 배송지              상품', 2, '1회차', 'ERD에서 잘못 표현된 관계를 고르시오.', '고객과 배송지의 관계에서 한 고객이 여러 배송지를 가질 수 있으므로, 현재 표현된 1:1 관계가 아닌 1:N 관계로 표현되어야 합니다.', NULL, 4),
	(727, 3, NULL, 3, '1회차', '다음 중 슈퍼타입-서브타입 관계를 잘못 설계한 것은?', '회원등급은 슈퍼타입-서브타입 관계가 아닌 속성으로 관리되어야 합니다. 등급은 회원의 상태를 나타내는 것이며, 한 회원이 시간에 따라 등급이 변경될 수 있기 때문입니다.', NULL, 3),
	(728, 3, NULL, 2, '1회차', '다음 중 반정규화를 고려해야 하는 상황으로 가장 부적절한 것은?', '배송완료된 주문의 상세 정보는 자주 변경되지 않는 데이터이며, 조회 빈도가 높지 않을 것으로 예상됩니다. 따라서 반정규화를 고려할 필요가 없습니다.', NULL, 6),
	(729, 3, NULL, 2, '1회차', '온라인 쇼핑몰의 로그인 이력 데이터를 설계할 때 가장 적절한 식별자 선택 방식은?', '로그인 이력은 빈번한 입력이 발생하는 이력성 데이터이며, 데이터 정합성이 중요하고, 조회 시 성능이 중요합니다. 따라서 별도의 로그인이력번호를 기본키로 사용하는 것이 가장 적절합니다.', NULL, 5),
	(730, 3, NULL, 3, '1회차', '다음은 여행사 패키지 상품 예약 시스템의 일부이다. 가장 적절하지 않은 모델링은?', '여행자정보 테이블의 회원번호는 불필요한 중복입니다. 예약번호만으로 충분히 식별이 가능하며, 회원번호는 예약 테이블과의 관계에서 조회할 수 있습니다. 또한 한 예약에 대해 여러 여행자가 존재할 수 있으므로, 별도의 여행자번호가 필요할 수 있습니다.', NULL, 2),
	(731, 3, 'SALES_MONTHLY\nSALES_MONTH    TOTAL_AMOUNT\n--------------------------\n202301         15000000\n202302         16500000\n202303         19000000\n202304         20000000\n202305         21000000', 3, '1회차', '월별 매출액이 직전 월 대비 10% 이상 증가한 월을 조회하는 SQL문으로 가장 적절한 것은?', 'LAG 함수를 사용하여 이전 월의 매출액과 비교하는 방식이 가장 효율적입니다. 윈도우 함수를 사용함으로써 자기 조인이나 서브쿼리 없이 간단하게 구현 가능하며 성능상 이점이 있고 코드의 가독성이 좋습니다.', NULL, 22),
	(732, 3, '[EMPLOYEE]\nEMP_NO  DEPT_NO  SALARY   BONUS\n--------------------------------\n1001    10       5000     1000\n1002    20       4000     NULL\n1003    10       3000     NULL\n1004    30       4500     700\n1005    20       2800     NULL', 2, '1회차', 'GROUP BY로 부서별 집계를 수행하는 SQL의 실행 결과는?', 'GROUP BY 절로 부서별 집계를 수행하고, COUNT(*)로 부서별 직원 수, SUM(SALARY)로 급여 합계, AVG(NVL(BONUS,0))로 NULL을 0으로 처리한 보너스 평균을 계산합니다.', NULL, 15),
	(733, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       2800', 3, '1회차', '부서별로 평균 급여보다 높은 급여를 받는 직원의 정보를 조회하려고 한다. 올바른 SQL문은?', '부서별 평균 급여를 구하고 이를 원래 테이블과 조인하는 방식이 가장 적절합니다. 인라인 뷰로 부서별 평균을 한 번만 계산하여 효율적입니다.', NULL, 19),
	(734, 3, NULL, 2, '1회차', 'UNION 연산에 대한 설명으로 틀린 것은?', 'UNION 연산에서는 칼럼 이름이 달라도 데이터 타입과 칼럼 개수가 일치하면 사용할 수 있습니다. ALIAS를 사용하여 결과 칼럼명을 지정할 수 있습니다.', NULL, 20),
	(735, 3, '[ORDERS]\nORDER_DATE\n----------\n2023-01-01\n2023-01-02\n2023-01-03\n2023-01-07\n2023-01-08\n2023-01-12\n2023-01-13', 3, '1회차', '연속으로 3일 이상 주문이 없는 기간을 찾으려고 한다. 적절한 SQL문은?', 'LEAD 함수를 사용하여 다음 주문일자와의 차이를 계산하는 방식이 가장 효율적입니다. date_diff를 통해 날짜 간격을 직접 계산하고, 윈도우 함수를 사용하여 복잡한 조인 없이 구현할 수 있으며, 결과가 명확하고 이해하기 쉽습니다.', NULL, 22),
	(736, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       4800', 3, '1회차', '각 부서별로 급여가 가장 높은 직원을 조회하는 SQL문 중 성능상 가장 효율적인 것은?', '부서별 최대 급여를 먼저 구하고 이를 원본 테이블과 조인하는 방식이 가장 효율적입니다. 인라인 뷰로 부서별 최대 급여를 한 번만 계산하고, 단순 조인으로 최종 결과를 도출하며, 불필요한 중복 계산이나 비교 작업이 없습니다.', NULL, 17),
	(737, 3, '[STOCK_HISTORY]\nPROD_ID  TRX_DATE    TRX_TYPE    QUANTITY\n----------------------------------------\nA001     2023-01-01  IN          100\nA001     2023-01-03  OUT         30\nA001     2023-01-05  IN          50\nA002     2023-01-02  IN          200\nA002     2023-01-04  OUT         100', 3, '1회차', '제품별 일별 재고 현황을 파악하려고 한다. 해당 일자에 입출고 내역이 없는 경우에도 직전 재고수량을 표시해야 한다. 적절한 SQL문은?', 'WITH 절과 CONNECT BY를 사용하여 모든 날짜를 생성하고, 이를 기준으로 재고 이력을 조회하는 방식이 가장 적절합니다. 날짜 연속성을 보장하고, 입출고 내역이 없는 날짜도 포함하며, 누적 재고 계산이 정확합니다.', NULL, 19),
	(738, 3, NULL, 2, '1회차', '다음 중 INSERT 문장에 대한 설명으로 올바르지 않은 것은?', 'INSERT 문장에서도 ORDER BY 절을 사용할 수 있습니다. INSERT SELECT 구문에서 ORDER BY 사용이 가능하며, 데이터의 삽입 순서가 중요한 경우 사용됩니다.', NULL, 27),
	(739, 3, '[DEPARTMENT]\nDEPT_ID   PARENT_DEPT_ID   DEPT_NAME\n----------------------------------------\n1         NULL             총무부\n2         1                인사팀\n3         1                총무팀\n4         NULL             영업부\n5         4                국내영업팀\n6         4                해외영업팀', 2, '1회차', '계층형 쿼리를 실행한 결과로 적절하지 않은 것은?', 'START WITH DEPT_ID IN (2,3)와 CONNECT BY PRIOR PARENT_DEPT_ID = DEPT_ID는 역방향 계층 구조를 잘못 구현한 예입니다. 하위에서 상위로 탐색하려면 PRIOR를 올바르게 사용해야 하며, 현재 구문은 논리적 오류가 있습니다.', NULL, 24),
	(740, 3, NULL, 2, '1회차', '다음 트랜잭션 관련 설명 중 틀린 것은?', 'TRUNCATE 문은 DDL이므로 ROLLBACK이 불가능합니다. AUTO COMMIT 되는 명령어이며, 로그를 남기지 않고, 복구가 불가능합니다.', NULL, 27),
	(741, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       4800', 2, '1회차', '다음 중 부서별 급여 순위를 구하는 가장 적절한 SQL문은?', 'RANK() 함수와 PARTITION BY를 사용하여 부서별로 급여 순위를 매기는 것이 가장 적절합니다. PARTITION BY로 부서별 그룹화하고, RANK()로 동일 순위 처리하며, ORDER BY SALARY DESC로 높은 급여순 정렬합니다.', NULL, 22),
	(742, 3, '[SALES]\nORDER_DATE  PRODUCT_ID  QUANTITY\n--------------------------------\n2023-01-01  A001        10\n2023-01-01  A002        15\n2023-01-01  A003         5\n2023-01-02  A001         8\n2023-01-02  A002        12', 3, '1회차', '주문일자별로 가장 많이 판매된 상품의 정보를 조회하려고 한다. 적절한 SQL문은?', 'RANK() 함수를 사용한 방식이 가장 효율적입니다. 윈도우 함수로 주문일자별 수량 순위를 계산하고 서브쿼리 중첩을 최소화하여 성능과 가독성이 우수합니다.', NULL, 22),
	(743, 3, NULL, 2, '1회차', '다음 중 데이터 정의어(DDL)에 해당하지 않는 것은?', 'UPDATE문은 DML(Data Manipulation Language)에 해당합니다. DDL은 CREATE, ALTER, DROP, TRUNCATE, RENAME 등의 명령어입니다.', NULL, 27),
	(744, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       8000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       7500\n1005    JUNG    20       4800\n1006    KANG    10       5500', 2, '1회차', '부서별 최대 급여와 최소 급여의 차이가 5000 이상인 부서를 조회하는 SQL문을 작성하시오.', 'GROUP BY와 HAVING절을 사용한 방식이 올바릅니다. WHERE절은 그룹함수를 사용할 수 없고, HAVING절에서 그룹 조건을 처리하며, MAX(), MIN() 함수로 급여차이를 계산해야 합니다.', NULL, 15),
	(745, 3, '[TARGET_TBL]\nPROD_ID  PROD_NAME  STOCK_QTY\n--------------------------------\nA001     Product1   100\nA002     Product2   150\n\n[SOURCE_TBL]\nPROD_ID  PROD_NAME  STOCK_QTY\n--------------------------------\nA001     Product1   120\nA003     Product3   200', 3, '1회차', '다음 테이블의 데이터를 MERGE 문을 사용하여 갱신하려고 한다. 올바른 구문은?', 'MERGE문의 기본 구문을 정확히 사용했습니다. USING절로 소스 테이블을 지정하고, ON절로 매칭 조건을 정의하며, MATCHED/NOT MATCHED로 각각의 경우를 처리합니다.', NULL, 27),
	(746, 3, '[LOGIN_HISTORY]\nUSER_ID    LOGIN_DT            SUCCESS_YN\n------------------------------------------\nUSER01    2024-01-01 09:00:00    N\nUSER01    2024-01-01 09:01:00    N\nUSER01    2024-01-01 09:02:00    N\nUSER02    2024-01-01 09:03:00    N\nUSER02    2024-01-01 09:04:00    Y', 3, '1회차', '연속으로 3회 이상 로그인 실패한 사용자를 찾으려고 한다. 적절한 SQL문은?', '연속된 실패를 찾기 위해서는 로그인 시도의 순서를 고려해야 합니다. 자기 조인으로 연속된 실패를 확인하고, 시간 순서를 고려하며, 동일 사용자의 연속된 실패만 카운트해야 합니다.', NULL, 22),
	(747, 3, '[PURCHASES]\nCUST_ID  PROD_ID  PURCHASE_DATE\n--------------------------------\nC001     A001     2024-01-01\nC001     B001     2024-01-02\nC002     B001     2024-01-01\nC002     C001     2024-01-02\nC003     A001     2024-01-03\nC003     B001     2024-01-04', 3, '1회차', '한 번이라도 A001 상품을 구매한 이력이 있는 고객이 구매한 다른 상품들의 정보를 조회하려 한다. 적절한 SQL문은?', 'EXISTS를 사용한 방식이 가장 효율적입니다. 불필요한 조인이나 중복 제거 없이 A001 상품 구매 여부 확인이 명확하고 성능상 이점이 있습니다.', NULL, 19),
	(748, 3, NULL, 2, '1회차', '다음 중 인덱스를 효과적으로 사용할 수 있는 WHERE 절 작성 방법으로 적절하지 않은 것은?', 'salary * 12와 같은 연산은 인덱스를 사용할 수 없습니다. 컬럼에 대한 연산은 인덱스 활용이 불가능하며, 순수 컬럼 비교만 인덱스 활용이 가능합니다.', NULL, 17),
	(749, 3, '[SALES]\nSALES_MONTH    AMOUNT\n----------------------\n202401         1000000\n202402         1200000\n202403         950000\n202404         1300000', 3, '1회차', '월별 매출액과 전월 대비 증감률을 계산하려고 한다. 적절한 SQL문은?', 'LAG 함수와 CASE문을 조합한 방식이 가장 적절합니다. 0으로 나누는 경우를 처리하고, 증감률 계산이 정확하며, 코드가 간결하고 명확합니다.', NULL, 22),
	(750, 3, NULL, 2, '1회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 틀린 것은?', 'FOREIGN KEY의 데이터 타입은 반드시 동일할 필요는 없습니다. 자동 형변환이 가능한 경우 다른 타입도 가능하며, 참조 무결성만 보장되면 됩니다.', NULL, 17),
	(751, 3, 'SELECT dept_no, job_id FROM emp_2023\nUNION\nSELECT dept_no, job_id FROM emp_2024\nINTERSECT\nSELECT dept_no, job_id FROM emp_2022;', 2, '1회차', '아래의 집합 연산자 실행 결과를 바르게 예측한 것은?', 'SQL 집합 연산자의 우선순위는 INTERSECT > UNION 순입니다. 따라서 2024년과 2022년 데이터의 교집합을 먼저 구하고, 그 결과와 2023년 데이터의 합집합을 구합니다.', NULL, 20),
	(752, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       4800', 3, '1회차', '부서별로 평균 급여보다 높은 급여를 받는 사원의 수를 조회하는 SQL문으로 가장 효율적인 것은?', 'WITH절을 사용한 방식이 가장 효율적입니다. 평균 급여를 한 번만 계산하고, 명확한 코드 구조를 가지며, 성능상 이점이 있습니다.', NULL, 19),
	(753, 3, '[BOARD]\nPOST_ID   PARENT_ID   TITLE          REG_DATE\n-------------------------------------------\n1         NULL        첫번째글       2024-01-01\n2         1           ㄴRE:답글1     2024-01-02\n3         1           ㄴRE:답글2     2024-01-03\n4         NULL        두번째글       2024-01-04\n5         4           ㄴRE:답글1     2024-01-05', 2, '1회차', '각 게시글의 답글 수를 조회하려고 한다. 적절한 SQL문은?', 'LEFT JOIN과 GROUP BY를 사용하여 각 원본 게시글의 답글 수를 정확히 계산할 수 있습니다. NULL 처리와 집계가 모두 올바르게 동작합니다.', NULL, 19),
	(754, 3, NULL, 2, '1회차', '다음 중 SELECT 문장에서 GROUP BY를 사용할 때의 규칙으로 올바르지 않은 것은?', 'GROUP BY절의 컬럼 순서는 결과에 영향을 주지 않습니다. 그룹화의 결과는 순서와 무관하며, ORDER BY로 정렬 순서를 지정할 수 있습니다.', NULL, 15),
	(755, 3, '[EMPLOYEE]\nEMP_NO  DEPT_NO  SALARY_GRADE\n---------------------------\n1001    10       A\n1002    20       B\n1003    10       A\n1004    30       C\n1005    20       B', 3, '1회차', '부서별 급여 등급 분포를 PIVOT을 사용하여 조회하려고 한다. 적절한 SQL문은?', 'PIVOT 절을 사용하면 행으로 출력되는 데이터를 열로 변환할 수 있습니다. 부서별 급여 등급의 분포를 보기 좋게 표현할 수 있습니다.', NULL, 19),
	(756, 3, '[SALES]\nREGION  PRODUCT  QUANTITY\n-------------------------\n서울    A        100\n서울    B        150\n부산    A        200\n부산    B        120\n대구    A         80', 2, '1회차', '지역별, 상품별 판매량을 ROLLUP을 사용하여 집계하려고 한다. 적절한 SQL문은?', 'ROLLUP을 사용한 계층적 집계가 가장 적절합니다. 전체 합계, 지역별 합계, 지역+상품별 합계 모두 계산되며, 계층 구조가 명확하고 코드가 간결합니다.', NULL, 21),
	(757, 3, '[EMPLOYEE]\nEMP_NO  HIRE_DATE   RESIGN_DATE\n--------------------------------\n1001    2020-01-01  NULL\n1002    2019-06-01  2023-12-31\n1003    2021-03-01  NULL\n1004    2018-01-01  2022-06-30', 2, '1회차', '퇴사일자(RESIGN_DATE)가 NULL인 현재 재직자들의 근속연수를 계산하려 한다. 적절한 SQL문은?', 'MONTHS_BETWEEN 함수를 사용한 방식이 가장 정확합니다. 월 단위 계산이 정확하고, TRUNC로 소수점 처리가 되며, 날짜 계산이 명확합니다.', NULL, 13),
	(758, 3, NULL, 2, '1회차', '다음 중 데이터베이스 트랜잭션의 ACID 속성에 대한 설명으로 틀린 것은?', 'Durability는 지속성으로, 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함을 의미합니다. 다른 트랜잭션 접근 제한은 Isolation의 특성입니다.', NULL, 27),
	(759, 3, NULL, 2, '1회차', '다음 중 인덱스 생성 시 고려사항으로 적절하지 않은 것은?', '조인 조건으로 자주 사용되는 컬럼에는 오히려 인덱스를 생성하는 것이 좋습니다. 조인 성능 향상을 위해 인덱스가 필요하고, 외래키에 대한 인덱스는 유용하며, 조인 최적화에 도움이 됩니다.', NULL, 17),
	(760, 3, '[PURCHASES]\nORDER_DATE  CUST_ID  PROD_ID\n------------------------------\n2024-01-01  C001     P001\n2024-01-02  C001     P002\n2024-01-03  C002     P003\n\n[PRODUCTS]\nPROD_ID  CATEGORY  PROD_NAME\n------------------------------\nP001     A         상품1\nP002     B         상품2\nP003     A         상품3\nP004     A         상품4', 3, '1회차', '가장 최근에 구매한 상품과 동일한 카테고리의 다른 상품들을 추천하려고 한다. 적절한 SQL문은?', 'WITH절을 사용한 방식이 가장 명확하고 효율적입니다. 마지막 구매 정보를 명확히 식별하고, 동일 카테고리 상품 추출이 용이하며, 코드의 가독성이 우수합니다.', NULL, 19),
	(761, 3, '[ATTENDANCE]\nSTUDENT_ID  ATT_DATE    STATUS\n--------------------------------\nS001        2024-01-01  출석\nS001        2024-01-02  결석\nS001        2024-01-03  결석\nS001        2024-01-04  결석\nS001        2024-01-05  출석\nS002        2024-01-01  결석\nS002        2024-01-02  결석', 3, '1회차', '연속된 결석일수가 3일 이상인 학생을 찾으려고 한다. 적절한 SQL문은?', '윈도우 함수를 사용하여 이전 2일과 현재를 포함한 3일간의 결석 수를 계산합니다.\n\nWITH절과 윈도우 함수를 사용하여 연속된 결석을 정확하게 찾을 수 있습니다.\n\nROWS BETWEEN 2 PRECEDING AND CURRENT ROW로 연속된 3일을 확인합니다.\n\nCOUNT와 CASE문을 조합하여 결석만 카운트합니다.', NULL, 24),
	(762, 3, '[EMPLOYEE]\nEMP_NO   DEPT_NO   POSITION   SALARY\n-----------------------------------\n1001     10        사원       3000\n1002     20        대리       4000\n1003     10        대리       3500\n1004     20        과장       5000\n1005     10        과장       4500', 3, '1회차', '부서별 직급별 평균 급여를 PIVOT을 사용하여 조회하려고 한다.', 'PIVOT을 사용하여 행으로 되어있는 직급별 정보를 열로 변환할 수 있습니다.\n\n부서별로 각 직급의 인원수를 한눈에 파악할 수 있게 됩니다.\n\nFOR절에서 직급을 지정하고 AS를 사용하여 열 이름을 설정합니다.\n\n결과는 부서별로 각 직급의 인원수가 열 형태로 표시됩니다.', NULL, 26),
	(763, 3, '[DAILY_SALES]\nSALES_DATE    AMOUNT\n----------------------\n2024-01-01    1000000\n2024-01-02    1200000\n2024-01-03     950000\n2024-01-04    1100000\n2024-01-05    1300000\n2024-01-06    1400000\n2024-01-07    1800000\n2024-01-08    1600000', 3, '1회차', '일 매출이 직전 일주일 평균 매출보다 20% 이상 높은 날짜를 찾으려고 한다.', '윈도우 함수를 사용하여 직전 7일간의 평균 매출을 계산합니다.\n\nPARTITION BY로 기준 단위를 정의합니다.\n\nROWS BETWEEN 7 PRECEDING AND 1 PRECEDING으로 정확한 기간을 지정합니다.\n\n현재 매출과 평균 매출을 비교하여 20% 이상 높은 날짜를 식별합니다.', NULL, 22),
	(764, 3, '[SALARY_HISTORY]\nDEPT_NO    SALARY_MONTH    MIN_SALARY\n-------------------------------------\n10         202401          3000000\n10         202402          3200000\n10         202403          3100000\n20         202401          2800000\n20         202402          3000000\n20         202403          3200000', 3, '1회차', '각 부서의 월별 최소 급여가 전월 최소 급여보다 증가한 경우를 찾으려고 한다.', 'LAG 함수를 사용하여 이전 월의 최소 급여와 비교하는 것이 가장 효율적입니다.\n\nPARTITION BY DEPT_NO로 부서별 처리를 합니다.\n\nORDER BY SALARY_MONTH로 월별 순서를 정렬합니다.\n\n서브쿼리나 자기조인 없이 단순하게 구현 가능합니다.', NULL, 22),
	(765, 3, '[EMPLOYEE]\nEMP_NO    DEPT_NO    SALARY\n----------------------------\n1001      10         5000\n1002      10         5000\n1003      10         4000\n1004      20         6000\n1005      20         5000\n1006      20         5000', 3, '1회차', '부서별로 급여가 높은 순서대로 등수를 매기되, 같은 급여는 같은 등수로 처리하고 다음 등수는 건너뛰어야 한다.', 'RANK() 함수가 요구사항에 가장 적합합니다.\n\n같은 급여는 같은 등수로 처리합니다.\n\n다음 등수는 동일 순위 개수만큼 건너뜁니다.\n\nPARTITION BY DEPT_NO로 부서별 순위를 매깁니다.', NULL, 22),
	(766, 3, '[USER_LOGIN]\nUSER_ID     LAST_LOGIN_DATE\n-----------------------------\nuser1       2024-01-01\nuser2       2023-12-01\nuser3       2024-01-15\nuser4       2023-11-30', 2, '1회차', '30일 이상 미접속한 사용자를 찾으려고 한다.', 'TRUNC를 사용하여 시간을 제외한 순수 일자 차이를 계산하는 것이 정확합니다.\n\n날짜 간의 차이를 정확하게 계산할 수 있습니다.\n\nTRUNC 함수로 시간 정보를 제거합니다.\n\n정확한 일수 차이를 구할 수 있습니다.', NULL, 13),
	(767, 3, '[CUSTOMER_PURCHASE]\nCUST_ID    PURCHASE_DATE    AMOUNT\n---------------------------------\nC001       2024-01-01      10000\nC002       2024-01-15      20000\nC001       2024-02-01      15000\nC003       2024-02-15      25000\nC002       2024-02-28      30000', 3, '1회차', '월별로 처음 구매한 고객과 마지막으로 구매한 고객의 수를 집계하려고 한다.', 'ROW_NUMBER와 PARTITION BY를 사용하여 고객별 첫 구매와 마지막 구매를 식별합니다.\n\n월별로 그룹화하여 첫 구매와 마지막 구매 고객 수를 집계합니다.\n\nCASE문을 활용하여 첫 구매와 마지막 구매를 구분합니다.\n\n코드가 명확하고 유지보수가 용이합니다.', NULL, 19),
	(768, 3, '[SALES]\nPROD_ID    SALES_MONTH    QUANTITY\n--------------------------------\nP001       202401         100\nP001       202402         120\nP001       202403         90\nP001       202404         110\nP002       202401         200\nP002       202402         180\nP002       202403         220', 3, '1회차', '각 상품의 월별 판매량과 직전 3개월 평균 판매량을 구하려고 한다.', 'ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING을 사용하여 직전 3개월의 평균을 정확하게 계산합니다.\n\nPARTITION BY로 상품별로 구분합니다.\n\nORDER BY로 월별 순서를 정렬합니다.\n\n현재 월을 제외한 이전 3개월의 평균을 구할 수 있습니다.', NULL, 22),
	(769, 3, '[DAILY_SALES]\nSALES_DATE     AMOUNT\n----------------------\n2024-01-01     1000000\n2024-01-02     1200000\n2024-01-03     950000\n2024-01-04     1100000\n2024-01-05     1300000\n2024-01-06     1400000\n2024-01-07     1800000\n2024-01-08     1600000', 3, '1회차', '일 매출이 직전 일주일 평균 매출보다 20% 이상 높은 날짜를 찾으려고 한다.', '서브쿼리를 사용하여 직전 일주일의 평균을 정확히 계산하는 것이 가장 적절합니다.\n\nBETWEEN 연산자로 정확한 날짜 범위를 지정할 수 있습니다.\n\n현재 날짜를 제외하고 이전 7일만 계산합니다.\n\n평균값에 1.2를 곱하여 20% 증가를 계산합니다.', NULL, 22),
	(770, 3, '[MONTHLY_SALARY]\nDEPT_NO    YM        AVG_SALARY\n--------------------------------\n10         202401    3000000\n10         202402    3100000\n10         202403    3200000\n10         202404    3150000\n20         202401    2800000\n20         202402    2900000\n20         202403    3000000\n20         202404    3100000', 3, '1회차', '각 부서별로 연속된 3개월 이상 평균 급여가 증가한 기간을 찾으려고 한다.', '세 개의 연속된 월을 JOIN으로 연결하여 비교하는 것이 가장 명확합니다.\n\n연속된 월을 명시적으로 조인하여 비교할 수 있습니다.\n\n증가 여부를 직접 비교할 수 있어 이해하기 쉽습니다.\n\n복잡한 윈도우 함수 없이 구현이 가능합니다.\n\n결과가 명확하고 유지보수가 용이합니다.', NULL, 22),
	(771, 3, NULL, 2, '2회차', '다음 중 엔터티를 도출하는 방법으로 가장 적절하지 않은 것은?', '엔터티 도출 시에는 정보의 가치와 중요성을 고려해야 합니다. 모든 통계 데이터를 무조건 엔터티로 도출하는 것은 적절하지 않으며, 업무적 필요성과 데이터의 활용도를 고려하여 도출해야 합니다.', NULL, 2),
	(772, 3, NULL, 2, '2회차', '엔터티와 인스턴스의 관계에 대한 설명으로 가장 옳지 않은 것은?', '엔터티는 0개 이상의 인스턴스를 가질 수 있습니다. 예를 들어, 새로 설립된 회사의 \'직원\' 엔터티는 초기에 인스턴스가 없을 수 있으며, 이는 정상적인 상황입니다.', NULL, 2),
	(773, 3, NULL, 3, '2회차', '다음 중 정규화에 대한 설명으로 가장 옳은 것은?', '정규화가 진행될수록 테이블은 더 작은 단위로 분해되므로 테이블의 수가 증가합니다. 이는 데이터의 중복을 제거하고 데이터 정합성을 향상시키는 과정입니다.', NULL, 6),
	(774, 3, NULL, 2, '2회차', '다음 중 속성의 특징으로 가장 적절하지 않은 것은?', '주식별자는 단일 속성 또는 여러 속성의 조합(복합 식별자)으로 구성될 수 있습니다. 예를 들어, \'주문상세\' 엔터티의 경우 \'주문번호\'와 \'상품번호\'의 조합으로 주식별자를 구성할 수 있습니다.', NULL, 3),
	(775, 3, NULL, 2, '2회차', '다음 중 관계(Relationship)에 대한 설명으로 가장 옳은 것은?', '관계는 업무적으로 연관된 엔터티 간의 논리적 연결을 표현합니다. 관계는 선택적으로 참여 여부가 결정될 수 있으며, 양방향성이 필수는 아닙니다.', NULL, 4),
	(776, 3, NULL, 3, '2회차', '다음 중 식별자 관계에 대한 설명으로 가장 적절한 것은?', '식별 관계에서는 부모 엔터티의 주식별자가 자식 엔터티의 주식별자의 구성요소가 됩니다. 이는 두 엔터티 간의 강한 연관관계를 나타냅니다.', NULL, 5),
	(777, 3, NULL, 3, '2회차', '다음 중 슈퍼타입/서브타입 모델링에 대한 설명으로 옳지 않은 것은?', '서브타입은 슈퍼타입의 속성을 상속받지만, 자신만의 고유한 속성을 추가로 가질 수 있습니다. 모든 속성을 포함해야 한다는 것은 잘못된 설명입니다.', NULL, 2),
	(778, 3, '기본 엔터티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가되는 엔터티', 2, '2회차', '엔터티의 유형 중 다음 설명에 해당하는 것은?', '행위 엔터티는 기본 엔터티로부터 발생되는 트랜잭션의 결과로 생성되는 엔터티입니다. 주문, 거래, 계약 등이 대표적인 예시이며, 업무적 프로세스의 실행 결과로 발생됩니다.', NULL, 2),
	(779, 3, NULL, 2, '2회차', '다음 중 논리적 데이터 모델링 단계에서 수행하는 작업이 아닌 것은?', '인덱스 설계는 물리적 데이터 모델링 단계에서 수행하는 작업입니다. 논리적 데이터 모델링 단계에서는 업무적 관점에서의 데이터 구조 설계에 중점을 둡니다.', NULL, 8),
	(780, 3, NULL, 1, '2회차', '다음 중 ERD(Entity Relationship Diagram)의 표기법으로 올바르지 않은 것은?', 'ERD에서 식별자 표현에 특정 색상을 강제하는 표준은 없습니다. 식별자는 일반적으로 밑줄이나 \'#\' 등의 표기로 구분하며, 색상은 표기법에 따라 다양하게 사용될 수 있습니다.', NULL, 5),
	(781, 3, NULL, 1, '2회차', '다음 중 Oracle의 데이터 정의어(DDL)에 해당하지 않는 것은?', 'UPDATE는 DML(데이터 조작어)에 속합니다. DDL(데이터 정의어)에는 CREATE, ALTER, DROP, TRUNCATE, RENAME 등이 포함됩니다.', NULL, 30),
	(782, 3, 'SELECT SUBSTR(\'SQLD자격검정\', 5, 2) FROM DUAL;', 2, '2회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'SUBSTR(\'SQLD자격검정\', 5, 2)는 5번째 위치에서 2개의 문자를 추출합니다. 한글도 한 문자로 계산되어 \'자격\'이 추출됩니다.', NULL, 13),
	(783, 3, NULL, 3, '2회차', '다음 중 GROUP BY절에 대한 설명으로 옳지 않은 것은?', 'GROUP BY절에서는 SELECT절에서 정의한 Alias를 사용할 수 없습니다. Alias는 ORDER BY절에서만 사용 가능합니다.', NULL, 15),
	(784, 3, '[EMPLOYEE]\nID NAME SALARY DEPT_ID\n------------------------\n1 Kim 3000 10\n2 Lee 3500 20\n3 Park 2800 10\n4 Choi 4000 30\n5 Jung 3200 20\n\nSELECT DEPT_ID, COUNT(*), MAX(SALARY)\nFROM EMPLOYEE\nGROUP BY DEPT_ID\nHAVING COUNT(*) >= 2;', 3, '2회차', '다음 테이블에서 SQL문의 실행 결과를 고르시오.', 'DEPT_ID별로 그룹화하고 COUNT(*) >= 2 조건을 적용하면, 2명 이상의 직원이 있는 부서 10, 20만 출력됩니다.', NULL, 15),
	(785, 3, NULL, 2, '2회차', '다음 중 NULL 관련 함수에 대한 설명으로 틀린 것은?', 'NVL2 함수는 첫 번째 인자가 NULL이 아니면 두 번째 인자를, NULL이면 세 번째 인자를 반환합니다.', NULL, 13),
	(786, 3, '2024\n2023\n2022', 3, '2회차', '다음과 같은 결과를 출력하는 SQL문으로 적절한 것은?', 'CONNECT BY LEVEL을 사용하여 현재 년도부터 3개의 연도를 내림차순으로 출력합니다.', NULL, 13),
	(787, 3, '[TABLE_A]\nID NAME\n--------\n1 AAA\n2 BBB\n3 CCC\n\n[TABLE_B]\nID VALUE\n---------\n1 100\n2 200\n4 400', 2, '2회차', '다음 두 테이블의 OUTER JOIN 결과를 바르게 나타낸 것은?', 'LEFT OUTER JOIN 시 TABLE_A의 모든 행(3개)과 TABLE_B에만 존재하는 ID=4인 행이 추가되어 총 4행이 됩니다.', NULL, 17),
	(788, 3, NULL, 3, '2회차', 'WINDOW 함수에 대한 설명으로 옳지 않은 것은?', 'DENSE_RANK는 동일한 값에 대해 동일한 순위를 부여하고, 다음 순위는 이전 순위+1로 계산합니다.', NULL, 22),
	(789, 3, NULL, 2, '2회차', '다음 중 UNION 연산자에 대한 설명으로 옳지 않은 것은?', 'UNION 연산자 사용 시 두 SELECT문의 칼럼 개수는 반드시 동일해야 하며, 데이터 타입도 호환 가능해야 합니다.', NULL, 20),
	(790, 3, '[SCORE]\nVALUE\n-----\n10\n20\nNULL\n30\nNULL', 2, '2회차', '다음 테이블에서 최댓값을 구하는 SQL문으로 옳은 것은?', 'MAX 함수는 자동으로 NULL을 제외하고 최댓값을 계산합니다. 별도의 NULL 처리가 필요하지 않습니다.', NULL, 13),
	(791, 3, NULL, 1, '2회차', '다음 중 DCL(Data Control Language)에 해당하는 것은?', 'DCL에는 GRANT(권한 부여)와 REVOKE(권한 회수)가 포함됩니다. COMMIT은 TCL, CREATE는 DDL, INSERT는 DML입니다.', NULL, 30),
	(792, 3, '[SALES]\nMONTH AMOUNT\n-------------\n01 1000\n02 2000\n02 3000\n03 1500\n03 2500\n\nSELECT MONTH, SUM(AMOUNT)\nFROM SALES\nGROUP BY ROLLUP(MONTH);', 2, '2회차', '다음 테이블에 대한 SQL 실행 결과로 알맞은 것은?', 'ROLLUP은 지정된 칼럼의 소계와 총계를 생성합니다. 월별 합계 5행과 전체 합계 1행이 추가되어 총 6행이 됩니다.', NULL, 21),
	(793, 3, NULL, 2, '2회차', '계층형 질의에 사용되는 가상 칼럼이 아닌 것은?', 'ROWID는 Oracle의 물리적 주소를 나타내는 의사열(Pseudo Column)이며, 계층형 질의의 가상 칼럼이 아닙니다.', NULL, 24),
	(794, 3, NULL, 2, '2회차', '다음 중 PIVOT 함수를 사용할 때 반드시 지정해야 하는 것이 아닌 것은?', 'PIVOT 함수 사용 시 반드시 필요한 요소는 집계함수, FOR절, IN절입니다. WHERE절은 선택적으로 사용할 수 있습니다.', NULL, 26),
	(795, 3, '[EMPLOYEE]\nEMP_ID SALARY DEPT_ID\n-----------------------\n1 3000 10\n2 4000 20\n3 3500 10\n4 5000 30', 3, '2회차', '다음과 같은 테이블이 있을 때, 서브쿼리를 이용한 SQL문 중 틀린 것은?', 'NULL 비교는 = 연산자가 아닌 IS NULL을 사용해야 합니다.', NULL, 19),
	(796, 3, NULL, 2, '2회차', '트랜잭션의 특성(ACID)이 아닌 것은?', '트랜잭션의 특성은 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)입니다.', NULL, 28),
	(797, 3, NULL, 2, '2회차', 'Oracle의 날짜 연산에 대한 설명으로 틀린 것은?', 'Oracle에는 NEXT_MONTH 함수가 없습니다. 다음 달의 첫 날을 구하려면 ADD_MONTHS 함수를 사용해야 합니다.', NULL, 13),
	(798, 3, NULL, 2, '2회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 옳지 않은 것은?', '참조 무결성 제약조건에 의해 참조되는 테이블(부모 테이블)은 참조하는 테이블(자식 테이블)이 먼저 삭제되어야 삭제할 수 있습니다.', NULL, 30),
	(799, 3, 'RANK VALUE\n-----------\n1 100\n1 100\n3 90\n4 80\n4 80', 3, '2회차', '다음과 같은 결과를 출력하는 SQL문으로 적절한 것은?', 'RANK 함수는 동일한 값에 대해 동일한 순위를 부여하고, 다음 순위는 동일한 순위의 개수만큼 건너뜁니다.', NULL, 22),
	(800, 3, '[PRODUCT]\nID NAME PRICE\n---------------\n1 A 1000\n2 B 2000\n3 C 3000\n\nSELECT NAME,\n       LAG(PRICE, 1) OVER (ORDER BY PRICE) AS PREV_PRICE,\n       LEAD(PRICE, 1) OVER (ORDER BY PRICE) AS NEXT_PRICE\nFROM PRODUCT;', 2, '2회차', '다음 테이블에 대한 SQL문의 실행 결과로 옳은 것은?', 'LAG는 이전 행의 값, LEAD는 다음 행의 값을 가져옵니다. 첫 행의 LAG와 마지막 행의 LEAD는 NULL이 됩니다.', NULL, 22),
	(801, 3, NULL, 3, '2회차', 'WITH절(별칭 지정)에 대한 설명으로 옳지 않은 것은?', 'WITH절은 재귀적 호출이 가능하며, 이를 재귀적 CTE(Common Table Expression)라고 합니다.', NULL, 19),
	(802, 3, '[SCORE]\nID VALUE\n---------\n1 NULL\n2 50\n3 NULL\n4 80\n\nSELECT COALESCE(MAX(VALUE), AVG(VALUE), MIN(VALUE), 0)\nFROM SCORE;', 2, '2회차', '다음 테이블에서 SQL의 실행 결과는?', 'COALESCE는 NULL이 아닌 첫 번째 값을 반환합니다. MAX(VALUE)가 80으로 NULL이 아니므로 80이 반환됩니다.', NULL, 13),
	(803, 3, NULL, 2, '2회차', '다음 중 인덱스에 대한 설명으로 틀린 것은?', '인덱스는 데이터의 특성과 사용 패턴에 따라 오히려 성능을 저하시킬 수 있습니다.', NULL, 30),
	(804, 3, 'SELECT CASE\n         WHEN NULL = NULL THEN \'A\'\n         WHEN NULL IS NULL THEN \'B\'\n         ELSE \'C\'\n       END AS RESULT\nFROM DUAL;', 2, '2회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'NULL은 = 연산자로 비교할 수 없으며, IS NULL 연산자를 사용해야 합니다. 따라서 두 번째 조건이 TRUE가 되어 \'B\'가 반환됩니다.', NULL, 13),
	(805, 3, NULL, 3, '2회차', '다음 중 SELECT 문장 실행 순서가 올바른 것은?', 'SQL 문장의 논리적 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY입니다.', NULL, 12),
	(806, 3, '[DEPT]\nID NAME\n---------\n10 HR\n20 IT\n30 SALES\n\nSELECT *\nFROM DEPT\nSTART WITH ID = 20\nCONNECT BY PRIOR ID = ID;', 2, '2회차', '다음 테이블의 조회 결과로 적절한 것은?', '계층형 쿼리에서 PRIOR가 없으면 자기 자신과 연결되어 순환이 발생하므로 데이터가 출력되지 않습니다.', NULL, 24),
	(807, 3, NULL, 3, '2회차', '다음 중 윈도우 함수의 PARTITION BY절에 대한 설명으로 옳은 것은?', 'PARTITION BY는 윈도우 함수에서 연산을 수행할 그룹을 지정하는 역할을 합니다.', NULL, 22),
	(808, 3, 'SELECT ROUND(3.45678, 2),\n       ROUND(3.45678, 0),\n       ROUND(345.678, -2)\nFROM DUAL;', 2, '2회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'ROUND(3.45678, 2)는 소수점 2자리, ROUND(3.45678, 0)는 정수, ROUND(345.678, -2)는 100단위로 반올림합니다.', NULL, 13),
	(809, 3, '[EMPLOYEE]\nEMP_ID NAME SALARY\n--------------------\n1 Kim 3000\n2 Lee 4000\n3 Park 3500\n4 Choi 5000\n5 Jung 4500', 3, '2회차', '다음과 같은 테이블이 있을 때, 전체 행의 20%를 추출하는 SQL문으로 옳은 것은?', '전체 행수의 20%를 구하기 위해서는 서브쿼리로 전체 행수를 먼저 계산해야 합니다.', NULL, 23),
	(810, 3, NULL, 2, '2회차', '다음 중 트리거(Trigger)에 대한 설명으로 틀린 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 사용할 수 없습니다. 이는 트리거의 원자성을 보장하기 위함입니다.', NULL, 28),
	(811, 3, NULL, 2, '2회차', '다음 중 DML 트리거의 시점(Timing)으로 올바르지 않은 것은?', 'DML 트리거의 시점은 BEFORE, AFTER, INSTEAD OF만 존재합니다. DURING은 존재하지 않는 시점입니다. INSTEAD OF는 주로 뷰에 대한 DML 작업을 다른 방식으로 처리하고자 할 때 사용됩니다.', NULL, 28),
	(812, 3, '[SALES]\nYEAR QUARTER AMOUNT\n----------------------\n2023 Q1 1000\n2023 Q2 2000\n2023 Q3 1500\n2023 Q4 3000\n2024 Q1 2500\n\nSELECT YEAR,\n       SUM(AMOUNT) OVER (ORDER BY YEAR, QUARTER\n           ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS MOVING_SUM\nFROM SALES;', 3, '2회차', '다음 테이블에서 SQL문의 실행 결과는?', 'ROWS BETWEEN 1 PRECEDING AND CURRENT ROW는 현재 행과 이전 행의 값을 합산합니다. 모든 행에 대해 이전 행과의 합계가 계산되며, 첫 번째 행은 자기 자신만의 값이 출력됩니다. 총 5개의 행이 출력됩니다.', NULL, 22),
	(813, 3, NULL, 2, '2회차', '다음 중 Oracle의 이전 버전과의 호환성을 위해 새로운 기능을 비활성화하는 힌트는?', 'OLD_PLAN_GENERATOR 힌트는 Oracle의 이전 버전의 실행 계획 생성 방식을 사용하도록 지정합니다. 다른 보기의 힌트들은 각각 특정 최적화 전략을 지정하는 힌트들입니다.', NULL, 19),
	(814, 3, '[EMPLOYEE]\nEMP_ID NAME SALARY DEPT_ID\n--------------------------\n1 Kim 3000 10\n2 Lee 3500 20\n3 Park 2800 10\n4 Choi 4000 20\n5 Jung 3200 30', 3, '2회차', '다음과 같은 테이블이 있을 때, 각 부서별로 급여가 가장 높은 사원을 조회하는 SQL문으로 올바른 것은?', '부서별 최고 급여를 받는 사원을 찾기 위해서는 DEPT_ID로 그룹화하고, 해당 그룹의 최대 급여를 받는 사원을 찾아야 합니다. IN 절에서 복합 칼럼 조건을 사용하여 정확한 결과를 얻을 수 있습니다.', NULL, 19),
	(815, 3, NULL, 2, '2회차', '다음 중 SQL Server의 TOP 절과 Oracle의 ROWNUM의 차이점으로 옳지 않은 것은?', 'ROWNUM은 WHERE 절 외에도 SELECT 절에서도 사용할 수 있습니다. 단, ORDER BY와 함께 사용할 때는 인라인 뷰를 사용해야 합니다.', NULL, 19),
	(816, 3, 'SELECT DEPTNO, JOB, AVG(SAL)\nFROM EMP\nWHERE AVG(SAL) > 3000\nGROUP BY DEPTNO, JOB;', 2, '2회차', '다음 SQL문에서 실행되지 않는 이유로 가장 적절한 것은?', '집계함수는 WHERE 절에서 사용할 수 없습니다. 집계함수를 이용한 조건은 HAVING 절에서 사용해야 합니다.', NULL, 15),
	(817, 3, NULL, 2, '2회차', '다음 중 Oracle의 계층형 쿼리에서 사용되는 연산자가 아닌 것은?', 'Oracle의 계층형 쿼리에서는 CONNECT_BY_ROOT(루트 노드 값 표시), SYS_CONNECT_BY_PATH(경로 표시), CONNECT_BY_DEPTH(깊이 표시)를 사용할 수 있습니다. CONNECT_BY_LENGTH는 존재하지 않는 연산자입니다.', NULL, 24),
	(818, 3, '[PRODUCT]\nNAME      PRICE\n---------------\nApple     1000\nOrange    1500\nBanana    2000\n\nSELECT REGEXP_REPLACE(NAME, \'[aeiou]\', \'*\')\nFROM PRODUCT;', 3, '2회차', '다음 테이블에서 SQL문의 실행 결과는?', 'REGEXP_REPLACE 함수는 정규표현식 패턴에 매칭되는 모든 문자를 지정된 문자로 치환합니다. [aeiou]는 모든 소문자 모음을 의미하며, 이를 \'*\'로 치환합니다.', NULL, 26),
	(819, 3, NULL, 2, '2회차', '다음 중 MERGE 문에 대한 설명으로 틀린 것은?', 'MERGE 문에서 WHEN MATCHED와 WHEN NOT MATCHED 절은 선택적으로 사용할 수 있습니다. 둘 중 하나만 사용하거나 둘 다 사용할 수 있으며, 필수 절이 아닙니다.', NULL, 27),
	(820, 3, NULL, 2, '2회차', 'Oracle에서 테이블의 특정 칼럼을 암호화하기 위한 방법으로 적절하지 않은 것은?', 'DECODE 함수는 데이터를 암호화하는 함수가 아니라 조건에 따라 값을 변환하는 함수입니다. 실제 데이터 암호화를 위해서는 TDE, ENCRYPT 키워드, VPD 등의 보안 기능을 사용해야 합니다.', NULL, 30),
	(821, 3, NULL, 2, '3회차', '다음 중 엔터티(Entity)의 특징으로 가장 부적절한 것은?', '엔터티는 반드시 두 개 이상의 속성을 가져야 합니다. 하나의 속성만으로는 엔터티로 정의할 수 없습니다. 엔터티의 특징은 업무에서 필요한 정보여야 하고, 식별 가능한 이름이 있어야 하며, 두 개 이상의 속성을 가져야 하고, 한 개 이상의 인스턴스가 존재해야 합니다.', NULL, 2),
	(822, 3, '직원은 부서에 속한다.', 2, '3회차', '아래의 관계에 대한 설명으로 가장 적절한 것은?', '직원과 부서의 관계에서 "직원은 부서에 속한다"는 관계는 IE 표기법에서 실선으로 표현됩니다. 이는 비식별자 관계이며, 관계 차수는 N:1 관계가 됩니다(여러 직원이 하나의 부서에 속함). Barker 표기법은 이와 다른 표기 방식을 사용합니다.', NULL, 4),
	(823, 3, NULL, 2, '3회차', '다음 중 속성(Attribute)의 유형으로 가장 거리가 먼 것은?', '속성의 유형은 기본속성(업무로부터 추출한 모든 속성), 설계속성(업무를 규칙화하기 위해 새로 만든 속성), 파생속성(다른 속성에서 계산되어 생성되는 속성)으로 구분됩니다. 임시속성이라는 개념은 없습니다.', NULL, 3),
	(824, 3, NULL, 2, '3회차', '엔터티 도출 시 가장 부적절한 것은?', '엔터티는 반드시 두 개 이상의 속성을 가져야 하므로, 한 개의 속성만으로는 엔터티가 될 수 없습니다. 업무에서 관리되는 정보의 집합이어야 하며, 명사형으로 정의되고, 복수의 인스턴스가 존재해야 합니다.', NULL, 2),
	(825, 3, '사원번호 + 성명" → "사원번호 + 성명 + 부서코드 + 부서명', 3, '3회차', '아래의 예시가 나타내는 정규화 단계는?', '제시된 예시는 3차 정규화를 나타냅니다. 부서코드가 결정자이고 부서명이 종속자인 이행적 함수 종속을 제거하는 과정을 보여주고 있습니다.', NULL, 6),
	(826, 3, NULL, 2, '3회차', '다음 중 속성의 특징으로 올바르지 않은 것은?', '모든 속성이 반드시 엔터티를 식별할 수 있어야 하는 것은 아닙니다. 이는 식별자의 특성이지 일반 속성의 특성이 아닙니다. 속성은 하나의 값만 가져야 하고, 업무적으로 관리되어야 하며, 주식별자의 구성요소가 될 수 있습니다.', NULL, 3),
	(827, 3, '주문(주문번호, 주문일자) - 주문상세(상품번호, 수량)', 2, '3회차', '다음 관계에서 적절한 식별자 관계 표현은?', '주문상세의 기본키가 주문의 기본키를 포함하는 식별자 관계이므로 실선으로 표현됩니다. 주문상세는 주문번호와 상품번호를 복합키로 가지게 됩니다.', NULL, 4),
	(828, 3, NULL, 2, '3회차', '엔터티의 특징이 아닌 것은?', '엔터티가 반드시 다른 엔터티와 관계를 가져야 하는 것은 아닙니다. 독립적으로 존재하는 엔터티도 있을 수 있습니다. 나머지 특징들은 모두 엔터티의 올바른 특징입니다.', NULL, 2),
	(829, 3, NULL, 3, '3회차', '다음 중 슈퍼타입/서브타입 모델링에 대한 설명으로 부적절한 것은?', '슈퍼타입과 서브타입은 1:1 관계가 아닌 1:N 관계를 가질 수 있습니다. 서브타입은 슈퍼타입의 속성을 상속받으며, 배타적/포괄적 관계에 따라 서브타입 선택이 달라질 수 있습니다.', NULL, 2),
	(830, 3, '고객(고객번호, 고객명, 주소, 가입일자) → 고객(고객번호, 고객명, 우편번호, 가입일자) + 우편번호(우편번호, 주소)', 3, '3회차', '아래의 정규화 과정에 대한 설명으로 가장 적절한 것은?', '제시된 예시는 이행적 함수 종속성을 제거하는 과정을 보여줍니다. 우편번호가 주소를 결정하는 이행적 함수 종속을 제거하여 두 개의 테이블로 분리하는 것은 3차 정규화의 예입니다.', NULL, 6),
	(831, 3, NULL, 2, '3회차', '다음 중 NULL에 대한 설명으로 가장 부적절한 것은?', 'NULL과의 비교연산 결과는 FALSE가 아닌 UNKNOWN입니다. NULL은 알 수 없는 값을 의미하므로 비교 자체가 불가능합니다. 따라서 NULL과의 모든 비교 연산은 UNKNOWN을 반환합니다.', NULL, 9),
	(832, 3, NULL, 2, '3회차', '다음 중 SQL문의 실행 순서로 올바른 것은?', 'SQL의 논리적 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY입니다. 이 순서는 SQL 최적화 및 실행 계획 수립에 중요한 의미를 갖습니다.', NULL, 12),
	(833, 3, 'SELECT SUBSTR(\'SQL Programming\', 5, 3) FROM DUAL;', 2, '3회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SUBSTR(\'SQL Programming\', 5, 3)은 5번째 위치에서부터 3개의 문자를 추출합니다. \'SQL Programming\'에서 5번째 위치는 \'P\'이며, 여기서 3글자를 추출하면 \'Pro\'가 됩니다.', NULL, 13),
	(834, 3, 'SELECT dept_id, COUNT(*) FROM employee GROUP BY dept_id', 3, '3회차', '다음 중 아래의 GROUP BY절에 사용할 수 있는 HAVING절 조건으로 적절하지 않은 것은?', 'HAVING절은 GROUP BY로 그룹화된 결과에 대한 조건을 지정할 때 사용합니다. dept_id는 그룹화 칼럼이므로 WHERE절에서 사용해야 합니다. HAVING절에는 집계함수를 포함한 조건이 와야 합니다.', NULL, 15),
	(835, 3, NULL, 2, '3회차', '아래의 집계함수 중 NULL을 제외하고 연산하는 함수가 아닌 것은?', 'COUNT(*)는 NULL을 포함한 모든 행을 카운트합니다. 반면 다른 집계함수들(COUNT(column), AVG, MAX 등)은 NULL을 제외하고 연산을 수행합니다.', NULL, 21),
	(836, 3, NULL, 2, '3회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'DCL(Data Control Language)은 데이터베이스의 접근 권한과 관련된 명령어로, GRANT(권한 부여)와 REVOKE(권한 회수)가 있습니다. COMMIT/ROLLBACK은 TCL, CREATE/ALTER는 DDL, INSERT/UPDATE는 DML입니다.', NULL, 30),
	(837, 3, 'SELECT name FROM employee ORDER BY name ASC;', 2, '3회차', '아래의 테이블에서 ORDER BY절의 결과로 맨 마지막에 출력되는 것은?', 'Oracle에서 ORDER BY절을 사용할 때 NULL은 오름차순(ASC)에서 마지막에 위치합니다. 내림차순(DESC)에서는 첫 번째에 위치합니다.', NULL, 16),
	(838, 3, NULL, 2, '3회차', '다음 중 데이터 무결성을 위한 제약조건이 아닌 것은?', 'DEFAULT는 제약조건이 아니라 기본값을 지정하는 속성입니다. 데이터 무결성을 위한 제약조건에는 PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK가 있습니다.', NULL, 29),
	(839, 3, NULL, 3, '3회차', '다음 중 UNION 연산자에 대한 설명으로 틀린 것은?', 'UNION 연산자 사용 시 두 SELECT문의 컬럼 개수와 데이터 타입이 일치해야 합니다. 일치하지 않으면 오류가 발생합니다.', NULL, 20),
	(840, 3, 'SELECT ROUND(123.456, 1) FROM DUAL;', 2, '3회차', '다음 SQL문의 실행 결과는?', 'ROUND(123.456, 1)은 소수점 첫째자리까지 반올림하므로 123.5가 됩니다.', NULL, 13),
	(841, 3, NULL, 3, '3회차', '다음 중 Self Join에 대한 설명으로 가장 적절한 것은?', 'Self Join은 하나의 테이블을 두 번 이상 참조하여 조인하는 것을 말합니다. 주로 조직도나 게시판의 답변 구조 등을 표현할 때 사용됩니다.', NULL, 24),
	(842, 3, NULL, 2, '3회차', '다음 중 트랜잭션의 특성(ACID)이 아닌 것은?', '트랜잭션의 특성(ACID)은 Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성)입니다. Integrity(무결성)는 ACID 특성에 포함되지 않습니다.', NULL, 28),
	(843, 3, NULL, 2, '3회차', 'CASE문을 사용할 때 주의사항으로 올바르지 않은 것은?', 'CASE문에서 END 뒤의 별칭 지정은 선택사항이며, 필수가 아닙니다. 별칭은 필요한 경우에만 지정하면 됩니다.', NULL, 13),
	(844, 3, 'SELECT DISTINCT column1 FROM table1 WHERE column2 > 10 ORDER BY column1;', 2, '3회차', '아래의 SQL문에서 실행 순서가 가장 마지막인 것은?', 'SQL의 실행 순서는 FROM → WHERE → SELECT → DISTINCT → ORDER BY 순입니다. ORDER BY는 항상 마지막에 실행됩니다.', NULL, 16),
	(845, 3, NULL, 2, '3회차', 'INSERT문에 대한 설명으로 올바르지 않은 것은?', '칼럼 리스트를 생략하면 테이블에 정의된 칼럼 순서대로 모든 값을 입력해야 합니다. 자동으로 NULL이 입력되는 것이 아닙니다.', NULL, 27),
	(846, 3, NULL, 3, '3회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', '모든 윈도우 함수에 ORDER BY절이 필수는 아닙니다. SUM, COUNT 등의 집계 함수를 윈도우 함수로 사용할 때는 ORDER BY절 없이도 사용 가능합니다.', NULL, 22),
	(847, 3, NULL, 2, '3회차', '다음 중 SQL의 JOIN 유형이 아닌 것은?', 'VERTICAL JOIN은 존재하지 않는 조인 유형입니다. SQL에서 지원하는 JOIN의 유형에는 INNER JOIN, OUTER JOIN(LEFT/RIGHT/FULL), CROSS JOIN, NATURAL JOIN 등이 있습니다.', NULL, 18),
	(848, 3, NULL, 2, '3회차', 'DDL(Data Definition Language)에 해당하지 않는 것은?', 'DELETE는 DML(Data Manipulation Language)에 속합니다. DDL에는 CREATE, ALTER, DROP, TRUNCATE, RENAME 등이 있습니다.', NULL, 29),
	(849, 3, 'SELECT NVL(NULL, \'Empty\') FROM DUAL;', 2, '3회차', '아래 SQL문의 실행 결과로 맞는 것은?', 'NVL 함수는 첫 번째 인자가 NULL이면 두 번째 인자를 반환합니다. 따라서 NVL(NULL, \'Empty\')는 \'Empty\'를 반환합니다.', NULL, 13),
	(850, 3, NULL, 3, '3회차', '다음 중 인덱스를 생성하기에 가장 적절한 경우는?', '인덱스는 WHERE절에서 자주 사용되는 칼럼에 생성하는 것이 가장 효과적입니다. 테이블의 행 수가 적거나, INSERT가 빈번하거나, NULL값이 많은 칼럼은 인덱스 생성의 적절한 대상이 아닙니다.', NULL, 29),
	(851, 3, NULL, 3, '3회차', '서브쿼리의 특징으로 올바르지 않은 것은?', '서브쿼리의 SELECT절에는 여러 개의 칼럼을 지정할 수 있습니다. 단, 비교 연산자와 함께 사용될 때는 단일 칼럼이어야 합니다.', NULL, 19),
	(852, 3, NULL, 3, '3회차', 'MERGE 문에 대한 설명으로 틀린 것은?', 'MERGE문에서 DELETE절을 사용할 수 있습니다. MATCHED 조건에서 UPDATE 또는 DELETE를 선택적으로 수행할 수 있습니다.', NULL, 27),
	(853, 3, 'SELECT DECODE(column1, 1, \'ONE\', 2, \'TWO\', \'OTHER\') FROM table1 WHERE column1 = 3;', 2, '3회차', '다음의 SQL 실행 결과는?', 'DECODE 함수에서 조건값과 일치하는 것이 없을 경우 마지막 인자가 반환됩니다. column1이 3이므로 \'OTHER\'가 반환됩니다.', NULL, 13),
	(854, 3, NULL, 3, '3회차', '아래와 같은 계층형 쿼리에서 사용할 수 없는 함수는?', 'RANK 함수는 계층형 쿼리에서 사용할 수 없습니다. 계층형 쿼리에서는 LEVEL, CONNECT_BY_ROOT, SYS_CONNECT_BY_PATH 등의 특수 함수를 사용할 수 있습니다.', NULL, 24),
	(855, 3, NULL, 3, '3회차', 'WITH절(별칭지정)의 특징으로 올바르지 않은 것은?', 'WITH절은 다른 WITH절 내에서도 사용할 수 있습니다. 단, 순환 참조가 발생하지 않도록 주의해야 합니다.', NULL, 19),
	(856, 3, 'TRUNCATE TABLE employee; ROLLBACK;', 2, '3회차', '아래 SQL문에서 실행되지 않는 것은?', 'TRUNCATE는 DDL이므로 ROLLBACK이 불가능합니다. 실행 즉시 모든 데이터가 삭제되고 자동 COMMIT됩니다.', NULL, 29),
	(857, 3, NULL, 2, '3회차', '다음 중 VIEW에 대한 설명으로 틀린 것은?', 'VIEW는 원본 테이블의 구조에 종속적입니다. 원본 테이블의 구조가 바뀌면 VIEW도 영향을 받습니다.', NULL, 29),
	(858, 3, NULL, 2, '3회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 맞는 것은?', 'FOREIGN KEY는 참조 무결성을 보장하기 위한 제약조건입니다. NULL을 허용하며, 중복된 값도 허용됩니다.', NULL, 29),
	(859, 3, NULL, 2, '3회차', '다음 중 DELETE문과 TRUNCATE문의 차이점으로 올바르지 않은 것은?', 'DELETE문은 WHERE절을 사용하여 조건을 지정할 수 있지만, TRUNCATE문은 조건절을 사용할 수 없습니다.', NULL, 27),
	(860, 3, NULL, 3, '3회차', '다음 중 데이터베이스 트랜잭션 격리 수준(Isolation Level)이 아닌 것은?', '데이터베이스의 트랜잭션 격리 수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE입니다. READ ONLY는 격리 수준이 아닙니다.', NULL, 28),
	(861, 3, NULL, 3, '3회차', '다음 중 ROLLUP 함수에 대한 설명으로 틀린 것은?', 'ROLLUP 함수는 인수의 순서에 따라 다른 결과를 생성합니다. 인수 순서가 계층 구조를 결정하기 때문에 순서가 바뀌면 결과도 달라집니다.', NULL, 21),
	(862, 3, 'SELECT employee_id, salary, RANK() OVER (ORDER BY salary) rank, DENSE_RANK() OVER (ORDER BY salary DESC) dense_rank, ROW_NUMBER() OVER (ORDER BY salary) row_num WHERE row_num <= 3 FROM employees;', 3, '3회차', '아래의 SQL문에서 발생하는 오류는?', '윈도우 함수는 WHERE절에서 사용할 수 없습니다. 이러한 조건을 적용하려면 서브쿼리를 사용해야 합니다.', NULL, 22),
	(863, 3, NULL, 2, '3회차', '다음 중 데이터베이스 파티셔닝(Partitioning)의 장점이 아닌 것은?', '파티셔닝은 테이블의 전체 크기를 감소시키지 않습니다. 오히려 파티션 관리를 위한 추가 공간이 필요할 수 있습니다.', NULL, 29),
	(864, 3, '-- SALES 테이블\n-- SALES_DATE: 판매일자\n-- AMOUNT: 매출액', 3, '3회차', '아래의 테이블에서 월별 매출액과 작년 동월 매출액을 함께 조회하는 SQL문으로 가장 적절한 것은?', 'LAG 함수를 사용하여 12개월 이전의 데이터를 가져오는 방식이 가장 효율적입니다. GROUP BY로 월별 집계 후 LAG 함수로 작년 동월 데이터를 조회합니다.', NULL, 22),
	(865, 3, NULL, 3, '3회차', '다음 중 EXISTS와 IN 연산자의 차이점으로 틀린 것은?', 'EXISTS가 항상 IN보다 성능이 좋은 것은 아닙니다. 데이터의 특성과 조건에 따라 성능이 달라질 수 있습니다.', NULL, 19),
	(866, 3, NULL, 3, '3회차', 'WITH절(WITH RECURSIVE)를 사용할 수 없는 경우는?', 'WITH RECURSIVE는 계층 구조 조회, 연속 데이터 생성, 반복 집계에 사용됩니다. 단순 테이블 조인에는 WITH RECURSIVE를 사용할 필요가 없습니다.', NULL, 19),
	(867, 3, '-- 1번\nSELECT deptno, SUM(salary) FROM emp GROUP BY deptno;\n\n-- 2번\nSELECT deptno, SUM(salary) FROM emp GROUP BY ROLLUP(deptno);\n\n-- 3번\nSELECT deptno, SUM(salary) FROM emp GROUP BY CUBE(deptno);\n\n-- 4번\nSELECT deptno, SUM(salary) FROM emp GROUP BY GROUPING SETS(deptno);', 3, '3회차', '아래의 SQL문에서 실행 결과가 다른 하나는?', 'ROLLUP은 소계와 총계를 함께 생성하므로, 다른 쿼리들과 다른 결과를 반환합니다. 나머지 쿼리들은 부서별 합계만 계산합니다.', NULL, 21),
	(868, 3, NULL, 2, '3회차', '다음 중 테이블 스페이스(Tablespace)에 대한 설명으로 틀린 것은?', '하나의 테이블을 여러 테이블 스페이스에 분산하여 저장할 수 있습니다(예: 파티션별로 다른 테이블 스페이스 사용).', NULL, 29),
	(869, 3, NULL, 2, '3회차', '다음 중 실행 계획(Execution Plan)에 대한 설명으로 옳지 않은 것은?', '실행 계획이 항상 최적의 성능을 보장하지는 않습니다. 데이터의 특성이나 통계 정보의 정확성에 따라 실제 성능은 달라질 수 있습니다.', NULL, 29),
	(870, 3, NULL, 2, '3회차', '아래의 WHERE절에서 인덱스를 사용할 수 있는 조건은?', 'dept_id = 10과 같이 컬럼에 대한 직접적인 비교만 인덱스를 사용할 수 있습니다. 함수를 사용하거나 연산을 수행하는 경우에는 인덱스를 사용할 수 없습니다.', NULL, 29),
	(871, 3, NULL, 2, '4회차', '다음 중 엔터티의 특징으로 올바르지 않은 것은?', '엔터티는 물리적 형태뿐만 아니라 개념적으로 존재하는 것도 포함됩니다. 예를 들어 \'거래\', \'계약\' 등은 물리적 형태는 없지만 업무적으로 관리해야 할 엔터티입니다.', NULL, 2),
	(872, 3, NULL, 2, '4회차', '다음 중 식별자가 가져야 할 특성이 아닌 것은?', '식별자의 주요 특성은 유일성(Unique), 최소성(Minimal), 불변성(Stable), 존재성(Existence)입니다. 대체성은 식별자의 필수 특성이 아닙니다.', NULL, 5),
	(873, 3, NULL, 2, '4회차', '두 개의 엔터티간 관계에서 참여하는 수를 표현하는 것을 무엇이라 하는가?', '관계차수는 두 개의 엔터티간 관계에서 참여자의 수를 표현하는 것을 의미합니다. 예를 들어 1:1, 1:N, N:M 등으로 표현합니다.', NULL, 4),
	(874, 3, NULL, 3, '4회차', '다음 중 약한 엔터티 타입에 대한 설명으로 올바른 것은?', '약한 엔터티 타입은 상위 엔터티 타입의 존재 여부에 따라 종속적인 엔터티 타입을 의미합니다. 독립적으로 존재할 수 없으며, 상위 엔터티와의 관계가 필수적입니다.', NULL, 2),
	(875, 3, NULL, 2, '4회차', '다음 중 속성의 특성이 아닌 것은?', '제시된 보기 중 "하나의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다"는 엔터티의 특성이며, 속성의 특성이 아닙니다. 나머지는 모두 속성의 특성입니다.', NULL, 3),
	(876, 3, NULL, 2, '4회차', '다음 중 정규화에 대한 설명으로 틀린 것은?', '정규화는 조회 시 조인이 필요할 수 있어 항상 조회 성능이 향상되는 것은 아닙니다. 정규화의 주된 목적은 데이터의 중복을 제거하고 일관성을 보장하는 것입니다.', NULL, 6),
	(877, 3, NULL, 3, '4회차', '다음 중 반정규화를 고려해야 하는 경우가 아닌 것은?', '데이터의 일관성이 중요한 경우는 오히려 정규화를 유지해야 합니다. 반정규화는 성능 향상이 필요한 경우에 고려되어야 합니다.', NULL, 6),
	(878, 3, NULL, 3, '4회차', '다음 중 슈퍼타입과 서브타입 관계에서 올바르지 않은 것은?', '슈퍼타입과 서브타입은 1:N 관계가 가능합니다. 즉, 하나의 슈퍼타입이 여러 서브타입을 가질 수 있으며, 반드시 1:1 관계일 필요는 없습니다.', NULL, 2),
	(879, 3, NULL, 2, '4회차', '다음 중 엔터티를 도출하는 방법이 아닌 것은?', '엔터티는 먼저 도출한 후 관계를 정의해야 합니다. 관계를 먼저 정의하는 것은 올바른 엔터티 도출 방법이 아닙니다.', NULL, 2),
	(880, 3, NULL, 3, '4회차', '다음 중 식별자 관계를 설정하는 기준으로 가장 적절하지 않은 것은?', '식별자 관계 설정은 업무적 이용 빈도가 아닌, 엔터티 간의 존재 종속성과 식별자 상속 여부를 기준으로 결정해야 합니다.', NULL, 5),
	(881, 3, 'EMPLOYEE (EMP_ID, EMP_NAME, DEPT_ID, SALARY)', 3, '4회차', '다음과 같은 테이블이 있을 때, 부서별 평균 급여가 전체 평균 급여보다 높은 부서를 조회하는 SQL문으로 올바른 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 GROUP BY와 서브쿼리를 함께 사용해야 합니다. HAVING 절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 것이 올바른 방법입니다.', NULL, 19),
	(882, 3, NULL, 3, '4회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', 'RANK 함수는 중복 순위를 포함하여 순위를 부여합니다. 중복 순위를 제외하고 순차적으로 순위를 부여하는 것은 DENSE_RANK 함수입니다.', NULL, 22),
	(883, 3, 'SELECT SUBSTR(\'\'SQLD자격검정\'\', 5, 2) FROM DUAL;', 2, '4회차', '다음 테이블에서 SUBSTR 함수를 사용한 SQL의 실행 결과를 고르시오.', 'SUBSTR(\'SQLD자격검정\', 5, 2)는 5번째 위치에서 2글자를 추출합니다. 따라서 \'자격\'이 출력됩니다.', NULL, 13),
	(884, 3, NULL, 2, '4회차', '다음 중 Oracle의 JOIN 구문에 대한 설명으로 틀린 것은?', 'CROSS JOIN은 조인 조건이 필요없는 조인입니다. WHERE 절에서 조인 조건을 지정하는 것은 CROSS JOIN의 특성이 아닙니다.', NULL, 17),
	(885, 3, '-- ORDERS 테이블\n-- ORDER_ID: 주문번호\n-- ORDER_DATE: 주문일자 (DATE)\n-- AMOUNT: 주문금액', 3, '4회차', '다음과 같은 테이블이 있을 때, 2023년 월별 주문금액의 합계를 조회하는 SQL문으로 올바른 것은?', 'GROUP BY절에서 사용한 표현식은 SELECT절에서도 동일하게 사용해야 하며, 결과의 정렬을 위해 ORDER BY절이 필요합니다. EXTRACT 함수를 사용하여 연도와 월을 추출하는 방식이 가장 적절합니다.', NULL, 13),
	(886, 3, NULL, 2, '4회차', '다음 중 NULL 값에 대한 설명으로 틀린 것은?', 'NULL과의 비교연산은 TRUE나 FALSE가 아닌 UNKNOWN을 반환합니다. 이는 3-valued logic의 특성입니다.', NULL, 9),
	(887, 3, NULL, 2, '4회차', '다음 중 DELETE문에 대한 설명으로 가장 적절한 것은?', 'DELETE문은 DML문으로 트랜잭션 제어가 가능합니다. 따라서 COMMIT 전에는 ROLLBACK이 가능합니다.', NULL, 27),
	(888, 3, NULL, 3, '4회차', '다음 중 계층형 질의문의 실행 순서로 올바른 것은?', '계층형 질의문의 실행 순서는 START WITH → CONNECT BY → WHERE → ORDER SIBLINGS BY 순입니다.', NULL, 24),
	(889, 3, 'WITH TEMP AS (SELECT DEPTNO, AVG(SAL) AS AVG_SAL FROM EMP GROUP BY DEPTNO) SELECT * FROM TEMP WHERE AVG_SAL > 3000;', 2, '4회차', '다음 테이블에서 WITH절을 사용한 SQL문의 실행 결과로 옳은 것은?', 'WITH절(임시 테이블)에서 부서별 평균 급여를 구한 후, 그 중 평균 급여가 3000 이상인 부서를 조회합니다.', NULL, 19),
	(890, 3, NULL, 2, '4회차', '다음 중 GROUP BY절에 대한 설명으로 틀린 것은?', 'Oracle 11g R2 버전부터는 GROUP BY절에도 Alias를 사용할 수 있습니다. 따라서 이 설명은 틀린 것입니다.', NULL, 15),
	(891, 3, NULL, 2, '4회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE 문은 DML문으로 트랜잭션을 발생시킵니다. 따라서 COMMIT이나 ROLLBACK의 대상이 됩니다.', NULL, 27),
	(892, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- SAL: 급여', 3, '4회차', '다음과 같은 테이블에서 사원별로 급여가 전체 평균급여와 비교하여 평균 이상인지 이하인지를 조회하는 SQL문을 고르시오.', '전체 평균 급여는 서브쿼리를 통해 구해야 하며, CASE문을 사용하여 비교 결과를 표시할 수 있습니다.', NULL, 13),
	(893, 3, NULL, 3, '4회차', 'PIVOT 절에 대한 설명으로 틀린 것은?', 'PIVOT 절은 GROUP BY절과 함께 사용할 수 없습니다. PIVOT 절 자체가 그룹화와 집계 기능을 수행합니다.', NULL, 25),
	(894, 3, NULL, 2, '4회차', '다음 중 데이터베이스 트랜잭션의 특성(ACID)이 아닌 것은?', '데이터베이스 트랜잭션의 특성은 ACID(Atomicity, Consistency, Isolation, Durability)입니다. Duplication(중복성)은 트랜잭션의 특성이 아닙니다.', NULL, 28),
	(895, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- DEPTNO: 부서번호\n-- SAL: 급여', 3, '4회차', '다음 테이블에서 부서별 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최고 급여를 구한 후, 해당 결과와 원본 테이블을 조인하여 최고 급여를 받는 사원의 정보를 조회할 수 있습니다. 서브쿼리와 조인을 사용한 방식이 가장 효율적입니다.', NULL, 17),
	(896, 3, NULL, 3, '4회차', 'ROLLUP과 CUBE의 차이점에 대한 설명으로 틀린 것은?', 'ROLLUP은 인수의 순서에 따라 다른 결과가 나옵니다. 계층적 구조로 순서대로 소계를 생성하기 때문입니다.', NULL, 21),
	(897, 3, NULL, 2, '4회차', '다음 중 인덱스에 대한 설명으로 옳지 않은 것은?', '테이블에는 여러 개의 인덱스를 생성할 수 있습니다. 단, 과도한 인덱스 생성은 성능에 영향을 줄 수 있습니다.', NULL, 29),
	(898, 3, 'SELECT LEVEL, EMPNO, ENAME, MGR FROM EMP START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;', 3, '4회차', '다음과 같은 계층형 쿼리의 실행 결과로 알맞은 것은?', 'START WITH MGR IS NULL은 최상위 관리자부터 시작하여, CONNECT BY PRIOR EMPNO = MGR은 해당 사원의 하위 사원을 찾아가는 TOP-DOWN 방식의 계층 구조 쿼리입니다.', NULL, 24),
	(899, 3, NULL, 3, '4회차', '다음 중 윈도우 함수의 프레임(FRAME) 절에서 사용할 수 없는 것은?', '윈도우 함수의 프레임절에서는 ROWS, RANGE, BETWEEN을 사용할 수 있으나, HAVING은 사용할 수 없습니다.', NULL, 22),
	(900, 3, NULL, 2, '4회차', '다음 중 트리거(TRIGGER)에 대한 설명으로 틀린 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 실행할 수 없습니다. 이는 트리거의 자동 실행 특성과 관련된 제약사항입니다.', NULL, 29),
	(901, 3, '-- SALES 테이블\n-- ORDER_DATE: 주문일자 (DATE)\n-- AMOUNT: 주문금액', 3, '4회차', '다음 테이블에서 연도별, 월별 주문금액의 누적합계를 구하는 SQL문으로 올바른 것은?', '연도별로 파티션을 나누고, 월별로 정렬하여 누적합계를 계산해야 합니다. PARTITION BY와 ORDER BY를 함께 사용하는 윈도우 함수가 적절합니다.', NULL, 22),
	(902, 3, NULL, 3, '4회차', '다음 중 EXISTS와 IN의 차이점에 대한 설명으로 틀린 것은?', 'IN 연산자에서 NULL 값을 포함할 경우 결과는 UNKNOWN이 되며, 항상 FALSE를 반환하는 것은 아닙니다.', NULL, 19),
	(903, 3, NULL, 2, '4회차', '다음 중 데이터베이스 뷰(View)에 대한 설명으로 올바른 것은?', '뷰는 특정 사용자에게 테이블의 일부 데이터만 보여주거나 접근을 제한하는 용도로 사용할 수 있습니다.', NULL, 29),
	(904, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- DEPTNO: 부서번호\n-- SAL: 급여', 3, '4회차', '다음과 같은 테이블에서 자신의 급여가 자신이 속한 부서의 평균 급여보다 많은 사원을 조회하는 SQL문으로 옳은 것은?', '상관 서브쿼리를 사용하여 각 사원이 속한 부서의 평균 급여를 구하고, 이와 비교하여 조회할 수 있습니다.', NULL, 19),
	(905, 3, NULL, 2, '4회차', '다음 중 Oracle의 DECODE 함수와 동일한 기능을 하는 ANSI 표준 구문은?', 'Oracle의 DECODE 함수는 ANSI 표준의 CASE 문과 동일한 기능을 수행합니다.', NULL, 13),
	(906, 3, NULL, 3, '4회차', '다음 중 데이터베이스 트랜잭션 격리수준(Isolation Level)을 낮은 순서대로 올바르게 나열한 것은?', '트랜잭션 격리수준은 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 격리성이 강화됩니다.', NULL, 28),
	(907, 3, NULL, 2, '4회차', '다음 명령어 중 DML(Data Manipulation Language)이 아닌 것은?', 'TRUNCATE는 DDL(Data Definition Language)에 속하며, 테이블의 모든 데이터를 삭제하고 저장 공간을 해제합니다.', NULL, 29),
	(908, 3, NULL, 2, '4회차', 'FOREIGN KEY 제약조건에서 부모 테이블의 데이터가 삭제될 때 자식 테이블의 데이터도 함께 삭제되도록 설정하는 옵션은?', 'CASCADE 옵션은 부모 테이블의 데이터가 삭제될 때 관련된 자식 테이블의 데이터도 함께 삭제되도록 설정합니다.', NULL, 29),
	(909, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- DEPTNO: 부서번호\n-- SAL: 급여', 3, '4회차', '다음과 같은 테이블에서 각 부서별로 급여 순위가 1위인 사원을 조회하는 SQL문으로 올바른 것은?', 'ROW_NUMBER() 함수를 사용하여 부서별로 급여 순위를 매기고, 순위가 1인 데이터만 조회하면 됩니다.', NULL, 22),
	(910, 3, NULL, 2, '4회차', '다음 중 데이터베이스 인덱스의 장점이 아닌 것은?', '인덱스는 데이터 수정, 삭제, 입력 시 인덱스도 함께 수정해야 하므로 오히려 작업 속도가 저하될 수 있습니다.', NULL, 29),
	(911, 3, NULL, 2, '4회차', '다음 중 데이터베이스 백업 방식에 대한 설명으로 틀린 것은?', '로그 백업은 다른 백업 방식과 함께 사용할 수 있으며, 일반적으로 전체 백업이나 증분 백업과 함께 사용하여 특정 시점으로의 복구를 가능하게 합니다.', NULL, 29),
	(912, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '4회차', '아래의 테이블에서 2023년 월별 매출액과 전월 대비 증감률을 계산하는 SQL문으로 올바른 것은?', '월별 매출액 합계를 구하고 LAG 함수를 사용하여 전월 대비 증감률을 계산합니다. TO_CHAR 함수를 사용하여 연월을 정확하게 표현하고, ROUND 함수로 소수점을 처리합니다.', NULL, 22),
	(913, 3, NULL, 2, '4회차', '다음 중 데이터베이스 테이블의 파티셔닝(Partitioning)에 대한 설명으로 틀린 것은?', '파티셔닝된 테이블도 인덱스를 사용할 수 있습니다. 로컬 파티션 인덱스와 글로벌 파티션 인덱스 모두 사용 가능합니다.', NULL, 29),
	(914, 3, NULL, 2, '4회차', '다음 중 데이터베이스 Object의 권한이 아닌 것은?', 'GRANT는 시스템 권한이며, 테이블이나 뷰와 같은 데이터베이스 Object에 대한 권한이 아닙니다.', NULL, 30),
	(915, 3, '-- EMPLOYEE 테이블\n-- EMP_ID: 직원ID\n-- EMP_NAME: 직원명\n-- DEPT_ID: 부서ID\n-- HIRE_DATE: 입사일자', 3, '4회차', '아래 테이블에서 부서별로 가장 최근에 입사한 직원 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최근 입사일자를 구한 후, 이를 원본 테이블과 조인하여 해당 직원의 정보를 조회합니다. 서브쿼리와 조인을 사용한 방식이 가장 효율적입니다.', NULL, 17),
	(916, 3, NULL, 2, '4회차', '다음 중 데이터베이스 락(Lock)에 대한 설명으로 틀린 것은?', '테이블 락은 테이블 전체에 대한 락으로, 로우 락보다 더 큰 범위의 락입니다. 로우 락이 더 세분화된 락입니다.', NULL, 28),
	(917, 3, '-- SCORE 테이블\n-- STUDENT_ID: 학생ID\n-- SCORE: 점수', 3, '4회차', '다음과 같은 테이블에서 범위를 지정하여 순위를 부여하는 SQL문으로 올바른 것은?', 'WIDTH_BUCKET 함수는 지정된 범위를 균등하게 나누어 등급을 부여합니다. 0-100점을 4개의 구간으로 나누어 등급을 매기는데 적합합니다.', NULL, 22),
	(918, 3, NULL, 2, '4회차', '다음 중 데이터베이스 인덱스의 종류가 아닌 것은?', '스캔 인덱스는 존재하지 않는 인덱스 유형입니다. 일반적인 인덱스 유형은 B-tree, 비트맵, 해시 인덱스 등이 있습니다.', NULL, 29),
	(919, 3, NULL, 2, '4회차', '다음 중 Oracle의 ROWNUM과 관련된 설명으로 옳은 것은?', 'ROWNUM은 조회되는 행의 순서대로 1부터 순차적으로 번호를 부여합니다. 단, ORDER BY 절 이전에 할당되므로 정렬 후 번호를 부여하려면 서브쿼리를 사용해야 합니다.', NULL, 12),
	(920, 3, NULL, 2, '4회차', '다음 중 데이터베이스 저장 프로시저(Stored Procedure)의 특징이 아닌 것은?', '저장 프로시저는 자동으로 트랜잭션을 롤백하지 않습니다. 트랜잭션의 커밋이나 롤백은 프로시저 내에서 명시적으로 처리해야 합니다.', NULL, 29),
	(921, 3, NULL, 2, '5회차', '다음 중 엔터티(Entity)의 분류 방식으로 가장 부적절한 것은?', '기본 엔터티와 중심 엔터티는 일반적인 엔터티 분류 방식이 아닙니다. 일반적인 엔터티 분류는 유형/개념 엔터티, 기초/중심/행위 엔터티, 실체/가상 엔터티 등이 있습니다.', NULL, 2),
	(922, 3, '두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가진다.', 2, '5회차', '아래의 설명에 해당하는 것은?', '설명은 행위 엔터티의 특징을 나타냅니다. 행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 이력 정보를 저장하며, 주문, 계약, 거래 등이 대표적인 예입니다.', NULL, 2),
	(923, 3, NULL, 2, '5회차', '다음 중 관계(Relationship)의 표기법에 포함되지 않는 것은?', '관계의 표기법에는 관계명, 관계차수, 관계선택사양이 포함됩니다. 관계스키마는 관계형 데이터베이스의 구조를 나타내는 용어로, 관계 표기법에 포함되지 않습니다.', NULL, 4),
	(924, 3, NULL, 2, '5회차', 'PK 컬럼을 FK로 사용하여 관계를 맺을 때, 부모 테이블의 PK 컬럼이 자식 테이블의 PK 컬럼으로 전이되는 관계는?', '식별관계는 부모 테이블의 기본키가 자식 테이블의 기본키의 일부로 전이되는 관계를 말합니다.', NULL, 4),
	(925, 3, NULL, 2, '5회차', '다음 중 속성의 특성으로 옳지 않은 것은?', '속성은 물리적으로 존재하지 않는 개념적인 성질도 가질 수 있습니다. 예를 들어 나이, 할인율, 등급 등은 물리적으로 존재하지 않는 속성입니다.', NULL, 3),
	(926, 3, NULL, 3, '5회차', '다음 중 슈퍼타입/서브타입 데이터 모델의 변환 타입이 아닌 것은?', '슈퍼타입/서브타입 변환 타입은 OneToOne Type, Single Type, Mix Type이 있습니다. Plus Type은 존재하지 않습니다.', NULL, 2),
	(927, 3, NULL, 2, '5회차', '엔터티-관계(E-R) 모델에서 차수(Cardinality)의 표현으로 올바르지 않은 것은?', 'M:N 관계와 N:N 관계는 같은 의미이므로, 둘 다 표기할 필요가 없습니다. 일반적으로 M:N으로 표기합니다.', NULL, 4),
	(928, 3, NULL, 3, '5회차', '정규화에 대한 설명으로 틀린 것은?', 'BCNF는 결정자가 후보키가 아닌 함수 종속을 제거합니다. 이는 모든 결정자가 후보키가 되도록 하는 것이 BCNF의 목적입니다.', NULL, 6),
	(929, 3, NULL, 2, '5회차', '다음 중 식별자의 분류 기준이 아닌 것은?', '식별자는 대표성 여부, 스스로 생성 여부, 속성의 수, 대체 여부에 따라 분류됩니다. 업무적 활용도에 따른 분류는 일반적인 식별자 분류 기준이 아닙니다.', NULL, 5),
	(930, 3, NULL, 2, '5회차', '반정규화를 고려해야 하는 경우로 가장 부적절한 것은?', '데이터의 일관성과 정합성이 중요한 경우에는 오히려 정규화를 유지해야 합니다. 반정규화는 조회 성능 향상이 필요한 경우에 고려해야 합니다.', NULL, 6),
	(931, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- SALARY: 급여', 2, '5회차', '다음 테이블에서 부서별로 평균 급여를 구하되, 평균 급여가 3000 이상인 부서만 조회하는 SQL문 중 잘못된 것은?', 'WHERE절에서는 집계함수를 사용할 수 없습니다. 집계함수를 이용한 조건은 HAVING절에서 사용해야 합니다.', NULL, 15),
	(932, 3, NULL, 2, '5회차', '다음 중 CASE문에 대한 설명으로 틀린 것은?', 'CASE문에서 여러 조건이 있을 때는 먼저 만족하는 조건의 결과값이 채택되며, 이후의 조건은 무시됩니다.', NULL, 13),
	(933, 3, NULL, 3, '5회차', '다음 중 서브쿼리의 특징으로 옳은 것은?', '상관 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있으며, 이는 상관 서브쿼리의 주요 특징입니다.', NULL, 19),
	(934, 3, 'SELECT SUBSTR(\'SQL전문가\', 2, 2) FROM DUAL;', 2, '5회차', '아래의 SQL문을 실행했을 때의 결과로 옳은 것은?', 'SUBSTR(\'SQL전문가\', 2, 2)는 두 번째 위치에서 2글자를 추출합니다. 따라서 \'L전\'이 출력됩니다.', NULL, 13),
	(935, 3, NULL, 2, '5회차', '다음 중 DISTINCT 키워드에 대한 설명으로 틀린 것은?', 'DISTINCT는 SELECT절에서만 사용할 수 있으며, ORDER BY절 이후에는 사용할 수 없습니다.', NULL, 12),
	(936, 3, '-- ORDERS 테이블\n-- ORDER_DATE: 주문일자 (DATE)\n-- ORDER_AMOUNT: 주문금액', 3, '5회차', '다음과 같은 테이블이 있을 때, 2024년 1월의 일자별 주문금액 합계를 구하되, 주문이 없는 날의 주문금액은 0으로 표시하는 SQL문으로 올바른 것은?', '계층 쿼리로 1월의 모든 날짜를 생성한 후, LEFT OUTER JOIN을 통해 주문 데이터와 조인하고 NVL 함수로 NULL을 0으로 변환하는 방식이 가장 적절합니다.', NULL, 17),
	(937, 3, NULL, 2, '5회차', '다음 중 NULL 값과 관련된 설명으로 틀린 것은?', 'GROUP BY절에서 NULL 값도 하나의 그룹으로 취급됩니다. NULL 값이 제외되지 않습니다.', NULL, 9),
	(938, 3, NULL, 2, '5회차', '다음 중 조인에 대한 설명으로 옳은 것은?', 'CROSS JOIN은 조인 조건 없이 두 테이블의 모든 행을 조합한 카테시안 곱(Cartesian Product)을 반환합니다.', NULL, 17),
	(939, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- HIRE_DATE: 입사일자', 3, '5회차', '다음과 같은 테이블에서 부서별 최근 입사한 직원을 조회하는 SQL문으로 적절한 것은?', '(DEPT_NO, HIRE_DATE) IN (Subquery) 형태로 복합 조건을 사용하면 부서별 최근 입사자를 정확하게 조회할 수 있습니다.', NULL, 19),
	(940, 3, NULL, 2, '5회차', '다음 중 Oracle의 집계함수 사용시 특징으로 틀린 것은?', 'HAVING절에는 GROUP BY절에 명시되지 않은 컬럼도 집계함수와 함께 사용할 수 있습니다.', NULL, 15),
	(941, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '5회차', '다음과 같은 테이블에서 연도별, 분기별 매출액과 전년 동기 대비 증감률을 계산하는 SQL문으로 올바른 것은?', '연도와 분기로 그룹화한 후, LAG 함수를 사용하여 4분기 전(전년 동기) 데이터와 비교하여 증감률을 계산합니다.', NULL, 22),
	(942, 3, NULL, 2, '5회차', '다음 중 데이터베이스 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Isolation(독립성)은 트랜잭션 수행 시 다른 트랜잭션의 연산 작업에 끼어들 수 없음을 의미합니다. 반드시 대기해야 하는 것은 아닙니다.', NULL, 28),
	(943, 3, NULL, 2, '5회차', 'Oracle의 JOIN 구문에 대한 설명으로 올바른 것은?', 'USING절을 사용할 때는 컬럼에 테이블 별칭을 사용할 수 없습니다. 이는 USING절의 특성입니다.', NULL, 17),
	(944, 3, 'SELECT * FROM TABLE_A\nUNION\nSELECT * FROM TABLE_B;\n\nSELECT * FROM TABLE_A\nUNION ALL\nSELECT * FROM TABLE_B;', 2, '5회차', '아래의 테이블에서 UNION과 UNION ALL의 실행 결과가 같은 경우는?', '두 테이블 간에 중복되는 데이터가 없을 경우, UNION과 UNION ALL의 결과가 동일합니다.', NULL, 20),
	(945, 3, NULL, 2, '5회차', '다음 중 인덱스(Index)를 사용하기 적절한 경우가 아닌 것은?', '데이터가 자주 변경되는 컬럼에 인덱스를 생성하면 인덱스 갱신 오버헤드가 커져 성능이 저하될 수 있습니다.', NULL, 29),
	(946, 3, NULL, 2, '5회차', '다음 중 데이터베이스 락(Lock)에 대한 설명으로 틀린 것은?', '로우 락은 특정 행에만 적용되며, 테이블의 모든 행에 동시에 적용되는 것은 테이블 락입니다.', NULL, 28),
	(947, 3, 'SELECT LEVEL, EMPNO, MGR, CONNECT_BY_ISLEAF FROM EMP START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;', 3, '5회차', '다음과 같은 계층형 쿼리의 결과로 알맞은 것은?', '주어진 쿼리는 TOP-DOWN 방식으로 순방향 전개되며, CONNECT_BY_ISLEAF는 해당 노드가 리프 노드일 때 1을 반환합니다.', NULL, 24),
	(948, 3, NULL, 2, '5회차', '다음 중 데이터베이스 테이블 파티셔닝(Partitioning)의 장점이 아닌 것은?', '파티셔닝은 데이터의 물리적인 저장 공간을 감소시키지 않습니다. 오히려 파티션 관리를 위한 추가 공간이 필요할 수 있습니다.', NULL, 29),
	(949, 3, NULL, 2, '5회차', '다음 중 PL/SQL의 특징으로 옳지 않은 것은?', 'PL/SQL에서 SELECT문의 결과를 변수에 저장하기 위해서는 INTO절을 명시적으로 사용해야 합니다.', NULL, 29),
	(950, 3, NULL, 2, '5회차', '다음 중 데이터베이스 저장 프로시저(Stored Procedure)의 장점이 아닌 것은?', '저장 프로시저는 트랜잭션을 자동으로 롤백하지 않습니다. 트랜잭션의 롤백은 명시적으로 처리해야 합니다.', NULL, 29),
	(951, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- HIRE_DATE: 입사일자', 3, '5회차', '다음과 같은 테이블에서 부서별로 입사일자가 빠른 순서대로 순번을 매기는 SQL문 중 틀린 것은?', 'COUNT(*) OVER절은 누적 건수를 반환하므로 순번을 매기는 용도로 적절하지 않습니다. ROW_NUMBER(), RANK(), DENSE_RANK()가 순번 매기기에 적합한 함수입니다.', NULL, 22),
	(952, 3, NULL, 2, '5회차', '다음 중 DROP TABLE과 TRUNCATE TABLE의 차이점으로 틀린 것은?', 'DROP TABLE과 TRUNCATE TABLE 모두 DDL 명령어이므로 롤백이 불가능합니다. DROP TABLE은 테이블 구조를 포함하여 완전히 삭제하고, TRUNCATE TABLE은 데이터만 삭제합니다.', NULL, 29),
	(953, 3, 'SELECT EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM DATE \'2020-12-25\') AS RESULT FROM DUAL;', 2, '5회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SYSDATE는 현재 날짜를 반환하므로, 실행 시점에 따라 결과가 달라집니다. 2024년에 실행하면 4가 반환되고, 2025년에 실행하면 5가 반환됩니다.', NULL, 13),
	(954, 3, NULL, 2, '5회차', '다음 중 데이터베이스 트리거(Trigger)에 대한 설명으로 옳지 않은 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 실행할 수 없습니다. 이는 트리거의 자동 실행 특성으로 인한 제약사항입니다.', NULL, 29),
	(955, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '5회차', '다음과 같은 테이블이 있을 때, 2024년 상반기(1~6월) 중 매출이 발생하지 않은 월을 찾는 SQL문으로 가장 적절한 것은?', '1부터 6까지의 월 리스트를 생성한 후, 실제 매출이 발생한 월과 LEFT OUTER JOIN하여 매출이 없는 월(B.MONTH IS NULL)을 찾는 방식이 가장 적절합니다.', NULL, 19),
	(956, 3, NULL, 2, '5회차', '다음 중 Oracle의 DCL(Data Control Language)에 속하는 명령어가 아닌 것은?', 'ALTER는 DDL(Data Definition Language)에 속하는 명령어입니다. DCL에는 GRANT, REVOKE, AUDIT 등이 포함됩니다.', NULL, 30),
	(957, 3, NULL, 2, '5회차', '다음 중 데이터베이스 뷰(View)의 장점이 아닌 것은?', '뷰는 실제 데이터를 저장하지 않는 가상 테이블이므로, 원본 테이블보다 빠른 검색 성능을 제공하지 않습니다.', NULL, 29),
	(958, 3, 'WITH TEMP AS (\n    SELECT \'A\' AS COL1, 1 AS COL2 FROM DUAL UNION ALL\n    SELECT \'A\' AS COL1, 2 AS COL2 FROM DUAL UNION ALL\n    SELECT \'B\' AS COL1, 3 AS COL2 FROM DUAL UNION ALL\n    SELECT \'B\' AS COL1, 4 AS COL2 FROM DUAL\n)\nSELECT COL1, LISTAGG(COL2, \',\') WITHIN GROUP (ORDER BY COL2) AS RESULT\nFROM TEMP\nGROUP BY COL1;', 3, '5회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'LISTAGG 함수는 GROUP BY로 그룹화된 데이터를 지정된 구분자로 연결합니다. ORDER BY 절에 의해 COL2가 오름차순으로 정렬되어 연결됩니다.', NULL, 21),
	(959, 3, NULL, 2, '5회차', '다음 중 Oracle의 MERGE 문에 대한 설명으로 틀린 것은?', 'MERGE 문의 WHEN NOT MATCHED 절에서는 INSERT만 수행할 수 있습니다. DELETE는 WHEN MATCHED 절에서만 사용 가능합니다.', NULL, 27),
	(960, 3, '-- SALARY_HISTORY 테이블\n-- DEPT_NO: 부서번호\n-- PAY_MONTH: 지급월 (YYYYMM)\n-- SALARY: 급여', 3, '5회차', '다음과 같은 테이블에서 각 부서의 월별 평균 급여를 Pivot하여 조회하는 SQL문으로 올바른 것은?', 'PIVOT절을 사용하여 월별 평균 급여를 컬럼으로 변환할 때는, FOR절에 변환할 컬럼(PAY_MONTH)과 해당 값을 명시해야 합니다.', NULL, 25),
	(961, 3, NULL, 3, '5회차', '다음 중 SQL 성능과 관련된 설명으로 틀린 것은?', 'IN 절이 항상 EXISTS 절보다 성능이 우수한 것은 아닙니다. 데이터의 특성과 조건에 따라 성능이 달라질 수 있으며, EXISTS가 더 효율적인 경우도 있습니다.', NULL, 29),
	(962, 3, '-- ORDERS 테이블\n-- ORDER_NO: 주문번호\n-- MEMBER_ID: 회원ID\n-- ORDER_DATE: 주문일자\n-- AMOUNT: 주문금액', 3, '5회차', '다음과 같은 테이블에서 회원별 최근 3개의 주문 정보를 조회하는 SQL문으로 올바른 것은?', 'ROW_NUMBER() 함수를 사용하여 회원별로 주문일자 순으로 순번을 매긴 후, 상위 3건을 조회하는 방식이 가장 적절합니다.', NULL, 22),
	(963, 3, NULL, 2, '5회차', '다음 중 데이터베이스 인덱스의 성능이 저하될 수 있는 경우가 아닌 것은?', '선택도가 높다는 것은 고유한 값의 비율이 높다는 의미로, 이는 인덱스 성능을 향상시키는 요인입니다. 나머지는 모두 인덱스 성능을 저하시키는 요인입니다.', NULL, 29),
	(964, 3, 'SELECT TO_CHAR(SYSDATE, \'YYYY-MM-DD HH24:MI:SS\') AS NOW, TO_CHAR(SYSDATE + INTERVAL \'2\' HOUR, \'YYYY-MM-DD HH24:MI:SS\') AS AFTER_2HOUR FROM DUAL;', 2, '5회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'INTERVAL 키워드를 사용하여 시간을 더하는 것이 가능하며, 결과적으로 현재 시간과 2시간 후의 시간이 각각 출력됩니다.', NULL, 13),
	(965, 3, NULL, 2, '5회차', '다음 중 Oracle의 집합 연산자에 대한 설명으로 틀린 것은?', 'MINUS는 첫 번째 집합에서 두 번째 집합을 뺀 결과에서 중복된 행을 제거합니다. 중복을 허용하지 않습니다.', NULL, 20),
	(966, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '5회차', '다음과 같은 테이블이 있을 때, 월별 누적 매출액을 계산하는 SQL문으로 올바른 것은?', '연도와 월로 그룹화한 후, SUM OVER절을 사용하여 누적 합계를 계산합니다. ORDER BY절에 연도와 월을 모두 포함해야 정확한 누적 합계가 계산됩니다.', NULL, 22),
	(967, 3, NULL, 2, '5회차', '다음 중 데이터베이스 설계시 고려사항이 아닌 것은?', '데이터베이스 설계시 데이터의 중복성은 최소화해야 하는 대상이지, 고려해야 할 특성이 아닙니다.', NULL, 29),
	(968, 3, NULL, 2, '5회차', '다음 중 Oracle의 날짜 함수 사용법으로 틀린 것은?', 'NEXT_DAY 함수는 지정된 날짜 다음에 오는 특정 요일의 날짜를 반환합니다. 모든 날짜를 반환하는 것이 아닙니다.', NULL, 13),
	(969, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- SALARY: 급여', 3, '5회차', '다음과 같은 테이블에서 부서별로 급여 순위가 1위인 직원의 급여보다 많이 받는 직원을 조회하는 SQL문으로 알맞은 것은?', '윈도우 함수를 사용하여 부서별 급여 순위를 구한 후, 1위 급여와 비교하여 더 많이 받는 직원을 조회합니다.', NULL, 22),
	(970, 3, NULL, 3, '5회차', '다음 중 데이터베이스 트랜잭션 격리 수준(Isolation Level)에 대한 설명으로 틀린 것은?', 'SERIALIZABLE은 가장 엄격한 격리 수준으로, 동시성이 크게 저하됩니다. 트랜잭션들이 순차적으로 실행되어 동시 처리가 제한됩니다.', NULL, 28),
	(971, 3, NULL, 2, '6회차', '다음 중 엔터티의 정의로 가장 부적절한 것은?', '엔터티는 정적인 데이터뿐만 아니라 주문, 거래 등과 같은 동적인 데이터도 포함할 수 있습니다. 업무상 관리가 필요한 모든 데이터의 집합이 엔터티가 될 수 있습니다.', NULL, 2),
	(972, 3, NULL, 2, '6회차', '다음 중 식별자의 특징으로 가장 부적절한 것은?', '식별자는 반드시 업무상 대표성을 가질 필요는 없습니다. 예를 들어 인조식별자(Surrogate Key)는 업무적 의미와 관계없이 식별을 위해 인위적으로 만든 식별자입니다. 식별자의 필수 특성은 유일성, 최소성, 불변성, 존재성입니다.', NULL, 5),
	(973, 3, '하나의 부서는 여러 명의 사원을 가질 수 있고, 하나의 사원은 반드시 하나의 부서에 소속되어야 한다.', 1, '6회차', '다음은 엔터티 A와 엔터티 B의 관계에 대한 설명이다. 가장 적절한 관계 차수는?', '하나의 부서는 여러 명의 사원을 가질 수 있고(1:M), 하나의 사원은 반드시 하나의 부서에 소속(1:1)이므로 1:M 관계입니다.', NULL, 4),
	(974, 3, NULL, 1, '6회차', '다음 중 데이터 모델에서 NULL의 의미로 가장 부적절한 것은?', 'NULL은 아직 값이 할당되지 않음, 값이 입력되었으나 삭제됨, 해당 없음의 의미를 가질 수 있지만, 값이 0임은 NULL과 다른 의미입니다. 0은 명확한 값이므로 NULL과는 다른 개념입니다.', NULL, 9),
	(975, 3, NULL, 2, '6회차', '엔터티를 도출하는 방법으로 가장 부적절한 것은?', '엔터티는 물리적 형태로 존재하는 것뿐만 아니라 계약, 거래 등과 같이 개념적으로 존재하는 것도 포함됩니다.', NULL, 2),
	(976, 3, NULL, 2, '6회차', '다음 중 정규화 과정에서 나타날 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상에는 삭제 이상, 삽입 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않는 개념입니다.', NULL, 6),
	(977, 3, NULL, 3, '6회차', '다음 중 반정규화를 고려해야 하는 경우로 가장 부적절한 것은?', '데이터의 일관성이 매우 중요한 경우에는 오히려 정규화를 유지해야 합니다. 반정규화는 데이터의 중복을 허용하므로 일관성이 깨질 위험이 있습니다.', NULL, 6),
	(978, 3, NULL, 3, '6회차', '엔터티의 속성 중 설계 속성(Designed Attribute)에 대한 설명으로 가장 적절한 것은?', '설계 속성은 업무상 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하기 위해 만든 속성을 의미합니다. 예를 들어 상태코드, 순번 등이 이에 해당합니다.', NULL, 3),
	(979, 3, NULL, 2, '6회차', '다음 중 슈퍼타입/서브타입 모델링 변환 시 고려사항이 아닌 것은?', '슈퍼타입/서브타입 모델링 변환 시 고려사항은 데이터 검색의 효율성, 데이터의 볼륨, 트랜잭션의 유형 등입니다. 테이블명의 길이는 고려사항이 아닙니다.', NULL, 2),
	(980, 3, NULL, 2, '6회차', '다음 중 관계에서 참여도(참여 여부)가 필수적(Mandatory)인 것은?', '필수적 참여(Mandatory)는 반드시 관계에 참여해야 하는 것을 의미합니다. 보기 중 "직원은 반드시 하나의 부서에 속해야 한다"만이 필수적 참여에 해당합니다. 나머지는 선택적 참여(Optional)입니다.', NULL, 4),
	(981, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | SALARY\n-------|---------|--------\n1001   | 10      | 5000\n1002   | 20      | 6000\n1003   | 10      | 4500\n1004   | 30      | 5500\n\n"부서별 평균 급여가 전체 평균 급여보다 높은 부서의 부서ID와 부서 평균급여를 조회하시오."', 2, '6회차', '다음과 같은 테이블이 있을 때, 가장 적절한 SQL문은?', '부서별 평균 급여를 계산하고 이를 전체 평균 급여와 비교하기 위해서는 GROUP BY절과 서브쿼리를 함께 사용해야 합니다. HAVING절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 것이 올바른 방법입니다.', NULL, 15),
	(982, 3, NULL, 2, '6회차', '다음 중 NULL 관련 설명으로 가장 부적절한 것은?', 'NULL과 \'\'(빈문자)는 다릅니다. \'\'는 길이가 0인 문자열이고, NULL은 값이 없음을 의미합니다. Oracle에서는 \'\'를 NULL로 자동 변환하지만, SQL Server에서는 다른 값으로 취급합니다.', NULL, 9),
	(983, 3, 'SELECT SUBSTR(\'SQLD자격검정\', 5, 2) FROM DUAL;', 1, '6회차', '다음 SQL문의 실행 결과는?', 'SUBSTR(\'SQLD자격검정\', 5, 2)는 5번째 위치에서 2글자를 추출합니다. 따라서 \'자격\'이 출력됩니다.', NULL, 13),
	(984, 3, NULL, 2, '6회차', '다음 중 NATURAL JOIN에 대한 설명으로 가장 적절하지 않은 것은?', 'NATURAL JOIN에서는 조인되는 칼럼을 식별자 없이 사용합니다. 즉, 테이블명이나 alias를 붙이지 않고 칼럼명만으로 사용합니다.', NULL, 17),
	(985, 3, '[SALES]\nSALE_DATE  | AMOUNT\n-----------|--------\n2023-01-01 | 1000\n2023-01-15 | 2000\n2023-02-01 | 1500\n2024-01-01 | 3000', 2, '6회차', '다음과 같은 테이블에서 연도별, 월별 매출액의 합계를 구하는 SQL문으로 가장 적절한 것은?', 'GROUP BY절에서 사용한 표현식은 SELECT절에서도 동일하게 사용해야 하며, 결과의 정렬을 위해 ORDER BY절이 필요합니다. EXTRACT 함수를 사용하여 연도와 월을 추출하는 방식이 가장 적절합니다.', NULL, 13),
	(986, 3, NULL, 1, '6회차', '다음 중 SELECT 문장 실행 순서로 올바른 것은?', 'SELECT 문장의 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다.', NULL, 12),
	(987, 3, '[ORGANIZATION]\nEMP_ID | MGR_ID | NAME\n-------|--------|\n1      | NULL   | 김사장\n2      | 1      | 이부장\n3      | 2      | 박과장\n4      | 2      | 최과장', 3, '6회차', '다음과 같은 테이블에서 계층형 쿼리를 이용해 조직도를 역방향으로 출력하고자 할 때, 적절한 SQL문은?', '역방향 계층 조회를 위해서는 START WITH로 시작점을 지정하고, CONNECT BY절에서 MGR_ID = PRIOR EMP_ID 형태로 작성해야 합니다.', NULL, 24),
	(988, 3, NULL, 2, '6회차', '다음 중 ROLLUP과 CUBE에 대한 설명으로 가장 부적절한 것은?', 'CUBE는 모든 가능한 조합의 소계를 생성하므로 ROLLUP보다 더 많은 연산이 필요하며, 실행 속도가 더 느립니다.', NULL, 21),
	(989, 3, NULL, 1, '6회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'DCL(Data Control Language)에는 GRANT(권한 부여)와 REVOKE(권한 회수)가 포함됩니다.', NULL, 30),
	(990, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME | SALARY\n-------|---------|------|--------\n1001   | 10      | Kim  | 5000\n1002   | 20      | Lee  | 6000\n1003   | 10      | Park | 5500\n1004   | 20      | Choi | 5800', 2, '6회차', '다음과 같은 테이블에서 부서별 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 최고 급여를 받는 사원을 찾기 위해서는, (DEPT_ID, SALARY) 쌍이 부서별 최대 급여와 일치하는 데이터를 찾아야 합니다. IN 절을 사용한 서브쿼리가 가장 적절한 방법입니다.', NULL, 19),
	(991, 3, '[EMPLOYEE]\n- NAME VARCHAR2(10)을 VARCHAR2(20)으로 변경\n- NOT NULL 제약조건 추가', 2, '6회차', '다음과 같은 테이블의 칼럼을 변경하고자 할 때, 적절한 SQL문은?', 'Oracle에서 칼럼을 변경할 때는 MODIFY 절을 사용하며, 여러 속성을 동시에 변경할 수 있습니다.', NULL, 29),
	(992, 3, NULL, 2, '6회차', '다음 중 윈도우 함수(Window Function)의 설명으로 가장 부적절한 것은?', '윈도우 함수는 GROUP BY 절과 함께 사용할 수 없습니다. 윈도우 함수는 결과 집합이 만들어진 후에 적용됩니다.', NULL, 22),
	(993, 3, '[SALES]\nMONTH | AMOUNT\n------|--------\n01    | 100\n02    | 150\n03    | 200\n04    | 250\n\nSELECT MONTH, AMOUNT, LAG(AMOUNT, 1, 0) OVER (ORDER BY MONTH) AS PREV_AMOUNT FROM SALES WHERE MONTH = \'02\';', 2, '6회차', '다음과 같은 테이블에서 LAG 함수를 사용한 SQL의 결과는?', 'LAG 함수는 이전 행의 값을 가져옵니다. 현재 행(MONTH=02)의 이전 행(MONTH=01)의 AMOUNT 값인 100이 반환됩니다.', NULL, 22),
	(994, 3, '[SCORE]\nNAME  | SCORE\n------|-------\nKim   | 90\nLee   | 90\nPark  | 85\nChoi  | 90\nJung  | 80', 2, '6회차', '다음과 같은 테이블에서 RANK 함수와 DENSE_RANK 함수의 결과가 다른 경우는?', 'RANK는 동일한 값에 대해 동일한 순위를 부여하고 다음 순위는 건너뛰지만, DENSE_RANK는 건너뛰지 않고 다음 순위를 부여합니다.', NULL, 22),
	(995, 3, NULL, 2, '6회차', 'GROUP BY 절에 대한 설명으로 가장 부적절한 것은?', 'Oracle 11g R2부터는 GROUP BY 절에서도 Alias를 사용할 수 있습니다.', NULL, 15),
	(996, 3, NULL, 2, '6회차', '다음 중 집합 연산자(Set Operator)의 설명으로 가장 부적절한 것은?', 'MINUS는 순서에 따라 결과가 달라집니다. A MINUS B와 B MINUS A는 다른 결과를 반환할 수 있습니다.', NULL, 20),
	(997, 3, 'SELECT 1/2*3 FROM DUAL;', 1, '6회차', '다음 SQL문의 실행 결과는?', 'Oracle에서 숫자 연산은 왼쪽에서 오른쪽으로 수행됩니다. 따라서 1/2*3은 0.5*3 = 1.5가 됩니다.', NULL, 13),
	(998, 3, NULL, 2, '6회차', '다음 중 서브쿼리(Subquery)에 대한 설명으로 가장 부적절한 것은?', '서브쿼리에서도 ORDER BY절을 사용할 수 있습니다. 특히 TOP-N 쿼리나 ROW_NUMBER() 함수와 함께 사용될 때 유용합니다.', NULL, 19),
	(999, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME\n--------|---------|-------\n1001    | 10      | Kim\n1002    | 20      | Lee\n1003    | 10      | Park\n1004    | 30      | Choi', 2, '6회차', '다음과 같은 테이블에서 사원수가 2명 이상인 부서의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '그룹함수를 조건으로 사용할 때는 HAVING절을 사용해야 하며, GROUP BY절이 필요합니다.', NULL, 15),
	(1000, 3, NULL, 1, '6회차', '다음 중 트랜잭션(Transaction)의 특성이 아닌 것은?', '트랜잭션의 특성은 ACID(원자성, 일관성, 독립성, 지속성(Durability))입니다. 확장성은 트랜잭션의 특성이 아닙니다.', NULL, 28),
	(1001, 3, '[ORDERS]\nORDER_ID | CUSTOMER_ID | ORDER_DATE | AMOUNT\n---------|-------------|------------|--------\n1        | A          | 2024-01-01 | 1000\n2        | B          | 2024-01-02 | 2000\n3        | A          | 2024-01-03 | 1500\n4        | C          | 2024-01-04 | 3000', 2, '6회차', '다음과 같은 테이블에서 고객별 최근 주문 정보를 조회하는 SQL문으로 가장 적절한 것은?', '상관 서브쿼리를 사용하여 각 고객별로 최근 주문일자를 찾고, 해당 주문 정보를 조회하는 것이 가장 적절한 방법입니다.', NULL, 19),
	(1002, 3, 'SELECT LENGTH(\'한글\'), LENGTHB(\'한글\') FROM DUAL;', 2, '6회차', '다음 SQL문의 실행 결과는?', 'LENGTH는 문자의 개수를, LENGTHB는 바이트 수를 반환합니다. 한글은 일반적으로 한 글자당 3바이트를 차지하므로, \'한글\'은 2글자, 6바이트가 됩니다.', NULL, 13),
	(1003, 3, 'SELECT TO_CHAR(SYSDATE, \'YYYY/MM/DD HH24:MI:SS\') FROM DUAL;', 1, '6회차', 'Oracle에서 다음 SQL문의 결과는?', 'TO_CHAR 함수에서 \'YYYY/MM/DD HH24:MI:SS\' 형식을 지정했으므로, \'2024/12/16 14:30:00\' 형태로 출력됩니다.', NULL, 13),
	(1004, 3, NULL, 2, '6회차', '다음 중 MERGE 문에 대한 설명으로 가장 부적절한 것은?', 'MERGE 문에서는 MATCHED와 NOT MATCHED 조건을 모두 사용할 필요는 없습니다. 상황에 따라 하나만 사용할 수도 있습니다.', NULL, 27),
	(1005, 3, 'SELECT DECODE(NULL, NULL, \'A\', \'B\') FROM DUAL;', 2, '6회차', '다음과 같은 데이터가 있을 때, 결과로 적절하지 않은 것은?', 'DECODE(NULL, NULL, \'A\', \'B\')에서 첫 번째와 두 번째 파라미터가 모두 NULL이므로 \'A\'가 반환됩니다.', NULL, 13),
	(1006, 3, NULL, 2, '6회차', '다음 중 Oracle의 날짜 연산에 대한 설명으로 가장 부적절한 것은?', 'NEXT_DAY 함수는 숫자로도 요일을 지정할 수 있습니다(1=일요일, 2=월요일, ..., 7=토요일).', NULL, 13),
	(1007, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME | SALARY\n-------|---------|------|--------\n1001   | 10      | Kim  | 5000\n1002   | 20      | Lee  | 6000\n1003   | 10      | Park | 5500\n1004   | 20      | Choi | 5800', 3, '6회차', '다음과 같은 테이블에서 부서별로 가장 높은 급여를 받는 사원의 정보를 조회할 때, 인라인 뷰를 사용한 가장 적절한 SQL문은?', '인라인 뷰를 사용하여 부서별 최고 급여를 구하고, 이를 원본 테이블과 조인하여 해당 사원의 정보를 조회하는 방법이 가장 적절합니다.', NULL, 19),
	(1008, 3, NULL, 2, '6회차', '다음 중 EXISTS와 IN의 차이점으로 가장 부적절한 것은?', 'EXISTS와 IN의 성능은 데이터의 특성과 양에 따라 달라질 수 있으며, 항상 EXISTS가 더 좋은 것은 아닙니다.', NULL, 19),
	(1009, 3, '[SALES]\nYEAR | QUARTER | AMOUNT\n-----|---------|--------\n2023 | Q1      | 100\n2023 | Q2      | 200\n2023 | Q3      | 300\n2023 | Q4      | 400\n\nSELECT * FROM (SELECT YEAR, QUARTER, AMOUNT FROM SALES) PIVOT (SUM(AMOUNT) FOR QUARTER IN (\'Q1\',\'Q2\',\'Q3\',\'Q4\'))', 3, '6회차', '다음과 같은 테이블에서 PIVOT을 사용한 SQL문의 실행 결과로 가장 적절한 것은?', 'PIVOT 절은 행을 열로 변환합니다. 결과적으로 각 분기별 금액이 별도의 열로 표시됩니다.', NULL, 25),
	(1010, 3, NULL, 2, '6회차', '다음 중 인덱스(Index)에 대한 설명으로 가장 부적절한 것은?', '인덱스가 많을수록 조회 성능이 반드시 향상되는 것은 아닙니다. 오히려 너무 많은 인덱스는 INSERT, UPDATE, DELETE 성능을 저하시키고 저장 공간을 많이 사용하게 됩니다.', NULL, 29),
	(1011, 3, '[DEPARTMENT]\nDEPT_ID | PARENT_DEPT_ID | DEPT_NAME\n--------|----------------|------------\n1       | NULL           | 영업부\n2       | 1              | 국내영업팀\n3       | 1              | 해외영업팀\n4       | 2              | 서울영업소\n5       | 2              | 부산영업소\n\nSELECT DEPT_ID, LEVEL, DEPT_NAME\nFROM DEPARTMENT\nSTART WITH PARENT_DEPT_ID IS NULL\nCONNECT BY PRIOR DEPT_ID = PARENT_DEPT_ID;', 3, '6회차', '다음과 같은 테이블에서 계층형 쿼리의 실행 결과로 가장 적절한 것은?', 'START WITH PARENT_DEPT_ID IS NULL로 최상위 노드부터 시작하여, CONNECT BY PRIOR DEPT_ID = PARENT_DEPT_ID로 하위 방향으로 계층 구조를 전개합니다.', NULL, 24),
	(1012, 3, NULL, 2, '6회차', '다음 중 ROWNUM의 특성으로 가장 부적절한 것은?', 'ROWNUM은 ORDER BY 절 이전에 순번이 부여됩니다. 따라서 ORDER BY로 정렬된 결과에 대해 순번을 부여하려면 인라인 뷰를 사용해야 합니다.', NULL, 23),
	(1013, 3, 'SELECT ROUND(123.456, 2), \nROUND(123.456, 0), \nROUND(123.456, -1)\nFROM DUAL;', 2, '6회차', '다음 SQL문의 실행 결과는?', 'ROUND(숫자, n)은 소수점 n자리까지 반올림합니다. n이 0이면 정수로, 음수이면 정수부분에서 반올림합니다.', NULL, 13),
	(1014, 3, '[TABLE_A]        [TABLE_B]\nCOL1             COL1\n----             ----\n1                2\n2                3\n3                4', 2, '6회차', '다음과 같은 테이블에서 UNION과 UNION ALL의 결과가 같은 경우는?', '두 집합이 서로 중복되는 데이터가 없을 때는 UNION과 UNION ALL의 결과가 동일합니다.', NULL, 20),
	(1015, 3, NULL, 2, '6회차', '다음 중 트랜잭션 격리성 수준(Transaction Isolation Level)이 아닌 것은?', '트랜잭션 격리성 수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE이 있습니다.', NULL, 28),
	(1016, 3, 'CREATE TABLE TEST (\n    ID NUMBER PRIMARY KEY,\n    REG_DATE DATE DEFAULT SYSDATE,\n    STATUS VARCHAR2(10) CHECK (STATUS IN (\'A\',\'B\',\'C\'))\n);\n\nINSERT INTO TEST (ID, STATUS) VALUES (1, \'D\');', 2, '6회차', '다음 SQL문에서 발생하는 오류는?', 'STATUS 컬럼의 CHECK 제약조건은 \'A\', \'B\', \'C\'만 허용하는데, \'D\'를 입력하려고 했으므로 CHECK 제약조건을 위배합니다.', NULL, 29),
	(1017, 3, NULL, 2, '6회차', '다음 중 데이터베이스 트랜잭션의 특성(ACID)과 그 설명이 잘못 연결된 것은?', 'Durability(지속성)는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나도 영구적으로 반영되어야 한다는 특성입니다.', NULL, 28),
	(1018, 3, NULL, 2, '6회차', '다음 중 DELETE, TRUNCATE, DROP의 차이점으로 가장 부적절한 것은?', 'TRUNCATE는 롤백이 불가능합니다. 자동으로 커밋되며 DML이 아닌 DDL문이기 때문입니다.', NULL, 27),
	(1019, 3, NULL, 2, '6회차', 'GROUP BY절과 관련된 다음 설명 중 가장 부적절한 것은?', 'GROUP BY절에는 SELECT절에 있는 집계함수를 제외한 모든 컬럼이 포함되어야 하며, SELECT절에 있는 모든 컬럼이 GROUP BY절에 포함될 필요는 없습니다.', NULL, 15),
	(1020, 3, NULL, 2, '6회차', '다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?', 'WITH CHECK OPTION은 뷰의 조건절을 위배하는 DML만 금지하며, 모든 DML을 금지하는 것은 아닙니다. 모든 DML을 금지하려면 WITH READ ONLY를 사용해야 합니다.', NULL, 29),
	(1021, 3, NULL, 1, '7회차', '엔터티(Entity)의 특징으로 가장 부적절한 것은?', '엔터티는 반드시 물리적 형태로 존재할 필요는 없습니다. \'거래\', \'계약\' 등과 같이 개념적으로만 존재하는 것도 엔터티가 될 수 있습니다. 중요한 것은 업무적으로 관리가 필요한 정보의 집합이라는 점입니다.', NULL, 2),
	(1022, 3, NULL, 2, '7회차', '다음 중 정규화에 대한 설명으로 가장 부적절한 것은?', '정규화는 데이터의 일관성과 무결성을 보장하기 위한 과정이며, 조회 성능이 항상 향상되는 것은 아닙니다. 오히려 정규화로 인해 테이블이 분리되면 조회 시 조인이 필요해져 성능이 저하될 수 있습니다.', NULL, 6),
	(1023, 3, NULL, 2, '7회차', '엔터티를 물리적 모델로 구현할 때 주의사항으로 가장 부적절한 것은?', '테이블명은 반드시 영문 대문자로만 작성할 필요는 없습니다. 각 조직의 네이밍 규칙에 따라 소문자나 혼용도 가능합니다. 중요한 것은 일관성 있는 네이밍 규칙을 적용하는 것입니다.', NULL, 2),
	(1024, 3, NULL, 3, '7회차', '다음 중 슈퍼타입과 서브타입에 대한 설명으로 가장 부적절한 것은?', '서브타입 엔터티는 슈퍼타입에 종속적이며 독립적으로 존재할 수 없습니다. 서브타입은 항상 슈퍼타입의 인스턴스와 연관되어야 합니다.', NULL, 2),
	(1025, 3, NULL, 2, '7회차', '다음 중 식별자의 특징으로 가장 부적절한 것은?', '식별자의 특성에는 유일성, 최소성, 불변성, 존재성이 있습니다. 대체성은 식별자의 특성이 아니며, 오히려 식별자는 안정적이고 변하지 않아야 합니다.', NULL, 5),
	(1026, 3, '두 개 이상의 속성이 모여서 기본키를 이루는 경우, 일부 속성이 타 엔터티와의 관계를 위한 외부키이면서 동시에 자신의 엔터티를 식별하는 기본키의 구성요소인 경우', 2, '7회차', '아래의 설명에 해당하는 것은?', '설명은 복합식별자의 특징을 설명하고 있습니다. 복합식별자는 둘 이상의 속성으로 구성된 식별자를 의미하며, 이 중 일부가 외부키로 사용될 수 있습니다.', NULL, 5),
	(1027, 3, NULL, 1, '7회차', '다음 중 관계의 표현 요소로 가장 부적절한 것은?', '관계의 표현 요소는 관계명, 관계차수, 관계선택사양(필수/선택)이 있습니다. 관계스키마는 관계의 표현 요소가 아닌 데이터베이스 스키마의 한 종류입니다.', NULL, 4),
	(1028, 3, NULL, 2, '7회차', '다음 중 반정규화를 고려해야 하는 경우가 아닌 것은?', '데이터의 일관성이 매우 중요한 경우에는 오히려 정규화를 유지해야 합니다. 반정규화는 데이터의 중복을 허용하므로 일관성이 깨질 위험이 있습니다.', NULL, 6),
	(1029, 3, NULL, 2, '7회차', '다음 중 속성의 특징으로 가장 부적절한 것은?', '속성은 물리적으로 관찰 가능할 필요는 없습니다. \'평점\', \'등급\' 등과 같이 논리적이거나 개념적인 것도 속성이 될 수 있습니다.', NULL, 3),
	(1030, 3, NULL, 2, '7회차', 'PK 컬럼을 FK로 사용하여 관계를 맺을 때, 부모 테이블의 PK 컬럼이 자식 테이블의 일반 컬럼으로 전이되는 관계는?', '비식별관계는 부모 테이블의 기본키가 자식 테이블의 일반 속성(외래키)으로 전이되는 관계입니다. 이는 점선으로 표현되며, 자식 테이블의 PK에 포함되지 않습니다.', NULL, 4),
	(1031, 3, '[EMPLOYEE]\nEMP_NO | DEPT_NO | SALARY\n--------|---------|--------\n10001   | 10      | 5000\n10002   | 20      | 6000\n10003   | 10      | 4500\n10004   | 30      | 5500', 2, '7회차', '다음 테이블에서 부서별 평균 급여가 전체 평균 급여보다 큰 부서의 부서번호와 부서별 평균 급여를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 GROUP BY절과 서브쿼리를 함께 사용해야 합니다. HAVING절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 것이 올바른 방법입니다.', NULL, 15),
	(1032, 3, 'SELECT CASE WHEN NULL = NULL THEN \'T\'\n            WHEN NULL != NULL THEN \'F\'\n            ELSE \'N\'\n       END AS RESULT\nFROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'NULL과 NULL을 비교하는 연산은 항상 UNKNOWN을 반환합니다. 따라서 CASE문의 첫 번째, 두 번째 조건은 모두 FALSE가 되어 ELSE절의 \'N\'이 반환됩니다.', NULL, 9),
	(1033, 3, NULL, 2, '7회차', '다음 중 GROUP BY절의 특성으로 가장 부적절한 것은?', 'Oracle 11g R2 이후 버전부터는 GROUP BY절에서도 별칭(Alias)을 사용할 수 있습니다. 따라서 "GROUP BY절에서는 컬럼의 별칭을 사용할 수 없다"는 설명은 부적절합니다.', NULL, 15),
	(1034, 3, NULL, 3, '7회차', '다음 중 윈도우 함수(Window Function)에 대한 설명으로 가장 부적절한 것은?', 'PERCENT_RANK 함수는 최소값이 0, 최대값이 1입니다. 백분율로 표현하면 0%에서 100%가 되지만, 함수 자체의 반환값 범위는 0~1입니다.', NULL, 22),
	(1035, 3, '[ORGANIZATION]\nEMP_ID | MGR_ID | EMP_NAME\n--------|---------|----------\n1       | NULL    | 김사장\n2       | 1       | 이부장\n3       | 2       | 박과장\n4       | 2       | 최과장', 3, '7회차', '아래의 테이블에서 계층형 쿼리를 사용하여 조직도를 조회할 때, 최상위 노드부터 시작하는 순방향 전개를 위한 적절한 SQL문은?', '순방향 전개를 위해서는 START WITH로 최상위 노드(MGR_ID IS NULL)를 지정하고, CONNECT BY PRIOR EMP_ID = MGR_ID 형태로 작성해야 합니다.', NULL, 24),
	(1036, 3, NULL, 2, '7회차', '다음 중 테이블의 모든 데이터를 삭제하는 명령어에 대한 설명으로 가장 부적절한 것은?', 'TRUNCATE는 데이터와 할당된 공간을 모두 삭제하며, DDL문이므로 ROLLBACK이 불가능합니다. 자동으로 COMMIT이 수행됩니다.', NULL, 27),
	(1037, 3, NULL, 2, '7회차', '다음 중 VIEW에 대한 설명으로 가장 부적절한 것은?', '뷰는 가상의 테이블이므로 자체적인 인덱스를 가질 수 없습니다. 인덱스는 실제 테이블에만 생성할 수 있습니다.', NULL, 29),
	(1038, 3, 'SELECT SUBSTR(\'SQLD자격검정\', -3, 2) FROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'SUBSTR(\'SQLD자격검정\', -3, 2)는 뒤에서 3번째 위치에서 2글자를 추출합니다. 따라서 \'격검\'이 출력됩니다.', NULL, 13),
	(1039, 3, 'CREATE TABLE TEST (\n    ID NUMBER,\n    NAME VARCHAR2(10) NOT NULL,\n    AGE NUMBER DEFAULT 0\n);\n\nINSERT INTO TEST (ID) VALUES (1);', 2, '7회차', '다음 SQL문을 실행했을 때 발생하는 오류는?', 'NAME 컬럼은 NOT NULL 제약조건이 있으므로 반드시 값을 입력해야 합니다. AGE는 DEFAULT 값이 지정되어 있어 생략 가능하지만, NAME은 생략할 수 없습니다.', NULL, 29),
	(1040, 3, NULL, 2, '7회차', '다음 중 MERGE 문에 대한 설명으로 가장 부적절한 것은?', 'MERGE문에서 WHEN MATCHED THEN 절은 필수가 아닙니다. 상황에 따라 WHEN NOT MATCHED THEN 절만 사용할 수도 있습니다.', NULL, 27),
	(1041, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME | SALARY\n-------|---------|------|--------\n1001   | 10      | Kim  | 5000\n1002   | 20      | Lee  | 6000\n1003   | 10      | Park | 5500\n1004   | 20      | Choi | 5800', 2, '7회차', '다음과 같은 테이블이 있을 때, 각 부서별 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 최고 급여를 받는 사원을 찾기 위해서는, (DEPT_ID, SALARY) 쌍이 부서별 최대 급여와 일치하는 데이터를 찾아야 합니다. IN 절을 사용한 서브쿼리가 가장 적절한 방법입니다.', NULL, 19),
	(1042, 3, 'SELECT NVL(MAX(SAL), 0), COUNT(*), COUNT(SAL)\nFROM EMP\nWHERE DEPTNO = 50;', 2, '7회차', '다음 SQL문의 실행 결과는?', '조건을 만족하는 행이 없을 경우, MAX는 NULL이 반환되지만 NVL(MAX(SAL), 0)에 의해 0으로 변환됩니다. COUNT(*)는 항상 0 이상의 값을 반환하며, COUNT(SAL)도 조건에 맞는 행이 없으면 0을 반환합니다.', NULL, 21),
	(1043, 3, NULL, 2, '7회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 가장 부적절한 것은?', 'FOREIGN KEY는 NULL 값을 허용합니다. 이는 선택적 참조의 경우에 필요한 기능입니다.', NULL, 29),
	(1044, 3, 'SELECT ENAME\nFROM EMP\nORDER BY SAL DESC, HIREDATE;', 1, '7회차', '다음의 SQL문을 실행했을 때, 어떤 순서로 결과가 출력되는가?', 'ORDER BY절에서 SAL DESC는 급여를 내림차순으로, HIREDATE는 별도의 정렬 방향이 없으므로 기본값인 오름차순으로 정렬됩니다.', NULL, 16),
	(1045, 3, NULL, 2, '7회차', '다음 중 EXISTS 연산자에 대한 설명으로 가장 부적절한 것은?', 'EXISTS의 서브쿼리에서는 SELECT 절의 컬럼이 결과에 영향을 미치지 않습니다. 따라서 와일드카드(*)보다는 상수값(예: SELECT 1)을 사용하는 것이 성능상 유리합니다.', NULL, 19),
	(1046, 3, NULL, 2, '7회차', '다음 중 UNION과 UNION ALL의 차이점으로 가장 적절한 것은?', 'UNION은 중복된 행을 제거하고 결과를 반환하지만, UNION ALL은 중복된 행을 포함하여 모든 결과를 반환합니다. 정렬 여부는 UNION의 특성이 아닙니다.', NULL, 20),
	(1047, 3, '[EMPLOYEE]\nEMP_ID | NAME  | SALARY\n-------|-------|--------\n1      | Kim   | 5000\n2      | Lee   | 6000\n3      | Park  | 5500\n4      | Choi  | 7000', 2, '7회차', '다음과 같은 테이블에서 ROWNUM을 이용해 급여 상위 3명을 조회하는 SQL문으로 가장 적절한 것은?', 'ROWNUM은 WHERE절 이전에 부여되므로, ORDER BY로 정렬된 결과에서 상위 N개를 추출하려면 인라인 뷰를 사용해야 합니다.', NULL, 23),
	(1048, 3, NULL, 2, '7회차', '다음 중 WITH 절(임시테이블)의 특징으로 가장 부적절한 것은?', 'WITH절로 생성된 임시 테이블은 해당 쿼리 내에서만 유효하며, 영구적으로 저장되지 않습니다. 다른 세션에서는 사용할 수 없습니다.', NULL, 19),
	(1049, 3, 'DECODE(JOB, \'MANAGER\', 1000,\n           \'SALESMAN\', 800,\n           \'CLERK\', 600,\n           0)', 2, '7회차', '다음 중 DECODE 함수를 CASE 문으로 변환한 것으로 가장 적절한 것은?', 'DECODE 함수는 단순 CASE 표현식으로 변환됩니다. CASE 표현식에서 비교 연산자를 생략하면 자동으로 등호(=) 비교가 적용됩니다.', NULL, 13),
	(1050, 3, NULL, 2, '7회차', '다음 중 인덱스(Index)를 사용하기 적절한 경우가 아닌 것은?', '일반적으로 테이블의 전체 행 중 15% 이상을 검색하는 경우에는 인덱스를 사용하는 것이 비효율적입니다. 이 경우 테이블 전체 스캔(Full Table Scan)이 더 효율적일 수 있습니다.', NULL, 29),
	(1051, 3, '[EMPLOYEE]\nEMP_ID | MGR_ID | NAME\n--------|---------|-------\n1      | NULL    | Kim\n2      | 1       | Lee\n3      | 1       | Park\n4      | 2       | Choi\n5      | 2       | Jung', 3, '7회차', '다음과 같은 테이블에서 계층형 쿼리를 사용할 때 리프(Leaf) 노드를 찾는 SQL문으로 가장 적절한 것은?', 'CONNECT_BY_ISLEAF = 1은 리프 노드(자식이 없는 노드)를 찾는 조건입니다. 리프 노드는 계층구조에서 가장 하위에 있는 노드를 의미합니다.', NULL, 24),
	(1052, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | SALARY\n--------|---------|--------\n1      | 10      | 5000\n2      | 20      | 6000\n3      | 10      | 5500\n4      | 30      | 4500', 2, '7회차', '다음과 같은 테이블에서 각 부서의 평균 급여와 전체 평균 급여의 차이를 계산하는 SQL문으로 가장 적절한 것은?', '부서별 평균과 전체 평균의 차이를 구하기 위해서는 GROUP BY로 부서별 평균을 구하고, 서브쿼리로 전체 평균을 구해야 합니다.', NULL, 19),
	(1053, 3, 'SELECT INSTR(\'ORACLE SQL\', \'L\', 1, 2)\nFROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'INSTR 함수는 문자열에서 특정 문자의 위치를 찾습니다. 여기서는 \'L\'의 두 번째 출현 위치인 9를 반환합니다.', NULL, 13),
	(1054, 3, NULL, 2, '7회차', '다음 중 트랜잭션 격리 수준(Transaction Isolation Level)을 순서대로 나열한 것으로 가장 적절한 것은?', '트랜잭션 격리 수준은 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 격리성이 강화됩니다.', NULL, 28),
	(1055, 3, '[TABLE_A]\nCOL1\n----\n1\n2\n3\n\n[TABLE_B]\nCOL1\n----\n3\n4\n5', 2, '7회차', '다음과 같은 테이블에서 UNION과 UNION ALL의 실행 결과가 같은 경우는?', '두 집합에서 중복되는 데이터가 없는 경우 UNION과 UNION ALL의 결과가 동일합니다.', NULL, 20),
	(1056, 3, 'SELECT ROUND(123.456, -1), TRUNC(123.456, 1)\nFROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'ROUND(-1)은 10의 자리에서 반올림하여 TRUNC(1)는 소수점 첫째자리까지 잘라서 123.4가 됩니다.', NULL, 13),
	(1057, 3, NULL, 2, '7회차', '다음 중 GRANT 명령어에 대한 설명으로 가장 부적절한 것은?', '부여된 권한은 REVOKE 명령어를 통해 회수할 수 있습니다.', NULL, 30),
	(1058, 3, NULL, 2, '7회차', '다음 중 NULL 관련 함수에 대한 설명으로 가장 부적절한 것은?', 'NVL2 함수는 첫 번째 인자가 NULL이 아니면 두 번째 인자를, NULL이면 세 번째 인자를 반환합니다.', NULL, 13),
	(1059, 3, '[SALES]\nDEPT_ID | AMOUNT\n--------|--------\n10      | 1000\n10      | 2000\n20      | 1500\n20      | 2500\n30      | 3000\n\nSELECT DEPT_ID, SUM(AMOUNT)\nFROM SALES\nGROUP BY DEPT_ID\nHAVING SUM(AMOUNT) > 3000;', 2, '7회차', '다음과 같은 테이블에서 HAVING 절을 사용한 SQL문의 결과로 가장 적절한 것은?', 'DEPT_ID별 AMOUNT 합계가 3000을 초과하는 부서는 20번 부서(4000)뿐입니다.', NULL, 15),
	(1060, 3, NULL, 2, '7회차', '다음 중 데이터베이스 트랜잭션의 ACID 특성과 그 설명이 잘못 연결된 것은?', 'Durability(지속성)는 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다는 특성입니다.', NULL, 28),
	(1061, 3, '[ORDERS]\nORDER_DATE\n----------\n2024-01-01', 2, '7회차', '다음과 같은 테이블에서 날짜 관련 함수를 사용한 결과로 가장 적절하지 않은 것은?', 'NEXT_DAY(\'2024-01-01\', \'월\')의 결과는 2024-01-08입니다. 다음 월요일을 반환하기 때문입니다.', NULL, 13),
	(1062, 3, NULL, 2, '7회차', '다음 중 윈도우 함수(분석 함수)에 대한 설명으로 가장 부적절한 것은?', '윈도우 함수는 WHERE 절에서 사용할 수 없고, SELECT 절이나 ORDER BY 절에서 사용할 수 있습니다.', NULL, 22),
	(1063, 3, NULL, 1, '7회차', '다음 중 서브쿼리의 특징으로 가장 부적절한 것은?', '서브쿼리에서 ORDER BY 절은 필수가 아니며, 대부분의 경우 사용할 수 없습니다.', NULL, 19),
	(1064, 3, NULL, 2, '7회차', '다음 중 인덱스(Index)에 대한 설명으로 가장 적절하지 않은 것은?', 'INSERT, UPDATE, DELETE가 빈번한 테이블의 컬럼에는 인덱스 생성을 신중히 고려해야 합니다. 잦은 데이터 변경은 인덱스 유지 비용을 증가시킵니다.', NULL, 29),
	(1065, 3, 'SELECT LPAD(\'SQL\', 5, \'*\'), RPAD(\'SQL\', 5, \'*\')\nFROM DUAL;', 1, '7회차', '다음 SQL문의 실행 결과는?', 'LPAD는 왼쪽을, RPAD는 오른쪽을 지정된 문자로 채웁니다.', NULL, 13),
	(1066, 3, NULL, 1, '7회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어끼리 올바르게 묶인 것은?', 'DCL은 데이터 제어어로 GRANT(권한 부여)와 REVOKE(권한 회수)가 포함됩니다.', NULL, 30),
	(1067, 3, '[SALES]\nYEAR | QUARTER | AMOUNT\n-----|---------|--------\n2023 | Q1      | 1000\n2023 | Q2      | 2000\n2024 | Q1      | 1500\n2024 | Q2      | 2500\n\nSELECT YEAR, QUARTER, SUM(AMOUNT)\nFROM SALES\nGROUP BY ROLLUP(YEAR, QUARTER);', 2, '7회차', '다음과 같은 테이블에서 ROLLUP을 사용한 SQL문의 결과행 수는?', 'ROLLUP(YEAR, QUARTER)은 (YEAR, QUARTER), (YEAR), () 순으로 그룹화하여 총 7개의 행을 생성합니다.', NULL, 21),
	(1068, 3, NULL, 2, '7회차', '다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 가장 부적절한 것은?', 'PRIMARY KEY 제약조건은 테이블당 하나만 설정할 수 있습니다.', NULL, 29),
	(1069, 3, NULL, 3, '7회차', '다음 중 트리거(Trigger)에 대한 설명으로 가장 부적절한 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 사용할 수 없습니다. 이는 트리거의 자동성을 해치기 때문입니다.', NULL, 29),
	(1070, 3, 'SELECT REPLACE(\'ORACLE SQL\', \'L\', \'*L*\')\nFROM DUAL;', 1, '7회차', '다음 SQL문의 실행 결과는?', 'REPLACE 함수는 모든 \'L\'을 \'*L*\'로 대체하므로, \'ORAC*L*E SQ*L*\'이 됩니다.', NULL, 13),
	(1071, 3, NULL, 2, '8회차', '데이터 모델링 단계에서 각 엔터티를 도출하고 그들 간의 관계를 정의할 때, 가장 적절하지 않은 것은?', '엔터티는 업무프로세스에서 반드시 이용되어야 합니다. 업무프로세스에서 이용되지 않는 데이터는 엔터티로 선정될 수 없습니다. 나머지는 모두 엔터티의 올바른 특성입니다.', NULL, 2),
	(1072, 3, NULL, 2, '8회차', '아래의 식별자 특성 중 가장 부적절한 것은?', '식별자는 단일 속성으로만 구성되어야 한다는 제약은 없습니다. 복합 식별자도 가능하며, 이는 두 개 이상의 속성을 조합하여 식별자로 사용하는 것을 의미합니다.', NULL, 5),
	(1073, 3, NULL, 2, '8회차', '다음 중 ERD의 관계선택사양(Optionality)에 대한 설명으로 가장 옳은 것은?', '관계선택사양에서는 필수관계는 실선으로, 선택관계는 점선으로 표시합니다. \'O\'와 \'|\' 표기는 관계선택사양의 올바른 표기법이 아닙니다.', NULL, 4),
	(1074, 3, '학생번호 | 이름 | 수강과목 | 교수\n1001    | 김철수 | 수학   | 박교수\n1001    | 김철수 | 영어   | 이교수\n1002    | 이영희 | 수학   | 박교수', 2, '8회차', '아래와 같은 테이블이 있을 때, 이상현상(Anomaly)이 발생하지 않는 것은?', '제시된 테이블에서는 조회이상이 발생하지 않습니다. 학생별 수강과목 수는 GROUP BY를 통해 정상적으로 조회가 가능합니다. 나머지 보기들은 모두 발생 가능한 이상현상입니다.', NULL, 6),
	(1075, 3, NULL, 2, '8회차', '다음 중 엔터티의 특징으로 가장 부적절한 것은?', '엔터티가 다른 엔터티와 반드시 관계를 가져야 한다는 것은 잘못된 설명입니다. 독립적으로 존재하는 엔터티도 있을 수 있습니다.', NULL, 2),
	(1076, 3, '두 개의 엔터티 사이에서 엔터티 A의 하나의 인스턴스가 엔터티 B의 여러 개의 인스턴스와 관계를 가지고, 엔터티 B의 하나의 인스턴스도 엔터티 A의 여러 개의 인스턴스와 관계를 가진다.', 2, '8회차', '아래의 설명이 나타내는 관계유형은?', '설명은 M:N(다대다) 관계를 나타냅니다. 양쪽 엔터티 모두 서로에 대해 여러 개의 인스턴스와 관계를 맺을 수 있는 경우입니다.', NULL, 4),
	(1077, 3, NULL, 2, '8회차', '다음 중 정규화 과정에서 발생할 수 있는 단점으로 가장 적절한 것은?', '정규화를 수행하면 테이블이 분할되므로, 데이터 조회 시 조인이 필요할 수 있어 성능이 저하될 수 있습니다. 이는 정규화의 대표적인 단점입니다.', NULL, 6),
	(1078, 3, NULL, 1, '8회차', '두 개의 엔터티가 관계를 맺을 때 관계의 형태를 결정하는 것은?', '두 엔터티 간의 관계 형태는 관계차수(Cardinality)에 의해 결정됩니다. 관계차수는 1:1, 1:N, N:M 등의 수적인 관계를 나타냅니다.', NULL, 4),
	(1079, 3, NULL, 2, '8회차', '다음 중 속성의 분류 기준으로 가장 부적절한 것은?', '속성의 분류 기준에 \'크기에 따른 분류\'는 없습니다. 이는 잘못된 분류 기준입니다. 나머지는 모두 올바른 속성 분류 기준입니다.', NULL, 3),
	(1080, 3, NULL, 2, '8회차', '다음 중 슈퍼타입/서브타입 데이터 모델의 변환시 고려사항이 아닌 것은?', '슈퍼타입/서브타입 변환시 고려사항은 데이터 양, 조회 비중, 트랜잭션의 유형 등입니다. 테이블 이름의 길이는 변환시 고려사항이 아닙니다.', NULL, 2),
	(1081, 3, '[EMPLOYEE]\nEMP_NO    DEPT_NO    SALARY\n1001      10         5000\n1002      10         6000\n1003      20         4000\n1004      20         4500\n1005      30         3500', 2, '8회차', '다음과 같은 테이블이 있을 때, 부서별 평균 급여가 전체 평균 급여보다 높은 부서의 부서번호와 평균급여를 출력하는 SQL문으로 가장 적절한 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 GROUP BY절과 서브쿼리를 함께 사용해야 합니다. HAVING절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 2번이 올바른 답입니다.', NULL, 15),
	(1082, 3, NULL, 2, '8회차', '다음 중 RANK 함수에 대한 설명으로 올바르지 않은 것은?', 'RANK 함수는 NULL 값도 순위를 매깁니다. Oracle의 경우 기본적으로 NULL을 가장 큰 값으로 취급하여 ORDER BY ASC에서는 마지막 순위로, DESC에서는 처음 순위로 매깁니다.', NULL, 22),
	(1083, 3, 'SELECT SUBSTR(\'SQL전문가\',1,3) FROM DUAL;', 1, '8회차', '다음의 SQL문을 실행한 결과로 맞는 것은?', 'SUBSTR(\'SQL전문가\',1,3)는 첫 번째 위치에서 3개의 문자를 추출합니다. 따라서 \'SQL\'이 출력됩니다.', NULL, 13),
	(1084, 3, NULL, 2, '8회차', '다음 중 테이블 CROSS JOIN의 특징으로 가장 적절한 것은?', 'CROSS JOIN은 두 테이블의 모든 행을 조합하여 곱집합(Cartesian Product)을 반환합니다. 조인 조건이 필요없으며, 결과 행의 수는 두 테이블의 행의 수를 곱한 값이 됩니다.', NULL, 17),
	(1085, 3, '[ORDERS]\nORDER_DATE          ORDER_AMOUNT\n2023-01-01         1000\n2023-01-15         2000\n2023-02-01         1500\n2024-01-01         3000', 2, '8회차', '다음의 데이터에서 연도별, 월별 주문금액의 합계를 구하는 SQL문으로 가장 적절한 것은?', 'EXTRACT 함수를 사용하여 연도와 월을 추출하고, 이를 GROUP BY절에 동일하게 사용하여 그룹화해야 합니다. ORDER BY절로 정렬까지 수행하는 3번이 가장 적절합니다.', NULL, 13),
	(1086, 3, NULL, 2, '8회차', '다음 중 NULL 값과의 연산에 대한 설명으로 가장 적절한 것은?', 'NULL과의 모든 연산(산술, 비교 등)의 결과는 NULL입니다. 이는 \'NULL propagation\' 특성으로, NULL과 연산된 결과는 항상 NULL이 됩니다.', NULL, 9),
	(1087, 3, NULL, 2, '8회차', '다음 중 DELETE문에 대한 설명으로 옳지 않은 것은?', 'DELETE문은 DML문으로 트랜잭션 로그를 남깁니다. 이는 ROLLBACK이 가능한 이유이기도 합니다. 로그를 남기지 않는다는 설명은 잘못된 것입니다.', NULL, 27),
	(1088, 3, NULL, 3, '8회차', '계층형 질의문의 실행 순서로 올바른 것은?', '계층형 질의문의 실행 순서는 START WITH → CONNECT BY → WHERE → ORDER SIBLINGS BY 입니다. 이는 Oracle의 계층형 질의 처리 순서입니다.', NULL, 24),
	(1089, 3, '[EMPLOYEE]\nEMP_NO   DEPT_NO   SALARY\n1001     10        5000\n1002     10        4000\n1003     20        2000\n1004     20        2500', 2, '8회차', '다음의 테이블에서 부서별 평균 급여가 3000 이상인 부서를 조회하는 SQL문으로 가장 효율적인 것은?', 'WITH절(임시테이블)을 사용하여 부서별 평균 급여를 먼저 계산한 후, 그 결과에서 조건을 적용하는 방식이 가장 효율적입니다. 이는 중간 결과를 재사용할 수 있게 해주며, 쿼리의 가독성도 높여줍니다.', NULL, 19),
	(1090, 3, NULL, 2, '8회차', '다음 중 GROUP BY 절에 대한 설명으로 틀린 것은?', 'Oracle 11g R2 버전부터는 GROUP BY절에도 Alias를 사용할 수 있습니다. 따라서 "GROUP BY절에서 Alias를 사용할 수 없다"는 설명은 틀린 것입니다.', NULL, 15),
	(1091, 3, '[현재 테이블 구조]\nCREATE TABLE EMPLOYEE (\n    EMP_NO NUMBER(5),\n    NAME VARCHAR2(10)\n);', 2, '8회차', '다음 중 ALTER 문을 사용한 테이블 변경에 대한 올바른 구문은?', 'ALTER TABLE의 컬럼 변경은 MODIFY 구문을 사용합니다. 1번은 NOT NULL 제약조건을 가진 컬럼을 추가할 수 없고, 3번의 CHANGE는 MySQL 구문이며, 4번의 DELETE COLUMN은 잘못된 구문입니다(DROP COLUMN이 올바른 구문).', NULL, 29),
	(1092, 3, 'SELECT DISTINCT A.COL1, B.COL2, SUM(A.AMT)\nFROM TABLE1 A, TABLE2 B\nWHERE A.NO = B.NO\nGROUP BY A.COL1, B.COL2;', 2, '8회차', '다음의 SQL 문에서 잘못된 부분을 고르시오.', 'DISTINCT와 집계함수는 함께 사용할 수 있습니다. GROUP BY절에는 필요한 모든 컬럼이 포함되어 있고, WHERE절은 GROUP BY절 이전에 실행됩니다.', NULL, 15),
	(1093, 3, NULL, 2, '8회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', 'ROW_NUMBER() 함수는 중복값에 대해서도 고유한 순위를 부여합니다. 중복값에 대해 같은 순위를 부여하는 것은 RANK() 함수의 특징입니다.', NULL, 22),
	(1094, 3, NULL, 3, '8회차', 'EMPLOYEES 테이블에서 같은 부서 내에서 자신의 급여가 평균 급여보다 많은 직원을 조회하는 SQL문으로 가장 적절한 것은?', '부서별 평균 급여를 구하기 위해 상관 서브쿼리를 사용해야 합니다. E1.deptno = E2.deptno 조건으로 같은 부서 내에서의 평균 급여와 비교가 가능합니다.', NULL, 19),
	(1095, 3, NULL, 2, '8회차', '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Isolation(고립성)은 트랜잭션 실행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것입니다. 트랜잭션들이 서로 영향을 주면서 실행되어야 한다는 설명은 잘못되었습니다.', NULL, 28),
	(1096, 3, NULL, 1, '8회차', '다음 중 데이터 정의어(DDL)에 해당하는 것은?', 'DDL(Data Definition Language)은 데이터베이스 객체를 정의하는 명령어로 CREATE, ALTER, DROP, TRUNCATE 등이 포함됩니다. 1번은 TCL, 2번은 DCL, 3번은 DML에 해당합니다.', NULL, 29),
	(1097, 3, 'SELECT LPAD(\'SQL\', 5, \'#\') FROM DUAL;', 1, '8회차', '다음의 SQL문을 실행한 결과로 맞는 것은?', 'LPAD는 왼쪽에 지정한 문자를 채워넣는 함수입니다. \'SQL\'을 5자리로 만들기 위해 왼쪽에 \'#\'을 2개 채워넣으므로 \'##SQL\'이 됩니다.', NULL, 13),
	(1098, 3, NULL, 2, '8회차', '다음 중 인덱스(Index)에 대한 설명으로 틀린 것은?', 'Primary Key 제약조건을 생성하면 자동으로 인덱스가 생성됩니다. 제약조건이 생성될 때 인덱스가 삭제되는 것이 아닙니다.', NULL, 29),
	(1099, 3, '[ORDERS]\nORDER_DATE    ORDER_AMOUNT\n2023-01-01    1000\n2023-01-15    2000\n2023-02-01    1500\n2024-01-01    3000', 2, '8회차', '다음과 같은 테이블이 있을 때, 2023년도의 월별 주문금액 합계를 조회하는 SQL문으로 적절한 것은?', 'EXTRACT 함수를 사용하여 연도와 월을 추출하고, WHERE절에서 2023년도 데이터만 필터링한 후 월별로 그룹화하는 방식이 가장 적절합니다. HAVING절을 사용한 4번은 비효율적입니다.', NULL, 13),
	(1100, 3, NULL, 2, '8회차', '다음 중 View에 대한 설명으로 옳지 않은 것은?', '뷰는 물리적인 저장공간을 가지지 않는 가상 테이블이므로 직접적으로 인덱스를 생성할 수 없습니다. 인덱스는 실제 테이블에만 생성이 가능합니다.', NULL, 29),
	(1101, 3, NULL, 3, '8회차', '다음 중 Oracle의 계층형 질의에서 사용되는 가상 컬럼으로 올바르지 않은 것은?', 'Oracle의 계층형 질의에서 사용되는 가상 컬럼은 LEVEL, CONNECT_BY_ROOT, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE입니다. CONNECT_BY_ORDER는 존재하지 않는 가상 컬럼입니다.', NULL, 24),
	(1102, 3, 'SELECT ROUND(123.456, 2),\n       ROUND(123.456, 0),\n       ROUND(123.456, -1)\nFROM DUAL;', 2, '8회차', '아래의 SQL을 실행했을 때의 결과로 올바른 것은?', 'ROUND 함수의 두 번째 인자는 반올림할 소수점 자리를 지정합니다. ROUND(123.456, 2) → 123.46 (소수점 2자리까지), ROUND(123.456, 0) → 123 (정수), ROUND(123.456, -1) → 120 (10단위 반올림)', NULL, 13),
	(1103, 3, '[SCORES]\nNAME    SUBJECT    SCORE\n김철수   수학        90\n이영희   수학        85\n박지민   수학        95\n김철수   영어        85\n이영희   영어        90\n박지민   영어        80', 3, '8회차', '다음 데이터에서 과목별 최고점수를 가진 학생의 이름을 조회하는 SQL문으로 가장 적절한 것은?', '과목별 최고점수를 가진 학생을 찾기 위해서는 상관 서브쿼리를 사용합니다. 각 과목별로 최고점수를 구한 뒤, 해당 점수와 일치하는 학생을 찾는 방식입니다.', NULL, 19),
	(1104, 3, NULL, 2, '8회차', '다음 중 NULL 값과 관련된 설명으로 옳지 않은 것은?', 'NULL과 숫자 0은 전혀 다른 의미입니다. NULL은 \'알 수 없는 값\' 또는 \'해당없음\'을 의미하지만, 0은 숫자로서의 명확한 값을 의미합니다.', NULL, 9),
	(1105, 3, '[EMPLOYEES]\nEMP_NO    DEPT_NO    HIRE_DATE    NAME\n1001      10         2023-01-01   김철수\n1002      10         2023-03-15   이영희\n1003      20         2023-02-01   박지민\n1004      20         2023-04-01   최동욱', 3, '8회차', '다음과 같은 테이블이 있을 때, 부서별로 최근 입사한 직원의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 최근 입사자를 찾기 위해서는 상관 서브쿼리를 사용하여 각 부서의 최대 입사일자와 일치하는 직원을 찾아야 합니다.', NULL, 19),
	(1106, 3, 'SELECT TO_CHAR(SYSDATE, \'YYYY/MM/DD HH24:MI:SS\'),\n       TO_CHAR(SYSDATE, \'YYYY-MM-DD DAY\'),\n       TO_CHAR(SYSDATE, \'YYYY.MM.DD\')\nFROM DUAL;', 2, '8회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'TO_CHAR 함수는 지정된 형식에 따라 날짜를 문자열로 변환합니다. YYYY: 4자리 연도, HH24: 24시간 형식, DAY: 요일 전체 이름.', NULL, 13),
	(1107, 3, NULL, 2, '8회차', '다음 중 GROUP BY 절과 집계 함수에 대한 설명으로 틀린 것은?', 'HAVING 절은 GROUP BY 절과 함께 사용해야 합니다. HAVING 절만 단독으로 사용할 수 없습니다. 이는 GROUP BY로 그룹화된 데이터에 대한 조건을 지정하는 절이기 때문입니다.', NULL, 15),
	(1108, 3, '[EMPLOYEES]\nEMP_NO    DEPT_NO    SALARY    NAME\n1001      10         5000      김철수\n1002      10         4000      이영희\n1003      20         3000      박지민\n1004      20         4500      최동욱', 3, '8회차', '다음과 같은 테이블에서 각 부서의 평균 급여보다 높은 급여를 받는 직원을 조회하는 SQL문으로 가장 적절한 것은?', '각 부서의 평균 급여를 구하고, 이와 비교하기 위해서는 상관 서브쿼리를 사용해야 합니다. 서브쿼리에서 현재 행의 부서와 같은 부서의 평균 급여를 구하고, 이를 현재 행의 급여와 비교합니다.', NULL, 19),
	(1109, 3, NULL, 2, '8회차', '다음 중 UNION과 UNION ALL의 차이점에 대한 설명으로 틀린 것은?', 'UNION이 자동으로 정렬을 수행한다는 것은 틀린 설명입니다. UNION은 중복을 제거하는 과정에서 정렬이 발생할 수 있지만, 이는 명시적인 정렬이 아닙니다. 명시적인 정렬을 위해서는 ORDER BY 절을 사용해야 합니다.', NULL, 20),
	(1110, 3, NULL, 2, '8회차', '다음 중 인덱스(Index)를 생성하는 것이 적절하지 않은 경우는?', '데이터가 자주 변경되는 컬럼에 인덱스를 생성하는 것은 적절하지 않습니다. 데이터가 변경될 때마다 인덱스도 함께 업데이트되어야 하므로 오버헤드가 발생하고 성능이 저하될 수 있습니다.', NULL, 29),
	(1111, 3, '[DEPT]\nDEPT_NO   DEPT_NAME\n10        인사부\n20        총무부\n30        영업부\n\n[EMP]\nEMP_NO    DEPT_NO    NAME\n1001      10         김철수\n1002      20         이영희\n1003      10         박지민', 3, '8회차', '다음과 같은 테이블에서 INNER JOIN과 LEFT OUTER JOIN의 결과가 같을 조건은?', 'INNER JOIN과 LEFT OUTER JOIN의 결과가 같으려면 EMP 테이블의 모든 직원이 DEPT 테이블에 존재하는 부서번호를 가지고 있어야 합니다. 즉, EMP 테이블의 DEPT_NO가 모두 DEPT 테이블에 존재하는 경우입니다.', NULL, 17),
	(1112, 3, 'SELECT DECODE(NULLIF(LENGTH(\'\'SQL\'\'), 3), NULL, \'\'SAME\'\', \'\'DIFFERENT\'\') FROM DUAL;', 2, '8회차', '다음의 SQL문을 실행했을 때의 결과로 올바른 것은?', 'NULLIF는 두 값이 같으면 NULL을 반환하고, 다르면 첫 번째 값을 반환합니다. LENGTH(\'SQL\')은 3이므로 NULLIF(3,3)은 NULL을 반환합니다. DECODE는 첫 번째 값이 NULL이면 \'SAME\'을 반환하므로 최종 결과는 \'SAME\'입니다.', NULL, 13),
	(1113, 3, NULL, 3, '8회차', '다음 중 윈도우 함수의 ROWS와 RANGE 옵션에 대한 설명으로 틀린 것은?', 'ROWS와 RANGE는 다른 결과를 반환할 수 있습니다. ROWS는 물리적 행의 수를 기준으로, RANGE는 논리적 값의 범위를 기준으로 행 집합을 지정하기 때문입니다.', NULL, 22),
	(1114, 3, '[ATTENDANCE]\nEMP_NO    ABSENT_DATE\n1001      2023-12-01\n1001      2023-12-02\n1001      2023-12-03\n1002      2023-12-01\n1002      2023-12-03', 3, '8회차', '아래와 같은 테이블이 있을 때, 연속된 결근일수를 계산하는 SQL문으로 가장 적절한 것은?', '연속된 결근일수를 계산하기 위해서는 ROW_NUMBER()와 날짜 차이를 이용하여 그룹을 만들고, 각 그룹별로 카운트를 구해야 합니다. 이 방식을 통해 날짜가 연속된 그룹을 식별할 수 있습니다.', NULL, 22),
	(1115, 3, NULL, 2, '8회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE문에서 WHEN NOT MATCHED THEN 절은 선택사항입니다. 필요한 경우에만 사용할 수 있으며, 필수적으로 포함되어야 하는 것은 아닙니다.', NULL, 27),
	(1116, 3, '[SALES]\nSALE_DATE    AMOUNT\n2023-01-01   1000\n2023-01-02   2000\n2023-01-03   1500', 2, '8회차', '다음의 테이블에서 누적 합계를 구하는 SQL문으로 가장 적절한 것은?', '누적 합계를 구하기 위해서는 윈도우 함수의 ROWS BETWEEN 절을 사용하는 것이 가장 명확합니다. UNBOUNDED PRECEDING AND CURRENT ROW는 처음부터 현재 행까지의 범위를 지정합니다.', NULL, 22),
	(1117, 3, NULL, 2, '8회차', '다음 중 Oracle의 PIVOT 절을 사용할 때의 제한사항으로 옳지 않은 것은?', 'PIVOT 절에서는 여러 개의 집계함수를 사용할 수 있습니다. 하나의 집계함수만 사용해야 한다는 제한은 없습니다.', NULL, 25),
	(1118, 3, '[EMPLOYEES]\nEMP_NO    DEPT_NO    SALARY    NAME\n1001      10         5000      김철수\n1002      10         4000      이영희\n1003      20         3000      박지민\n1004      20         4500      최동욱', 3, '8회차', '다음과 같은 테이블에서 부서별로 가장 높은 급여를 받는 상위 2명의 직원을 조회하는 SQL문으로 가장 적절한 것은?', '부서별로 급여 순위를 매기고 상위 2명을 선택하기 위해서는 ROW_NUMBER() 함수를 사용하는 것이 가장 적절합니다. PARTITION BY로 부서별로 분할하고 ORDER BY로 급여 순서를 정합니다.', NULL, 23),
	(1119, 3, 'WITH RECURSIVE NUMS AS (\n    SELECT 1 AS N\n    UNION ALL\n    SELECT N + 1\n    FROM NUMS\n    WHERE N < 5\n)\nSELECT * FROM NUMS;', 3, '8회차', '다음의 SQL문을 실행했을 때의 결과로 올바른 것은?', '재귀 CTE는 초기 값 1부터 시작하여 N < 5 조건을 만족할 때까지 N + 1 값을 생성합니다. 따라서 1부터 5까지의 숫자가 생성됩니다.', NULL, 19),
	(1120, 3, NULL, 2, '8회차', '다음 중 데이터베이스 트랜잭션 격리 수준(Isolation Level)에 대한 설명으로 틀린 것은?', 'READ COMMITTED 격리 수준에서는 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 없습니다. 커밋된 데이터만 읽을 수 있습니다. 커밋되지 않은 데이터를 읽을 수 있는 것은 READ UNCOMMITTED 격리 수준의 특징입니다.', NULL, 28),
	(1121, 3, NULL, 2, '9회차', '다음 중 엔터티(Entity)의 특성으로 가장 부적절한 것은?', '엔터티는 물리적 형태뿐만 아니라 개념적으로 존재하는 것도 포함됩니다. 예를 들어 \'거래\', \'계약\' 등은 물리적 형태는 없지만 업무적으로 관리해야 할 엔터티입니다.', NULL, 2),
	(1122, 3, NULL, 2, '9회차', '다음 중 식별자의 특징으로 가장 부적절한 것은?', '식별자의 주요 특성은 유일성(Unique), 최소성(Minimal), 불변성(Stable), 존재성(Existence)입니다. 대체성은 식별자의 필수 특성이 아닙니다.', NULL, 5),
	(1123, 3, '"두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가진다."', 3, '9회차', '아래의 설명에 해당하는 것은?', '행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가집니다.', NULL, 2),
	(1124, 3, NULL, 2, '9회차', '다음 중 관계(Relationship)의 표기법에 포함되지 않는 것은?', '관계의 표기법은 관계명, 관계차수, 관계선택사양이 있습니다. 관계스키마는 관계 표기법에 포함되지 않습니다.', NULL, 4),
	(1125, 3, NULL, 2, '9회차', '다음 중 정규화 과정에서 발생할 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상은 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않습니다.', NULL, 6),
	(1126, 3, NULL, 3, '9회차', '비식별관계에 대한 설명으로 가장 적절한 것은?', '비식별관계는 부모 테이블의 기본키가 자식 테이블의 일반 속성으로 전이되는 관계를 의미합니다.', NULL, 4),
	(1127, 3, NULL, 2, '9회차', '다음 중 정규화의 특징으로 부적절한 것은?', '정규화는 조회 시 조인이 필요할 수 있어 항상 조회 성능이 향상되는 것은 아닙니다.', NULL, 6),
	(1128, 3, NULL, 2, '9회차', '엔터티의 속성 중 스스로 생성된 값이 아닌, 다른 엔터티로부터 받아오는 값을 무엇이라고 하는가?', '다른 엔터티로부터 받아오는 속성을 외부 속성이라고 합니다.', NULL, 3),
	(1129, 3, NULL, 3, '9회차', '슈퍼타입/서브타입 모델링에 대한 설명으로 옳지 않은 것은?', '하나의 서브타입은 단 하나의 슈퍼타입만 가질 수 있습니다. 여러 개의 슈퍼타입을 가질 수 없습니다.', NULL, 3),
	(1130, 3, NULL, 2, '9회차', '도메인(Domain)에 대한 설명으로 가장 부적절한 것은?', '도메인은 테이블 생성 시 반드시 지정해야 하는 것이 아닙니다. 도메인은 속성이 가질 수 있는 값의 범위를 정의하는 것입니다.', NULL, 3),
	(1131, 3, NULL, 2, '9회차', '다음 중 GROUP BY절에 대한 설명으로 옳지 않은 것은?', 'Oracle 11g R2 버전부터는 GROUP BY절에도 별칭(Alias)을 사용할 수 있습니다.', NULL, 15),
	(1132, 3, '[EMPLOYEE]\nEMP_ID  SALARY\n-------------------\n101     3000\n102     3000\n103     4000\n104     5000\n105     4000\n\n```sql\nSELECT COUNT(DISTINCT SALARY) \nFROM EMPLOYEE;```', 2, '9회차', '다음 테이블에서 SQL 실행결과로 올바른 것은?', '중복을 제거한 SALARY 값은 3000, 4000, 5000으로 총 3개입니다.', NULL, 13),
	(1133, 3, NULL, 2, '9회차', '다음 중 NULL 처리 함수에 대한 설명으로 잘못된 것은?', 'ISNULL(A,B)는 A가 NULL이면 B를 반환합니다. A를 반환한다는 설명은 잘못되었습니다.', NULL, 13),
	(1134, 3, '```sql\nSELECT SUBSTR(\'SQL Developer\', -4, 2) \nFROM DUAL;```', 2, '9회차', '다음 중 SUBSTR 함수를 사용한 결과로 올바른 것은?', 'SUBSTR 함수에서 음수 위치는 뒤에서부터 계산합니다. -4는 뒤에서 4번째 위치에서 시작하여 2글자를 추출하므로 \'pe\'가 됩니다.', NULL, 13),
	(1135, 3, '[SALES]\nJOIN_DATE    MEMBER_ID   AMOUNT\n--------------------------------\n2023-01-01   A001        1000\n2023-01-15   A002        2000\n2023-02-01   A003        1500\n2022-12-31   A004        3000', 3, '9회차', '다음과 같은 테이블이 있을 때, 2023년에 가입한 회원의 월별 합계 금액을 구하는 SQL문으로 가장 적절한 것은?', 'EXTRACT 함수를 사용하여 연도와 월을 추출하고, GROUP BY와 ORDER BY를 적절히 사용한 쿼리가 가장 적절합니다.', NULL, 15),
	(1136, 3, '[DEPT]\nDEPT_ID   DEPT_NAME\n----------------------\n10        영업부\n20        개발부\n30        인사부\n\n[EMP]\nEMP_ID    DEPT_ID    EMP_NAME\n--------------------------------\n1         10         김사원\n2         10         박사원\n3         20         이사원\n4         NULL       최사원', 2, '9회차', '다음과 같은 테이블에서 LEFT OUTER JOIN의 결과행 수로 올바른 것은?', 'LEFT OUTER JOIN은 왼쪽 테이블(DEPT)의 모든 행과 오른쪽 테이블(EMP)의 매칭되는 행을 반환합니다. DEPT의 3행과 EMP의 매칭되는 행으로 총 3행이 됩니다.', NULL, 17),
	(1137, 3, NULL, 3, '9회차', '다음 중 계층형 질의문(Hierarchical Query)에서 사용되는 가상 컬럼이 아닌 것은?', 'CONNECT_BY_PARENT는 계층형 질의문의 가상 컬럼이 아닙니다. 실제 가상 컬럼은 LEVEL, CONNECT_BY_ROOT, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE 등이 있습니다.', NULL, 24),
	(1138, 3, NULL, 3, '9회차', '다음 중 ROLLUP과 CUBE에 대한 설명으로 옳지 않은 것은?', 'CUBE는 ROLLUP보다 더 많은 소계를 생성하며, 결과가 항상 동일하지 않습니다.', NULL, 21),
	(1139, 3, NULL, 2, '9회차', '다음 중 ORDER BY절에 대한 설명으로 옳지 않은 것은?', 'ORDER BY절은 GROUP BY절이 있더라도 사용할 수 있습니다.', NULL, 16),
	(1140, 3, '[EMP]\nEMP_ID    SALARY\n------------------\n101       5000\n102       5000\n103       4000\n104       3000', 3, '9회차', '다음과 같은 테이블에서 연봉 순위를 구하는 SQL문 중 잘못된 것은?', 'RANK() OVER절의 정렬 순서와 최종 결과의 정렬 순서가 일치하지 않아 순위가 올바르게 계산되지 않습니다.', NULL, 22),
	(1141, 3, '[EMP]\nEMP_ID    DEPT_ID    SALARY\n-----------------------------\n101       10         5000\n102       10         4000\n103       20         6000\n104       20         5500\n105       30         4500', 3, '9회차', '다음 테이블에서 부서별로 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 올바른 것은?', '상관 서브쿼리를 사용하여 각 부서별 최고 급여를 받는 사원의 모든 정보를 조회할 수 있습니다.', NULL, 19),
	(1142, 3, NULL, 2, '9회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE 문은 Oracle 10g부터 DELETE 절을 포함할 수 있습니다.', NULL, 27),
	(1143, 3, '[SALES]\nYEAR    MONTH    AMOUNT\n------------------------\n2023    01       1000\n2023    02       1500\n2023    03       2000\n2023    04       1800\n\n```sql\nSELECT YEAR, MONTH, AMOUNT,\n       LAG(AMOUNT, 1, 0) OVER (ORDER BY YEAR, MONTH) AS PREV_AMOUNT\nFROM SALES;```', 3, '9회차', '다음과 같은 테이블에서 WINDOW 함수를 사용한 결과로 올바른 것은?', 'LAG 함수는 이전 행의 값을 반환합니다. LAG(AMOUNT, 1, 0)는 이전 달의 판매액을 보여주며, 첫 번째 행은 0을 반환합니다.', NULL, 22),
	(1144, 3, NULL, 2, '9회차', '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Durability(영속성)는 성공적으로 완료된 트랜잭션의 결과가 영구적으로 반영되어야 한다는 의미입니다. 시스템 장애 발생 시 자동 롤백과는 관련이 없습니다.', NULL, 28),
	(1145, 3, '[ORGANIZATION]\nEMP_ID    MANAGER_ID    EMP_NAME\n---------------------------------\n1         NULL          김사장\n2         1             이부장\n3         1             박부장\n4         2             최과장\n5         2             정과장', 3, '9회차', '다음과 같은 계층형 구조의 데이터를 조회하는 SQL문으로 가장 적절한 것은?', '계층형 구조를 조회할 때는 START WITH로 시작점을 지정하고, CONNECT BY PRIOR로 부모-자식 관계를 정의합니다.', NULL, 24),
	(1146, 3, NULL, 2, '9회차', '다음 중 DCL(Data Control Language)에 해당하지 않는 것은?', 'COMMIT은 TCL(Transaction Control Language)에 속합니다. DCL은 GRANT, REVOKE, DENY 등이 있습니다.', NULL, 30),
	(1147, 3, '```sql\nSELECT ROUND(123.456, 2),\n       ROUND(123.456, 0),\n       ROUND(123.456, -1)\nFROM DUAL;```', 2, '9회차', '다음 SQL문의 실행 결과로 옳은 것은?', 'ROUND 함수는 지정된 소수점 자리에서 반올림합니다. 2는 소수점 둘째 자리, 0은 정수, -1은 십의 자리에서 반올림합니다.', NULL, 13),
	(1148, 3, '```sql\nSELECT DEPTNO, COUNT(*) \nFROM EMP \nWHERE SAL > 2000 \nGROUP BY DEPTNO \nHAVING COUNT(*) > 1 \nORDER BY DEPTNO;```', 2, '9회차', '다음 SQL문에서 실행 순서가 올바른 것은?', 'SQL 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순입니다.', NULL, 12),
	(1149, 3, NULL, 2, '9회차', '다음 중 UNION과 UNION ALL의 차이점으로 옳지 않은 것은?', 'UNION과 UNION ALL 모두 열의 개수가 동일해야 하는 것은 맞는 설명입니다. 틀린 설명은 없습니다.', NULL, 20),
	(1150, 3, NULL, 2, '9회차', '다음 중 인덱스(Index)에 대한 설명으로 틀린 것은?', '인덱스가 있으면 DELETE 연산 시 인덱스도 함께 갱신해야 하므로 오히려 성능이 저하될 수 있습니다.', NULL, 11),
	(1151, 3, '[EMPLOYEE]\nEMP_ID    SALARY\n-------------------\n101       5000\n102       4000\n103       6000\n104       3000\n105       5500', 3, '9회차', '다음 테이블에서 ROWNUM을 사용한 쿼리 중 잘못된 것은?', 'ROWNUM을 WHERE 절에서 직접 사용하고 ORDER BY를 나중에 하면 원하는 결과를 얻을 수 없습니다. 정렬을 먼저 하고 ROWNUM을 적용해야 합니다.', NULL, 23),
	(1152, 3, NULL, 2, '9회차', '다음 중 NULL 값과 관련된 설명으로 올바르지 않은 것은?', 'NULL과 NULL은 서로 같다고 판단할 수 없습니다. NULL끼리의 비교는 UNKNOWN을 반환합니다.', NULL, 9),
	(1153, 3, '```sql\nSELECT LTRIM(\'***ORACLE***\', \'*\'),\n       RTRIM(\'***ORACLE***\', \'*\'),\n       TRIM(\'*\' FROM \'***ORACLE***\')\nFROM DUAL;```', 2, '9회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'LTRIM은 왼쪽에서, RTRIM은 오른쪽에서, TRIM은 양쪽에서 지정된 문자를 제거합니다.', NULL, 13),
	(1154, 3, '[SALES]\nDEPT    YEAR    AMOUNT\n------------------------\nA       2023    1000\nA       2024    2000\nB       2023    1500\nB       2024    2500\n\n```sql\nSELECT DEPT, YEAR, SUM(AMOUNT)\nFROM SALES\nGROUP BY ROLLUP(DEPT, YEAR);```', 3, '9회차', '다음과 같은 테이블이 있을 때, ROLLUP을 사용한 SQL문의 결과로 올바른 것은?', 'ROLLUP은 지정된 컬럼의 소계와 전체 합계를 생성합니다. DEPT, YEAR에 대한 개별 그룹(4행) + DEPT별 소계(2행) + 전체 합계(1행) = 총 7행이 출력됩니다.', NULL, 21),
	(1155, 3, NULL, 2, '9회차', '다음 중 WITH절(Common Table Expression)에 대한 설명으로 틀린 것은?', 'WITH절은 쿼리가 완전히 종료될 때까지 메모리에 유지됩니다. 즉시 삭제되지 않습니다.', NULL, 19),
	(1156, 3, '```sql\nWITH TEMP AS (\n    SELECT 1 AS NUM FROM DUAL UNION ALL\n    SELECT 2 FROM DUAL UNION ALL\n    SELECT 3 FROM DUAL\n)\nSELECT SUM(NUM) OVER (ORDER BY NUM\n    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS RESULT\nFROM TEMP;```', 3, '9회차', '다음 SQL문의 실행 결과는?', '윈도우 절의 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING은 현재 행을 중심으로 이전 행과 다음 행의 값을 합산합니다. 따라서 1+2=3, 1+2+3=6, 2+3=5가 됩니다.', NULL, 22),
	(1157, 3, NULL, 2, '9회차', '다음 중 윈도우 함수(Window Function)에 대한 설명으로 올바르지 않은 것은?', '윈도우 함수는 WHERE 절에서 사용할 수 없습니다. SELECT, ORDER BY 절에서만 사용 가능합니다.', NULL, 22),
	(1158, 3, '[PRODUCT]\nPROD_CD    STATUS\n--------------------\nA001       1\nA002       2\nA003       3\nA004       NULL', 2, '9회차', '다음과 같은 테이블에서 DECODE 함수를 사용한 결과로 잘못된 것은?', 'DECODE 함수에서 \'진행\', \'완료\'는 각각 독립된 조건과 결과값으로 해석되어 의도한 대로 동작하지 않습니다.', NULL, 13),
	(1159, 3, NULL, 2, '9회차', '다음 중 인라인 뷰(Inline View)에 대한 설명으로 틀린 것은?', '인라인 뷰에서도 ORDER BY 절을 사용할 수 있습니다. 특히 TOP-N 쿼리 등에서 자주 사용됩니다.', NULL, 19),
	(1160, 3, '```sql\nCREATE TABLE TEST (COL1 NUMBER);\nINSERT INTO TEST VALUES (1);\nINSERT INTO TEST VALUES (2);\nSAVEPOINT S1;\nINSERT INTO TEST VALUES (3);\nROLLBACK TO S1;\nINSERT INTO TEST VALUES (4);\nCOMMIT;\n\nSELECT COUNT(*) FROM TEST;```', 2, '9회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SAVEPOINT S1까지 2개의 행이 삽입되고, ROLLBACK TO S1으로 3번째 INSERT가 취소되며, 마지막 INSERT와 COMMIT으로 최종적으로 3개의 행이 남게 됩니다.', NULL, 28),
	(1161, 3, '[EMP]\nDEPT_ID    SALARY\n------------------\n10         5000\n10         4000\n20         3000\n20         3500\n30         4500', 3, '9회차', '다음과 같은 테이블에서 부서별 평균 급여가 전체 평균 급여보다 높은 부서를 조회하는 SQL문으로 올바른 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 HAVING 절에서 서브쿼리를 사용해야 합니다.', NULL, 19),
	(1162, 3, '[SALES]\nQUARTER    AMOUNT\n------------------\nQ1         1000\nQ2         2000\nQ1         1500\nQ2         2500', 3, '9회차', '다음 중 PIVOT 함수를 사용한 결과로 올바르지 않은 것은?', 'PIVOT 함수에서는 하나의 집계 함수만 사용할 수 있습니다. 여러 집계 함수를 동시에 사용할 수 없습니다.', NULL, 25),
	(1163, 3, NULL, 2, '9회차', '다음 중 트랜잭션 격리 수준(Transaction Isolation Level)에 대한 설명으로 틀린 것은?', '트랜잭션 격리 수준이 높을수록 동시성은 낮아지고 데이터 정합성은 높아집니다.', NULL, 28),
	(1164, 3, '```sql\nSELECT LEVEL, CONNECT_BY_ISLEAF\nFROM DUAL\nCONNECT BY LEVEL <= 3;```', 3, '9회차', '다음 SQL문의 실행 결과는?', 'CONNECT_BY_ISLEAF는 계층형 쿼리에서 리프 노드(자식이 없는 노드)일 경우 1, 아닐 경우 0을 반환합니다.', NULL, 24),
	(1165, 3, '[EMPLOYEE]\nEMP_ID    DEPT_ID    SALARY    BONUS\n----------------------------------------\n1         10         5000      NULL\n2         10         4000      500\n3         20         3000      NULL\n4         20         3500      300', 2, '9회차', '다음과 같은 테이블에서 올바른 SQL문은?', 'NULL 값이 포함된 계산을 할 때는 NVL 함수를 사용하여 NULL을 다른 값으로 대체해야 정확한 결과를 얻을 수 있습니다.', NULL, 13),
	(1166, 3, NULL, 2, '9회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 틀린 것은?', '외래키로 지정된 컬럼은 NULL 값을 가질 수 있습니다. 이는 선택적 참조 무결성을 지원하기 위한 것입니다.', NULL, 29),
	(1167, 3, NULL, 3, '9회차', '다음 중 DML(Data Manipulation Language) 성능을 향상시키는 방법으로 적절하지 않은 것은?', 'COMMIT을 자주 수행하면 UNDO 세그먼트를 자주 사용하게 되어 성능이 저하될 수 있습니다. 대량 DML 작업 시에는 적절한 COMMIT 주기를 설정해야 합니다.', NULL, 27),
	(1168, 3, '[NUMBERS]\nNUM\n----\n1\n2\n3\n5\n6\n8\n9', 3, '9회차', '다음과 같은 테이블이 있을 때, 연속된 숫자를 찾는 SQL문으로 올바른 것은?', 'ROW_NUMBER() 함수와 숫자의 차이값을 이용하면 연속된 숫자들을 그룹화할 수 있습니다.', NULL, 22),
	(1169, 3, NULL, 2, '9회차', '다음 중 VIEW에 대한 설명으로 틀린 것은?', '단순 뷰라도 집계 함수나 DISTINCT를 포함하는 경우 DML이 불가능할 수 있습니다.', NULL, 29),
	(1170, 3, '```sql\nSELECT CAST(\'2024-01-01\' AS DATE) + 1,\n       ADD_MONTHS(\'2024-01-01\', 2),\n       MONTHS_BETWEEN(\'2024-03-01\', \'2024-01-01\')\nFROM DUAL;```', 2, '9회차', '다음 SQL문의 실행 결과로 올바른 것은?', '날짜에 1을 더하면 하루가 증가하고, ADD_MONTHS는 지정된 개월 수를 더하며, MONTHS_BETWEEN은 두 날짜 간의 개월 수 차이를 반환합니다.', NULL, 13),
	(1171, 3, NULL, 2, '10회차', '다음 중 엔터티 도출 시 고려해야 할 사항으로 가장 부적절한 것은?', '엔터티는 물리적인 형태로 존재하지 않더라도, 업무적으로 관리가 필요한 개념적 정보라면 엔터티가 될 수 있습니다. 예를 들어 \'계약\', \'거래\' 등은 물리적 형태는 없지만 엔터티가 될 수 있습니다.', NULL, 2),
	(1172, 3, NULL, 2, '10회차', '다음 중 속성(Attribute)의 특성으로 올바른 것은?', '속성은 업무상 구체적인 의미를 가지는 더 이상 분리될 수 없는 데이터의 최소 단위입니다. 하나의 속성은 한 개의 값만 가질 수 있으며, 기본키는 NULL 값을 가질 수 없습니다.', NULL, 3),
	(1173, 3, '```\n[고객] -----○--< [주문]\n```', 2, '10회차', '다음 보기의 ERD에 대한 설명으로 가장 올바르지 않은 것은?', '주어진 ERD에서 실선으로 표시된 관계는 필수관계를 나타냅니다. 따라서 주문은 반드시 하나의 고객에 속해야 하며, 고객 없이 존재할 수 없습니다.', NULL, 4),
	(1174, 3, '"시간에 따라 변하는 값을 이력으로 관리하기 위한 속성으로, 실제 업무상 필요한 데이터가 아닌 데이터 모델링 시 필요에 따라 생성하는 속성"', 2, '10회차', '아래의 정의에 해당하는 것은 무엇인가?', '설계 속성은 업무상 필요한 데이터가 아닌, 데이터 모델링 시 필요에 따라 생성하는 속성을 의미합니다. 시작일자, 종료일자, 이력번호 등이 대표적인 예입니다.', NULL, 3),
	(1175, 3, NULL, 2, '10회차', '엔터티의 주식별자 도출 기준으로 가장 부적절한 것은?', '이름이나 설명과 같은 속성은 변경될 가능성이 높고 중복될 수 있으므로 주식별자로 적절하지 않습니다. 주식별자는 안정적이고 유일한 값을 가져야 합니다.', NULL, 5),
	(1176, 3, NULL, 2, '10회차', '다음 중 정규화에 대한 설명으로 가장 올바르지 않은 것은?', '정규화는 조회 시 조인을 유발할 수 있어 항상 성능이 향상되는 것은 아닙니다. 때로는 성능 향상을 위해 반정규화를 고려해야 할 수 있습니다.', NULL, 6),
	(1177, 3, NULL, 2, '10회차', '다음 중 슈퍼타입/서브타입 변환 시 고려사항이 아닌 것은?', '슈퍼타입/서브타입 변환 시 고려사항은 데이터 볼륨, 조회 성능, 트랜잭션의 유형, 확장성 등입니다. 테이블 이름은 주요 고려사항이 아닙니다.', NULL, 3),
	(1178, 3, NULL, 3, '10회차', '다음 중 관계 유형에 대한 설명으로 옳은 것은?', '식별관계에서는 부모 테이블의 기본키가 자식 테이블의 기본키의 일부로 전이됩니다. 비식별관계는 점선으로 표현되며, 항상 성능을 저하시키는 것은 아닙니다.', NULL, 4),
	(1179, 3, NULL, 2, '10회차', '다음 중 도메인(Domain)에 대한 설명으로 가장 부적절한 것은?', '도메인은 테이블 생성 시 반드시 지정해야 하는 것이 아닙니다. 도메인은 속성이 가질 수 있는 값의 범위를 정의하는 것입니다.', NULL, 3),
	(1180, 3, NULL, 2, '10회차', '다음 중 반정규화(Denormalization)를 고려해야 하는 경우가 아닌 것은?', '데이터의 일관성이 중요한 경우는 오히려 정규화를 유지해야 합니다. 반정규화는 데이터의 중복을 허용하므로 일관성이 저하될 수 있습니다.', NULL, 6),
	(1181, 3, '[EMPLOYEE]\nEMP_ID    DEPT_ID    NAME    SALARY\n----------------------------------------\n1001      10         김유신    5000\n1002      10         이순신    4500\n1003      20         강감찬    5500\n1004      20         을지문덕  4800\n1005      30         정약용    4700', 3, '10회차', '다음과 같은 테이블이 있을 때, 부서별 최고 급여자의 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최고 급여자의 모든 정보를 조회하기 위해서는 상관 서브쿼리(Correlated Subquery)를 사용해야 합니다. 각 직원의 급여가 자신이 속한 부서의 최대 급여와 같은지 비교합니다.', NULL, 19),
	(1182, 3, NULL, 2, '10회차', '다음 중 GROUP BY 절에 대한 설명으로 옳지 않은 것은?', 'GROUP BY 절에는 SELECT 목록에 있는 집계 함수를 제외한 모든 컬럼이 포함되어야 합니다. 반대로 GROUP BY 절에 있는 모든 컬럼이 SELECT 목록에 포함될 필요는 없습니다.', NULL, 15),
	(1183, 3, '```sql\nSELECT SUBSTR(\'ORACLE SQL\', -3, 2)\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'SUBSTR 함수에서 음수 위치는 문자열 끝에서부터 계산됩니다. -3은 뒤에서 3번째 위치(\'S\')에서 시작하여 2글자를 추출하므로 \'SQ\'가 됩니다.', NULL, 13),
	(1184, 3, '[DEPT]\nDEPT_ID    DEPT_NAME\n---------------------\n10         인사부\n20         영업부\n30         개발부\n\n[EMP]\nEMP_ID    DEPT_ID    EMP_NAME\n--------------------------------\n1         10         김사원\n2         20         이사원\n3         40         박사원\n\n```sql\nSELECT D.DEPT_NAME, E.EMP_NAME\nFROM DEPT D LEFT OUTER JOIN EMP E\nON D.DEPT_ID = E.DEPT_ID;```', 2, '10회차', '다음과 같은 테이블에서 올바른 조인 결과는?', 'LEFT OUTER JOIN은 왼쪽 테이블(DEPT)의 모든 행과 오른쪽 테이블(EMP)의 매칭되는 행을 반환합니다. 개발부(30)는 매칭되는 사원이 없으므로 NULL로 출력되어 총 3행이 조회됩니다.', NULL, 17),
	(1185, 3, NULL, 2, '10회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', '윈도우 함수는 GROUP BY 절에서 사용할 수 없습니다. SELECT 절과 ORDER BY 절에서만 사용할 수 있습니다.', NULL, 22),
	(1186, 3, '```sql\nSELECT CASE WHEN NULL = NULL THEN \'TRUE\'\n            WHEN NULL IS NULL THEN \'IS NULL\'\n            ELSE \'FALSE\' END AS RESULT\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'NULL과 NULL의 비교는 알 수 없는 결과(UNKNOWN)를 반환하므로 첫 번째 조건은 FALSE가 됩니다. NULL IS NULL은 TRUE를 반환하므로 \'IS NULL\'이 결과가 됩니다.', NULL, 13),
	(1187, 3, NULL, 2, '10회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE 문에서는 WHEN NOT MATCHED THEN DELETE를 사용할 수 없습니다. DELETE는 WHEN MATCHED THEN 절에서만 사용할 수 있습니다.', NULL, 27),
	(1188, 3, '```sql\nSELECT LEVEL\nFROM DUAL\nCONNECT BY LEVEL <= 3\nSTART WITH LEVEL = 1;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'CONNECT BY LEVEL <= 3은 1부터 3까지의 연속된 숫자를 생성합니다. START WITH LEVEL = 1은 시작점을 지정합니다.', NULL, 24),
	(1189, 3, NULL, 2, '10회차', '다음 중 집합 연산자에 대한 설명으로 옳은 것은?', 'UNION은 중복을 제거하고 자동으로 정렬된 결과를 반환합니다. INTERSECT는 교집합, MINUS는 차집합을 반환합니다.', NULL, 20),
	(1190, 3, '[ATTENDANCE]\nSTUDENT_ID   ABSENT_DATE\n--------------------------\nA001         2024-01-01\nA001         2024-01-02\nA001         2024-01-03\nA001         2024-01-05', 3, '10회차', '다음과 같은 테이블에서 연속된 결석일을 찾는 SQL문으로 가장 적절한 것은?', '연속된 날짜를 찾기 위해서는 날짜와 행 번호의 차이가 같은 그룹을 찾아야 합니다. ROW_NUMBER()와 GROUP BY를 활용한 방법이 가장 적절합니다.', NULL, 22),
	(1191, 3, '[EMPLOYEE]\nEMP_ID    SALARY    COMMISSION\n-------------------------------\n101       5000      1000\n102       4000      NULL\n103       3000      500\n\n```sql\nUPDATE EMPLOYEE\nSET SALARY = SALARY + COMMISSION;```', 2, '10회차', '다음과 같은 테이블에서 UPDATE문이 실행될 때 발생하는 결과로 올바른 것은?', 'NULL과 숫자의 연산은 NULL을 반환합니다. 따라서 NULL이 포함된 행의 연산 결과는 NULL이 되어 SALARY가 NULL이 되므로 오류가 발생합니다.', NULL, 27),
	(1192, 3, NULL, 2, '10회차', '다음 중 WITH절(Common Table Expression)의 특징으로 올바르지 않은 것은?', 'WITH절은 쿼리가 완전히 종료될 때까지 메모리에 유지됩니다. 즉시 삭제되지 않습니다.', NULL, 19),
	(1193, 3, '```sql\nSELECT REGEXP_REPLACE(\'SQL Developer 2024\', \'[0-9]\', \'*\')\nFROM DUAL;```', 2, '10회차', '아래의 SQL 실행 결과로 올바른 것은?', 'REGEXP_REPLACE 함수는 모든 숫자를 \'*\'로 치환합니다. 따라서 \'2024\'의 모든 숫자가 \'*\'로 바뀝니다.', NULL, 26),
	(1194, 3, '- 고객번호는 오름차순\n- 주문금액은 내림차순\n- 주문일자는 오름차순', 2, '10회차', '다음 조건을 만족하는 ORDER BY 절로 올바른 것은?', 'ORDER BY 절에서 여러 컬럼의 정렬 방향을 각각 지정할 수 있습니다. ASC는 생략 가능합니다.', NULL, 16),
	(1195, 3, NULL, 2, '10회차', '다음 중 인덱스를 사용할 수 없는 경우는?', '인덱스 컬럼에 함수가 적용되면 인덱스를 사용할 수 없습니다. 이를 방지하려면 함수 기반 인덱스를 별도로 생성해야 합니다.', NULL, 11),
	(1196, 3, '```sql\nCREATE TABLE TEST (\n    ID NUMBER,\n    CODE CHAR(2) DEFAULT \'01\',\n    NAME VARCHAR2(10) NOT NULL\n);```', 2, '10회차', '아래의 DDL문에서 발생하는 결과로 올바른 것은?', 'NAME 컬럼은 NOT NULL 제약조건이 있어 NULL 값을 입력할 수 없습니다. 두 번째 INSERT문은 이 제약조건을 위배합니다.', NULL, 29),
	(1197, 3, '```sql\nSELECT TO_CHAR(SYSDATE, \'YYYY/MM/DD HH24:MI:SS\') AS NOW,\n       TO_CHAR(SYSDATE + 1/24, \'YYYY/MM/DD HH24:MI:SS\') AS AFTER_1HOUR\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SYSDATE + 1/24는 현재 시간에 1시간을 더한 결과를 반환합니다. 하루는 24시간이므로 1/24는 1시간을 의미합니다.', NULL, 13),
	(1198, 3, NULL, 2, '10회차', '다음 중 DISTINCT 키워드의 사용으로 올바르지 않은 것은?', 'DISTINCT는 함수가 아니라 키워드이므로 괄호로 묶어 사용하는 것은 문법적으로 올바르지 않습니다.', NULL, 12),
	(1199, 3, '[EMP]\nEMP_ID    DEPT_ID    SALARY\n---------------------------\n101       10         5000\n102       10         4000\n103       20         6000\n104       20         5500', 3, '10회차', '다음과 같은 테이블에서 부서별 최고 급여자를 찾는 SQL문 중 성능이 가장 좋은 것은?', '복합 IN 절을 사용하는 방식이 가장 효율적입니다. 그룹화된 결과를 한 번만 스캔하여 결과를 얻을 수 있기 때문입니다.', NULL, 19),
	(1200, 3, NULL, 2, '10회차', '다음 중 테이블 스페이스(Tablespace)에 대한 설명으로 올바르지 않은 것은?', '하나의 테이블은 하나의 테이블스페이스에만 저장됩니다. 여러 테이블스페이스에 나누어 저장될 수 없습니다.', NULL, 11),
	(1201, 3, '[EMPLOYEE]\nEMP_ID    MANAGER_ID    NAME    LEVEL\n----------------------------------------\n1         NULL          김사장    1\n2         1             박부장    2\n3         1             이부장    2\n4         2             최대리    3\n5         2             정과장    3', 3, '10회차', '다음과 같은 테이블에서 계층형 쿼리를 사용해 직원의 조직도를 출력하는 SQL문으로 가장 적절한 것은?', '계층형 쿼리에서 CONNECT BY PRIOR EMP_ID = MANAGER_ID는 현재 행의 EMP_ID를 상위 행의 MANAGER_ID와 연결하는 구문입니다. 이는 하향식 계층 구조를 만듭니다.', NULL, 24),
	(1202, 3, NULL, 2, '10회차', '다음 중 SEQUENCE에 대한 설명으로 옳지 않은 것은?', 'CURRVAL은 현재 세션에서 NEXTVAL을 최소 한 번 실행한 후에만 사용할 수 있습니다. NEXTVAL을 실행하지 않은 상태에서 CURRVAL을 사용하면 오류가 발생합니다.', NULL, 29),
	(1203, 3, '```sql\nSELECT GREATEST(3, NULL, 5, 2), \n       LEAST(3, NULL, 5, 2)\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'NULL이 포함된 계산에서 GREATEST와 LEAST는 모두 NULL을 반환합니다.', NULL, 13),
	(1204, 3, '[EMPLOYEE]\nDEPT_ID    EMP_NAME\n--------------------\n10         김사원\n10         이사원\n20         박사원\n20         최사원\n30         정사원\n\n```sql\nSELECT DEPT_ID,\n       LISTAGG(EMP_NAME, \',\') WITHIN GROUP (ORDER BY EMP_NAME)\nFROM EMPLOYEE\nGROUP BY DEPT_ID;```', 2, '10회차', '다음과 같은 테이블이 있을 때, LISTAGG 함수를 사용한 결과로 올바른 것은?', 'LISTAGG 함수는 그룹별로 데이터를 연결하여 하나의 문자열로 만듭니다. WITHIN GROUP절의 ORDER BY에 따라 정렬된 순서로 연결됩니다.', NULL, 21),
	(1205, 3, NULL, 2, '10회차', '다음 중 SELECT 문의 실행 순서로 올바른 것은?', 'SELECT 문의 논리적 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다.', NULL, 12),
	(1206, 3, '```sql\nSELECT CAST(\'2024-01-01\' AS DATE) + INTERVAL \'1\' HOUR,\n       CAST(\'2024-01-01\' AS DATE) + 1/24\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', '두 표현식 모두 현재 시간에 1시간을 더하는 것으로, 동일한 결과를 반환합니다.', NULL, 13),
	(1207, 3, '[TRANSACTIONS]\nTRANS_ID    TRANS_DATE    AMOUNT\n---------------------------------\n1           2024-01-01    1000\n2           2024-01-02    2000\n3           2024-01-03    1500\n4           2024-01-04    3000\n5           2024-01-05    2500', 2, '10회차', '다음과 같은 데이터가 있을 때, 가장 최근 3개의 거래내역만 조회하는 SQL문으로 올바른 것은?', '최근 3개의 거래내역을 조회하기 위해서는 먼저 정렬을 수행한 후 상위 3개를 선택해야 합니다. 따라서 인라인 뷰를 사용한 두 번째 방법이 올바릅니다.', NULL, 23),
	(1208, 3, NULL, 2, '10회차', '다음 중 NULL 값에 대한 설명으로 틀린 것은?', 'NULL과 NULL의 비교는 FALSE가 아닌 UNKNOWN을 반환합니다.', NULL, 9),
	(1209, 3, NULL, 2, '10회차', '다음 중 DCL(Data Control Language)에 해당하지 않는 것은?', 'TRUNCATE는 DDL(Data Definition Language)에 속합니다. DCL은 데이터베이스의 접근 권한과 관련된 명령어들입니다.', NULL, 30),
	(1210, 3, '```sql\nSELECT ROUND(123.456, 2),\n       ROUND(123.456, 0),\n       ROUND(123.456, -1)\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'ROUND 함수는 지정된 소수점 자리에서 반올림합니다. 양수는 소수점 오른쪽, 0은 정수, 음수는 정수 왼쪽을 의미합니다.', NULL, 13),
	(1211, 3, '[SALES]\nYEAR    DEPT    AMOUNT\n------------------------\n2023    A       1000\n2023    B       2000\n2024    A       1500\n2024    B       2500', 3, '10회차', '다음과 같은 테이블에서 년도별, 부서별 매출 합계를 PIVOT을 사용하여 조회하는 SQL문으로 올바른 것은?', 'PIVOT 절은 행을 열로 변환합니다. 부서별 매출을 열로 표시하려면 FOR절에 DEPT를 지정해야 합니다.', NULL, 25),
	(1212, 3, NULL, 2, '10회차', '다음 중 인덱스(Index)의 특징으로 옳지 않은 것은?', '인덱스가 있으면 INSERT 시 인덱스도 함께 갱신해야 하므로 오히려 성능이 저하됩니다.', NULL, 11),
	(1213, 3, '```sql\nSELECT LEVEL, \n       LPAD(\' \', 2*(LEVEL-1)) || ENAME AS EMPLOYEE\nFROM EMP\nSTART WITH MGR IS NULL\nCONNECT BY PRIOR EMPNO = MGR;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'LPAD 함수를 사용하여 LEVEL에 따라 공백을 추가함으로써 계층형 구조를 시각적으로 표현합니다.', NULL, 24),
	(1214, 3, NULL, 2, '10회차', '다음 중 DML 성능을 향상시키는 방법으로 가장 적절하지 않은 것은?', '자주 COMMIT하면 UNDO 세그먼트를 자주 사용하게 되어 오히려 성능이 저하될 수 있습니다.', NULL, 27),
	(1215, 3, '[SALES]\nSALE_DATE    AMOUNT\n--------------------\n2024-01-01   1000\n2024-01-02   2000\n2024-01-03   1500\n2024-01-04   3000', 2, '10회차', '다음과 같은 테이블에서 누적 합계를 구하는 SQL문으로 올바른 것은?', '윈도우 함수에서 ORDER BY를 사용하면 누적 합계를 계산할 수 있습니다.', NULL, 22),
	(1216, 3, NULL, 2, '10회차', '다음 중 VIEW에 대한 설명으로 틀린 것은?', '뷰를 통해 INSERT된 데이터는 원본 테이블에 반영됩니다. 뷰는 가상 테이블이므로 독립적인 데이터 저장소가 없습니다.', NULL, 29),
	(1217, 3, '```sql\nCREATE TABLE TEST (\n    ID NUMBER PRIMARY KEY,\n    NAME VARCHAR2(10) NOT NULL UNIQUE\n);\n\nINSERT INTO TEST VALUES (1, \'AAA\');\nINSERT INTO TEST VALUES (2, \'BBB\');\nINSERT INTO TEST VALUES (1, \'CCC\');```', 2, '10회차', '다음 SQL문에서 발생하는 결과는?', '첫 두 개의 INSERT는 제약조건을 위배하지 않지만, 세 번째 INSERT는 PRIMARY KEY 제약조건을 위배하여 실패합니다.', NULL, 29),
	(1218, 3, NULL, 2, '10회차', '다음 중 ROLLUP과 CUBE의 차이점으로 옳은 것은?', 'ROLLUP은 지정된 컬럼의 계층적 집계를 생성하고, CUBE는 가능한 모든 조합의 집계를 생성합니다.', NULL, 21),
	(1219, 3, '[EMP]\nEMP_ID    DEPT_ID    SALARY\n---------------------------\n1001      10         5000\n1002      10         4000\n1003      20         6000\n1004      20         5500', 3, '10회차', '다음과 같은 테이블에서 부서별 평균 연봉보다 높은 연봉을 받는 직원을 조회하는 SQL문으로 올바른 것은?', '상관 서브쿼리를 사용하여 각 부서별 평균 급여를 계산하고, 이와 비교하여 높은 급여를 받는 직원을 찾습니다.', NULL, 19),
	(1220, 3, '```sql\nSELECT DECODE(NULL, NULL, \'A\',\n                    1, \'B\',\n                    2, \'C\',\n                    \'D\')\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'DECODE에서 첫 번째 비교값과 두 번째 비교값이 모두 NULL이므로 \'A\'를 반환합니다.', NULL, 13),
	(1221, 3, NULL, 1, '11회차', '데이터 모델링의 특징이 아닌 것은?', '명확화는 누구나 이해하기 쉽게 표현하는 것이지만, 하나의 엔터티에 대해 여러 관점을 제시하는 것은 오히려 혼란을 야기할 수 있습니다. 데이터 모델링은 단일하고 명확한 관점을 제시해야 합니다.', NULL, 1),
	(1222, 3, NULL, 2, '11회차', '다음 중 ERD에서 관계를 정의할 때 체크해야 할 사항이 아닌 것은?', '인덱스 전략은 물리적 설계 단계에서 고려할 사항이며, ERD에서 관계를 정의할 때 체크해야 할 사항이 아닙니다.', NULL, 1),
	(1223, 3, NULL, 2, '11회차', '주식별자의 특성으로 올바르지 않은 것은?', '주식별자의 특성 중 하나는 불변성입니다. 한번 정해진 값은 변하지 않아야 하므로, 변경성은 주식별자의 특성이 될 수 없습니다.', NULL, 4),
	(1224, 3, NULL, 2, '11회차', '다음 중 엔터티의 분류 기준이 아닌 것은?', '스키마에 따른 내부/외부 엔터티 분류는 일반적인 엔터티 분류 기준이 아닙니다.', NULL, 2),
	(1225, 3, NULL, 1, '11회차', '아래의 정의에 해당하는 속성 유형은?\n"업무를 수행하면서 생성되는 속성으로 다른 속성으로부터 계산되어 생성되는 속성"', '파생 속성은 다른 속성으로부터 계산이나 변형되어 생성되는 속성을 의미합니다. 예를 들어 나이(생년월일로부터 계산), 합계금액(수량*단가) 등이 있습니다.', NULL, 3),
	(1226, 3, NULL, 2, '11회차', '다음 중 정규화 과정에서 발생할 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상은 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않습니다.', NULL, 7),
	(1227, 3, NULL, 2, '11회차', '관계의 정의가 올바르지 않은 것은?', '관계는 엔터티 간의 논리적인 연관성을 표현하는 것으로, 물리적인 형태로 존재할 필요가 없습니다.', NULL, 5),
	(1228, 3, NULL, 2, '11회차', '다음 중 반정규화를 고려해야 하는 경우가 아닌 것은?', '입력, 수정, 삭제의 성능이 중요한 경우에는 오히려 정규화를 유지하는 것이 좋습니다. 반정규화는 조회 성능을 향상시키기 위해 고려됩니다.', NULL, 9),
	(1229, 3, NULL, 3, '11회차', '다음 중 식별자 관계를 사용해야 하는 경우로 가장 부적절한 것은?', '데이터의 양은 식별자 관계를 결정하는 기준이 되지 않습니다. 식별자 관계는 업무적 연관성과 존재 종속성에 기반하여 결정해야 합니다.', NULL, 4),
	(1230, 3, NULL, 2, '11회차', 'M:M 관계를 해소하기 위한 방법으로 가장 적절한 것은?', 'M:M 관계는 새로운 관계엔터티를 생성하여 1:M, M:1 관계로 해소하는 것이 일반적입니다. 이를 통해 두 엔터티 간의 관계를 명확하게 표현할 수 있습니다.', NULL, 5),
	(1231, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 각 부서별 최고 연봉자의 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최고 연봉자를 찾기 위해서는 상관 서브쿼리를 사용하여 각 부서별로 최대 급여와 비교해야 합니다.', NULL, 17),
	(1232, 3, NULL, 2, '11회차', '다음 중 ROLLUP 함수와 CUBE 함수의 차이점으로 올바른 것은?', 'ROLLUP은 지정된 컬럼의 계층 구조로 소계를 계산하고, CUBE는 지정된 컬럼들의 모든 가능한 조합으로 소계를 계산합니다.', NULL, 21),
	(1233, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과는?', 'REPLACE는 특정 문자열을 다른 문자열로 대체하고, TRANSLATE는 지정된 문자를 일대일로 변환합니다. \'BC\'를 \'DE\'로 변환하므로 각각의 문자가 대체됩니다.', NULL, 13),
	(1234, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 모든 부서와 사원 정보를 조회하는 SQL문으로 올바른 것은?', '모든 부서 정보와 해당 부서의 사원 정보를 조회하기 위해서는 LEFT OUTER JOIN을 사용해야 합니다.', NULL, 17),
	(1235, 3, NULL, 2, '11회차', '다음 중 DELETE문에 대한 설명으로 틀린 것은?', 'DELETE문으로 삭제된 데이터는 트랜잭션이 COMMIT되기 전에는 ROLLBACK으로 복구할 수 있습니다.', NULL, 26),
	(1236, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'LAG는 이전 행의 값을, LEAD는 다음 행의 값을 가져오며, 값이 없는 경우 지정된 기본값(0)을 반환합니다.', NULL, 22),
	(1237, 3, NULL, 1, '11회차', '다음 중 WHERE 절에서 사용할 수 있는 연산자가 아닌 것은?', 'GROUP BY는 WHERE 절에서 사용할 수 없는 구문입니다. GROUP BY는 독립적인 절로 사용됩니다.', NULL, 14),
	(1238, 3, NULL, 1, '11회차', '다음 중 날짜 함수에 대한 설명으로 틀린 것은?', 'NEXT_DAY는 지정된 날짜로부터 명시된 요일이 처음으로 도래하는 날짜를 반환합니다. 반드시 주말을 반환하는 것은 아닙니다.', NULL, 12),
	(1239, 3, NULL, 2, '11회차', '다음과 같은 테이블이 있을 때, 부서별 평균 연봉보다 높은 연봉을 받는 직원을 조회하는 SQL문으로 올바른 것은?', '부서별 평균 연봉과 비교하기 위해서는 상관 서브쿼리를 사용하여 각 직원이 속한 부서의 평균 연봉을 구해야 합니다.', NULL, 17),
	(1240, 3, NULL, 1, '11회차', '다음 중 NULL 값에 대한 설명으로 올바르지 않은 것은?', 'NULL과 NULL은 같다고 판단할 수 없습니다. NULL과의 비교는 항상 UNKNOWN을 반환합니다.', NULL, 9),
	(1241, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과는?', 'CONNECT_BY_ISLEAF는 해당 노드가 리프 노드(자식이 없는 노드)일 경우 1, 아닐 경우 0을 반환합니다. LEVEL이 2와 3인 노드는 리프 노드입니다.', NULL, 24),
	(1242, 3, NULL, 2, '11회차', '다음 중 WITH절(Common Table Expression)의 특징이 아닌 것은?', 'WITH절은 쿼리가 완전히 종료될 때까지 메모리에 유지됩니다. 즉시 삭제되지 않습니다.', NULL, 20),
	(1243, 3, NULL, 2, '11회차', '다음과 같은 테이블이 있을 때, MERGE문을 사용하는 가장 적절한 경우는?', 'MERGE문은 조건에 따라 UPDATE 또는 INSERT를 수행할 때 사용하는 것이 가장 적절합니다.', NULL, 27),
	(1244, 3, NULL, 2, '11회차', '다음 중 인덱스를 생성하는 것이 가장 부적절한 경우는?', 'NULL값이 많은 컬럼은 인덱스의 효율성이 떨어지므로 인덱스 생성이 부적절합니다.', NULL, 30),
	(1245, 3, NULL, 2, '11회차', '다음 SQL문이 실행될 때의 결과로 올바른 것은?', 'UNIQUE 제약조건으로 인해 동일한 NAME 값을 가진 두 번째 INSERT문은 실패합니다.', NULL, 28),
	(1246, 3, NULL, 2, '11회차', '다음 중 트랜잭션의 ACID 특성으로 올바르지 않은 것은?', 'Isolation(격리성)은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 보장하는 것을 의미합니다. 반드시 완료될 때까지 대기하는 것은 아닙니다.', NULL, 29),
	(1247, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과는?', 'TO_NUMBER(\'123.45\')는 오류가 발생합니다. 소수점이 있는 문자열은 TO_NUMBER 함수로 직접 변환할 수 없습니다.', NULL, 13),
	(1248, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 누적 합계를 구하는 SQL문으로 올바른 것은?', '윈도우 함수를 사용하여 ORDER BY와 함께 SUM을 적용하면 누적 합계를 구할 수 있습니다.', NULL, 22),
	(1249, 3, NULL, 1, '11회차', '다음 중 DDL(Data Definition Language)에 해당하지 않는 것은?', 'COMMIT은 TCL(Transaction Control Language)에 속합니다. DDL은 데이터베이스의 구조를 정의하는 명령어들입니다.', NULL, 30),
	(1250, 3, NULL, 2, '11회차', '다음 중 NULL 관련 함수의 설명으로 틀린 것은?', 'COALESCE는 지정된 표현식들 중에서 첫 번째로 NULL이 아닌 값을 반환합니다. 반드시 첫 번째 값이 아닐 수 있습니다.', NULL, 9),
	(1251, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 부서별로 급여 순위를 매기는 SQL문으로 올바른 것은?', '부서별로 급여 순위를 매기기 위해서는 PARTITION BY와 ORDER BY를 함께 사용해야 합니다.', NULL, 22),
	(1252, 3, NULL, 2, '11회차', '다음 중 EXISTS 연산자의 특징으로 올바르지 않은 것은?', 'EXISTS는 조건을 만족하는 행을 찾으면 즉시 검색을 중단합니다. 모든 행을 검색하지 않습니다.', NULL, 20),
	(1253, 3, NULL, 1, '11회차', '다음 SQL문의 실행 결과는?', 'MOD는 나머지(1), CEIL은 올림(4), FLOOR는 내림(3), ROUND는 반올림(3.6)을 반환합니다.', NULL, 13),
	(1254, 3, NULL, 1, '11회차', '다음 중 GROUP BY절에 대한 설명으로 틀린 것은?', 'GROUP BY절에 있는 컬럼이 SELECT절에 반드시 포함될 필요는 없습니다.', NULL, 15),
	(1255, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 중복된 데이터를 제거하는 SQL문으로 가장 효율적인 것은?', 'ROWID를 이용한 방법이 가장 효율적입니다. 각 행의 고유한 식별자를 사용하여 중복을 제거합니다.', NULL, 27),
	(1256, 3, NULL, 2, '11회차', '다음 중 조인(JOIN)의 특징으로 올바르지 않은 것은?', 'LEFT OUTER JOIN은 왼쪽 테이블의 모든 데이터를 포함합니다. 오른쪽 테이블의 모든 데이터를 포함하는 것은 RIGHT OUTER JOIN입니다.', NULL, 17),
	(1257, 3, NULL, 1, '11회차', '다음 SQL문의 실행 결과는?', 'EXTRACT 함수는 날짜에서 특정 부분을 숫자형으로 추출합니다.', NULL, 12),
	(1258, 3, NULL, 2, '11회차', '다음 중 서브쿼리의 특징으로 틀린 것은?', '서브쿼리에서는 ORDER BY절을 사용할 수 없습니다. ORDER BY는 전체 쿼리의 마지막 결과를 정렬할 때만 사용됩니다.', NULL, 20),
	(1259, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 PIVOT을 사용한 결과로 올바른 것은?', 'PIVOT은 행을 열로 변환하며, 지정된 그룹화 함수(SUM)의 결과를 표시합니다.', NULL, 25),
	(1260, 3, NULL, 3, '11회차', '다음 중 데이터베이스 트랜잭션의 격리 수준으로 가장 높은 것은?', '트랜잭션 격리 수준은 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 높아집니다.', NULL, 29),
	(1261, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 각 월별 매출액과 전월 대비 증감률을 구하는 SQL문으로 올바른 것은?', 'LAG 함수를 사용하여 이전 월의 매출액을 가져오고, 이를 통해 증감률을 계산합니다.', NULL, 22),
	(1262, 3, NULL, 2, '11회차', '다음 중 테이블 스페이스(Tablespace)에 대한 설명으로 옳지 않은 것은?', '하나의 테이블은 하나의 테이블스페이스에만 저장됩니다. 여러 테이블스페이스에 분산 저장될 수 없습니다.', NULL, 30),
	(1263, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 계층형 질의를 사용한 결과로 올바른 것은?', 'LPAD 함수를 사용하여 레벨에 따른 들여쓰기를 적용하여 계층 구조를 표현합니다.', NULL, 24),
	(1264, 3, NULL, 2, '11회차', '다음과 같은 테이블이 있을 때, MERGE 문을 사용하는 적절한 경우는?', 'MERGE문은 데이터가 존재하면 UPDATE하고 없으면 INSERT하는 경우에 적절합니다.', NULL, 27),
	(1265, 3, NULL, 2, '11회차', '다음 중 인덱스(Index)의 특징으로 올바르지 않은 것은?', '데이터의 수정이 빈번한 컬럼에 인덱스를 생성하면 성능이 저하될 수 있습니다.', NULL, 30),
	(1266, 3, NULL, 3, '11회차', '다음과 같은 데이터가 있을 때, 부서별 최근 3명의 입사자를 조회하는 SQL문으로 옳은 것은?', 'ROW_NUMBER()와 PARTITION BY를 사용하여 부서별로 입사일자 순으로 순번을 부여하고 최근 3명을 선택합니다.', NULL, 22),
	(1267, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'INSTR은 문자열에서 특정 문자의 위치를 반환하며, 찾지 못한 경우 0을 반환합니다.', NULL, 13),
	(1268, 3, NULL, 2, '11회차', '다음 중 트랜잭션에 대한 설명으로 틀린 것은?', 'SAVEPOINT는 부분 ROLLBACK을 위한 것이며, 부분 COMMIT은 불가능합니다.', NULL, 29),
	(1269, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 부서별 직급별 평균 급여를 조회하는 SQL문으로 올바른 것은?', '부서별, 직급별 평균 급여를 구하기 위해서는 GROUP BY절에 두 컬럼을 모두 지정해야 합니다.', NULL, 15),
	(1270, 3, NULL, 1, '11회차', '다음 중 PL/SQL의 특징이 아닌 것은?', 'PL/SQL에서는 COMMIT, ROLLBACK 등의 트랜잭션 제어가 가능합니다.', NULL, 26),
	(1271, 3, NULL, 2, '12회차', '다음 중 엔터티(Entity)의 분류 방식으로 가장 부적절한 것은?', '엔터티의 일반적인 분류는 유형/개념 엔터티, 기본/중심/행위 엔터티, 실체/가상 엔터티입니다. "기초 엔터티와 행위 엔터티"는 분류 기준으로 적절하지 않습니다.', NULL, 2),
	(1272, 3, NULL, 2, '12회차', '아래의 설명에 해당하는 것은?\n"두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가진다."', '행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가집니다.', NULL, 2),
	(1273, 3, NULL, 2, '12회차', '다음 중 관계(Relationship)의 표기법에 포함되지 않는 것은?', '관계의 표기법에는 관계명, 관계차수, 관계선택사양이 포함됩니다. 관계스키마는 관계의 표기법에 포함되지 않습니다.', NULL, 5),
	(1274, 3, NULL, 2, '12회차', '다음 중 식별자가 가져야 할 특징이 아닌 것은?', '식별자의 특성에는 유일성, 최소성, 불변성, 존재성이 있습니다. 대체성은 식별자의 특성이 아닙니다.', NULL, 4),
	(1275, 3, NULL, 1, '12회차', '다음 중 정규화 과정에서 발생할 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않습니다.', NULL, 7),
	(1276, 3, NULL, 2, '12회차', '관계의 정의가 잘못된 것은?', '관계는 엔터티 간의 연관성을 표현하는 것으로, 반드시 동사나 동사구를 사용해야 한다는 것은 잘못된 설명입니다. 관계는 명사형으로도 표현될 수 있습니다.', NULL, 5),
	(1277, 3, NULL, 2, '12회차', '다음 중 도메인(Domain)에 대한 설명으로 옳지 않은 것은?', '도메인은 속성이 가질 수 있는 값의 범위를 의미하며, 반드시 물리적으로 구현될 필요는 없습니다.', NULL, 3),
	(1278, 3, NULL, 2, '12회차', '아래의 ER 다이어그램에서 적절하지 않은 관계 표현은?', '주어진 ER 다이어그램에서 하나의 과목은 여러 개의 수강내역과 연결될 수 있어야 합니다. 따라서 "하나의 과목은 하나의 수강내역에만 연결된다"는 설명은 잘못되었습니다.', NULL, 5),
	(1279, 3, NULL, 2, '12회차', '다음 중 비식별자 관계의 특징이 아닌 것은?', '비식별자 관계에서는 부모 테이블의 기본키가 자식 테이블의 기본키로 전이되지 않고 일반 컬럼으로 전이됩니다.', NULL, 5),
	(1280, 3, NULL, 2, '12회차', '슈퍼타입/서브타입 모델링에 대한 설명 중 틀린 것은?', '하나의 슈퍼타입은 여러 개의 서브타입을 가질 수 있습니다. 하나의 슈퍼타입이 반드시 하나의 서브타입만 가질 수 있다는 설명은 잘못되었습니다.', NULL, 5),
	(1281, 3, NULL, 2, '12회차', '다음 중 SELECT 문장의 실행 순서로 올바른 것은?', 'SQL 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다.', NULL, 11),
	(1282, 3, NULL, 2, '12회차', '다음의 테이블에서 SQL을 실행했을 때의 결과로 맞는 것은?', 'GROUP BY 절이 없는 집계함수는 전체 데이터를 하나의 그룹으로 처리합니다. COUNT(*)는 전체 행의 수(5), COUNT(DISTINCT SALARY)는 중복을 제거한 SALARY의 수(3)를 반환합니다.', NULL, 21),
	(1283, 3, NULL, 2, '12회차', '다음 중 NULL 관련 함수에 대한 설명으로 틀린 것은?', 'ISNULL은 SQL Server에서만 사용 가능한 함수입니다. Oracle에서는 NVL을 사용해야 합니다.', NULL, 9),
	(1284, 3, NULL, 2, '12회차', '다음의 SQL문에서 결과값이 다른 것은?', '첫 세 개의 쿼리는 동일한 결과를 반환하지만, 네 번째 쿼리는 SAL이 0보다 큰 부서만 출력하므로 다른 결과가 나올 수 있습니다.', NULL, 15),
	(1285, 3, NULL, 2, '12회차', '다음 중 WINDOW 함수의 프레임 절(Frame Clause)에 대한 설명으로 올바르지 않은 것은?', 'CURRENT ROW는 현재 행을 의미하며, 앞뒤 기준이 아닙니다.', NULL, 22),
	(1286, 3, NULL, 2, '12회차', '다음과 같은 테이블이 있을 때, 가장 많은 결과 행을 출력하는 JOIN은?', 'FULL OUTER JOIN은 양쪽 테이블의 모든 행을 포함하므로 가장 많은 결과 행을 출력합니다.', NULL, 17),
	(1287, 3, NULL, 2, '12회차', '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Durability(영구성)는 트랜잭션이 성공적으로 완료된 후에는 영구적으로 반영되어야 함을 의미합니다.', NULL, 29),
	(1288, 3, NULL, 2, '12회차', '다음 중 계층형 질의문에서 사용되는 가상 칼럼이 아닌 것은?', 'CONNECT_BY_PARENT는 계층형 질의문의 가상 칼럼이 아닙니다. 실제 가상 칼럼은 LEVEL, CONNECT_BY_ROOT, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE 등이 있습니다.', NULL, 24),
	(1289, 3, NULL, 2, '12회차', '아래의 테이블에서 SQL을 실행한 결과로 맞는 것은?', 'CASE문을 사용한 조건부 집계에서 1,2분기 합계는 300(100+200), 3,4분기 합계는 700(300+400)이 됩니다.', NULL, 21),
	(1290, 3, NULL, 2, '12회차', '다음 중 인덱스에 대한 설명으로 부적절한 것은?', '모든 컬럼에 인덱스를 생성하면 오히려 성능이 저하될 수 있습니다. 인덱스는 필요한 컬럼에만 선별적으로 생성해야 합니다.', NULL, 30),
	(1291, 3, NULL, 2, '12회차', '다음 중 서브쿼리에 대한 설명으로 틀린 것은?', '서브쿼리는 제한 없이 중첩이 가능합니다. 단, 과도한 중첩은 성능에 영향을 줄 수 있으므로 적절히 사용해야 합니다.', NULL, 20),
	(1292, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 실행한 SQL의 결과는?', 'COUNT(*)는 NULL을 포함한 모든 행의 수(2), COUNT(SALARY)는 NULL을 제외한 행의 수(1)를 반환합니다.', NULL, 21),
	(1293, 3, NULL, 2, '12회차', '아래의 테이블에서 각 부서별로 가장 높은 급여를 받는 사원을 조회하는 SQL로 적절하지 않은 것은?', 'SAL > ANY는 하나라도 큰 값이 있으면 TRUE를 반환하므로, 각 부서에서 가장 높은 급여를 받는 사원을 찾는 조건으로 적절하지 않습니다.', NULL, 17),
	(1294, 3, NULL, 2, '12회차', '다음과 같은 테이블이 있을 때, MERGE 문을 실행한 후의 결과로 옳은 것은?', 'MERGE 문에서 MATCHED는 ID가 같은 경우 UPDATE를 수행하고(1,X), NOT MATCHED는 TARGET_TABLE에 없는 데이터를 INSERT합니다(3,C).', NULL, 27),
	(1295, 3, NULL, 2, '12회차', '다음 중 윈도우 함수에 대한 설명으로 잘못된 것은?', 'RANK는 동일한 값에 대해 동일한 순위를 부여하고 다음 순위는 건너뛰지만, DENSE_RANK는 다음 순위를 이어서 부여합니다.', NULL, 22),
	(1296, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 SELECT 문을 실행했을 때 결과는?', 'COUNT(*)는 NULL을 포함한 전체 행 수(3), COUNT(PRICE)는 NULL을 제외한 행 수(2), COUNT(DISTINCT PRICE)는 중복을 제거한 NULL이 아닌 값의 수(2)를 반환합니다.', NULL, 21),
	(1297, 3, NULL, 2, '12회차', '아래의 SQL을 실행했을 때, 실행되지 않는 것은?', 'NAME 컬럼이 NOT NULL 제약조건이 있으므로, NAME 값을 지정하지 않은 4번 INSERT문은 실행되지 않습니다.', NULL, 27),
	(1298, 3, NULL, 2, '12회차', '다음 중 데이터베이스 트랜잭션 격리수준(Isolation Level)에 대한 설명으로 틀린 것은?', 'READ COMMITTED는 Phantom Read를 방지할 수 없습니다. Phantom Read는 REPEATABLE READ 이상의 격리수준에서 방지됩니다.', NULL, 29),
	(1299, 3, NULL, 2, '12회차', '아래의 두 테이블을 JOIN할 때, 가장 많은 결과 행이 생성되는 경우는?', 'FULL OUTER JOIN은 양쪽 테이블의 모든 행을 포함하고 매칭되지 않는 행도 NULL로 포함하므로 가장 많은 결과 행이 생성됩니다.', NULL, 17),
	(1300, 3, NULL, 2, '12회차', '다음의 계층형 쿼리에 대한 설명으로 틀린 것은?', 'START WITH 절은 선택사항입니다. START WITH 절이 없으면 모든 노드가 루트 노드가 될 수 있습니다.', NULL, 24),
	(1301, 3, NULL, 2, '12회차', '다음 중 GROUP BY 절에 대한 설명으로 틀린 것은?', 'GROUP BY 절에서는 집계 함수를 사용할 수 있습니다.', NULL, 15),
	(1302, 3, NULL, 2, '12회차', '다음 테이블에서 SQL을 실행했을 때의 결과는?', 'GROUP BY MONTH로 그룹화하고, NVL 함수를 사용하여 NULL값을 \'00\'으로 변환합니다.', NULL, 21),
	(1303, 3, NULL, 2, '12회차', '다음 중 UNION과 UNION ALL의 차이점에 대한 설명으로 옳지 않은 것은?', 'UNION이 자동으로 정렬된다는 것은 잘못된 설명입니다. ORDER BY를 사용하지 않으면 정렬되지 않습니다.', NULL, 20),
	(1304, 3, NULL, 2, '12회차', '다음 중 테이블 생성 시 제약조건에 대한 설명으로 틀린 것은?', 'PRIMARY KEY 제약조건은 테이블당 하나만 설정할 수 있습니다.', NULL, 30),
	(1305, 3, NULL, 2, '12회차', '아래의 SQL문을 실행했을 때 결과로 적절한 것은?', 'SUBSTR 함수에서 음수 위치는 뒤에서부터 계산하므로, -3은 뒤에서 3번째 위치에서 시작하여 2개의 문자를 추출합니다.', NULL, 13),
	(1306, 3, NULL, 2, '12회차', '각 부서별 평균 급여보다 높은 급여를 받는 사원을 조회하는 SQL로 올바른 것은?', '상관 서브쿼리를 사용하여 각 부서별 평균 급여를 구하고, 이와 비교하는 것이 올바른 방법입니다.', NULL, 21),
	(1307, 3, NULL, 2, '12회차', '다음 중 데이터베이스 트랜잭션의 Commit과 Rollback에 대한 설명으로 틀린 것은?', 'Commit이 수행된 이후에는 Rollback을 통해 이전 상태로 되돌릴 수 없습니다.', NULL, 29),
	(1308, 3, NULL, 2, '12회차', '다음과 같은 계층형 쿼리에서 결과로 알맞은 것은?', 'LPAD 함수를 사용하여 LEVEL값에 따라 들여쓰기가 적용되어 계층 구조가 시각적으로 표현됩니다.', NULL, 24),
	(1309, 3, NULL, 2, '12회차', '다음 중 인덱스를 사용할 수 없는 경우는?', 'WHERE 절에서 컬럼에 함수를 적용하면 인덱스를 사용할 수 없습니다. 이를 함수 기반 인덱스로 해결할 수 있습니다.', NULL, 30),
	(1310, 3, NULL, 2, '12회차', '아래의 테이블에서 부서별로 최고 급여를 받는 직원을 조회하기 위한 SQL문 중 틀린 것은?', 'GROUP BY 절에서는 집계함수와 GROUP BY에 명시된 컬럼만 SELECT 할 수 있습니다. 또한 WHERE 절에서는 집계함수를 사용할 수 없습니다.', NULL, 17),
	(1311, 3, NULL, 2, '12회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'DCL(Data Control Language)은 데이터베이스에 대한 접근 권한을 제어하는 명령어로 GRANT(권한 부여)와 REVOKE(권한 회수)가 있습니다.', NULL, 30),
	(1312, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 윈도우 함수를 사용한 SQL의 결과로 옳은 것은?', 'ROWS BETWEEN 1 PRECEDING AND CURRENT ROW는 현재 행과 이전 행의 값을 합산합니다. 따라서 첫 행은 자신만의 값, 두 번째 행부터는 자신과 이전 행의 합이 됩니다.', NULL, 22),
	(1313, 3, NULL, 2, '12회차', '다음 중 테이블 변경(ALTER TABLE)에 대한 설명으로 틀린 것은?', '기본키를 삭제할 때 관련된 외래키가 있으면 오류가 발생합니다. 자동으로 삭제되지 않습니다.', NULL, 30),
	(1314, 3, NULL, 2, '12회차', '아래의 테이블에서 REGEXP_LIKE 함수를 사용한 SQL 결과로 올바른 것은?', '^[A-Z]+[0-9]+$는 처음에 대문자가 하나 이상, 그 다음에 숫자가 하나 이상 나오는 패턴을 의미합니다. 이 조건을 만족하는 것은 \'ABC123\'입니다.', NULL, 26),
	(1315, 3, NULL, 2, '12회차', '다음 중 데이터베이스 트랜잭션 격리 수준에서 발생할 수 있는 현상이 아닌 것은?', '트랜잭션 격리 수준에서 발생할 수 있는 현상은 Dirty Read, Non-Repeatable Read, Phantom Read입니다. Isolated Read는 존재하지 않는 용어입니다.', NULL, 29),
	(1316, 3, NULL, 2, '12회차', '다음의 DDL 문장을 실행했을 때, 오류가 발생하는 것은?', '하나의 테이블에 두 개의 PRIMARY KEY 제약조건을 정의할 수 없습니다.', NULL, 30),
	(1317, 3, NULL, 2, '12회차', '다음 중 Oracle의 날짜 함수에 대한 설명으로 틀린 것은?', 'NEXT_DAY는 명시된 날짜보다 크고 명시된 요일에 해당하는 첫 번째 날짜를 반환합니다. 반드시 다음 주의 같은 요일이 아닐 수 있습니다.', NULL, 13),
	(1318, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 부서별 순위를 매기는 SQL문 중 틀린 것은?', 'RANK() OVER 절과 GROUP BY 절은 함께 사용할 수 없습니다. 또한 PARTITION BY를 사용하지 않으면 전체 데이터에 대한 순위가 매겨집니다.', NULL, 22),
	(1319, 3, NULL, 2, '12회차', '다음 중 TOP-N 쿼리에 대한 설명으로 틀린 것은?', 'TOP-N 쿼리에서 ORDER BY 절은 선택사항입니다. 정렬이 필요 없는 경우에는 사용하지 않을 수 있습니다.', NULL, 23),
	(1320, 3, NULL, 2, '12회차', '다음 중 데이터베이스 락(Lock)에 대한 설명으로 옳지 않은 것은?', '락의 크기가 작을수록 동시성은 증가하고 일관성은 감소합니다. 반대로 락의 크기가 클수록 동시성은 감소하고 일관성은 증가합니다.', NULL, 29);
/*!40000 ALTER TABLE `question` ENABLE KEYS */;

-- 테이블 데이터 qriz.skill:~30 rows (대략적) 내보내기
/*!40000 ALTER TABLE `skill` DISABLE KEYS */;
INSERT INTO `skill` (`skill_id`, `description`, `frequency`, `importance_level`, `key_concepts`, `title`, `type`, `version`) VALUES
	(1, '데이터 모델의 개념, 구성요소 및 데이터 모델링 절차에 대한 기본적인 이해', 74, '상', '데이터모델의 이해', '1과목', '데이터 모델링의 이해', NULL),
	(2, '업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것(thing)으로 서로 구별되는 객체', 1, '하', '엔터티', '1과목', '데이터 모델링의 이해', NULL),
	(3, '업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위', 57, '상', '속성', '1과목', '데이터 모델링의 이해', NULL),
	(4, '엔터티를 유일하게 구분할 수 있는 속성 또는 속성의 집합', 28, '하', '식별자', '1과목', '데이터 모델링의 이해', NULL),
	(5, '엔터티 간의 업무적 연관성 및 데이터 연관성', 3, '하', '관계', '1과목', '데이터 모델링의 이해', NULL),
	(6, '엔터티 간의 관계 유형과 SQL에서의 조인 연산에 대한 이해', 6, '하', '관계와 조인의 이해', '1과목', '데이터 모델과 SQL', NULL),
	(7, '데이터의 중복을 최소화하고 데이터 무결성을 보장하기 위한 데이터베이스 설계 기법', 41, '중', '정규화', '1과목', '데이터 모델과 SQL', NULL),
	(8, '데이터 모델에서 표현되는 업무 규칙과 트랜잭션의 관계 이해', 7, '하', '모델이 표현하는 트랜잭션의 이해', '1과목', '데이터 모델과 SQL', NULL),
	(9, '데이터베이스에서 Null 값의 의미와 처리 방법에 대한 이해', 8, '하', 'Null 속성의 이해', '1과목', '데이터 모델과 SQL', NULL),
	(10, '자연적으로 발생하는 식별자와 인위적으로 만들어진 식별자의 차이점과 사용 시 고려사항', 9, '하', '본질 식별자 vs 인조 식별자', '1과목', '데이터 모델과 SQL', NULL),
	(11, '관계형 데이터베이스의 기본 개념, 특징 및 구조에 대한 이해', 10, '하', '관계형 데이터 베이스 개요', '2과목', 'SQL 기본', NULL),
	(12, '데이터베이스에서 데이터를 조회하는 기본적인 SQL 명령문', 104, '상', 'SELECT 문', '2과목', 'SQL 기본', NULL),
	(13, 'SQL에서 사용되는 다양한 내장 함수들의 종류와 사용법', 72, '상', '함수', '2과목', 'SQL 기본', NULL),
	(14, 'SQL 쿼리에서 조건을 지정하여 원하는 데이터만 필터링하는 방법', 64, '상', 'WHERE 절', '2과목', 'SQL 기본', NULL),
	(15, '데이터를 그룹화하고 그룹별 조건을 지정하는 SQL 구문', 14, '하', 'GROUP BY, HAVING 절', '2과목', 'SQL 기본', NULL),
	(16, '쿼리 결과를 정렬하는 SQL 구문', 15, '하', 'ORDER BY 절', '2과목', 'SQL 기본', NULL),
	(17, '여러 테이블의 데이터를 연결하여 조회하는 SQL 기법', 105, '상', '조인', '2과목', 'SQL 기본', NULL),
	(18, 'ANSI SQL 표준에 따른 조인 구문과 그 사용법', 16, '하', '표준 조인', '2과목', 'SQL 기본', NULL),
	(19, '쿼리 내부에 포함된 또 다른 쿼리로, 복잡한 데이터 검색에 활용', 56, '상', '서브 쿼리', '2과목', 'SQL 활용', NULL),
	(20, '여러 쿼리 결과를 하나로 결합하는 UNION, INTERSECT, MINUS 등의 연산자', 24, '하', '집합 연산자', '2과목', 'SQL 활용', NULL),
	(21, '데이터 그룹에 대한 계산을 수행하는 SQL 함수들', 20, '하', '그룹 함수', '2과목', 'SQL 활용', NULL),
	(22, '행과 행 간의 관계를 정의하여 결과를 출력하는 함수', 24, '하', '윈도우 함수', '2과목', 'SQL 활용', NULL),
	(23, '조건에 맞는 상위 N개의 레코드를 추출하는 쿼리 기법', 18, '하', 'Top N 쿼리', '2과목', 'SQL 활용', NULL),
	(24, '계층적 데이터 구조를 다루는 SQL 기법과 같은 테이블 내에서의 조인', 31, '중', '계층형 질의와 셀프 조인', '2과목', 'SQL 활용', NULL),
	(25, '행 데이터를 열 데이터로, 열 데이터를 행 데이터로 변환하는 SQL 기법', 19, '하', 'PIVOT 절과 UNPIVOT 절', '2과목', 'SQL 활용', NULL),
	(26, '문자열 패턴을 정의하고 검색, 치환하는 기법', 21, '하', '정규 표현식', '2과목', 'SQL 활용', NULL),
	(27, '데이터 조작어: INSERT, UPDATE, DELETE 등 데이터를 조작하는 SQL 명령어', 36, '중', 'DML', '2과목', '관리구문', NULL),
	(28, '트랜잭션 제어어: COMMIT, ROLLBACK 등 트랜잭션을 제어하는 명령어', 17, '하', 'TCL', '2과목', '관리구문', NULL),
	(29, '데이터 정의어: CREATE, ALTER, DROP 등 데이터베이스 객체를 정의하는 SQL 명령어', 29, '하', 'DDL', '2과목', '관리구문', NULL),
	(30, '데이터 제어어: GRANT, REVOKE 등 데이터베이스 접근 권한을 제어하는 명령어', 22, '하', 'DCL', '2과목', '관리구문', NULL);

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */;
