-- --------------------------------------------------------
-- 호스트:                          127.0.0.1
-- 서버 버전:                        8.0.33 - MySQL Community Server - GPL
-- 서버 OS:                        Win64
-- HeidiSQL 버전:                  11.3.0.6295
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!50503 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

-- 테이블 데이터 qriz.skill:~30 rows (대략적) 내보내기
/*!40000 ALTER TABLE `skill` DISABLE KEYS */;
INSERT INTO `skill` (`skill_id`, `description`, `frequency`, `importance_level`, `key_concepts`, `title`, `type`, `version`) VALUES
	(1, '데이터 모델의 개념, 구성요소 및 데이터 모델링 절차에 대한 기본적인 이해', 74, '상', '데이터모델의 이해', '1과목', '데이터 모델링의 이해', NULL),
	(2, '업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것(thing)으로 서로 구별되는 객체', 1, '하', '엔터티', '1과목', '데이터 모델링의 이해', NULL),
	(3, '업무에서 필요로 하는 인스턴스로 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위', 57, '상', '속성', '1과목', '데이터 모델링의 이해', NULL),
	(4, '엔터티를 유일하게 구분할 수 있는 속성 또는 속성의 집합', 28, '하', '식별자', '1과목', '데이터 모델링의 이해', NULL),
	(5, '엔터티 간의 업무적 연관성 및 데이터 연관성', 3, '하', '관계', '1과목', '데이터 모델링의 이해', NULL),
	(6, '엔터티 간의 관계 유형과 SQL에서의 조인 연산에 대한 이해', 6, '하', '관계와 조인의 이해', '1과목', '데이터 모델과 SQL', NULL),
	(7, '데이터의 중복을 최소화하고 데이터 무결성을 보장하기 위한 데이터베이스 설계 기법', 41, '중', '정규화', '1과목', '데이터 모델과 SQL', NULL),
	(8, '데이터 모델에서 표현되는 업무 규칙과 트랜잭션의 관계 이해', 7, '하', '모델이 표현하는 트랜잭션의 이해', '1과목', '데이터 모델과 SQL', NULL),
	(9, '데이터베이스에서 Null 값의 의미와 처리 방법에 대한 이해', 8, '하', 'Null 속성의 이해', '1과목', '데이터 모델과 SQL', NULL),
	(10, '자연적으로 발생하는 식별자와 인위적으로 만들어진 식별자의 차이점과 사용 시 고려사항', 9, '하', '본질 식별자 vs 인조 식별자', '1과목', '데이터 모델과 SQL', NULL),
	(11, '관계형 데이터베이스의 기본 개념, 특징 및 구조에 대한 이해', 10, '하', '관계형 데이터 베이스 개요', '2과목', 'SQL 기본', NULL),
	(12, '데이터베이스에서 데이터를 조회하는 기본적인 SQL 명령문', 104, '상', 'SELECT 문', '2과목', 'SQL 기본', NULL),
	(13, 'SQL에서 사용되는 다양한 내장 함수들의 종류와 사용법', 72, '상', '함수', '2과목', 'SQL 기본', NULL),
	(14, 'SQL 쿼리에서 조건을 지정하여 원하는 데이터만 필터링하는 방법', 64, '상', 'WHERE 절', '2과목', 'SQL 기본', NULL),
	(15, '데이터를 그룹화하고 그룹별 조건을 지정하는 SQL 구문', 14, '하', 'GROUP BY, HAVING 절', '2과목', 'SQL 기본', NULL),
	(16, '쿼리 결과를 정렬하는 SQL 구문', 15, '하', 'ORDER BY 절', '2과목', 'SQL 기본', NULL),
	(17, '여러 테이블의 데이터를 연결하여 조회하는 SQL 기법', 105, '상', '조인', '2과목', 'SQL 기본', NULL),
	(18, 'ANSI SQL 표준에 따른 조인 구문과 그 사용법', 16, '하', '표준 조인', '2과목', 'SQL 기본', NULL),
	(19, '쿼리 내부에 포함된 또 다른 쿼리로, 복잡한 데이터 검색에 활용', 56, '상', '서브 쿼리', '2과목', 'SQL 활용', NULL),
	(20, '여러 쿼리 결과를 하나로 결합하는 UNION, INTERSECT, MINUS 등의 연산자', 24, '하', '집합 연산자', '2과목', 'SQL 활용', NULL),
	(21, '데이터 그룹에 대한 계산을 수행하는 SQL 함수들', 20, '하', '그룹 함수', '2과목', 'SQL 활용', NULL),
	(22, '행과 행 간의 관계를 정의하여 결과를 출력하는 함수', 24, '하', '윈도우 함수', '2과목', 'SQL 활용', NULL),
	(23, '조건에 맞는 상위 N개의 레코드를 추출하는 쿼리 기법', 18, '하', 'Top N 쿼리', '2과목', 'SQL 활용', NULL),
	(24, '계층적 데이터 구조를 다루는 SQL 기법과 같은 테이블 내에서의 조인', 31, '중', '계층형 질의와 셀프 조인', '2과목', 'SQL 활용', NULL),
	(25, '행 데이터를 열 데이터로, 열 데이터를 행 데이터로 변환하는 SQL 기법', 19, '하', 'PIVOT 절과 UNPIVOT 절', '2과목', 'SQL 활용', NULL),
	(26, '문자열 패턴을 정의하고 검색, 치환하는 기법', 21, '하', '정규 표현식', '2과목', 'SQL 활용', NULL),
	(27, '데이터 조작어: INSERT, UPDATE, DELETE 등 데이터를 조작하는 SQL 명령어', 36, '중', 'DML', '2과목', '관리구문', NULL),
	(28, '트랜잭션 제어어: COMMIT, ROLLBACK 등 트랜잭션을 제어하는 명령어', 17, '하', 'TCL', '2과목', '관리구문', NULL),
	(29, '데이터 정의어: CREATE, ALTER, DROP 등 데이터베이스 객체를 정의하는 SQL 명령어', 29, '하', 'DDL', '2과목', '관리구문', NULL),
	(30, '데이터 제어어: GRANT, REVOKE 등 데이터베이스 접근 권한을 제어하는 명령어', 22, '하', 'DCL', '2과목', '관리구문', NULL);

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */;



-- 테이블 데이터 qriz.question:~1,320 rows (대략적) 내보내기
/*!40000 ALTER TABLE `question` DISABLE KEYS */;
INSERT INTO `question` (`question_id`, `category`, `description`, `difficulty`, `exam_session`, `question`, `solution`, `time_limit`, `skill_id`) VALUES
	(1, 2, NULL, 1, NULL, '다음 중 데이터 모델링의 특징으로 가장 부적절한 것은?', '데이터 모델은 물리적인 저장 구조와 독립적이어야 합니다. 이는 논리적 데이터 모델과 물리적 데이터 모델의 분리를 통해 유연성을 확보할 수 있게 합니다.', 60, 1),
	(2, 2, NULL, 2, NULL, '다음 중 ERD(Entity Relationship Diagram)에서 사용되는 관계 차수의 표현으로 올바른 것은?', '1:1 관계는 한 개체의 하나의 인스턴스가 다른 개체의 하나의 인스턴스와 관계를 갖는 것을 의미합니다. 예를 들어, 한 사람이 하나의 주민등록번호를 갖는 관계가 있습니다.', 120, 1),
	(3, 2, NULL, 2, NULL, '다음 중 엔터티(Entity)의 특징으로 가장 적절하지 않은 것은?', '엔터티는 다른 엔터티와 반드시 관계를 가질 필요는 없습니다. 독립적으로 존재할 수 있는 엔터티도 있을 수 있습니다. 중요한 것은 해당 엔터티가 업무적으로 의미가 있고, 식별이 가능하며, 속성을 가져야 한다는 점입니다.', 120, 1),
	(4, 2, NULL, 3, NULL, '다음 중 정규화에 대한 설명으로 가장 올바른 것은?', '제1정규형(1NF)은 테이블의 모든 속성이 원자값을 가지도록 하는 것입니다. 이는 복합 속성을 분해하고 반복 속성을 제거하는 과정을 포함합니다.', 180, 1),
	(5, 2, '[상황]\n대학교 수강신청 시스템에서 수강신청 테이블을 설계하려고 합니다.\n- 한 학생은 여러 과목을 신청할 수 있습니다.\n- 한 과목은 여러 학생이 신청할 수 있습니다.\n- 동일한 과목이라도 분반이 다를 수 있습니다.\n- 한 학생이 동일한 과목을 중복 신청할 수 없습니다.', 3, NULL, '다음 상황에서 가장 적절한 식별자 선정 방식은?', '학번과 과목코드를 복합키로 설정하는 것이 가장 적절합니다. 분반은 과목코드에 포함될 수 있으며, 한 학생이 동일한 과목을 중복 신청할 수 없다는 요구사항을 만족시키기 위해서는 학번과 과목코드의 조합으로 유일성을 보장해야 합니다.', 180, 1),
	(6, 2, NULL, 1, NULL, '데이터 모델에서 \'속성(Attribute)\'에 대한 설명으로 옳은 것은?', '속성은 업무에서 관리하고자 하는 항목으로, 엔터티가 가지는 항목이나 성질을 의미합니다. 속성은 엔터티에 종속적이며, 하나의 엔터티 내에서 같은 이름으로 중복될 수 없습니다.', 60, 1),
	(7, 2, NULL, 1, NULL, '다음 중 개념적 데이터 모델링 단계에서 수행하는 작업이 아닌 것은?', '인덱스 정의는 물리적 데이터 모델링 단계에서 수행하는 작업입니다. 개념적 데이터 모델링에서는 업무 분석을 통한 핵심 엔터티 도출, 엔터티 간의 관계 설정, 주요 속성 식별 등을 수행합니다.', 60, 1),
	(8, 2, NULL, 2, NULL, '다음 중 슈퍼타입/서브타입 관계에 대한 설명으로 올바른 것은?', '서브타입 엔터티는 슈퍼타입 엔터티의 인스턴스와 1:1 관계를 가집니다. 서브타입은 슈퍼타입의 속성을 상속받으며, 한 엔터티는 다중 상속이 가능하고, 서브타입 간의 관계도 설정할 수 있습니다.', 120, 1),
	(9, 2, NULL, 2, NULL, '다음 중 반정규화(Denormalization)를 고려해야 하는 상황으로 가장 적절한 것은?', '반정규화는 성능 향상을 위해 정규화된 데이터 모델을 의도적으로 통합하거나 중복을 허용하는 것입니다. 특히 조인이 자주 발생하는 테이블의 조회 성능 개선이 필요한 경우 반정규화를 고려할 수 있습니다.', 120, 1),
	(10, 2, '[상황]\n회사의 조직도를 데이터 모델로 설계하려고 합니다.\n- 모든 부서는 상위 부서를 가질 수 있습니다.\n- 최상위 부서는 상위 부서가 없습니다.\n- 부서는 여러 개의 하위 부서를 가질 수 있습니다.\n- 부서의 계층 구조는 언제든지 변경될 수 있습니다.', 3, NULL, '다음과 같은 상황에서 가장 적절한 모델링 방식은?', '이러한 계층 구조는 자기참조 관계를 사용하여 설계하는 것이 가장 적절합니다. 부서 테이블에 상위부서ID를 외래키로 설정하면 유연한 계층 구조를 표현할 수 있으며, 구조 변경에도 용이합니다.', 180, 1),
	(11, 2, NULL, 1, NULL, '다음 중 엔터티(Entity)의 특징으로 가장 부적절한 것은?', '엔터티가 되기 위한 필수 조건은:\n1. 업무적으로 관리가 필요한 정보\n2. 유일한 식별자로 식별 가능\n3. 두 개 이상의 인스턴스의 존재\n\n속성을 반드시 가질 필요는 없으며, 관계 엔터티의 경우 식별자만으로 구성될 수도 있습니다.', 60, 2),
	(12, 2, NULL, 2, NULL, '다음 중 엔터티 분류에 대한 설명으로 가장 올바른 것은?', '엔터티 유형별 특징:\n1. 기본 엔터티: 독립적으로 생성 가능한 엔터티\n2. 중심 엔터티: 기본 엔터티로부터 발생하고 행위 엔터티의 부모가 되는 엔터티\n3. 행위 엔터티: 두 개 이상의 엔터티간 행위로 발생하는 엔터티\n4. 코드 엔터티: 각종 코드성 데이터를 관리하는 엔터티', 120, 2),
	(13, 2, '[업무 상황]\n1. 고객이 상품을 주문한다\n2. 한 번의 주문에 여러 상품을 담을 수 있다\n3. 상품의 재고는 실시간으로 관리되어야 한다\n4. 주문 상태는 \'주문\', \'결제\', \'배송\', \'완료\' 로 관리된다', 2, NULL, '다음과 같은 상황에서 적절한 엔터티 도출 방식은?', '엔터티 도출 분석:\n1. 기본 엔터티\n   - 고객: 독립적으로 생성되는 마스터 데이터\n   - 상품: 독립적으로 생성되는 마스터 데이터\n2. 중심 엔터티\n   - 주문: 고객으로부터 발생하는 중심 데이터\n3. 행위 엔터티\n   - 주문상품: 주문과 상품의 관계에서 발생\n4. 코드 엔터티\n   - 주문상태: 상태 값을 관리하는 코드성 데이터', 120, 2),
	(14, 2, '[현재 설계]\n1. 회원(회원ID, 회원명, 등급, 포인트)\n2. 등급(등급코드, 등급명, 최소포인트, 최대포인트)\n3. 주문(주문ID, 회원ID, 주문금액, 적립포인트, 등급할인율)', 3, NULL, '다음의 엔터티 설계에서 잘못된 부분을 찾고, 가장 적절한 해결 방안은?', '엔터티 설계의 문제점과 해결방안:\n1. 문제점:\n   - 회원의 등급 정보가 독립 엔터티로 관리되지 않음\n   - 등급 정보의 일관성 유지가 어려움\n2. 해결방안:\n   - 회원 엔터티의 등급을 등급코드(FK)로 변경\n   - 등급 관련 정보는 등급 엔터티에서 통합 관리\n3. 기대효과:\n   - 데이터 정합성 향상\n   - 등급 정보 변경 시 용이한 관리\n   - 확장성 확보', 180, 2),
	(15, 2, '[요구사항]\n1. 사용자는 게시글을 작성할 수 있다\n2. 게시글에는 여러 개의 첨부파일을 등록할 수 있다\n3. 사용자는 게시글에 댓글을 달 수 있다\n4. 댓글에 대한 답글(대댓글)도 가능하다\n5. 게시글과 댓글에 대한 좋아요 기능이 있다', 3, NULL, '다음과 같은 시스템 요구사항에서 가장 적절한 엔터티 설계는?', '요구사항 분석과 엔터티 도출:\n1. 기본 엔터티\n   - 사용자: 독립적으로 존재하는 마스터 데이터\n2. 중심 엔터티\n   - 게시글: 사용자로부터 발생하는 주요 데이터\n   - 댓글: 게시글에 종속적이지만 독자적인 특성을 가짐\n3. 행위 엔터티\n   - 게시글첨부파일: 게시글과 파일의 관계\n   - 게시글좋아요: 사용자와 게시글의 행위\n   - 댓글좋아요: 사용자와 댓글의 행위', 180, 2),
	(16, 2, NULL, 1, NULL, '다음 중 엔터티를 도출하는 방법으로 가장 적절하지 않은 것은?', '엔터티 도출 시 중요한 것은 해당 업무에서 필요한 정보이며, 속성의 개수는 엔터티 도출의 판단 기준이 되지 않습니다.\n\n영속적인 정보여야 하고, 업무적으로 관리가 필요하며, 식별 가능하고, 두 개 이상의 인스턴스가 존재해야 합니다.', 60, 2),
	(17, 2, NULL, 2, NULL, '다음 중 파생 엔터티(Derived Entity)에 대한 설명으로 가장 올바른 것은?', '파생 엔터티는 다른 엔터티의 부분집합으로 생성되는 엔터티로, 상위 엔터티의 식별자를 상속받아 식별자로 사용합니다.\n\n독립적인 식별자를 가질 필요는 없으며, M:N 관계 해결을 위한 것만은 아닙니다.', 120, 2),
	(18, 2, '[상황]\n1. 직원 정보를 관리하는 시스템을 구축한다\n2. 직원은 부서에 소속되며, 부서 이동이 가능하다\n3. 직원의 부서 이동 이력을 관리해야 한다\n4. 이력 관리 시 해당 기간의 직급도 함께 관리한다', 2, NULL, '다음 상황에서 올바른 엔터티 식별자 지정 방식은?', '직원 이력 관리를 위한 식별자 지정 시:\n1. 이력번호를 주식별자로 지정하여 각 이력을 고유하게 식별\n2. 직원번호를 외래키로 지정하여 직원과의 관계 표현\n3. 시작일자는 이력관리를 위한 속성으로 처리\n4. 이를 통해 동일 직원의 여러 이력을 효과적으로 관리 가능', 120, 2),
	(19, 2, '[현재 설계]\n1. 프로젝트(프로젝트ID, 프로젝트명, PM사원번호)\n2. 프로젝트인력(프로젝트ID, 사원번호, 역할, 참여시작일자)\n3. 사원(사원번호, 사원명, 소속부서, 직급)\n4. PM정보(PM사원번호, PM등급, 수행프로젝트수)', 3, NULL, '다음 엔터티 설계의 문제점을 찾고, 가장 적절한 해결 방안은?', '현재 설계의 분석:\n1. PM은 사원의 특수한 형태로, 추가적인 정보가 필요\n2. PM정보는 사원 정보에 종속적이지만 독립적인 특성을 가짐\n\n해결방안:\n- PM정보를 별도 엔터티로 유지\n- 사원 엔터티와 1:1 관계 설정\n- PM의 특수 속성을 독립적으로 관리\n\n기대효과:\n- PM 관련 정보의 무결성 확보\n- 유연한 확장성 제공', 180, 2),
	(20, 2, '[요구사항]\n1. 병원의 진료 예약 시스템을 구축한다\n2. 환자는 여러 진료과에 예약할 수 있다\n3. 한 진료과에는 여러 의사가 있다\n4. 의사는 요일별로 진료 시간이 다르다\n5. 예약은 30분 단위로 관리된다\n6. 예약 취소 시 취소 사유를 관리한다', 3, NULL, '다음 요구사항에 따른 엔터티 설계 시 고려사항으로 가장 적절한 것은?', '요구사항 분석 및 설계 방향:\n1. 기본 엔터티:\n   - 환자, 진료과, 의사\n2. 중심 엔터티:\n   - 예약\n3. 행위 엔터티:\n   - 의사일정: 의사의 요일별 진료시간 관리\n   - 예약취소: 취소 사유 관리\n\n고려사항:\n- 의사일정을 별도 엔터티로 관리하여 유연성 확보\n- 시간대별 예약 관리를 위한 구조 필요\n- 취소 이력 관리를 위한 구조 필요', 180, 2),
	(21, 2, NULL, 1, NULL, '다음 중 속성(Attribute)의 특징으로 가장 부적절한 것은?', '속성은 반드시 특정 엔터티에 포함될 필요는 없습니다. 속성은 독립적으로 존재할 수 있으며, 어떤 속성은 여러 엔터티에서 공통으로 사용될 수도 있고, 특정 엔터티에만 속할 수도 있습니다.', 60, 3),
	(22, 2, NULL, 2, NULL, '다음 중 속성의 종류를 설명한 것으로 가장 올바른 것은?', '- 기본속성: 업무로부터 직접 생성되는 속성(이름, 주민번호 등)\n- 설계속성: 업무를 위해 설계자가 추가한 속성(상품코드 등)\n- 파생속성: 다른 속성에서 계산되거나 변형된 속성(나이, 총합 등)\n- 복합속성: 여러 속성이 모여 구성된 속성(주소 = 시/군/구/동/번지)', 120, 3),
	(23, 2, '[주문] 엔터티\n- 주문번호\n- 주문일자\n- 배송비\n- 주문총액 (상품구매금액 + 배송비)\n- 적립포인트 (주문총액의 1%)\n- 회원ID', 2, NULL, '다음은 쇼핑몰 데이터베이스의 일부입니다. 속성의 유형이 다른 하나는?', '적립포인트는 파생속성입니다. 주문총액의 1%로 계산되는 값으로, 다른 속성으로부터 도출됩니다. 나머지는 모두 기본속성으로, 업무로부터 직접 생성되는 속성입니다.', 120, 3),
	(24, 2, '[상황]\n대학교 학사관리 시스템에서 \'학생\' 엔터티를 설계하려고 합니다.\n- 학생의 주소는 도로명주소와 지번주소를 모두 저장해야 합니다.\n- 주소 변경 이력을 관리해야 합니다.\n- 학생의 평균평점은 매 학기 성적이 입력될 때마다 갱신되어야 합니다.', 3, NULL, '다음 상황에서 가장 적절한 속성 설계는?', '주소 정보의 이력 관리를 위해서는 별도의 엔터티로 분리하고 시작일자, 종료일자 속성을 추가하는 것이 적절합니다. 평균평점은 파생속성으로 설계해야 하며, 주소 정보는 이력관리를 위해 별도 엔터티로 관리하는 것이 바람직합니다.', 180, 3),
	(25, 2, '[속성 예시]\n1. 회원등급: VIP, Gold, Silver, Bronze\n2. 성별: 남성/여성\n3. 재직여부: Y/N\n4. 부서코드: 영업부(S), 관리부(M), 개발부(D)', 3, NULL, '다음 중 속성의 데이터 표현 방법으로 가장 부적절한 것은?', '코드성 속성은 반드시 숫자형으로 정의할 필요가 없습니다. 부서코드의 경우 업무적 의미를 담은 문자형으로 정의하는 것이 가독성과 유지보수 측면에서 더 유리할 수 있습니다. 중요한 것은 일관성 있는 규칙을 적용하는 것입니다.', 180, 3),
	(26, 2, NULL, 1, NULL, '다음 중 단일값 속성(Single Value Attribute)에 대한 설명으로 가장 적절한 것은?', '단일값 속성은 하나의 속성이 한 개의 값만을 가질 수 있는 속성을 의미합니다. 예를 들어 주민등록번호, 직원번호 등이 이에 해당합니다.', 60, 3),
	(27, 2, '[상황]\n온라인 서점의 \'도서\' 엔터티에서 다음 정보를 관리하려고 합니다.\n- 도서의 저자는 1명 이상이 될 수 있음\n- 도서는 여러 개의 카테고리에 속할 수 있음\n- 도서의 평점은 독자들의 별점 평균값임\n- ISBN은 국제표준도서번호임', 2, NULL, '다음 중 가장 적절한 속성 설계는?', '저자, 카테고리는 다중값을 가지므로 별도의 엔터티로 설계해야 합니다.\nISBN은 업무로부터 직접 생성되는 기본속성입니다.\n평점은 별점의 평균이므로 파생속성으로 설계해야 합니다.', 120, 3),
	(28, 2, NULL, 2, NULL, '다음 중 속성의 도메인(Domain)을 정의한 것으로 가장 부적절한 것은?', '나이의 도메인 정의에서 0은 적절하지 않습니다. 일반적으로 나이는 1 이상의 값을 가지며, 150이라는 상한값도 현실적이지 않을 수 있습니다. 도메인 정의 시에는 업무 규칙과 현실적인 제약을 고려해야 합니다.', 120, 3),
	(29, 2, '[현재 설계]\n주문(\n  주문번호(PK),\n  주문일시,\n  회원ID(FK),\n  배송주소_도로명,\n  배송주소_지번,\n  배송주소_우편번호,\n  수령자명,\n  수령자전화번호1,\n  수령자전화번호2,\n  수령자전화번호3,\n  주문상태(1:주문,2:결제,3:배송,4:완료),\n  주문금액,\n  할인금액,\n  결제금액,\n  적립포인트\n)', 3, NULL, '다음과 같은 \'주문\' 엔터티의 속성 설계에서 개선이 필요한 부분을 찾고, 가장 적절한 해결 방안은?', '현재 설계의 문제점:\n- 배송지 정보가 주문 엔터티에 직접 포함됨\n- 동일 배송지 정보의 중복 가능성\n- 배송지 이력 관리 어려움\n\n개선 방안:\n- 배송지 정보를 별도 엔터티로 분리\n- 배송지 정보의 재사용성 확보\n- 배송지 이력 관리 가능', 180, 3),
	(30, 2, '[요구사항]\n1. 고객의 보유 포인트는 실시간으로 갱신되어야 한다\n2. 포인트 적립/사용 내역을 기간별로 조회할 수 있어야 한다\n3. 포인트 만료일은 적립일로부터 1년이다\n4. 포인트는 먼저 적립된 것부터 사용된다\n5. 고객별 포인트 사용 통계를 월별로 집계해야 한다', 3, NULL, '다음 요구사항에 따른 속성 설계 시 고려사항으로 가장 적절한 것은?', '설계 고려사항:\n- 실시간 포인트 관리 필요\n- 이력 관리 필요\n- 만료일 자동 계산\n- FIFO 방식의 포인트 사용\n\n해결방안:\n- 포인트 이력 테이블 별도 생성\n- 고객의 보유 포인트는 이력의 합계로 계산\n- 만료일은 적립일 기준 자동 계산\n\n기대효과:\n- 정확한 포인트 관리\n- 유연한 통계 집계\n- 명확한 이력 관리', 180, 3),
	(31, 2, NULL, 1, NULL, '다음 중 식별자의 특성으로 가장 부적절한 것은?', '식별자의 최소성은 식별자를 구성하는 속성의 수가 최소가 되어야 함을 의미합니다. 불필요하게 많은 속성으로 식별자를 구성하면 관리가 복잡해지고 성능에도 영향을 미칠 수 있습니다.', 60, 4),
	(32, 2, '[학생 테이블]\n- 학번\n- 주민등록번호\n- 이름\n- 전화번호\n- 학과코드\n- 입학일자\n- 학년', 2, NULL, '다음 중 후보키(Candidate Key)가 될 수 있는 것은?', '후보키의 조건:\n1. 유일성: 중복된 값이 없어야 함\n2. 최소성: 불필요한 속성이 포함되지 않아야 함\n\n분석:\n- 학번: 유일성과 최소성 모두 만족\n- 주민등록번호: 유일성과 최소성 모두 만족 (후보키 가능)\n- 기타 조합: 유일성을 보장할 수 없음', 120, 4),
	(33, 2, '[상황]\n온라인 쇼핑몰의 주문 관리 시스템\n1. 하나의 주문에 여러 상품이 포함될 수 있다\n2. 동일한 상품을 여러 번 주문할 수 있다\n3. 주문 취소 시 이력 관리가 필요하다\n4. 주문 상품의 가격은 시점에 따라 다를 수 있다', 2, NULL, '다음과 같은 상황에서 가장 적절한 식별자 선정 방식은?', '적절한 식별자 선정 이유:\n1. 주문(orders) 테이블:\n   - 인조식별자(order_id) 사용으로 안정성 확보\n   - 자연키 사용 시 발생할 수 있는 변경 위험 회피\n\n2. 주문상품(order_items) 테이블:\n   - 개별 식별자(order_item_id) 부여로 이력 관리 용이\n   - 복합키 사용 시 발생할 수 있는 참조 무결성 제약 회피', 120, 4),
	(34, 2, '[게시판]        [게시글]        [첨부파일]\nBOARD_ID       POST_ID         FILE_ID\nBOARD_NAME     BOARD_ID        POST_ID\n              TITLE           FILE_NAME\n              CONTENT         FILE_PATH', 3, NULL, '다음과 같은 ERD에서 가장 적절한 식별자 관계 설정은?', '비식별관계를 선택한 이유:\n1. 유연성:\n   - 게시글이나 파일의 독립적인 관리 가능\n   - 게시판 이동이나 구조 변경 시 유연한 대응\n\n2. 성능:\n   - 단순한 키 구조로 인한 조인 성능 향상\n   - 인덱스 크기 감소\n\n3. 관리 용이성:\n   - 단순한 참조 구조\n   - 데이터 이관이나 백업이 용이', 180, 4),
	(35, 2, '[요구사항]\n1. 직원은 여러 프로젝트에 참여할 수 있다\n2. 프로젝트별로 직원의 역할이 다를 수 있다\n3. 직원의 역할은 시작일자와 종료일자를 가진다\n4. 동일 프로젝트에서 직원의 역할은 기간별로 변경될 수 있다\n5. 이력 관리가 필요하다', 3, NULL, '다음과 같은 시스템 요구사항에서 가장 적절한 식별자 설계는?', '요구사항을 만족하는 이유:\n1. 이력관리를 위한 독립적인 식별자(MEMBER_ID) 사용\n2. 동일 프로젝트/직원의 역할 변경 이력 관리 가능\n3. 기간 중첩 체크 가능\n4. 참조 무결성 제약조건 설정 용이\n5. 조회 성능 향상', 180, 4),
	(36, 2, NULL, 1, NULL, '다음 중 대체식별자(Surrogate Key)의 특징으로 가장 적절하지 않은 것은?', '대체식별자가 자연식별자보다 항상 더 나은 것은 아닙니다. 상황에 따라 적절한 식별자를 선택해야 합니다. 예를 들어, 주민등록번호나 사업자등록번호처럼 업무적으로 중요하고 변경이 거의 없는 경우에는 자연식별자가 더 적절할 수 있습니다.', 60, 4),
	(37, 2, '[상황]\n회사의 조직도 관리 시스템\n- 부서는 부서코드(3자리)와 부서명을 가진다\n- 직원은 사번(5자리)을 부여받는다\n- 직원은 하나의 부서에 소속된다\n- 부서별 직원의 이력 관리가 필요하다', 2, NULL, '다음의 식별자 선정 방식 중 가장 적절한 것은?', '이력 관리를 위해서는 별도의 식별자(HISTORY_ID)를 사용하는 것이 가장 적절합니다. \n1. 유연성: 부서 이동 이력을 자유롭게 관리 가능\n2. 성능: 단순한 키 구조로 인한 조회 성능 향상\n3. 이력 관리: 시간의 흐름에 따른 모든 변경 사항 추적 가능', 120, 4),
	(38, 2, NULL, 2, NULL, '다음 중 식별관계 적용이 가장 적절한 경우는?', '식별관계는 부모 테이블의 기본키가 자식 테이블의 기본키이자 외래키가 되는 관계입니다.\n공통코드와 상세코드의 관계에서는:\n1. 상세코드가 공통코드에 종속적\n2. 공통코드 없이 상세코드가 존재할 수 없음\n3. 계층적 구조를 명확하게 표현 가능\n따라서 식별관계 적용이 가장 적절합니다.', 120, 4),
	(39, 2, '[현재 설계]\n```sql\nCREATE TABLE PRODUCTS (\n    CATEGORY_ID VARCHAR2(10),\n    PRODUCT_CODE VARCHAR2(10),\n    PRODUCT_NAME VARCHAR2(100),\n    PRICE NUMBER,\n    PRIMARY KEY (CATEGORY_ID, PRODUCT_CODE)\n);\n\nCREATE TABLE ORDERS (\n    ORDER_ID NUMBER,\n    ORDER_DATE DATE,\n    CATEGORY_ID VARCHAR2(10),\n    PRODUCT_CODE VARCHAR2(10),\n    QUANTITY NUMBER,\n    PRIMARY KEY (ORDER_ID),\n    FOREIGN KEY (CATEGORY_ID, PRODUCT_CODE) \n        REFERENCES PRODUCTS(CATEGORY_ID, PRODUCT_CODE)\n);\n```', 3, NULL, '다음과 같은 테이블 설계에서 발생할 수 있는 문제점과 가장 적절한 해결 방안은?', '현재 설계의 문제점:\n1. 복잡한 참조 관계로 인한 성능 저하\n2. 카테고리 변경 시 제약조건으로 인한 어려움\n3. 외래키 관리의 복잡성\n\n해결방안:\n1. PRODUCTS 테이블에 PRODUCT_ID라는 대체키 도입\n2. ORDERS 테이블은 PRODUCT_ID만 참조\n3. 카테고리 정보는 비식별관계로 유지', 180, 4),
	(40, 2, '[요구사항]\n1. 고객은 여러 개의 배송지를 등록할 수 있다\n2. 배송지는 기본 배송지를 설정할 수 있다\n3. 주문 시 등록된 배송지 중 하나를 선택할 수 있다\n4. 주문 시점의 배송지 정보가 보존되어야 한다\n5. 배송지 변경 이력 관리가 필요하다', 3, NULL, '다음과 같은 요구사항에서 가장 적절한 식별자 설계 방식은?', '적절한 설계 방식:\n1. 배송지 마스터 테이블:\n   - 인조식별자(DELIVERY_ADDR_ID) 사용\n   - 고객ID는 외래키로 참조\n   - 기본 배송지 여부 표시\n\n2. 배송지 이력 테이블:\n   - 이력ID를 인조식별자로 사용\n   - 배송지ID를 외래키로 참조\n   - 변경일자 및 이력 관리\n\n3. 주문 테이블:\n   - 배송지ID를 외래키로 참조\n   - 주문 시점의 배송지 정보 스냅샷 보관', 180, 4),
	(41, 2, NULL, 1, NULL, '다음 중 데이터베이스의 관계(Relationship)에 대한 설명으로 틀린 것은?', '1:1 관계에서는 외래키를 양쪽 테이블 모두에 둘 필요는 없습니다. 일반적으로 업무적 특성이나 데이터 접근 빈도를 고려하여 한쪽 테이블에만 외래키를 둡니다. 양쪽에 모두 두는 것은 중복과 관리 비용을 증가시킬 수 있습니다.', 60, 5),
	(42, 2, '[상황]\n1. 직원은 하나의 부서에만 소속될 수 있다\n2. 한 부서에는 여러 직원이 소속될 수 있다\n3. 부서는 직원이 없어도 존재할 수 있다\n4. 모든 직원은 반드시 부서에 소속되어야 한다', 2, NULL, '다음과 같은 업무 상황에서 가장 적절한 관계 유형은?', '주어진 상황 분석:\n1. 1:N 관계 (한 부서 : 여러 직원)\n2. 필수/선택 관계 (직원->부서: 필수, 부서->직원: 선택)\n3. 부서는 독립적으로 존재 가능\n4. 직원은 부서에 의존적이지만 식별자로 부서를 사용하지는 않음\n따라서 비식별 관계를 가진 1:N 관계가 적절합니다.', 120, 5),
	(43, 2, '[직원]                [프로젝트]\n+------------+        +------------+\n|직원ID(PK)   |<------>|프로젝트ID(PK)|\n|직원명       |  N:M   |프로젝트명   |\n|부서ID       |        |시작일      |\n+------------+        |종료일      |\n                     +------------+', 2, NULL, '다음과 같은 ERD에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'N:M 관계의 문제점과 해결방안:\n1. 직원과 프로젝트는 다대다 관계\n2. 현재 구조에서는 참여 이력(기간, 역할 등) 관리 불가\n3. 해결방안: 교차 엔터티 생성\n```sql\n[직원_프로젝트]\n+---------------+\n|직원ID(FK)      |\n|프로젝트ID(FK)   |\n|참여시작일      |\n|참여종료일      |\n|역할           |\n+---------------+\n```', 120, 5),
	(44, 2, NULL, 3, NULL, '다음 중 식별관계와 비식별관계에 대한 설명으로 가장 적절한 것은?', '식별/비식별관계의 특징:\n1. 식별관계\n   - 부모 테이블의 PK가 자식 테이블의 PK 일부로 사용\n   - 강한 종속성\n   - 부모가 없으면 자식도 존재 불가\n2. 비식별관계\n   - 부모 테이블의 PK가 자식 테이블의 일반 컬럼으로 사용\n   - 약한 종속성\n   - 필수/선택 여부 선택 가능', 180, 5),
	(45, 2, '[요구사항]\n1. 주문은 여러 개의 상품을 포함할 수 있다\n2. 상품은 여러 주문에 포함될 수 있다\n3. 주문별로 상품의 수량과 금액이 다르다\n4. 상품의 가격은 시간에 따라 변경될 수 있다\n5. 주문 시점의 상품 가격이 보존되어야 한다', 3, NULL, '다음과 같은 상황에서 가장 적절한 설계 방식은?', '요구사항을 만족하는 이유:\n1. ORDER_ITEMS 테이블로 N:M 관계 해소\n2. UNIT_PRICE로 주문 시점의 가격 보존\n3. AMOUNT를 계산 컬럼으로 설정하여 데이터 정합성 보장\n4. ORDER_ITEM_ID를 별도로 두어 향후 확장성 고려\n5. 참조 무결성 제약조건 설정', 180, 5),
	(46, 2, NULL, 1, NULL, '다음 중 참조무결성 제약조건(Reference Integrity)에 대한 설명으로 가장 부적절한 것은?', '부모 테이블의 기본키가 변경될 때 자식 테이블의 외래키가 자동으로 변경되지는 않습니다. 이는 별도의 옵션(ON UPDATE CASCADE)을 설정해야 하며, 많은 DBMS에서 이 기능을 지원하지 않거나 권장하지 않습니다.', 60, 5),
	(47, 2, '[상황]\n1. 카테고리는 계층 구조를 가진다 (대분류-중분류-소분류)\n2. 각 카테고리는 하위 카테고리를 여러 개 가질 수 있다\n3. 최하위 카테고리에만 상품을 등록할 수 있다\n4. 카테고리의 depth는 3단계로 고정되어 있다', 2, NULL, '다음과 같은 상황에서 가장 적절한 관계 설정은?', '카테고리 레벨이 고정된 3단계이므로, 각 레벨별로 테이블을 생성하는 것이 가장 적절합니다.\n1. 명확한 구조 표현 가능\n2. 각 레벨별 속성 관리 용이\n3. 참조 무결성 보장\n4. 레벨별 조회 성능 향상', 120, 5),
	(48, 2, '[상황]\n회원(Member) 엔터티\n- 일반회원(Normal)\n- 기업회원(Corporate)\n- VIP회원(VIP)\n\n특징:\n1. 회원 유형별로 속성이 다르다\n2. 회원 유형 변경이 가능하다\n3. 전체 회원을 대상으로 한 조회가 빈번하다\n4. 각 회원 유형별 특화 기능이 있다', 2, NULL, '다음 중 슈퍼타입-서브타입 관계를 물리적 모델로 구현할 때 가장 적절한 방식은?', '주어진 상황에서는 단일 테이블 전략이 가장 적합합니다.\n1. 전체 조회가 빈번한 경우 조인 없이 조회 가능\n2. 회원 유형 변경 시 데이터 이동 없이 처리 가능\n3. 약간의 저장 공간 낭비는 있으나 성능상 이점이 큼', 120, 5),
	(49, 2, '[현재 설계]\n```sql\nCREATE TABLE EMPLOYEES (\n    EMP_ID NUMBER PRIMARY KEY,\n    MANAGER_ID NUMBER,\n    FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEES(EMP_ID)\n);\n\nCREATE TABLE PROJECTS (\n    PROJECT_ID NUMBER PRIMARY KEY,\n    MANAGER_ID NUMBER,\n    FOREIGN KEY (MANAGER_ID) REFERENCES EMPLOYEES(EMP_ID)\n);\n```', 3, NULL, '다음과 같은 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '재귀적 관계를 포함한 참조 관계에서:\n1. 문제점:\n   - 직원 삭제 시 순환 참조로 인한 제약조건 위배 가능\n   - 관련 데이터 삭제 순서 결정 어려움\n2. 해결방안:\n   - ON DELETE SET NULL 옵션 사용\n   - 삭제 전 참조 관계 정리 프로시저 구현\n   - 논리적 삭제(삭제 플래그) 도입 고려', 180, 5),
	(50, 2, '[요구사항]\n1. 고객은 여러 보험 상품에 가입할 수 있다\n2. 보험 상품별로 보장 내용이 다르다\n3. 고객별로 보험료와 보장 금액이 다르게 책정된다\n4. 보험 계약은 갱신될 수 있으며, 갱신 시 보험료가 변경될 수 있다\n5. 계약 이력과 보험료 변경 이력이 모두 관리되어야 한다', 3, NULL, '다음 요구사항에 대한 가장 적절한 관계 모델링은?', '주어진 요구사항을 가장 잘 만족하는 모델입니다.\n1. 계약 기본 정보와 보험료 정보를 분리하여 관리\n2. 계약별 보험료 이력을 효과적으로 관리 가능\n3. 기간별 보험료 변경 이력 추적 가능\n4. 계약 갱신과 보험료 변경을 유연하게 처리 가능\n5. 기본키와 외래키를 통한 참조 무결성 보장', 180, 5),
	(51, 2, NULL, 1, NULL, '다음 중 관계와 조인에 대한 설명으로 가장 부적절한 것은?', 'N:M 관계는 반드시 교차 테이블로 해소할 필요는 없습니다. 업무 요구사항과 시스템 특성에 따라 다른 방식으로도 구현 가능합니다. 예를 들어, JSON이나 배열 타입을 사용하거나, 특정 DBMS의 고유 기능을 활용할 수도 있습니다.', 60, 6),
	(52, 2, '[학생]              [수강신청]         [과목]\n학번(PK)            학번(FK)           과목코드(PK)\n이름                과목코드(FK)       과목명\n학과                신청일자           담당교수\n                   성적', 2, NULL, '다음과 같은 관계를 가진 테이블에서 적절한 조인 방식은?', '가장 적절한 조인 방식 선택 이유:\n1. 모든 학생 정보 포함 필요:\n   - LEFT JOIN으로 학생 테이블 기준\n   - 수강신청이 없는 학생도 포함\n\n2. 조인 순서의 최적화:\n   - 기준 테이블(학생)부터 시작\n   - 관계의 방향성 고려\n   - 1:N 관계 순서로 조인', 120, 6),
	(53, 2, '[Query 1]\n```sql\nSELECT d.dept_name, COUNT(e.emp_id) as emp_count\nFROM departments d, employees e\nWHERE d.dept_id = e.dept_id\nGROUP BY d.dept_name;\n```\n\n[Query 2]\n```sql\nSELECT d.dept_name, COUNT(e.emp_id) as emp_count\nFROM departments d\nLEFT OUTER JOIN employees e ON d.dept_id = e.dept_id\nGROUP BY d.dept_name;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', '두 쿼리의 차이점:\n1. Query 1 (일반 조인):\n   - 매칭되는 데이터만 조회\n   - 직원이 없는 부서는 제외\n\n2. Query 2 (LEFT OUTER JOIN):\n   - 모든 부서 포함\n   - 직원이 없는 부서도 포함(emp_count = 0)', 120, 6),
	(54, 2, '[요구사항]\n1. 부서별 평균 급여 계산\n2. 부서가 없는 직원도 포함\n3. 직원이 없는 부서도 포함\n4. 평균 급여가 NULL인 경우 0으로 표시\n5. 부서명 기준으로 정렬', 3, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '요구사항을 만족하는 이유:\n1. FULL OUTER JOIN:\n   - 양쪽 테이블의 모든 데이터 포함\n   - 부서 없는 직원과 직원 없는 부서 모두 포함\n\n2. NULL 처리:\n   - COALESCE로 부서명 NULL 처리\n   - NVL로 평균 급여 NULL 처리\n\n3. 정렬:\n   - 부서명 기준 정렬\n   - NULLS LAST로 NULL 처리', 180, 6),
	(55, 2, '[주문]              [주문상품]         [상품]\n주문ID(PK)          주문ID(FK)         상품ID(PK)\n고객ID              상품ID(FK)         상품명\n주문일자            수량               가격\n                   금액               재고', 3, NULL, '다음과 같은 다중 테이블 관계에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '다중 테이블 조인 시 고려사항:\n1. 명시적 조인 조건:\n   - 모든 테이블 간 관계 명확히 정의\n   - 카테시안 곱 방지\n   - 성능 향상\n\n2. 조인 순서 최적화:\n   - 1:N 관계 순서 고려\n   - 인덱스 활용\n   - 데이터 양 고려\n\n3. 적절한 조인 유형:\n   - INNER JOIN vs OUTER JOIN\n   - 업무 요구사항 반영\n   - 불필요한 OUTER JOIN 제거\n\n4. 성능 고려사항:\n   - 조인 조건의 인덱스 활용\n   - 조인 칼럼의 데이터 타입 일치\n   - 불필요한 조인 제거', 180, 6),
	(56, 2, NULL, 1, NULL, '다음 중 SELF JOIN에 대한 설명으로 가장 부적절한 것은?', 'SELF JOIN이 반드시 성능을 저하시키는 것은 아닙니다. 적절한 인덱스와 조인 조건이 있다면 다른 테이블 간의 조인과 비슷한 성능을 보일 수 있습니다. 오히려 계층 구조 등을 표현할 때는 SELF JOIN이 가장 효율적인 방법일 수 있습니다.', 60, 6),
	(57, 2, '[직원 테이블]\n```sql\nCREATE TABLE EMPLOYEE (\n    EMP_ID NUMBER PRIMARY KEY,\n    EMP_NAME VARCHAR2(100),\n    MANAGER_ID NUMBER\n);\n```', 2, NULL, '다음과 같은 테이블에서 각 직원의 이름과 직속 상사의 이름을 조회하는 가장 적절한 SQL문은?', 'LEFT OUTER JOIN을 사용하는 것이 가장 적절합니다.\n1. 모든 직원 포함 (상사가 없는 직원도 포함)\n2. 명시적 조인 구문 사용으로 가독성 향상\n3. 결과의 정렬을 통한 데이터 확인 용이\n4. 표준 SQL 문법 준수', 120, 6),
	(58, 2, '[Query 1]\n```sql\nSELECT dept_id, COUNT(*) as emp_count\nFROM employees\nGROUP BY dept_id;\n```\n\n[Query 2]\n```sql\nSELECT d.dept_id, COUNT(e.emp_id) as emp_count\nFROM departments d\nLEFT JOIN employees e ON d.dept_id = e.dept_id\nGROUP BY d.dept_id;\n```\n\n[Query 3]\n```sql\nSELECT d.dept_id, COUNT(1) as emp_count\nFROM departments d\nINNER JOIN employees e ON d.dept_id = e.dept_id\nGROUP BY d.dept_id;\n```', 2, NULL, '다음 SQL문들의 실행 결과가 다른 경우를 고르시오.', '직원이 없는 부서가 있는 경우:\n1. Query 1: 직원이 있는 부서만 집계\n2. Query 2: 모든 부서 포함 (직원이 없는 부서는 0으로 집계)\n3. Query 3: 직원이 있는 부서만 집계', 120, 6),
	(59, 2, '[요구사항]\n1. 부서별 평균 급여보다 많은 급여를 받는 직원 조회\n2. 부서가 없는 직원도 포함하여 전체 평균과 비교\n3. 결과는 부서별, 급여 내림차순 정렬', 3, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '주어진 요구사항을 가장 잘 만족하는 이유:\n1. WITH 절을 사용한 명확한 구조\n2. 부서가 없는 직원 처리 (LEFT JOIN)\n3. 부서별 평균과 NULL 부서 평균 구분 처리\n4. COALESCE를 통한 NULL 처리\n5. 정렬 조건 준수', 180, 6),
	(60, 2, NULL, 3, NULL, '아래와 같은 다중 테이블 조인에서 발생할 수 있는 성능 이슈와 해결방안으로 가장 적절한 것은?', '성능 최적화 방안:\n1. 인라인 뷰로 데이터 축소:\n```sql\nSELECT c.cust_name, p.prod_name, \n       o.order_date, d.quantity\nFROM (\n    SELECT order_id, cust_id, order_date\n    FROM orders\n    WHERE order_date >= \'2024-01-01\'\n) o\nJOIN customers c ON c.cust_id = o.cust_id\nJOIN order_details d ON o.order_id = d.order_id\nJOIN products p ON d.prod_id = p.prod_id;\n```\n2. 장점:\n   - 초기 처리 대상 데이터 감소\n   - 불필요한 조인 연산 제거\n   - 메모리 사용량 감소\n3. 고려사항:\n   - 인덱스 활용 가능성\n   - 데이터 분포도\n   - 조인 순서의 최적화', 180, 6),
	(61, 2, NULL, 1, NULL, '다음 중 정규화에 대한 설명으로 가장 부적절한 것은?', '정규화가 진행될수록 테이블이 분리되어 조인의 필요성이 증가합니다. 이로 인해 조회 시 성능이 저하될 수 있습니다. 이는 정규화와 성능이 서로 상충관계에 있음을 보여주는 대표적인 예입니다.', 60, 7),
	(62, 2, '[학생수강테이블]\n------------------------------------\n학번 | 이름 | 수강과목 | 교수 | 강의실 | 성적\n------------------------------------\n1001 | 김철수 | 데이터베이스 | 박교수 | A동101호 | A\n1001 | 김철수 | 전자계산기 | 이교수 | B동201호 | B\n1002 | 이영희 | 데이터베이스 | 박교수 | A동101호 | B', 2, NULL, '다음 테이블에 대한 정규화 진행 시 적절한 단계는?', '학번과 이름은 부분함수적 종속성을 가집니다. 즉, 복합키(학번, 수강과목)에서 학번에만 종속되므로 제2정규형을 위반합니다. 따라서 학생정보(학번, 이름)를 별도 테이블로 분리해야 합니다.', 120, 7),
	(63, 2, '[후보키 및 함수적 종속성]\n1) 수강신청(학번, 과목코드, 교수번호, 신청일자)\n   - 후보키: (학번, 과목코드)\n   - 교수번호 → 과목코드\n\n2) 직원정보(직원번호, 부서코드, 직원명, 부서명)\n   - 후보키: (직원번호)\n   - 부서코드 → 부서명\n\n3) 강의실배정(강의실번호, 시간대, 교수번호, 과목명)\n   - 후보키: (강의실번호, 시간대)\n   - (교수번호, 시간대) → 강의실번호\n\n4) 학생정보(학번, 주민번호, 이름, 학과코드, 학과명)\n   - 후보키: (학번), (주민번호)\n   - 학과코드 → 학과명', 2, NULL, '다음 중 BCNF(Boyce-Codd Normal Form)를 위반하는 경우는?', 'BCNF는 모든 결정자가 후보키여야 합니다. 수강신청 테이블에서 교수번호는 과목코드를 결정하지만 후보키가 아니므로 BCNF를 위반합니다. 이를 해결하기 위해서는 (교수번호, 과목코드) 테이블을 별도로 분리해야 합니다.', 120, 7),
	(64, 2, '[과목수강테이블]\n-------------------------------------------------\n학번 | 학생명 | 등록학과 | 과목코드 | 과목명 | 강의실\n-------------------------------------------------\n1001 | 김철수 | 컴퓨터공학과 | CS001 | 자료구조 | A101\n1001 | 김철수 | 컴퓨터공학과 | CS002 | 데이터베이스 | B201\n1002 | 이영희 | 전자공학과 | CS001 | 자료구조 | A101\n\n[이상현상]\n1. 새로운 과목을 개설할 때 수강학생이 없으면 등록할 수 없다\n2. 마지막 수강학생이 과목 수강취소 시 과목 정보가 모두 삭제된다', 3, NULL, '다음과 같은 이상현상(Anomaly)이 발생하는 테이블의 정규화 단계와 해결방안으로 가장 적절한 것은?', '과목코드와 과목명, 강의실은 수강학생과 무관하게 독립적으로 존재해야 하는 정보입니다. 이는 제1정규형의 원자성 원칙과 관련이 있으며, 과목정보(과목코드, 과목명, 강의실)를 별도 테이블로 분리함으로써 삽입, 삭제 이상을 해결할 수 있습니다.', 180, 7),
	(65, 2, '[상황]\n1. 주문상세 테이블에서 주문금액 합계를 자주 조회한다\n2. 게시판의 답글 개수를 실시간으로 표시해야 한다\n3. 상품 분류별 재고수량을 일괄 계산한다\n4. 회원의 최근 로그인 시간을 저장한다', 3, NULL, '다음 중 반정규화(Denormalization)가 가장 적절한 경우는?', '게시판의 답글 개수는 실시간 표시가 필요하고 자주 조회되는 정보이며, 매번 COUNT 연산을 수행하면 성능이 저하될 수 있습니다. 이런 경우 답글 개수를 게시글 테이블에 컬럼으로 추가하는 반정규화가 적절합니다. 단, 답글이 추가되거나 삭제될 때마다 개수를 업데이트해야 하는 오버헤드가 있습니다.', 180, 7),
	(66, 2, NULL, 1, NULL, '다음 중 함수적 종속성(Functional Dependency)에 대한 설명으로 가장 부적절한 것은?', '함수적 종속성이 많다는 것은 데이터의 중복과 불일치 가능성이 높다는 것을 의미합니다. 이는 데이터의 일관성을 저해할 수 있으며, 정규화를 통해 적절히 제거되어야 합니다.', 60, 7),
	(67, 2, '[주문(ORDER)]\n----------------------------------------\n주문번호 | 고객ID | 고객등급 | 할인율 | 주문금액\n----------------------------------------\nO001    | C001  | GOLD    | 10%    | 10000\nO002    | C001  | GOLD    | 10%    | 20000\nO003    | C002  | SILVER  | 5%     | 15000', 2, NULL, '다음 테이블에서 제3정규형 위반 사항과 해결방안을 고르시오.', '제3정규형을 위반하는 이행적 함수 종속이 존재합니다:\n1. 고객ID → 고객등급\n2. 고객등급 → 할인율\n따라서 다음과 같이 분리해야 합니다:\n- 주문(주문번호, 고객ID, 주문금액)\n- 고객등급(고객등급, 할인율)\n- 고객(고객ID, 고객등급)', 120, 7),
	(68, 2, '[비정규형]\n학생정보(학번, 이름, 수강과목1, 수강과목2, 수강과목3)\n\n[정규화 단계]\nA: 학생정보(학번, 이름)\n   수강정보(학번, 과목코드)\n   과목정보(과목코드, 과목명)\n\nB: 학생수강(학번, 과목코드, 과목명)\n   학생정보(학번, 이름)\n\nC: 학생수강(학번, 이름, 과목코드)\n   과목정보(과목코드, 과목명)\n\nD: 학생과목(학번, 과목코드)\n   학생정보(학번, 이름)', 2, NULL, '다음 중 정규화 과정이 올바르게 진행된 것은?', '정규화가 올바르게 진행된 이유:\n1. 1NF: 반복 속성(수강과목1,2,3) 제거\n2. 2NF: 부분 종속성 제거 (학번→이름)\n3. 3NF: 이행적 종속성 제거 (과목코드→과목명)\n4. 각 테이블의 기본키와 외래키 관계가 명확함', 120, 7),
	(69, 2, '[요구사항]\n1. 대용량 주문 데이터 처리 시스템\n2. 주문 상태별 조회가 빈번함\n3. 주문 상태 변경 이력 관리 필요\n4. 실시간 통계 집계 필요', 3, NULL, '다음과 같은 상황에서 가장 적절한 정규화 전략은?', '제안된 정규화 전략:\n1. 주문 테이블:\n   - 주문ID, 고객ID, 현재상태코드, 금액\n2. 주문상태 테이블:\n   - 상태코드, 상태명\n3. 주문상태이력 테이블:\n   - 이력ID, 주문ID, 상태코드, 변경일시\n\n장점:\n- 이력 관리 용이\n- 상태별 조회 성능 향상\n- 데이터 정합성 확보', 180, 7),
	(70, 2, NULL, 3, NULL, '다음과 같은 반정규화 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '반정규화된 댓글수 컬럼의 유지보수를 위해 트리거를 사용하여 자동 갱신합니다.', 180, 7),
	(71, 2, NULL, 1, NULL, '다음 중 트랜잭션(Transaction)의 특성으로 가장 부적절한 것은?', '독립성(Isolation)은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리되어야 한다는 의미입니다. 반드시 순차적으로 실행될 필요는 없으며, 적절한 격리 수준에서 동시에 실행될 수 있습니다.', 60, 8),
	(72, 2, '-- Transaction 1\nUPDATE accounts SET balance = balance - 1000 WHERE account_no = \'A001\';\n\n-- Transaction 2\nSELECT balance FROM accounts WHERE account_no = \'A001\';', 2, NULL, '다음과 같은 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제점으로 가장 적절한 것은?', 'Dirty Read 현상 분석:\n1. Transaction 1이 계좌 잔액을 갱신\n2. 아직 COMMIT되지 않은 상태\n3. Transaction 2가 변경된 잔액을 읽음\n4. Transaction 1이 ROLLBACK하면 Transaction 2는 잘못된 데이터를 사용\n\n해결방안:\n- 적절한 트랜잭션 격리 수준 설정\n- READ COMMITTED 이상의 격리 수준 사용', 120, 8),
	(73, 2, '[주문]                [주문상세]\nORDER_ID (PK)        ORDER_ID (FK)\nORDER_DATE           PRODUCT_ID (FK)\nTOTAL_AMOUNT         QUANTITY\n                    AMOUNT', 2, NULL, '다음과 같은 데이터 모델에서 발생할 수 있는 트랜잭션 문제점으로 가장 적절한 것은?', '트랜잭션 관점의 문제점:\n1. 정합성 위험:\n   - 주문 총액과 상세 금액 합계의 불일치\n   - 부분 업데이트 가능성\n\n2. 해결방안:\n   - 트리거 사용\n   - 계산 컬럼 활용\n   - 트랜잭션 범위 적절히 설정\n   - 정합성 체크 로직 구현', 120, 8),
	(74, 2, '[요구사항]\n1. 상품 주문 시 재고 확인 및 차감\n2. 결제 처리\n3. 포인트 적립\n4. 모든 처리가 성공적으로 완료되어야 함\n5. 실패 시 모든 변경사항 롤백', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 트랜잭션 설계는?', '적절한 트랜잭션 처리 방식:\n1. 재고 확인과 차감을 동시에 처리\n2. 모든 처리를 하나의 트랜잭션으로 관리\n3. 예외 발생 시 전체 롤백\n4. 에러 처리와 메시지 전달\n\n다른 방식의 문제점:\n- ①: 예외 처리 누락\n- ②: 부분 커밋으로 인한 일관성 훼손\n- ③: SAVEPOINT 사용이 부적절', 180, 8),
	(75, 2, NULL, 3, NULL, '다음 중 트랜잭션 설계 시 고려사항으로 가장 부적절한 것은?', '트랜잭션 설계 원칙:\n1. 트랜잭션 범위:\n   - 최소화하여 설정\n   - 잠금 시간 최소화\n   - 동시성 향상\n\n2. 고려사항:\n   - 데이터 일관성\n   - 동시성\n   - 성능\n   - 복구 가능성\n\n3. 권장사항:\n   - 짧은 트랜잭션 설계\n   - 장시간 작업 분리\n   - 적절한 격리 수준 선택\n   - 효율적인 잠금 관리', 180, 8),
	(76, 2, NULL, 1, NULL, '다음 중 트랜잭션의 격리 수준(Isolation Level)에 대한 설명으로 가장 올바른 것은?', '트랜잭션 격리 수준별 특징:\n1. READ UNCOMMITTED: 커밋되지 않은 데이터도 읽을 수 있음(Dirty Read 발생)\n2. SERIALIZABLE: 가장 높은 고립성을 제공하지만 성능이 가장 낮음\n3. READ COMMITTED: 커밋된 데이터만 읽을 수 있지만, Non-repeatable Read 발생 가능\n4. REPEATABLE READ: 동일 데이터 반복 읽기 보장, Phantom Read는 발생 가능', 60, 8),
	(77, 2, '-- 포인트 차감 및 적립 프로세스\nUPDATE member_points \nSET point = point - 1000\nWHERE member_id = \'M001\';\n\nINSERT INTO point_history (\n    member_id, point_type, point_amount, description\n) VALUES (\n    \'M001\', \'USE\', -1000, \'포인트 사용\'\n);', 2, NULL, '다음과 같은 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '포인트 처리 시 고려사항:\n1. 동시성 제어 필요\n   ```sql\n   SELECT point FROM member_points \n   WHERE member_id = \'M001\'\n   FOR UPDATE;\n   ```\n2. 장점:\n   - 동시 업데이트 방지\n   - 데이터 일관성 보장\n   - 최소한의 잠금 범위', 120, 8),
	(78, 2, NULL, 2, NULL, '다음 중 낙관적 잠금(Optimistic Lock)이 가장 적절한 경우는?', '낙관적 잠금 적용 기준:\n1. 적절한 경우:\n   - 충돌 가능성이 낮은 경우\n   - 읽기가 많은 경우\n   - 긴 트랜잭션이 필요한 경우\n2. 부적절한 경우:\n   - 실시간 처리가 필요한 경우\n   - 충돌 가능성이 높은 경우\n   - 짧은 트랜잭션의 경우', 120, 8),
	(79, 2, '[요구사항]\n1. 대용량 주문 데이터 일괄 처리\n2. 각 주문별 재고 확인 및 차감\n3. 실패한 주문은 별도 로그 기록\n4. 전체 처리 시간 최소화', 3, NULL, '다음과 같은 업무 요구사항에서 가장 적절한 트랜잭션 처리 방식은?', '배치 처리 최적화 방안:\n1. 적절한 배치 크기 설정\n2. 부분 커밋으로 리소스 관리\n3. 실패 건에 대한 별도 처리\n4. 성능과 안정성 균형', 180, 8),
	(80, 2, '-- Transaction 1\nUPDATE orders SET status = \'PROCESSING\' WHERE order_id = 1;\nUPDATE inventory SET stock = stock - 1 WHERE product_id = 100;\n\n-- Transaction 2\nUPDATE inventory SET stock = stock - 1 WHERE product_id = 100;\nUPDATE orders SET status = \'PROCESSING\' WHERE order_id = 1;', 3, NULL, '다음과 같은 데드락(Deadlock) 상황의 해결방안으로 가장 적절한 것은?', '데드락 방지 전략:\n1. 테이블 접근 순서의 표준화:\n   ```sql\n   -- 모든 트랜잭션에서 동일한 순서 적용\n   UPDATE inventory SET ... ;  -- 항상 먼저\n   UPDATE orders SET ... ;     -- 항상 나중에\n   ```\n2. 장점:\n   - 데드락 원천 방지\n   - 관리 용이성\n   - 성능 저하 없음', 180, 8),
	(81, 2, NULL, 1, NULL, '다음 중 NULL에 대한 설명으로 가장 부적절한 것은?', 'NULL과 숫자 0은 전혀 다른 의미입니다. 0은 정의된 숫자값이지만, NULL은 \'아직 정의되지 않은 값\' 또는 \'알 수 없는 값\'을 의미합니다.', 60, 9),
	(82, 2, '```sql\nSELECT COUNT(*) as cnt1,\n       COUNT(department_id) as cnt2,\n       COUNT(DISTINCT department_id) as cnt3\nFROM employees\nWHERE salary IS NULL;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', '각 COUNT의 의미:\n1. COUNT(*): NULL을 포함한 모든 행의 수\n2. COUNT(department_id): department_id가 NULL이 아닌 행의 수\n3. COUNT(DISTINCT department_id): 중복을 제거한 department_id의 수\n따라서 cnt1 >= cnt2 (department_id가 NULL인 경우 때문)\ncnt2 >= cnt3 (department_id 중복 때문)', 120, 9),
	(83, 2, '```sql\n-- Query 1\nSELECT employee_id, salary\nFROM employees\nWHERE NVL(commission_pct, 0) = 0;\n\n-- Query 2\nSELECT employee_id, salary\nFROM employees\nWHERE commission_pct IS NULL OR commission_pct = 0;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'Query 1은 NULL을 0으로 변환 후 비교하고, Query 2는 NULL과 0을 별도 조건으로 처리합니다. NULL과 0이 모두 있는 경우, 실행 계획과 성능이 다를 수 있습니다.', 120, 9),
	(84, 2, '```sql\n[요구사항]\n1. 부서별 평균 급여 계산\n2. NULL 급여는 0으로 계산\n3. 부서가 없는 직원은 \'미배치\'로 표시\n4. 평균 급여가 NULL이면 0으로 표시\n```', 3, NULL, '다음과 같은 NULL 처리가 필요할 때, 가장 적절한 SQL문은?', 'NVL(salary, 0)로 NULL을 0으로 변환하고, LEFT JOIN을 사용하여 부서 없는 직원도 포함합니다. 또한, NULL 평균을 처리하기 위해 AVG(NVL(salary, 0))를 사용하여 모든 요구사항을 만족합니다.', 180, 9),
	(85, 2, '```sql\n[성능 테스트 결과]\nMethod 1: WHERE column1 IS NULL\nMethod 2: WHERE NVL(column1, \'X\') = \'X\'\nMethod 3: WHERE COALESCE(column1, \'X\') = \'X\'\nMethod 4: WHERE column1 = NULL\n```', 3, NULL, '다음과 같은 NULL 값 비교가 필요할 때, 가장 적절한 방법은?', 'NULL 비교는 IS NULL을 사용하는 것이 가장 효율적이며, 함수(NVL, COALESCE)를 사용하면 모든 행에 대해 함수 연산이 수행되어 성능이 저하될 수 있습니다.', 180, 9),
	(86, 2, NULL, 1, NULL, '다음 중 NULL 관련 함수에 대한 설명으로 가장 올바른 것은?', 'NULLIF(exp1, exp2)는 exp1과 exp2가 같으면 NULL을 반환합니다. 다른 NULL 관련 함수들과 비교하여 각각의 동작을 이해하는 것이 중요합니다.', 60, 9),
	(87, 2, '```sql\nSELECT \n    COUNT(*) as total_count,\n    SUM(CASE WHEN salary IS NULL THEN 1 ELSE 0 END) as null_count,\n    AVG(NVL(salary, 0)) as avg_salary1,\n    AVG(salary) as avg_salary2\nFROM employees\nWHERE department_id = 50;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', 'AVG(NVL(salary, 0))는 NULL을 0으로 변환 후 계산하지만, AVG(salary)는 NULL을 제외하고 계산하기 때문에 avg_salary1이 항상 더 작습니다.', 120, 9),
	(88, 2, '```sql\n-- Method 1\nSELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id\nORDER BY department_id NULLS FIRST;\n\n-- Method 2\nSELECT NVL(department_id, -1) as dept_id, COUNT(*)\nFROM employees\nGROUP BY NVL(department_id, -1)\nORDER BY dept_id;\n\n-- Method 3\nSELECT CASE WHEN department_id IS NULL \n            THEN \'미배치\' \n            ELSE TO_CHAR(department_id) \n       END as dept_id,\n       COUNT(*)\nFROM employees\nGROUP BY department_id;\n```', 2, NULL, '다음과 같은 GROUP BY 절에서 NULL 처리 방식 중 가장 적절한 것은?', 'NULL을 특정 값으로 변환(NVL 사용)하면 인덱스를 활용할 수 있어 성능 최적화가 가능하며, 정렬도 용이해집니다.', 120, 9),
	(89, 2, '```sql\n[테이블 정의]\nCREATE TABLE orders (\n    order_id NUMBER PRIMARY KEY,\n    customer_id NUMBER,\n    status VARCHAR2(10),\n    total_amount NUMBER,\n    CONSTRAINT chk_status CHECK \n    (status IN (\'PENDING\',\'COMPLETED\',\'CANCELLED\'))\n);\n\n[요구사항]\n1. status가 NULL인 경우 \'PENDING\'으로 처리\n2. 데이터 정합성 유지\n3. 성능 최적화\n```', 3, NULL, '다음과 같은 조건에서 NULL 처리가 필요할 때 가장 적절한 방식은?', 'NOT NULL 제약조건과 DEFAULT를 함께 설정하면 데이터 정합성을 보장할 수 있으며, 성능 오버헤드가 없습니다.', 180, 9),
	(90, 2, '```sql\n[테이블 구조]\nORDERS(order_id, customer_id, order_date)\nCUSTOMERS(customer_id, customer_name)\nORDER_ITEMS(order_id, product_id, quantity)\nPRODUCTS(product_id, product_name, price)\n\n[요구사항]\n1. 주문별 총 금액 계산\n2. 주문이 없는 고객도 포함\n3. 상품가격이 NULL인 경우 0으로 계산\n4. 고객명이 NULL인 경우 \'삭제된 고객\'으로 표시\n```', 3, NULL, '다음과 같은 조인 상황에서 발생할 수 있는 NULL 처리 문제의 해결방안으로 가장 적절한 것은?', 'WITH절을 사용하면 복잡한 계산을 단계별로 처리할 수 있으며, 가독성과 성능을 최적화할 수 있습니다.', 180, 9),
	(91, 2, NULL, 1, NULL, '다음 중 본질 식별자와 인조 식별자에 대한 설명으로 가장 부적절한 것은?', '인조 식별자는 숫자뿐만 아니라 문자열 등 다양한 형태로 지정할 수 있습니다. 중요한 것은 인조 식별자가 업무적 의미를 포함하지 않고, 유일성을 보장하며, 변경되지 않는 특성을 가져야 한다는 점입니다.', 60, 10),
	(92, 2, '[상황]\n고객 테이블 설계 시 다음 정보가 있음:\n1. 주민등록번호\n2. 고객번호(시스템 자동생성)\n3. 이메일주소\n4. 휴대폰번호', 2, NULL, '다음과 같은 상황에서 가장 적절한 식별자 선택은?', '고객번호를 인조 식별자로 선택하는 것이 적절한 이유:\n1. 주민등록번호는 개인정보보호로 인한 제약\n2. 이메일주소와 휴대폰번호는 변경 가능성이 높음\n3. 고객번호는:\n   - 시스템에서 자동 생성되어 유일성 보장\n   - 업무적 의미 없어 변경 필요성 없음\n   - 개인정보와 무관\n   - 간단한 구조로 조인 성능 유리', 120, 10),
	(93, 2, '[설계]\nDesign 1: 본질 식별자 사용\nDesign 2: 인조 식별자 사용', 2, NULL, '다음 두 테이블 설계 중 더 적절한 것은?', '인조 식별자 설계가 더 적절한 이유:\n1. 단순한 키 구조:\n   - 외래키 참조가 단순해짐\n   - 인덱스 크기 감소\n   - 조인 성능 향상\n\n2. 본질 식별자 설계의 단점:\n   - 복합키로 인한 참조 복잡성\n   - 더 많은 저장 공간 필요\n   - 인덱스 크기 증가\n   - 조인 조건 복잡', 120, 10),
	(94, 2, '[요구사항]\n1. 게시판별로 게시글 관리\n2. 게시글의 답변 글 관리\n3. 게시글의 첨부파일 관리\n4. 게시글 이동 기능 필요\n5. 답변 글의 계층 구조 표현 필요', 3, NULL, '다음과 같은 요구사항이 있을 때, 가장 적절한 식별자 설계는?', '인조 식별자 설계가 적절한 이유:\n1. 게시글 이동 용이성:\n   - board_id가 변경되어도 post_id는 유지\n   - 참조 무결성 유지 용이\n\n2. 계층 구조 표현:\n   - parent_post_id로 자기참조 관계 명확\n   - 조인 성능 우수\n\n3. 첨부파일 관리:\n   - 단순한 외래키 참조\n   - 일관된 참조 구조', 180, 10),
	(95, 2, NULL, 3, NULL, '다음 중 식별자 선택에 대한 설명으로 가장 적절한 것은?', '식별자 선택 시 고려사항:\n1. 인조 식별자 유리한 경우:\n   - 시스템 확장 예상\n   - 식별자 변경 가능성 존재\n   - 복잡한 관계 구조\n   - 대용량 데이터 처리\n\n2. 본질 식별자 유리한 경우:\n   - 업무적 의미 중요\n   - 간단한 관계 구조\n   - 안정적인 값 존재', 180, 10),
	(96, 2, NULL, 1, NULL, '다음 중 인조 식별자(Surrogate Key)의 장점으로 가장 부적절한 것은?', '인조 식별자는 업무적 의미를 가지지 않는 것이 특징입니다. 오히려 업무적 의미가 없기 때문에 시스템 변경에 유연하게 대응할 수 있고, 이것이 인조 식별자의 주요 장점 중 하나입니다.', 60, 10),
	(97, 2, '[테이블]\nCREATE TABLE employees (\n    emp_no VARCHAR2(10),\n    resident_no VARCHAR2(13),\n    emp_id NUMBER,\n    dept_code VARCHAR2(5),\n    join_date DATE\n);', 2, NULL, '다음과 같은 테이블에서 가장 적절한 식별자 선택은?', 'emp_id를 기본키로 선택하는 것이 가장 적절한 이유:\n1. emp_no의 문제점:\n   - 회사 규칙 변경 가능성\n   - 부서 이동시 변경 가능성\n2. emp_id의 장점:\n   - 시스템에서 자동 생성되어 유일성 보장\n   - 단순한 구조로 조인 성능 향상\n   - 업무 규칙 변경에 영향받지 않음', 120, 10),
	(98, 2, NULL, 2, NULL, '다음 중 본질 식별자를 사용하는 것이 가장 적절한 경우는?', '은행 계좌 테이블에서 본질 식별자가 적절한 이유:\n1. 계좌번호의 특성:\n   - 업무적으로 중요한 의미\n   - 변경되지 않는 특성\n   - 은행 전산시스템의 핵심 데이터', 120, 10),
	(99, 2, '[요구사항]\n1. 직원의 부서 이동 이력 관리\n2. 급여 변경 이력 관리\n3. 직급 변경 이력 관리\n4. 이력 데이터의 장기 보관 필요\n5. 타 시스템과의 데이터 연계 고려', 3, NULL, '다음과 같은 이력 관리 시스템에서 가장 적절한 식별자 설계는?', '인조 식별자를 사용한 이력 관리의 장점:\n1. 데이터 연계 용이성:\n   - 단순한 키 구조로 인한 참조 용이\n   - 시스템 간 데이터 교환 편리\n2. 이력 관리 효율성:\n   - 순차적인 이력 번호 부여\n   - 조회 성능 향상\n3. 확장성:\n   - 새로운 이력 유형 추가 용이\n   - 데이터 구조 변경 유연성', 180, 10),
	(100, 2, '[요구사항]\n1. 계약 원본 문서 관리\n2. 계약별 첨부문서 관리\n3. 계약 변경이력 관리\n4. 문서 이력 추적 필요', 3, NULL, '다음과 같은 마스터-디테일 구조에서 가장 적절한 식별자 설계는?', '최적의 식별자 설계 선정 이유:\n1. 계약 테이블:\n   - 인조식별자(contract_id) 사용으로 안정성 확보\n   - 업무용 계약번호는 UNIQUE 제약조건으로 관리\n2. 문서 테이블:\n   - 독립적인 인조식별자(doc_id) 부여\n   - 단순한 참조 관계\n3. 장점:\n   - 문서 이력 추적 용이\n   - 계약번호 체계 변경 시 유연한 대응\n   - 조인 성능 최적화\n   - 업무적 식별성 유지', 180, 10),
	(101, 2, NULL, 1, NULL, '다음 중 관계형 데이터베이스(RDBMS)의 특징으로 가장 부적절한 것은?', '관계형 데이터베이스에서 테이블 간의 관계는 1:1, 1:N, N:M 등 다양한 형태가 가능합니다. 이러한 다양한 관계를 통해 복잡한 업무 규칙과 데이터 구조를 표현할 수 있습니다.', 60, 11),
	(102, 2, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 무결성 제약조건에 대한 설명으로 가장 올바른 것은?', '각 무결성 제약조건의 의미:\n1. 개체 무결성: 기본키는 NULL이 될 수 없고 중복될 수 없다\n2. 참조 무결성: 외래키는 참조하는 테이블의 기본키 값과 일치하거나 NULL이어야 한다\n3. 도메인 무결성: 컬럼의 값은 해당 도메인에서 정의된 값이어야 한다\n4. 사용자 정의 무결성: 업무 규칙에 따라 정의된 무결성', 120, 11),
	(103, 2, '[상황]\n1. 학생 테이블과 수강신청 테이블이 있음\n2. 학생이 자퇴하여 학생 테이블에서 삭제됨\n3. 해당 학생의 수강신청 기록은 그대로 남아있음', 2, NULL, '다음과 같은 데이터베이스 상황에서 발생할 수 있는 문제점으로 가장 적절한 것은?', '이는 전형적인 참조 무결성 위배 상황입니다:\n1. 수강신청 테이블의 학생 ID(외래키)가 참조하는 학생 테이블의 데이터가 삭제됨\n2. 고아 레코드(Orphan Record) 발생\n3. 해결방안:\n   - CASCADE DELETE 설정\n   - 학생 삭제 전 수강신청 데이터 처리\n   - 논리적 삭제(물리적 삭제 대신 상태 값 변경) 사용', 120, 11),
	(104, 2, NULL, 3, NULL, '다음 중 관계형 데이터베이스의 키(Key)에 대한 설명으로 가장 적절한 것은?', '각 키의 특징:\n1. 후보키: 유일성과 최소성을 만족하는 키(여러 개 가능)\n2. 기본키: 후보키 중 선택된 대표 키(복합키 가능)\n3. 대체키: 후보키 중 기본키로 선택되지 않은 키\n4. 외래키: 다른 테이블의 기본키를 참조하는 키(이름이 달라도 됨)', 180, 11),
	(105, 2, '[상황]\n회원제 쇼핑몰 데이터베이스 설계 중:\n1. 회원은 여러 개의 배송지 주소를 가질 수 있음\n2. 각 배송지는 기본 배송지 여부를 가짐\n3. 회원별로 딱 하나의 기본 배송지만 가질 수 있음\n4. 배송지는 회원 삭제 시 함께 삭제되어야 함', 3, NULL, '다음과 같은 데이터베이스 설계 상황에서 가장 적절한 해결방안은?', '요구사항을 만족하기 위한 제약조건:\n1. ON DELETE CASCADE: 회원 삭제 시 배송지도 삭제\n2. UNIQUE (MEMBER_ID, IS_DEFAULT): 회원별로 하나의 기본 배송지만 허용\n3. FK_MEMBER: 참조 무결성 보장\n4. PRIMARY KEY: 배송지 식별성 보장', 180, 11),
	(106, 2, NULL, 1, NULL, '다음 중 관계형 데이터베이스의 테이블(Table)에 대한 설명으로 가장 부적절한 것은?', '관계형 데이터베이스에서 테이블의 행과 열의 순서는 데이터의 의미에 영향을 주지 않습니다. 이는 관계형 데이터베이스의 중요한 특징 중 하나로, 데이터의 논리적 구조가 물리적 저장구조와 독립적임을 의미합니다.', 60, 11),
	(107, 2, NULL, 2, NULL, '다음 중 릴레이션(Relation)의 특징에 대한 설명으로 가장 올바른 것은?', '릴레이션의 주요 특징:\n1. 카디널리티: 튜플(행)의 수\n2. 차수: 속성(컬럼)의 수\n3. 속성: 서로 다른 이름을 가져야 함\n4. 튜플: 중복될 수 없음 (유일성)', 120, 11),
	(108, 2, '[테이블 정의]\nCREATE TABLE products (\n    product_id NUMBER,\n    category_id NUMBER,\n    product_name VARCHAR2(100),\n    price NUMBER,\n    stock NUMBER,\n    status CHAR(1)\n);', 2, NULL, '다음과 같은 관계형 데이터베이스 설계에서 가장 적절한 제약조건은?', '적절한 제약조건 설정의 근거:\n1. 기본키 설정:\n   - product_id만으로 충분\n   - 단순한 키 구조\n2. CHECK 제약조건:\n   - 가격과 재고는 음수가 될 수 없음\n   - 업무 규칙 반영\n3. 다른 방식의 문제점:\n   - 불필요한 복합키\n   - 과도한 제약조건', 120, 11),
	(109, 2, '[상황]\n1. 고객 포인트 시스템 운영 중\n2. 포인트 적립과 사용이 빈번하게 발생\n3. 포인트 합계가 마이너스가 되면 안 됨\n4. 모든 포인트 변동 이력 관리 필요', 3, NULL, '다음과 같은 데이터베이스 상황에서 가장 적절한 해결방안은?', '저장 프로시저 사용이 적절한 이유:\n1. 데이터 무결성 보장:\n   - 포인트 합계가 마이너스가 되는 경우 차단\n   - 포인트 변동 이력 자동 기록\n2. 트랜잭션 처리 용이', 180, 11),
	(110, 2, '[요구사항]\n1. 상품은 여러 카테고리에 속할 수 있음\n2. 각 카테고리별로 상품의 진열 순서가 다름\n3. 카테고리별 상품 노출 여부 관리\n4. 카테고리 계층 구조 관리', 3, NULL, '다음과 같은 요구사항에서 가장 적절한 데이터베이스 설계는?', '최적의 데이터베이스 설계 선택 이유:\n1. 카테고리 계층 구조:\n   - 재귀적 관계로 표현\n   - 유연한 깊이 지원\n2. 상품-카테고리 관계:\n   - M:N 관계 표현\n   - 진열 정보 포함\n3. 참조 무결성:\n   - 외래키 제약조건으로 보장\n   - 데이터 일관성 유지', 180, 11),
	(111, 2, NULL, 1, NULL, '다음 중 SELECT문의 실행 순서로 올바른 것은?', 'SQL SELECT문의 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다. 이는 논리적 실행 순서이며, 실제 작성 순서와는 다릅니다.', 60, 12),
	(112, 2, '```sql\nSELECT DEPARTMENT_ID, COUNT(*) AS EMP_COUNT\nFROM EMPLOYEES\nWHERE SALARY >= 5000\nGROUP BY DEPARTMENT_ID\nHAVING COUNT(*) >= 3\nORDER BY EMP_COUNT DESC;\n```', 2, NULL, '다음 SQL문의 실행 결과로 알맞은 것은?', 'WHERE 절에서 급여가 5000 이상인 직원만 필터링하고, GROUP BY로 부서별 그룹화한 후, HAVING 절에서 그룹별 카운트가 3 이상인 부서만 선택합니다.', 120, 12),
	(113, 2, '```sql\n-- Query 1\nSELECT DISTINCT DEPARTMENT_ID\nFROM EMPLOYEES;\n\n-- Query 2\nSELECT DEPARTMENT_ID\nFROM EMPLOYEES\nGROUP BY DEPARTMENT_ID;\n```', 2, NULL, '다음 두 SQL문의 결과가 다른 경우는?', '두 쿼리는 기본적으로 같은 결과를 반환하지만, NULL 값의 처리 방식이 약간 다를 수 있습니다. GROUP BY는 NULL을 하나의 그룹으로 처리합니다.', 120, 12),
	(114, 2, '```sql\nSELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SAL\nFROM EMPLOYEES\nWHERE AVG(SALARY) > 5000\nGROUP BY DEPARTMENT_ID;\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'WHERE 절은 개별 행을 필터링하는 용도로 사용되며, 집계 함수를 사용할 수 없습니다. 집계 함수를 이용한 필터링은 HAVING 절을 사용해야 합니다.', 180, 12),
	(115, 2, '```sql\n-- Base Query\nSELECT DEPARTMENT_ID, AVG(SALARY)\nFROM EMPLOYEES\nGROUP BY DEPARTMENT_ID;\n```', 3, NULL, '다음 SQL문의 실행 결과가 다른 것은?', 'ROLLUP은 지정된 컬럼의 소계를 생성하므로, 전체 총계 행이 추가로 생성됩니다. 따라서 기본 쿼리와 결과가 다릅니다. 나머지 쿼리들은 기본적으로 동일한 결과를 반환합니다.', 180, 12),
	(116, 2, NULL, 1, NULL, '다음 중 SELECT문의 ALIAS(별칭) 사용법으로 올바르지 않은 것은?', '하나의 컬럼에 대해 별칭(ALIAS)은 한 번만 지정할 수 있습니다. AS 키워드는 생략 가능하며, 공백이나 특수문자가 포함된 별칭은 큰따옴표로 묶어야 합니다.', 60, 12),
	(117, 2, '```sql\nSELECT department_id, COUNT(*) emp_count,\n       COUNT(DISTINCT job_id) job_count\nFROM employees\nWHERE salary >= 3000\nGROUP BY department_id\nHAVING AVG(salary) > 5000\nORDER BY emp_count DESC;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는:\n1. WHERE로 급여 3000 이상 필터링\n2. GROUP BY로 부서별 그룹화\n3. HAVING으로 평균 급여 5000 초과 필터링\n4. 각 그룹의 직원 수와 고유한 직무 수 계산\n5. 직원 수 기준 내림차순 정렬', 120, 12),
	(118, 2, '```sql\nSELECT COUNT(column1) as cnt FROM table1;\n```', 2, NULL, '다음과 같은 SELECT문에서 실행 결과가 다른 것은?', 'COUNT 함수의 특징:\n1. COUNT(*): NULL을 포함한 모든 행 카운트\n2. COUNT(1) or COUNT(상수): COUNT(*)와 동일\n3. COUNT(컬럼): 해당 컬럼의 NULL이 아닌 값 카운트\n4. COUNT(DISTINCT 컬럼): 중복을 제거한 고유한 값만 카운트', 120, 12),
	(119, 2, '[요구사항]\n1. 부서별 직원수 조회\n2. 직원이 없는 부서도 포함\n3. 직원수가 많은 순서대로 정렬\n4. 부서가 없는 직원은 \'미배치\'로 표시', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 SQL문은?', '요구사항 분석:\n1. LEFT OUTER JOIN으로 모든 부서 포함\n2. COUNT(e.employee_id)로 부서별 직원 수 계산\n3. NVL로 NULL 처리\n4. ORDER BY로 내림차순 정렬', 180, 12),
	(120, 2, '```sql\n-- Query 1\nSELECT *\nFROM employees\nWHERE department_id IN (\n    SELECT department_id\n    FROM departments\n    WHERE location_id = 1700\n);\n\n-- Query 2\nSELECT e.*\nFROM employees e, departments d\nWHERE e.department_id = d.department_id\nAND d.location_id = 1700;\n\n-- Query 3\nSELECT e.*\nFROM employees e\nINNER JOIN departments d \nON e.department_id = d.department_id\nWHERE d.location_id = 1700;\n```', 3, NULL, '다음 SQL문들의 성능상 차이점을 가장 정확하게 설명한 것은?', 'SQL 성능 고려사항:\n1. 데이터 분포도:\n   - 위치별 부서 분포\n   - 부서별 직원 분포\n2. 인덱스 구성:\n   - location_id 인덱스\n   - department_id 인덱스\n3. 실행 계획:\n   - 옵티마이저의 선택\n   - 통계 정보 활용\n4. 조인 방식:\n   - Nested Loop Join\n   - Hash Join\n   - Sort Merge Join', 180, 12),
	(121, 2, NULL, 1, NULL, '다음 중 숫자형 함수에 대한 설명으로 틀린 것은?', 'MOD 함수는 나머지를 구하는 함수입니다. MOD(10, 3)의 결과는 1입니다. 10을 3으로 나눈 나머지가 1이기 때문입니다.', 60, 13),
	(122, 2, '```sql\nSELECT EMPLOYEE_NAME,\n       NVL2(COMMISSION_PCT,\n            SALARY * (1 + COMMISSION_PCT),\n            SALARY) AS TOTAL_SALARY\nFROM EMPLOYEES\nWHERE EMPLOYEE_ID = 100;\n```', 2, NULL, '다음 SQL문의 실행 결과로 옳은 것은?', 'NVL2(expr1, expr2, expr3) 함수는 expr1이 NULL이 아니면 expr2를, NULL이면 expr3을 반환합니다. 따라서 COMMISSION_PCT가 NULL이면 SALARY를 반환합니다.', 120, 13),
	(123, 2, '[현재 날짜가 2024-03-15라고 가정]', 2, NULL, '다음 날짜형 함수의 실행 결과가 다른 것은?', 'ADD_MONTHS는 정확히 3개월을 더하지만(2024-06-15), SYSDATE + 90은 정확히 90일을 더합니다(2024-06-13). 월마다 일수가 다르기 때문에 결과가 다릅니다.', 120, 13),
	(124, 2, '```sql\nSELECT DEPARTMENT_ID,\n       LISTAGG(EMPLOYEE_NAME, \', \') \n       WITHIN GROUP (ORDER BY SALARY DESC) AS EMPLOYEES\nFROM EMPLOYEES\nGROUP BY DEPARTMENT_ID;\n```', 3, NULL, '다음 SQL문의 실행 결과로 적절한 것은?', 'LISTAGG 함수는 GROUP BY로 그룹화된 데이터를 하나의 열에 가로로 나열합니다. WITHIN GROUP (ORDER BY SALARY DESC)로 인해 급여가 높은 순으로 정렬되어 출력됩니다.', 180, 13),
	(125, 2, '```sql\n-- Query 1\nSELECT DECODE(GRADE,\n             \'A\', \'최우수\',\n             \'B\', \'우수\',\n             \'C\', \'보통\',\n             \'미달\') AS RESULT\nFROM SCORES;\n\n-- Query 2\nSELECT CASE GRADE\n         WHEN \'A\' THEN \'최우수\'\n         WHEN \'B\' THEN \'우수\'\n         WHEN \'C\' THEN \'보통\'\n         ELSE \'미달\'\n       END AS RESULT\nFROM SCORES;\n```', 3, NULL, '다음 중 DECODE 함수와 CASE 문을 비교한 설명으로 가장 적절한 것은?', 'DECODE 함수는 등호(=) 비교만 가능하지만, CASE 문은 >, <, >=, <= 등 다양한 비교 연산자를 사용할 수 있습니다. 또한 CASE 문은 BETWEEN, IN, LIKE 등의 조건식도 사용 가능합니다.', 180, 13),
	(126, 2, NULL, 1, NULL, '다음 중 문자형 함수의 실행 결과로 옳지 않은 것은?', 'INSTR 함수는 문자열에서 특정 문자나 문자열의 위치를 찾는 함수입니다. \'ORACLE SQL\'에서 \'SQL\'은 8번째 위치에서 시작하므로 INSTR(\'ORACLE SQL\', \'SQL\')의 결과는 8입니다.', 60, 13),
	(127, 2, '```sql\nSELECT department_id,\n       COUNT(*) as total,\n       SUM(DECODE(gender, \'M\', 1, 0)) as male,\n       SUM(DECODE(gender, \'F\', 1, 0)) as female\nFROM employees\nGROUP BY department_id;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는:\n1. COUNT(*)로 전체 직원 수 계산\n2. DECODE와 SUM으로 성별 별 인원 계산\n   - gender가 \'M\'이면 1, 아니면 0을 합산하여 남성 수 계산\n   - gender가 \'F\'면 1, 아니면 0을 합산하여 여성 수 계산\n3. GROUP BY로 부서별 집계', 120, 13),
	(128, 2, '```\nPHONE_NUMBER\n-------------\n010-1234-5678\n010-2345-6789\n010)3456-7890\n01045678901\n```', 2, NULL, '다음과 같은 데이터가 있을 때, SQL 실행 결과가 다른 것은?', '④번 쿼리는 \'-\'가 있는 경우만 처리하고 \')\'는 처리하지 않습니다. 나머지 쿼리들은 모든 특수문자를 제거하여 숫자만 남깁니다.', 120, 13),
	(129, 2, '[요구사항]\n1. 직원의 근속연수를 계산\n2. 근속연수에 따라 다음과 같이 표시\n   - 10년 이상: \'10년 이상\'\n   - 5년 이상 10년 미만: \'5년 이상\'\n   - 3년 이상 5년 미만: \'3년 이상\'\n   - 3년 미만: \'신입사원\'\n3. 근속연수는 월 단위까지 계산 (예: 3년 2개월)', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 SQL문은?', '요구사항을 가장 정확히 만족하는 이유:\n1. MONTHS_BETWEEN으로 정확한 월수 계산\n2. 년과 월을 분리하여 표시\n3. 개월 수 기준으로 정확한 근속 기간 계산\n4. 결과에 년수와 개월수를 모두 표시', 180, 13),
	(130, 2, '```sql\n-- Query 1\nSELECT ROUND(AVG(NVL(commission_pct, 0)), 2) as avg_comm\nFROM employees;\n\n-- Query 2\nSELECT ROUND(NVL(AVG(commission_pct), 0), 2) as avg_comm\nFROM employees;\n\n-- Query 3\nSELECT COALESCE(ROUND(AVG(commission_pct), 2), 0) as avg_comm\nFROM employees;\n\n-- Query 4\nSELECT ROUND(AVG(COALESCE(commission_pct, 0)), 2) as avg_comm\nFROM employees;\n```', 3, NULL, '다음 SQL문들의 수행 결과가 다른 것을 고르시오.', 'Query 2는 나머지와 다른 결과를 반환할 수 있습니다. 왜냐하면 commission_pct가 모두 NULL인 경우, AVG 함수의 결과가 NULL이 되고, 이를 0으로 변환하기 때문입니다.', 180, 13),
	(131, 2, NULL, 1, NULL, '다음 중 WHERE절에서 사용할 수 있는 연산자에 대한 설명으로 틀린 것은?', 'NULL값을 찾을 때는 반드시 IS NULL을 사용해야 합니다. "=" 연산자로는 NULL값을 찾을 수 없습니다. NULL은 "알 수 없는 값"이므로 비교 연산자로 비교할 수 없습니다.', 60, 14),
	(132, 2, '```sql\nSELECT employee_name\nFROM employees\nWHERE salary BETWEEN 5000 AND 6000\nAND commission_pct IS NOT NULL\nAND department_id NOT IN (10, 20, 30)\nAND hire_date >= \'2020-01-01\';\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'WHERE절의 조건들은 AND로 연결되어 있어 모든 조건을 동시에 만족해야 합니다. BETWEEN은 경계값을 포함하고, NOT IN은 나열된 값을 제외한 결과를 반환합니다.', 120, 14),
	(133, 2, '```sql\n-- Query 1\nSELECT employee_id, employee_name\nFROM employees\nWHERE department_id = 20\nOR job_id = \'SA_REP\'\nAND salary >= 5000;\n\n-- Query 2\nSELECT employee_id, employee_name\nFROM employees\nWHERE (department_id = 20\nOR job_id = \'SA_REP\')\nAND salary >= 5000;\n```', 2, NULL, '다음 두 SQL문의 실행 결과가 다른 경우는?', 'Query 1은 "department_id = 20" 또는 "job_id = \'SA_REP\' AND salary >= 5000"을 만족하는 직원을 찾습니다. Query 2는 "department_id = 20 OR job_id = \'SA_REP\'"를 만족하면서 "salary >= 5000"인 직원을 찾습니다.', 120, 14),
	(134, 2, '```sql\nSELECT employee_id, employee_name\nFROM employees\nWHERE department_id LIKE \'1%\'\nAND job_id = \'SA_REP\'\nAND salary + NVL(commission_pct, 0) > 5000\nAND hire_date BETWEEN \'2020-01-01\' AND \'2020-12-31\';\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', '숫자형 컬럼인 department_id에 LIKE 연산자를 사용하면 암시적 형변환이 발생하여 성능이 저하될 수 있습니다. 숫자형 컬럼은 = 또는 BETWEEN 등의 연산자를 사용하는 것이 바람직합니다.', 180, 14),
	(135, 2, NULL, 3, NULL, '다음 중 WHERE절의 성능과 관련된 설명으로 가장 부적절한 것은?', 'OR 조건을 AND 조건으로 변환하는 것이 항상 좋은 것은 아닙니다. 때로는 OR 조건을 UNION ALL로 변환하거나, 원래의 OR 조건을 그대로 사용하는 것이 더 나은 성능을 보일 수 있습니다. 실행 계획과 데이터 분포를 고려하여 적절한 방식을 선택해야 합니다.', 180, 14),
	(136, 2, NULL, 1, NULL, '다음 WHERE 절의 조건식 중 올바르지 않은 것은?', 'BETWEEN 연산자에는 NULL을 사용할 수 없습니다. NULL과의 비교는 항상 UNKNOWN을 반환하므로, NULL을 포함한 범위 비교는 불가능합니다. NULL 값 비교는 반드시 IS NULL 또는 IS NOT NULL을 사용해야 합니다.', 60, 14),
	(137, 2, '```sql\n-- Query 1\nSELECT employee_name\nFROM employees\nWHERE NVL(commission_pct, 0) != 0;\n\n-- Query 2\nSELECT employee_name\nFROM employees\nWHERE commission_pct IS NOT NULL;\n\n-- Query 3\nSELECT employee_name\nFROM employees\nWHERE COALESCE(commission_pct, 0) > 0;\n\n-- Query 4\nSELECT employee_name\nFROM employees\nWHERE commission_pct > 0;\n```', 2, NULL, '다음 SQL문들의 실행 결과가 다른 것을 고르시오.', 'Query 1, 3, 4는 commission_pct가 0보다 큰 직원을 조회합니다. 하지만 Query 2는 commission_pct가 NULL이 아닌 모든 직원을 조회하므로 값이 0인 경우도 포함됩니다. 따라서 Query 2만 다른 결과를 반환합니다.', 120, 14),
	(138, 2, '```sql\nSELECT *\nFROM employees\nWHERE _______________\n```', 2, NULL, '다음과 같은 WHERE 절에서 인덱스를 효율적으로 사용할 수 있는 조건은?', '인덱스 사용의 효율성:\n1. 함수를 컬럼에 적용하면 인덱스 사용 불가 (①)\n2. 컬럼에 연산을 수행하면 인덱스 사용 불가 (②)\n3. 날짜 형식 변환은 인덱스 사용 가능 (③)\n4. NVL 함수 사용 시 인덱스 사용 불가 (④)', 120, 14),
	(139, 2, '[요구사항]\n1. 2023년에 입사한 직원 중\n2. 급여가 5000 이상이며\n3. 부서가 10, 20, 30 중 하나이고\n4. 이메일이 \'A\'로 시작하는 직원 조회\n5. 인덱스: (hire_date, salary), (department_id), (email)', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 효율적인 WHERE 절은?', '복합 인덱스와 조건절 순서 고려:\n1. hire_date, salary 복합 인덱스를 활용하기 위해 날짜 범위 조건을 먼저 사용\n2. BETWEEN은 내부적으로 >= AND <= 로 변환되어 효율적\n3. department_id는 단일 인덱스로 IN 조건 사용 가능\n4. email은 LIKE \'A%\' 형태로 인덱스 활용 가능', 180, 14),
	(140, 2, '```sql\nSELECT *\nFROM employees\nWHERE (department_id, salary) IN (\n    SELECT department_id, MAX(salary)\n    FROM employees\n    GROUP BY department_id\n)\nAND commission_pct IS NOT NULL;\n```', 3, NULL, '다음 SQL문의 실행 결과와 성능 특성으로 가장 적절한 것은?', '쿼리 분석:\n1. 서브쿼리 특징:\n   - 독립적으로 실행 가능한 비상관 서브쿼리\n   - GROUP BY로 부서별 최대 급여 계산\n2. 메인 쿼리 특징:\n   - (department_id, salary) 쌍으로 비교\n   - commission_pct 조건 추가\n3. 성능 특성:\n   - 서브쿼리는 한 번만 실행\n   - 결과를 해시 테이블로 저장 가능\n   - 효율적인 조인 수행 가능', 180, 14),
	(141, 2, NULL, 1, NULL, '다음 중 GROUP BY, HAVING 절에 대한 설명으로 틀린 것은?', 'HAVING 절은 GROUP BY 절과 함께 사용해야 합니다. GROUP BY로 그룹화된 데이터에 대한 조건을 지정하는 것이 HAVING 절의 역할이므로, GROUP BY 없이는 사용할 수 없습니다.', 60, 15),
	(142, 2, NULL, 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'SQL문의 실행 순서와 조건:\n1. WHERE로 급여 5000 이상 직원 필터링\n2. department_id, job_id로 그룹화\n3. HAVING으로 그룹별 직원 수 2명 이상 필터링\n4. 직원 수 내림차순 정렬', 120, 15),
	(143, 2, NULL, 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'Query 1은 실행 시 에러 발생:\n- WHERE 절에서는 집계 함수를 사용할 수 없음\n- WHERE는 개별 행을 필터링하는 용도\nQuery 2는 정상 실행:\n- HAVING 절에서 집계 함수 사용 가능\n- 그룹화된 결과에 대한 조건 지정 가능', 120, 15),
	(144, 2, '[요구사항]\n1. 부서별, 직급별 평균 급여 계산\n2. 평균 급여가 5000 이상인 그룹만 조회\n3. 부서 내 직원이 3명 이상인 그룹만 대상\n4. 결과는 부서별, 평균 급여 내림차순 정렬\n5. NULL 값은 제외', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 SQL문은?', '요구사항을 만족하는 이유:\n1. NULL 값 제외를 WHERE 절에서 처리\n2. GROUP BY로 부서별, 직급별 그룹화\n3. HAVING 절에서 평균 급여와 직원 수 조건 체크\n4. ORDER BY로 정렬 요건 충족\n5. ROUND 함수로 소수점 처리', 180, 15),
	(145, 2, '[요구사항]\n- 부서별로 급여 구간대 인원 수 계산\n- 급여 구간: 0-5000, 5001-10000, 10001 이상\n- 부서별 전체 인원이 5명 이상인 부서만 조회\n- 구간별 인원수가 0명인 경우도 표시\n- 부서명과 함께 출력', 3, NULL, '다음과 같은 데이터에서 부서별 급여 분포를 조회하려고 할 때, 가장 적절한 SQL문은?', '가장 적절한 해결방안:\n1. CASE WHEN과 SUM을 조합하여 각 구간별 카운트\n2. ELSE 0을 통해 NULL 처리\n3. department_id도 GROUP BY에 포함하여 정확한 그룹화\n4. HAVING으로 전체 인원 5명 이상 필터링\n5. JOIN을 통해 부서명 표시', 180, 15),
	(146, 2, NULL, 1, NULL, '다음 중 GROUP BY 절에서 사용할 수 있는 표현식으로 올바르지 않은 것은?', 'GROUP BY 절에서는 연산식을 직접 사용할 수 없습니다. salary + commission_pct와 같은 산술식은 SELECT 절에서는 사용 가능하지만, GROUP BY 절에서는 사용할 수 없습니다. 함수나 CASE 표현식은 사용 가능합니다.', 60, 15),
	(147, 2, NULL, 2, NULL, '다음 SQL문에서 잘못된 부분을 찾으시오.', 'GROUP BY 절을 사용할 때는 집계 함수를 제외한 SELECT 절의 모든 컬럼이 GROUP BY 절에 포함되어야 합니다. employee_name은 집계 함수로 감싸지 않았으므로 GROUP BY 절에 포함되어야 합니다.', 120, 15),
	(148, 2, '[Employees 테이블]\nHIRE_DATE    DEPARTMENT_ID    SALARY\n2023-01-01   10              5000\n2023-02-01   10              6000\n2023-01-15   20              4500\n2023-03-01   20              5500', 2, NULL, '다음과 같은 데이터에서 적절한 그룹화 방법은?', '①번이 가장 적절한 이유:\n1. TO_CHAR 함수로 년-월 단위 그룹화\n2. GROUP BY 절에 SELECT 절의 모든 비집계 컬럼 포함\n3. 결과의 의미가 명확함\n4. 날짜 데이터를 원하는 형식으로 정확히 그룹화', 120, 15),
	(149, 2, '[요구사항]\n1. 분기별 매출 집계\n2. 전체 매출의 10% 이상인 분기만 조회\n3. 분기별 주문 건수도 함께 표시\n4. 분기별 평균 주문금액이 1000 이상인 경우만 포함', 3, NULL, '다음과 같은 분석 요구사항에 맞는 SQL문은?', '요구사항을 정확히 만족하는 이유:\n1. 분기별 그룹화: TO_CHAR(order_date, \'Q\')\n2. 전체 매출의 10% 조건: 서브쿼리로 비교\n3. 주문 건수: COUNT(*)\n4. 평균 주문금액 조건: AVG(amount) >= 1000\n5. HAVING 절에서 모든 조건을 정확히 체크', 180, 15),
	(150, 2, NULL, 3, NULL, '다음 GROUP BY 절의 성능 개선 방법으로 가장 부적절한 것은?', 'GROUP BY와 DISTINCT는 다른 목적으로 사용됩니다:\n1. GROUP BY:\n   - 집계 함수와 함께 사용\n   - 여러 행을 그룹화하여 요약 정보 생성\n   - 인덱스를 활용한 최적화 가능\n2. DISTINCT:\n   - 단순 중복 제거\n   - 집계 기능 없음\n   - 전체 데이터 스캔 필요\n3. 성능 개선 방안:\n   - 적절한 인덱스 사용\n   - 데이터 필터링\n   - 임시 테이블 활용', 180, 15),
	(151, 2, NULL, 1, NULL, '다음 중 ORDER BY 절에 대한 설명으로 틀린 것은?', 'ORDER BY 절에서는 SELECT 목록에 있는 모든 컬럼과 표현식을 사용할 수 있습니다. GROUP BY 절에 사용한 컬럼으로 제한되지 않습니다. 단, GROUP BY를 사용할 경우 집계함수나 GROUP BY에 사용된 컬럼으로 정렬하는 것이 일반적입니다.', 60, 16),
	(152, 2, '```sql\nSELECT department_id, \n       COUNT(*) as emp_count,\n       AVG(salary) as avg_salary\nFROM employees\nWHERE salary >= 5000\nGROUP BY department_id\nORDER BY 2 DESC, 3;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'ORDER BY 절의 해석:\n1. ORDER BY 2: SELECT 목록의 두 번째 컬럼(emp_count)으로 내림차순\n2. ORDER BY 3: SELECT 목록의 세 번째 컬럼(avg_salary)으로 오름차순\n3. DESC는 앞의 정렬 기준에만 적용\n4. 컬럼 번호 대신 컬럼명을 사용하는 것이 더 명확함', 120, 16),
	(153, 2, '```sql\n-- Query 1\nSELECT employee_id, first_name, salary\nFROM employees\nWHERE department_id = 50\nORDER BY salary DESC NULLS LAST;\n\n-- Query 2\nSELECT employee_id, first_name, salary\nFROM employees\nWHERE department_id = 50\nORDER BY salary DESC;\n```', 2, NULL, '다음 두 SQL문의 실행 결과가 다른 경우는?', 'NULLS LAST와 일반 정렬의 차이:\n1. NULLS LAST: NULL 값을 항상 마지막에 정렬\n2. 일반 정렬(Oracle): NULL 값을 가장 큰 값으로 처리\n3. salary가 NULL인 경우:\n   - Query 1: NULL 값이 결과의 마지막에 위치\n   - Query 2: NULL 값이 결과의 처음에 위치 (DESC 정렬 시)', 120, 16),
	(154, 2, '[요구사항]\n1. 부서별 직원 목록 조회\n2. 부서 내에서 직급별로 그룹화\n3. 같은 직급 내에서는 급여 높은 순\n4. 급여가 같은 경우 입사일이 빠른 순\n5. NULL 값은 마지막에 표시', 3, NULL, '다음과 같은 정렬이 필요할 때, 가장 적절한 SQL문은?', '요구사항을 만족하는 핵심 요소:\n1. department_name으로 첫 번째 정렬\n2. job_title로 두 번째 정렬\n3. salary DESC로 세 번째 정렬\n4. hire_date ASC로 네 번째 정렬\n5. 각 컬럼에 NULLS LAST 지정\n6. 명시적인 컬럼명 사용', 180, 16),
	(155, 2, '[요구사항]\n- 부서별 급여 순위 산출\n- 급여가 같은 경우 같은 순위 부여\n- 다음 순위는 건너뛰기\n- 부서별로 상위 3위까지만 표시', 3, NULL, '다음과 같은 순위 기반 정렬이 필요할 때, 가장 적절한 SQL문은?', '요구사항을 만족하는 이유:\n1. RANK() 함수 사용으로 동일 값 같은 순위\n2. PARTITION BY로 부서별 순위 계산\n3. salary DESC로 급여 내림차순\n4. 서브쿼리와 WHERE절로 상위 3위 필터링\n5. ORDER BY로 부서별, 순위별 정렬', 180, 16),
	(156, 2, NULL, 1, NULL, '다음 중 ORDER BY 절에서 NULL 값을 처리하는 방법으로 올바르지 않은 것은?', 'ORDER BY DESC와 NULLS FIRST를 함께 사용하는 것은 일반적이지 않습니다. DESC 정렬에서는 기본적으로 NULL이 가장 큰 값으로 처리되므로 NULLS FIRST는 정렬 의도와 맞지 않습니다.', 60, 16),
	(157, 2, '```sql\nSELECT * FROM employees\nWHERE department_id = 50\nORDER BY job_id, hire_date DESC, salary;\n```', 2, NULL, '다음과 같은 ORDER BY 절을 사용할 때 가장 효율적인 인덱스 구성은?', '복합 인덱스 구성 시 고려사항:\n1. WHERE 절의 조건이 선두 컬럼(department_id)\n2. ORDER BY의 모든 컬럼 포함\n3. 정렬 순서와 인덱스 구성 순서 일치\n4. 단일 인덱스 스캔으로 결과 도출 가능', 120, 16),
	(158, 2, '```sql\n-- Query 1\nSELECT employee_id, salary\nFROM employees\nORDER BY hire_date DESC;\n\n-- Query 2\nSELECT employee_id, salary\nFROM employees\nWHERE employee_id > 0\nORDER BY hire_date DESC;\n```', 2, NULL, '다음 두 SQL문의 실행 계획이 다른 경우는?', 'employee_id에 인덱스가 있는 경우:\n1. Query 1: hire_date 기준 정렬 필요\n2. Query 2: employee_id 인덱스 스캔 후 정렬 필요\n3. WHERE 조건으로 인해 인덱스 활용 방식이 달라짐\n4. 서로 다른 실행 계획 생성', 120, 16),
	(159, 2, '[요구사항]\n1. 부서별 급여 합계를 구하되\n2. 급여 합계 상위 3개 부서만 조회\n3. 나머지 부서는 \'Others\'로 묶어서 표시\n4. 결과는 급여 합계 내림차순 정렬', 3, NULL, '다음과 같은 복잡한 정렬이 필요할 때, 가장 적절한 SQL문은?', '최적의 해결방안 선택 이유:\n1. 순위 계산: RANK() 함수 사용\n2. 상위 3개 구분: CASE 문으로 처리\n3. Others 그룹화: 추가 GROUP BY로 처리\n4. 정렬: 최종 결과 ORDER BY로 정렬\n5. 서브쿼리로 단계적 처리', 180, 16),
	(160, 2, NULL, 3, NULL, '다음 중 ORDER BY 절의 성능 개선 방안으로 가장 부적절한 것은?', '모든 정렬 컬럼에 대한 인덱스 생성은 부적절:\n1. 과도한 인덱스:\n   - 저장 공간 낭비\n   - DML 성능 저하\n   - 인덱스 관리 비용 증가\n2. 적절한 개선 방안:\n   - 필요한 컬럼만 조회\n   - 데이터 필터링 후 정렬\n   - 복합 인덱스 활용\n   - 실행 계획 분석', 180, 16),
	(161, 2, '```sql\nSELECT * FROM EMP E, DEPT D\nWHERE E.DEPTNO = D.DEPTNO;\n```', 1, NULL, '다음 중 조인(JOIN)에 대한 설명으로 가장 부적절한 것은?', 'OUTER JOIN은 조인 조건에서 NULL 값을 가진 데이터도 출력할 수 있습니다. 이는 OUTER JOIN의 주요 특징 중 하나입니다.', 60, 17),
	(162, 2, '```sql\nSELECT COUNT(*) \nFROM EMPLOYEE E \nLEFT OUTER JOIN DEPARTMENT D\nON E.DEPT_ID = D.DEPT_ID\nWHERE D.DEPT_NAME IS NULL;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'LEFT OUTER JOIN을 수행한 후 D.DEPT_NAME IS NULL 조건은 부서 테이블과 매칭되지 않은 사원, 즉 부서가 없는 사원을 찾는 조건입니다.', 120, 17),
	(163, 2, '```sql\nSELECT *\nFROM TABLE1 T1, TABLE2 T2, TABLE3 T3\nWHERE T1.COL1 = T2.COL1\nAND T2.COL2 = T3.COL2;\n```', 2, NULL, '세 개의 테이블을 조인할 때 다음 SQL문의 실행 결과와 동일한 것은?', '일반적인 WHERE 절을 사용한 조인은 INNER JOIN과 동일한 결과를 반환합니다.', 120, 17),
	(164, 2, '```sql\n-- Query 1\nSELECT E.ENAME, D.DNAME\nFROM EMP E, DEPT D\nWHERE E.DEPTNO = D.DEPTNO;\n\n-- Query 2\nSELECT E.ENAME, D.DNAME\nFROM EMP E LEFT OUTER JOIN DEPT D\nON E.DEPTNO = D.DEPTNO;\n```', 3, NULL, '다음 두 쿼리의 결과가 다른 경우는?', 'EMP 테이블의 DEPTNO가 NULL인 경우, Query 1(INNER JOIN)에서는 해당 데이터가 제외되지만, Query 2(LEFT OUTER JOIN)에서는 포함됩니다.', 180, 17),
	(165, 2, '```sql\nSELECT E.EMPNO, E.ENAME, D.DNAME\nFROM EMP E, DEPT D\nWHERE E.DEPTNO = D.DEPTNO\nAND D.LOC IN (\'NEW YORK\', \'BOSTON\')\nAND E.SAL >= 3000;\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'WHERE 절을 사용한 INNER JOIN은 NULL 값을 가진 데이터를 자동으로 제외하므로, 누락될 수 있는 중요한 데이터가 있다면 OUTER JOIN을 고려해야 합니다.', 180, 17),
	(166, 2, NULL, 1, NULL, '다음 중 SELF JOIN에 대한 설명으로 가장 부적절한 것은?', 'SELF JOIN은 서브쿼리와 함께 사용할 필요가 없습니다. 동일한 테이블을 별칭을 달리하여 조인하는 것만으로도 충분합니다.', 60, 17),
	(167, 2, '```sql\n-- Query 1\nSELECT * FROM employees e\nINNER JOIN departments d\nON e.department_id = d.department_id;\n\n-- Query 2\nSELECT * FROM employees e, departments d\nWHERE e.department_id = d.department_id;\n\n-- Query 3\nSELECT * FROM employees e\nNATURAL JOIN departments d;\n\n-- Query 4\nSELECT * FROM employees e\nJOIN departments d USING (department_id);\n```', 2, NULL, '다음 SQL문들의 실행 결과가 같은 것을 고르시오.', 'Query 1과 Query 2는 동일한 INNER JOIN을 표현하는 다른 문법입니다.\nNATURAL JOIN은 같은 이름을 가진 모든 컬럼을 자동으로 조인합니다.\nUSING은 지정된 컬럼만 조인하며, 조인 컬럼이 결과에 한 번만 표시됩니다.', 120, 17),
	(168, 2, '```sql\n-- 주문(Orders) 테이블의 일부 데이터만 고객(Customers) 정보 필요\n-- 모든 주문은 반드시 고객 정보가 있어야 함\n-- 주문 금액으로 정렬 필요\n```', 2, NULL, '다음과 같은 테이블 구조에서 가장 적절한 조인 방식은?', 'INNER JOIN이 가장 적절한 이유:\n1. 모든 주문에 고객 정보가 필요하고 존재함\n2. 고객 정보가 없는 주문은 불가능함\n3. 고객 테이블의 모든 데이터가 필요하지 않음\n4. INNER JOIN이 성능상 가장 유리함', 120, 17),
	(169, 2, '```sql\n[요구사항]\n1. 부서별 사원 수 조회\n2. 사원이 없는 부서도 포함\n3. 부서가 없는 사원도 포함\n4. 부서 이름 기준 오름차순 정렬\n```', 3, NULL, '다음 요구사항을 만족하는 가장 적절한 SQL문은?', '최적의 해결방안 선택 이유:\n1. FULL OUTER JOIN으로 모든 케이스 포함\n2. NVL로 NULL 부서명 처리\n3. COUNT(employee_id)로 정확한 직원 수 계산\n4. CASE 식으로 NULL 정렬 처리\n5. ORDER BY로 정렬 요건 충족', 180, 17),
	(170, 2, NULL, 3, NULL, '다음 조인 쿼리의 성능 개선 방안으로 가장 부적절한 것은?', 'WHERE 절의 조건을 ON 절로 이동하는 것은:\n1. INNER JOIN의 경우 성능 차이가 없음\n2. OUTER JOIN의 경우 결과가 달라질 수 있음\n3. 가독성이 저하될 수 있음\n4. 쿼리 최적화에 부정적 영향을 줄 수 있음\n\n적절한 성능 개선 방안:\n1. 적절한 인덱스 생성\n2. 조인 테이블 순서 최적화\n3. 불필요한 OUTER JOIN 제거', 180, 17),
	(171, 2, NULL, 1, NULL, '다음 중 표준 SQL의 조인 문법에 대한 설명으로 틀린 것은?', 'CROSS JOIN은 ON 절을 사용하지 않습니다. CROSS JOIN은 두 테이블의 모든 행을 조합하는 카테시안 곱(Cartesian Product)을 생성하며, 조인 조건이 필요하지 않습니다.', 60, 18),
	(172, 2, NULL, 2, NULL, '다음 두 SQL문의 실행 결과가 다른 경우는?', '두 쿼리의 차이점:\n1. Query 1: WHERE 절로 인해 LEFT JOIN의 효과가 사라지고 INNER JOIN처럼 동작\n2. Query 2: ON 절의 조건으로 인해 LEFT JOIN의 효과 유지\n3. 특히 department_id가 NULL인 직원의 경우:\n   - Query 1: 결과에서 제외됨\n   - Query 2: NULL 값으로 포함됨', 120, 18),
	(173, 2, '[ORDERS 테이블]\nORDER_ID    CUSTOMER_ID    ORDER_DATE\n1           A001           2024-01-01\n2           A002           2024-01-02\n3           A003           2024-01-03\n\n[CUSTOMERS 테이블]\nCUSTOMER_ID    NAME        GRADE\nA001           김철수       VIP\nA002           이영희       GOLD\nA004           박지민       SILVER', 2, NULL, '다음과 같은 데이터가 있을 때, 주어진 SQL문의 결과로 올바른 것은?', 'RIGHT OUTER JOIN의 결과:\n1. A001 고객: 주문 있음 (1행)\n2. A002 고객: 주문 있음 (1행)\n3. A004 고객: 주문 없음 (1행, order_id는 NULL)\n4. A003의 주문은 결과에서 제외 (매칭되는 고객 없음)\n따라서 총 3개의 행이 조회됩니다.', 120, 18),
	(174, 2, '[요구사항]\n1. 모든 부서의 정보 출력\n2. 각 부서별 평균 급여 계산\n3. 부서에 직원이 없는 경우 평균 급여를 0으로 표시\n4. 부서명, 직원 수, 평균 급여 출력', 3, NULL, '다음 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '요구사항을 충족하기 위한 핵심 포인트:\n1. LEFT JOIN 또는 RIGHT JOIN으로 모든 부서 정보 포함\n2. COUNT(employee_id)로 정확한 직원 수 계산\n3. NVL(AVG(salary), 0)으로 NULL 처리\n4. GROUP BY에 department_id 포함하여 정확한 그룹화\n5. department_name도 GROUP BY에 포함', 180, 18),
	(175, 2, '[SQL문]\nSELECT e.employee_id, e.employee_name,\n       d.department_name,\n       l.city,\n       j.job_title\nFROM employees e\nLEFT JOIN departments d ON e.department_id = d.department_id\nLEFT JOIN locations l ON d.location_id = l.location_id\nLEFT JOIN jobs j ON e.job_id = j.job_id\nWHERE e.hire_date >= \'2023-01-01\'\nAND d.department_name LIKE \'IT%\';', 3, NULL, '다음과 같은 조인 쿼리의 성능 개선 방안으로 가장 부적절한 것은?', 'LEFT JOIN을 INNER JOIN으로 변경하는 것은 부적절합니다:\n1. 데이터의 의미가 변경될 수 있음\n2. 누락되는 데이터가 발생할 수 있음\n3. 업무 요구사항을 만족하지 못할 수 있음\n\n적절한 성능 개선 방안:\n1. WHERE 조건을 서브쿼리로 먼저 필터링\n2. 조인 순서 최적화\n3. 적절한 인덱스 사용\n4. 불필요한 조인 제거', 180, 18),
	(176, 2, NULL, 1, NULL, '다음 중 NATURAL JOIN에 대한 설명으로 가장 올바른 것은?', 'NATURAL JOIN은 두 테이블 간 동일한 이름을 가진 모든 컬럼을 자동으로 조인 조건으로 사용합니다. ON 절을 사용하지 않으며, 조인 컬럼은 결과에서 한 번만 나타납니다.', 60, 18),
	(177, 2, NULL, 2, NULL, '다음 SQL문들의 실행 결과가 다른 것은?', 'NATURAL JOIN은 동일한 이름을 가진 모든 컬럼을 조인 조건으로 사용합니다. 만약 department_id 외에도 다른 동일한 이름의 컬럼이 있다면, 결과가 다를 수 있습니다. 나머지는 모두 department_id만을 조인 조건으로 사용합니다.', 120, 18),
	(178, 2, '[데이터베이스 구조]\n- 직원은 반드시 하나의 부서에 속함\n- 부서는 반드시 하나의 지역에 속함\n- 직원은 여러 개의 프로젝트에 참여 가능\n- 프로젝트는 여러 명의 직원이 참여 가능', 2, NULL, '다음과 같은 데이터베이스 구조에서 가장 적절한 조인 방식은?', '주어진 상황 분석:\n1. 직원-부서: 필수 관계 → INNER JOIN\n2. 부서-지역: 필수 관계 → INNER JOIN\n3. 직원-프로젝트: M:N 관계 → 중간 테이블 사용한 INNER JOIN\n모든 관계가 필수적이므로 INNER JOIN이 가장 적절합니다.', 120, 18),
	(179, 2, '[요구사항]\n1. 모든 부서의 평균 급여 조회\n2. 직원이 있는 부서는 해당 부서 평균 급여 표시\n3. 직원이 없는 부서는 전체 평균 급여 표시\n4. 부서 없는 직원의 급여는 제외', 3, NULL, '다음 요구사항에 맞는 가장 적절한 SQL문은?', '요구사항을 만족하는 이유:\n1. LEFT JOIN으로 모든 부서 포함\n2. COUNT로 직원 유무 확인\n3. CASE 문으로 조건부 평균 계산\n4. 서브쿼리로 전체 평균 계산\n5. GROUP BY로 정확한 그룹화', 180, 18),
	(180, 2, NULL, 3, NULL, '다음과 같은 CROSS JOIN이 필요한 상황으로 가장 적절한 것은?', 'CROSS JOIN의 적절한 사용 사례:\n1. 모든 가능한 조합이 필요한 경우:\n   - 상품 크기와 색상의 모든 조합\n   - 날짜별 부서 조합\n   - 테스트 데이터 생성\n\n2. 부적절한 사용 사례:\n   - 계층 구조 → SELF JOIN\n   - 누락 데이터 → OUTER JOIN\n   - 집계 → GROUP BY', 180, 18),
	(181, 2, NULL, 1, NULL, '다음 중 서브쿼리에 대한 설명으로 틀린 것은?', '스칼라 서브쿼리는 SELECT절에서 사용되며 반드시 단일 행, 단일 컬럼을 반환해야 합니다. 다중 행을 반환하면 오류가 발생합니다.', 60, 19),
	(182, 2, '```sql\nSELECT employee_name, salary\nFROM employees e\nWHERE salary > (\n    SELECT AVG(salary)\n    FROM employees\n    WHERE department_id = e.department_id\n);\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', '이 쿼리는 상호연관 서브쿼리를 사용하여 각 직원이 속한 부서의 평균 급여와 비교합니다. e.department_id를 통해 메인쿼리의 각 행에 대해 해당 부서의 평균 급여를 계산하여 비교합니다.', 120, 19),
	(183, 2, '```sql\n-- Query 1\nSELECT department_id, department_name\nFROM departments\nWHERE department_id IN (\n    SELECT department_id\n    FROM employees\n    WHERE salary >= 5000\n);\n\n-- Query 2\nSELECT DISTINCT d.department_id, d.department_name\nFROM departments d, employees e\nWHERE d.department_id = e.department_id\nAND e.salary >= 5000;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'department_id가 NULL인 직원의 경우, Query 1에서는 IN 절에 NULL이 포함되어 결과에서 제외되지만, Query 2에서는 조인 조건을 만족하지 않아 처음부터 결과에 포함되지 않습니다.', 120, 19),
	(184, 2, '```sql\nSELECT employee_id, employee_name,\n       (SELECT department_name \n        FROM departments d \n        WHERE d.department_id = e.department_id) as dept_name,\n       (SELECT job_title \n        FROM jobs j \n        WHERE j.job_id = e.job_id) as job_name\nFROM employees e;\n```', 3, NULL, '다음 SQL문에서 발생할 수 있는 문제점으로 가장 적절한 것은?', '이 쿼리는 각 행마다 2개의 스칼라 서브쿼리가 실행되므로, 데이터 양이 많을 경우 성능이 크게 저하될 수 있습니다. 이런 경우 조인을 사용하는 것이 더 효율적일 수 있습니다.', 180, 19),
	(185, 2, '```sql\n-- Original Query\nSELECT *\nFROM employees e\nWHERE salary > (\n    SELECT AVG(salary)\n    FROM employees\n    WHERE department_id = e.department_id\n)\nAND department_id IN (\n    SELECT department_id\n    FROM departments\n    WHERE location_id = 1700\n);\n```', 3, NULL, '다음 중 서브쿼리 성능 개선 방안으로 가장 부적절한 것은?', '모든 서브쿼리를 뷰로 생성하는 것은 적절하지 않습니다. 뷰는 재사용성이 높고 복잡한 로직을 캡슐화할 때 사용하는 것이 좋으며, 단순한 서브쿼리의 경우 오히려 성능 저하를 초래할 수 있습니다.', 180, 19),
	(186, 2, NULL, 1, NULL, '다음 중 인라인 뷰(Inline View)에 대한 설명으로 가장 부적절한 것은?', '인라인 뷰에서도 메인쿼리의 컬럼을 참조할 수 있습니다. 이를 상관관계 서브쿼리(Correlated Subquery)라고 하며, 메인쿼리의 각 행에 대해 서브쿼리가 실행됩니다.', 60, 19),
	(187, 2, '```sql\nSELECT department_id, employee_name, salary\nFROM (\n    SELECT department_id, employee_name, salary,\n           RANK() OVER (PARTITION BY department_id \n                       ORDER BY salary DESC) as rank\n    FROM employees\n)\nWHERE rank <= 2;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는 부서별로 급여 순위를 계산한 후, 순위가 2 이하인 직원만 선택합니다. 따라서 각 부서별로 급여가 가장 높은 2명의 직원이 조회됩니다.', 120, 19),
	(188, 2, '```sql\nSELECT *\nFROM employees\nWHERE (department_id, salary) IN (\n    SELECT department_id, MAX(salary)\n    FROM employees\n    GROUP BY department_id\n);\n```', 2, NULL, '다음과 같은 서브쿼리를 사용할 때 가장 적절한 방식은?', '복합 컬럼 비교를 하는 경우 현재의 방식이 가장 적절합니다. 가독성이 좋고, 의도가 명확하며, 최적화도 잘 됩니다.', 120, 19),
	(189, 2, '[요구사항]\n1. 부서별 평균 급여보다 많은 급여를 받는 직원 조회\n2. 부서가 없는 직원도 전체 평균과 비교하여 포함\n3. 급여 순으로 정렬', 3, NULL, '다음과 같은 요구사항을 만족하는 가장 적절한 SQL문은?', 'LEFT JOIN을 사용하여 부서가 없는 직원도 포함하고, NVL을 사용하여 NULL을 처리하며, 상관 서브쿼리로 각 부서별 평균과 비교하여 급여가 높은 직원을 조회합니다.', 180, 19),
	(190, 2, '```sql\nSELECT e.employee_id, e.employee_name,\n       (SELECT department_name \n        FROM departments d \n        WHERE d.department_id = e.department_id) as dept_name,\n       (SELECT COUNT(*) \n        FROM employees \n        WHERE department_id = e.department_id) as dept_count\nFROM employees e\nWHERE salary > (\n    SELECT AVG(salary) \n    FROM employees \n    WHERE department_id = e.department_id\n);\n```', 3, NULL, '다음 서브쿼리의 성능 개선 방안으로 가장 적절한 것은?', 'WITH절을 사용하여 부서별 통계를 한 번만 계산하고 결과를 재사용하면 성능이 향상됩니다.', 180, 19),
	(191, 2, NULL, 1, NULL, '다음 중 집합 연산자에 대한 설명으로 틀린 것은?', 'MINUS는 첫 번째 집합에서 두 번째 집합을 뺀 차집합을 반환합니다. 교집합을 반환하는 것은 INTERSECT입니다.', 60, 20),
	(192, 2, '```sql\nSELECT employee_id, department_id\nFROM employees\nWHERE department_id = 10\nUNION\nSELECT employee_id, department_id\nFROM employees\nWHERE salary >= 5000\nORDER BY employee_id;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'UNION 연산자는 두 SELECT 결과를 합집합으로 반환하고 중복을 제거합니다. ORDER BY는 마지막에만 사용 가능하며 전체 결과를 정렬합니다.', 120, 20),
	(193, 2, '```sql\n-- Query 1\nSELECT department_id FROM employees\nMINUS\nSELECT department_id FROM departments;\n\n-- Query 2\nSELECT DISTINCT department_id \nFROM employees e\nWHERE NOT EXISTS (\n    SELECT 1 FROM departments d\n    WHERE d.department_id = e.department_id\n);\n```', 2, NULL, '다음 두 집합 연산의 결과가 같은 경우는?', '두 쿼리는 employees 테이블에만 존재하는 department_id를 조회하는 동일한 결과를 반환합니다.', 120, 20),
	(194, 2, '[요구사항]\n1. 2023년과 2024년의 월별 매출 비교\n2. 두 기간의 매출이 모두 존재하는 월만 조회\n3. 매출 차이도 함께 표시\n4. 월별로 정렬하여 출력', 3, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', '각 연도의 매출을 별도로 집계하고 조인을 통해 두 기간 모두 존재하는 월만 선택하여 차이를 계산합니다.', 180, 20),
	(195, 2, NULL, 3, NULL, '다음 중 집합 연산자의 제약사항으로 가장 부적절한 것은?', '집합 연산자를 사용할 때는 컬럼 개수와 데이터 타입이 일치해야 하지만, 별칭(Alias)은 동일할 필요가 없습니다.', 180, 20),
	(196, 2, NULL, 1, NULL, '다음 중 UNION ALL과 UNION의 차이점으로 가장 적절한 것은?', 'UNION은 중복을 제거하지만, UNION ALL은 중복을 허용합니다. 일반적으로 UNION ALL이 성능이 더 좋습니다.', 60, 20),
	(197, 2, '```sql\n-- Query 1\nSELECT department_id FROM employees\nINTERSECT\nSELECT department_id FROM departments;\n\n-- Query 2\nSELECT DISTINCT department_id\nFROM employees e\nWHERE EXISTS (\n    SELECT 1 FROM departments d\n    WHERE d.department_id = e.department_id\n);\n\n-- Query 3\nSELECT DISTINCT e.department_id\nFROM employees e\nINNER JOIN departments d\nON e.department_id = d.department_id;\n\n-- Query 4\nSELECT department_id FROM employees\nWHERE department_id IN (\n    SELECT department_id FROM departments\n);\n```', 2, NULL, '다음 SQL문들의 실행 결과가 같은 것을 고르시오.', 'INTERSECT, EXISTS, INNER JOIN, IN 연산자는 모두 동일한 결과를 반환합니다.', 120, 20),
	(198, 2, '```sql\n[TABLE1]        [TABLE2]\nID  VALUE       ID  VALUE\n1   A           1   A\n2   B           2   B\n3   C           4   D\nNULL E          NULL F\n\nSELECT * FROM TABLE1\nMINUS\nSELECT * FROM TABLE2;\n```', 2, NULL, '다음과 같은 데이터가 있을 때, SQL문의 결과로 올바른 것은?', 'MINUS 연산 시, 첫 번째 테이블(TABEL1)에는 존재하지만 두 번째 테이블(TABEL2)에는 없는 행이 반환됩니다.', 120, 20),
	(199, 2, '[요구사항]\n1. 2023년과 2024년 모두 주문한 고객 목록\n2. 각 연도의 주문 금액 합계\n3. 주문 금액이 증가한 고객만 조회\n4. 증가액 순으로 정렬', 3, NULL, '다음 요구사항에 맞는 가장 효율적인 SQL문은?', 'HAVING 절과 CASE 문을 활용하여 단일 테이블 조회로 성능을 최적화합니다.', 180, 20),
	(200, 2, '```sql\nSELECT employee_id, first_name \nFROM employees_2023\nUNION\nSELECT employee_id, first_name \nFROM employees_2024;\n```', 3, NULL, '다음 집합 연산의 성능 개선 방안으로 가장 적절한 것은?', 'UNION ALL은 중복 제거를 수행하지 않기 때문에 성능이 향상됩니다. 단, 중복이 필요 없는 경우 UNION을 유지해야 합니다.', 180, 20),
	(201, 2, NULL, 1, NULL, '다음 중 그룹 함수에 대한 설명으로 틀린 것은?', 'AVG 함수는 NULL 값을 제외하고 평균을 계산합니다. NULL을 0으로 처리하지 않습니다. NULL을 0으로 처리하고 싶다면 NVL 함수를 함께 사용해야 합니다. 예: AVG(NVL(column, 0))', 60, 21),
	(202, 2, '```sql\nSELECT department_id,\n       COUNT(*) as total_emp,\n       COUNT(commission_pct) as comm_emp,\n       MAX(salary) as max_sal,\n       MIN(salary) as min_sal,\n       ROUND(AVG(salary), 2) as avg_sal\nFROM employees\nGROUP BY department_id\nHAVING COUNT(*) >= 5\nORDER BY avg_sal DESC;\n```', 2, NULL, '다음 SQL문의 실행 결과로 적절한 것은?', '이 쿼리는 다음과 같은 정보를 제공합니다:\n1. department_id로 그룹화\n2. COUNT(*)로 전체 직원 수 계산\n3. COUNT(commission_pct)로 커미션이 있는 직원 수 계산\n4. MAX/MIN으로 최대/최소 급여 계산\n5. HAVING 절로 직원이 5명 이상인 부서만 필터링\n6. 평균 급여 내림차순으로 정렬', 120, 21),
	(203, 2, '```sql\n-- Query 1\nSELECT department_id, COUNT(employee_id)\nFROM employees\nGROUP BY department_id;\n\n-- Query 2\nSELECT department_id, COUNT(*)\nFROM employees\nGROUP BY department_id;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'COUNT(컬럼명)은 해당 컬럼의 NULL을 제외한 행의 수를 계산하고, COUNT(*)는 NULL을 포함한 모든 행의 수를 계산합니다. 따라서 employee_id에 NULL이 있는 경우 두 쿼리의 결과가 다릅니다.', 120, 21),
	(204, 2, '```sql\nSELECT department_id,\n       GROUPING(department_id) as dept_grp,\n       job_id,\n       GROUPING(job_id) as job_grp,\n       COUNT(*) as emp_count,\n       SUM(salary) as total_salary\nFROM employees\nGROUP BY ROLLUP(department_id, job_id);\n```', 3, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', 'ROLLUP은 지정된 컬럼의 계층적 집계를 생성합니다:\n1. (department_id, job_id) 조합별 집계\n2. department_id별 소계\n3. 전체 총계\nGROUPING 함수는 해당 행이 소계나 총계에서 생성된 것인지를 나타냅니다(1: 집계행, 0: 상세행).', 180, 21),
	(205, 2, '[요구사항]\n1. 부서별 급여 통계를 계산해야 함\n2. 급여가 NULL인 직원은 0으로 계산\n3. 커미션이 NULL인 경우는 제외\n4. 부서별로 다음 정보 필요:\n   - 평균 급여(소수점 2자리)\n   - 급여 합계\n   - 최대/최소 급여의 차이', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 그룹 함수 사용 방법은?', '요구사항을 모두 충족하는 쿼리는 ④입니다:\n1. NVL(salary,0)로 NULL 급여를 0으로 처리\n2. WHERE commission_pct IS NOT NULL로 커미션이 NULL인 경우 제외\n3. ROUND(AVG(...),2)로 평균 급여 소수점 2자리 처리\n4. MAX/MIN에도 NVL 적용하여 NULL 처리 일관성 유지\n5. department_id로 그룹화하여 부서별 통계 산출', 180, 21),
	(206, 2, NULL, 1, NULL, '다음 중 ROLLUP과 CUBE의 차이점으로 가장 올바른 것은?', 'ROLLUP은 지정된 컬럼의 계층적 순서로 집계를 생성하지만, CUBE는 가능한 모든 조합의 집계를 생성합니다. 예를 들어, ROLLUP(A,B)는 (A,B), (A), () 순으로 집계하고, CUBE(A,B)는 (A,B), (A), (B), () 모든 조합을 집계합니다.', 60, 21),
	(207, 2, '```sql\n-- Query 1\nSELECT COUNT(DISTINCT salary) FROM employees;\n\n-- Query 2\nSELECT COUNT(*) FROM (\n    SELECT DISTINCT salary FROM employees\n);\n\n-- Query 3\nSELECT COUNT(1) FROM (\n    SELECT salary FROM employees GROUP BY salary\n);\n\n-- Query 4\nSELECT COUNT(*) FROM (\n    SELECT salary FROM employees\n    WHERE salary IS NOT NULL\n    GROUP BY salary\n);\n```', 2, NULL, '다음 SQL문들의 실행 결과가 다른 것은?', '④번 쿼리는 WHERE 절로 NULL을 제외하므로 다른 결과가 나옵니다:\n1. Query 1,2,3: NULL을 포함한 고유한 급여 수 계산\n2. Query 4: NULL을 제외한 고유한 급여 수 계산\nCOUNT(DISTINCT)와 GROUP BY는 NULL 처리 방식이 동일합니다.', 120, 21),
	(208, 2, '[요구사항]\n- 부서별 직원 이름을 쉼표로 구분하여 나열\n- 이름은 알파벳 순으로 정렬\n- 결과가 4000바이트를 초과할 수 있음', 2, NULL, '다음과 같은 LISTAGG 함수 사용 시 가장 적절한 방법은?', 'ON OVERFLOW TRUNCATE를 사용하면서 "..."를 지정하여 결과가 잘린 것을 표시하는 것이 가장 적절합니다:\n1. 결과가 4000바이트 초과 시 자동 처리\n2. 잘린 부분 표시로 사용자에게 정보 제공\n3. 알파벳 순 정렬 유지\n4. 원본 데이터 변경 없음', 120, 21),
	(209, 2, NULL, 3, NULL, '다음과 같은 그룹 함수 사용 시 결과가 다른 것은?', 'NULL 처리 방식의 차이:\n1. ①: commission_pct NULL을 0으로 처리\n2. ②: NULL과의 연산 결과는 NULL\n3. ③: 최종 결과가 NULL이면 0으로 처리\n4. ④: 모든 NULL을 0으로 처리\n이 중 ②번만 NULL 결과를 그대로 사용하므로 다른 결과가 나옵니다.', 180, 21),
	(210, 2, '```sql\n-- Query 1\nSELECT department_id,\n       AVG(salary) OVER (PARTITION BY department_id) as avg_sal\nFROM employees;\n\n-- Query 2\nSELECT department_id, AVG(salary) as avg_sal\nFROM employees\nGROUP BY department_id;\n```', 3, NULL, '다음과 같은 윈도우 함수와 그룹 함수의 결과가 같은 경우는?', '두 쿼리는 다음과 같은 모든 경우에 같은 결과를 반환합니다:\n1. 직원이 한 명씩: 평균값이 동일\n2. 급여가 동일: 모든 평균이 같은 값\n3. 부서가 하나: 하나의 그룹으로 계산\n주요 차이점은 결과 행의 수입니다:\n- Query 1: 원본 테이블의 모든 행 반환\n- Query 2: 그룹별 한 행씩 반환', 180, 21),
	(211, 2, NULL, 1, NULL, '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', 'PARTITION BY는 GROUP BY와 달리 그룹별로 행을 나누지만, 원래의 행을 유지한 상태로 집계를 수행합니다.', 60, 22),
	(212, 2, '```sql\nSELECT department_id, employee_name, salary,\nSUM(salary) OVER (PARTITION BY department_id ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as running_total\nFROM employees\nWHERE department_id = 10\nORDER BY salary;\n```', 2, NULL, '다음 SQL문의 실행 결과로 올바른 것은?', '윈도우 함수에서 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW를 사용하면 현재 행까지의 누적 합계를 계산합니다.', 120, 22),
	(213, 2, '```sql\n-- Query 1\nSELECT department_id, employee_name, salary,\nROW_NUMBER() OVER (ORDER BY salary DESC) as rn\nFROM employees;\n\n-- Query 2\nSELECT department_id, employee_name, salary,\nROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn\nFROM employees;\n```', 2, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'ROW_NUMBER()는 모든 행에 대해 고유한 순위를 부여하지만, PARTITION BY를 사용하면 부서별로 순위가 부여됩니다.', 120, 22),
	(214, 2, '[요구사항]\n1. 부서별 급여 순위 산출\n2. 급여가 같을 경우 같은 순위 부여\n3. 같은 순위 다음은 건너뛰지 않고 순차적으로 부여\n4. 입사일이 빠른 순으로 정렬', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 윈도우 함수는?', 'DENSE_RANK() 함수는 동일한 값에 대해 같은 순위를 부여하고 다음 순위를 건너뛰지 않으므로 요구사항을 충족합니다.', 180, 22),
	(215, 2, '[요구사항]\n1. 일자별 매출 금액\n2. 전일 대비 증감액\n3. 3일 이동평균\n4. 연초부터의 누적 매출', 3, NULL, '다음과 같은 데이터에서 필요한 분석을 위한 적절한 윈도우 함수 사용은?', 'LAG()를 이용하여 전일 대비 증감액을 계산하고, ROWS BETWEEN을 이용해 3일 이동평균을 구할 수 있습니다.', 180, 22),
	(216, 2, NULL, 1, NULL, '다음 중 LAG와 LEAD 함수의 차이점으로 가장 올바른 것은?', 'LAG()는 이전 행을, LEAD()는 다음 행을 참조하는 함수입니다.', 60, 22),
	(217, 2, '```sql\n-- Query 1\nSELECT employee_id, salary,\nFIRST_VALUE(salary) OVER (ORDER BY salary) as lowest_sal\nFROM employees;\n\n-- Query 2\nSELECT employee_id, salary,\nMIN(salary) OVER () as lowest_sal\nFROM employees;\n\n-- Query 3\nSELECT employee_id, salary,\nMIN(salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as lowest_sal\nFROM employees;\n\n-- Query 4\nSELECT employee_id, salary,\nFIRST_VALUE(salary) OVER (ORDER BY salary ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) as lowest_sal\nFROM employees;\n```', 2, NULL, '다음 SQL문의 실행 결과가 다른 것은?', 'ROWS 절을 사용한 MIN() 함수는 누적 최소값을 반환하지만, FIRST_VALUE()나 MIN() OVER ()는 전체 최소값을 반환합니다.', 120, 22),
	(218, 2, '[요구사항]\n- 부서별 급여 중앙값 계산\n- NULL 값 제외\n- 부서별로 정렬된 상태 유지', 2, NULL, '다음과 같은 데이터 분석에 가장 적절한 윈도우 함수는?', 'PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary)는 부서별 급여의 중앙값을 계산할 수 있습니다.', 120, 22),
	(219, 2, '[요구사항]\n- 직원별 급여 비율 계산\n- 부서 내에서의 급여 비중\n- 전체 급여 대비 비율\n- 소수점 2자리까지 표시', 3, NULL, '다음과 같은 계산이 필요할 때 가장 적절한 방법은?', 'RATIO_TO_REPORT() 함수를 사용하면 부서별 및 전체 급여 대비 비율을 쉽게 계산할 수 있습니다.', 180, 22),
	(220, 2, '```sql\nSELECT department_id, employee_name, salary,\nRANK() OVER (\nPARTITION BY department_id\nORDER BY salary DESC\nROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n) as rnk\nFROM employees;\n```', 3, NULL, '다음 윈도우 함수의 실행 결과에 영향을 미치지 않는 것은?', 'RANK() 함수는 PARTITION BY와 ORDER BY의 영향을 받지만, ROWS 절은 무시됩니다.', 180, 22),
	(221, 2, NULL, 1, NULL, '다음 중 TOP N 쿼리에 대한 설명으로 틀린 것은?', 'ROWNUM은 WHERE 절이 실행되기 전에 부여됩니다. 따라서 WHERE 절에서 ROWNUM을 사용할 때는 주의가 필요합니다.', 60, 23),
	(222, 2, NULL, 2, NULL, '다음 SQL문 중 급여가 높은 상위 5명의 직원을 올바르게 조회하는 것은?', '정렬된 결과에서 상위 N개를 추출하기 위해서는:\n1. 내부 쿼리에서 먼저 정렬(ORDER BY)을 수행\n2. 정렬된 결과를 서브쿼리로 감싸기\n3. 외부 쿼리에서 ROWNUM으로 행 수 제한\n이러한 순서로 작성해야 원하는 결과를 얻을 수 있습니다.', 120, 23),
	(223, 2, '[요구사항]\n- 부서별로 급여가 높은 상위 3명의 직원을 조회\n- 같은 급여의 직원이 있을 경우 이름순으로 정렬\n- 직원번호, 이름, 부서명, 급여 정보 출력', 2, NULL, '다음과 같은 요구사항을 만족하는 SQL문으로 가장 적절한 것은?', 'RANK() 함수로 부서별(PARTITION BY) 순위를 부여하고, 급여 내림차순과 이름 오름차순으로 정렬 후 각 부서별 상위 3명만 선택하는 것이 올바른 방식입니다.', 120, 23),
	(224, 2, '```sql\n-- Query 1\nSELECT *\nFROM (\n    SELECT employee_id, name, salary,\n           ROW_NUMBER() OVER (ORDER BY salary DESC) as rn\n    FROM employees\n)\nWHERE rn <= 5;\n\n-- Query 2\nSELECT *\nFROM (\n    SELECT employee_id, name, salary,\n           RANK() OVER (ORDER BY salary DESC) as rn\n    FROM employees\n)\nWHERE rn <= 5;\n```', 3, NULL, '다음 두 쿼리의 실행 결과가 다른 경우는?', 'ROW_NUMBER()는 동일한 값에도 고유한 순위를 부여하지만, RANK()는 동일한 값에 동일 순위를 부여하며 다음 순위를 건너뛵니다.', 180, 23),
	(225, 2, '[요구사항]\n- 각 부서별로 급여 상위 20%에 해당하는 직원 목록\n- 급여가 같은 경우 모두 포함\n- 부서명, 직원명, 급여, 상위 백분율 정보 출력', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 SQL문은?', 'CUME_DIST() 함수를 사용하면 부서별 급여의 상위 20%에 해당하는 직원들을 올바르게 조회할 수 있습니다.', 180, 23),
	(226, 2, NULL, 1, NULL, '다음 중 Oracle의 FETCH 절에 대한 설명으로 틀린 것은?', 'FETCH 절은 ORDER BY 없이도 사용할 수 있습니다. 하지만 특정 순서로 정렬된 결과에서 상위 N개를 가져오려면 ORDER BY와 함께 사용하는 것이 좋습니다.', 60, 23),
	(227, 2, '```sql\n-- Query 1\nSELECT *\nFROM (\n    SELECT * FROM employees\n    ORDER BY salary DESC\n)\nWHERE ROWNUM <= 5;\n\n-- Query 2\nSELECT *\nFROM employees\nORDER BY salary DESC\nFETCH FIRST 5 ROWS ONLY;\n\n-- Query 3\nSELECT *\nFROM employees\nWHERE ROWNUM <= 5\nORDER BY salary DESC;\n\n-- Query 4\nSELECT TOP 5 *\nFROM employees\nORDER BY salary DESC;\n```', 2, NULL, '다음 SQL문들의 실행 결과가 같은 것은?', 'Query 1, 2, 4는 동일한 결과를 반환하지만, Query 3은 먼저 ROWNUM으로 5개 행을 선택한 후 정렬하여 다른 결과를 반환합니다.', 120, 23),
	(228, 2, '[요구사항]\n- 급여가 높은 순으로 정렬\n- 한 페이지당 10개의 데이터\n- 3번째 페이지 조회', 2, NULL, '다음과 같은 페이징 쿼리가 필요할 때, 가장 적절한 SQL문은?', 'OFFSET-FETCH 절을 사용하거나, 중첩 서브쿼리에서 ROWNUM을 활용하여 3번째 페이지 데이터를 조회할 수 있습니다.', 120, 23),
	(229, 2, '[요구사항]\n1. 부서별 급여 상위 3명씩 조회\n2. 같은 급여는 모두 포함\n3. 같은 순위가 있을 경우 다음 순위는 건너뛰기\n4. 전체 순위도 함께 표시', 3, NULL, '다음과 같은 분석이 필요할 때, 가장 적절한 SQL문은?', 'RANK()를 사용하면 부서별 급여 순위를 부여하고 같은 급여를 가진 직원은 같은 순위를 유지하며, 건너뛴 순위를 방지할 수 있습니다.', 180, 23),
	(230, 2, '```sql\nSELECT *\nFROM (\n    SELECT *\n    FROM employees\n    ORDER BY salary DESC\n)\nWHERE ROWNUM <= :N;\n```', 3, NULL, '다음과 같은 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', 'ORDER BY 절을 포함하면 정렬 비용이 증가할 수 있으며, 인덱스를 활용하거나 병렬 처리 등의 최적화 방법을 고려할 수 있습니다.', 180, 23),
	(231, 2, NULL, 1, NULL, '다음 중 계층형 질의(Hierarchical Query)에 대한 설명으로 가장 부적절한 것은?', '계층형 질의에서 ORDER BY절은 계층형 구조를 무시하고 정렬하면 안 됩니다. 계층형 구조를 유지하면서 정렬하려면 ORDER SIBLINGS BY를 사용해야 합니다. 이는 동일 레벨 내에서만 정렬을 수행합니다.', 60, 24),
	(232, 2, '```sql\nSELECT LEVEL,\n       LPAD(\' \', (LEVEL-1)*2) || employee_name as employee_hierarchy\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id\nORDER SIBLINGS BY employee_name;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', '이 쿼리는 직원의 상하 관계를 표현하되, 같은 레벨의 직원은 이름순으로 정렬합니다.', 120, 24),
	(233, 2, '```sql\n직원테이블(EMPLOYEE)\n- EMP_ID: 직원ID\n- EMP_NAME: 직원명\n- MANAGER_ID: 관리자ID\n```', 2, NULL, '다음과 같은 조직도를 표현하기 위한 셀프 조인 쿼리 중 옳은 것은?', '직원과 관리자의 관계를 표현하기 위해서는 EMPLOYEE 테이블을 셀프 조인하고, 직원의 MANAGER_ID와 관리자의 EMP_ID를 연결해야 합니다. 외부 조인(+)을 사용하여 관리자가 없는 직원도 출력할 수 있습니다.', 120, 24),
	(234, 2, '```sql\nSELECT CONNECT_BY_ROOT employee_name as root_emp,\n       SYS_CONNECT_BY_PATH(employee_name, \'/\') as emp_path,\n       CONNECT_BY_ISLEAF as is_leaf\nFROM employees\nSTART WITH job_id = \'CEO\'\nCONNECT BY PRIOR employee_id = manager_id\nAND LEVEL <= 3;\n```', 3, NULL, '다음 계층형 쿼리의 실행 결과로 알맞은 것은?', 'CEO부터 시작하여 3레벨까지의 조직도를 표시합니다.', 180, 24),
	(235, 2, '```sql\n-- 현재 쿼리\nSELECT LEVEL,\n       employee_name,\n       (SELECT d.department_name \n        FROM departments d \n        WHERE d.department_id = e.department_id) as dept_name\nFROM employees e\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n```', 3, NULL, '다음 중 계층형 쿼리와 셀프 조인의 성능 개선 방안으로 가장 부적절한 것은?', 'CONNECT BY 절의 조건을 WHERE 절로 이동하면 계층형 구조가 깨질 수 있습니다. CONNECT BY 절은 계층형 구조를 만들기 위한 필수 조건이므로, 이를 WHERE 절로 이동하는 것은 부적절합니다.', 180, 24),
	(236, 2, NULL, 1, NULL, '다음 중 CONNECT_BY_ROOT 연산자와 SYS_CONNECT_BY_PATH 함수의 차이점으로 가장 적절한 것은?', 'CONNECT_BY_ROOT는 계층 구조에서 최상위 노드의 값만을 반환하는 반면, SYS_CONNECT_BY_PATH는 루트 노드부터 현재 노드까지의 전체 경로를 지정된 구분자와 함께 문자열로 반환합니다.', 60, 24),
	(237, 2, '```sql\n-- Query 1\nSELECT LEVEL, employee_name, manager_id\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY NOCYCLE PRIOR employee_id = manager_id;\n\n-- Query 2\nSELECT LEVEL, employee_name, manager_id\nFROM employees\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n```', 2, NULL, '다음 두 쿼리의 결과가 다른 경우는?', '순환 참조가 있는 경우에만 결과가 다릅니다. NOCYCLE 있는 경우 순환 참조 발견 시 해당 경로만 중단되지만, 없는 경우 오류가 발생합니다.', 120, 24),
	(238, 2, '```sql\n[요구사항]\n1. 각 직원의 하위 직원 수 계산\n2. 직속 부하직원만 포함\n3. 결과는 하위 직원 수 기준 내림차순 정렬\n```', 2, NULL, '다음과 같은 조직도 데이터를 분석할 때 가장 적절한 SQL문은?', '직속 부하직원 수를 계산하는 가장 효율적인 방법은 셀프 조인을 사용하여 관리자-부하직원 관계를 설정한 후 GROUP BY와 COUNT로 부하직원 수를 계산하는 것입니다.', 120, 24),
	(239, 2, '```sql\n[요구사항]\n1. 조직도를 HTML 형식으로 출력\n2. 레벨별로 들여쓰기 적용\n3. 말단 직원 표시\n4. 각 직원의 레벨 표시\n```', 3, NULL, '다음과 같은 계층형 구조를 표현할 때 가장 적절한 방법은?', 'HTML 태그를 사용하여 계층형 구조를 표현하고, &nbsp;로 들여쓰기하며, CONNECT_BY_ISLEAF로 말단 직원 표시 및 LEVEL로 계층 레벨을 표현하는 것이 적절합니다.', 180, 24),
	(240, 2, '```sql\nSELECT LEVEL, employee_name, department_name\nFROM employees e, departments d\nWHERE e.department_id = d.department_id\nSTART WITH manager_id IS NULL\nCONNECT BY PRIOR employee_id = manager_id;\n```', 3, NULL, '다음과 같은 계층형 쿼리의 성능을 개선하기 위한 방법으로 가장 적절한 것은?', '계층형 쿼리를 먼저 실행하여 계층 구조를 최소화한 후 부서 정보를 조인하면 불필요한 조인을 회피하고 성능을 개선할 수 있습니다.', 180, 24),
	(241, 2, NULL, 1, NULL, '다음 중 PIVOT과 UNPIVOT에 대한 설명으로 틀린 것은?', 'UNPIVOT은 열을 행으로 변환할 때 집계함수를 사용하지 않습니다. 반면 PIVOT은 여러 행의 데이터를 열로 변환하면서 집계하기 때문에 반드시 집계함수(SUM, COUNT, AVG 등)가 필요합니다.', 60, 25),
	(242, 2, '[원본 데이터]\nYEAR  QUARTER  SALES\n2023  Q1       1000\n2023  Q2       1200\n2023  Q3       1100\n2023  Q4       1300', 2, NULL, '다음과 같은 데이터를 PIVOT을 사용하여 변환하고자 할 때, 적절한 SQL문은?', 'PIVOT을 사용할 때는 집계함수(SUM), 변환할 컬럼(QUARTER), 변환할 값(Q1~Q4)이 필요합니다.', 120, 25),
	(243, 2, '[원본 데이터]\nDEPT_ID  Q1_SALES  Q2_SALES  Q3_SALES  Q4_SALES\n10       1000      1200      1100      1300\n20       800       900       1000      1100', 2, NULL, '다음과 같은 데이터를 UNPIVOT하려고 할 때, 올바른 SQL문은?', 'UNPIVOT의 올바른 구문은 값으로 변환할 컬럼(SALES), FOR절에서 구분자가 될 컬럼(QUARTER), 변환할 원본 컬럼과 별칭 지정이 필요합니다.', 120, 25),
	(244, 2, '[원본 데이터]\nDEPT_ID  EMP_TYPE  SALARY\n10       정규직    5000\n10       계약직    3000\n20       정규직    4500\n20       계약직    2800\n\n[목표 데이터]\nDEPT_ID  정규직_급여  계약직_급여\n10       5000        3000\n20       4500        2800', 3, NULL, '다음과 같은 데이터 변환이 필요할 때, 가장 적절한 방법은?', 'SUM(SALARY)로 급여 합계를 계산하고, EMP_TYPE을 기준으로 PIVOT을 수행하여 열 변환해야 합니다.', 180, 25),
	(245, 2, NULL, 3, NULL, '다음의 PIVOT, UNPIVOT 사용 시 발생할 수 있는 문제점 중 가장 적절한 것은?', 'WHERE 절의 위치가 중요합니다. PIVOT/UNPIVOT 변환 전에 필터링이 필요한 경우 서브쿼리를 사용해야 합니다.', 180, 25),
	(246, 2, NULL, 1, NULL, '다음 중 PIVOT절에서 사용할 수 없는 집계 함수는?', 'PIVOT절에서는 SUM, COUNT, AVG, MAX, MIN, MEDIAN 등의 집계 함수는 사용 가능하지만 MODE는 사용할 수 없습니다.', 60, 25),
	(247, 2, '[원본 데이터]\nDEPT    JOB     SALARY\nIT      개발    5000\nIT      설계    4000\nHR      인사    3000', 2, NULL, '다음과 같은 데이터를 PIVOT한 후 다시 UNPIVOT 했을 때, 원본과 다른 결과가 나오는 경우는?', 'PIVOT 시 NULL 값은 집계에 포함되지 않으며, UNPIVOT 시 NULL 값은 기본적으로 제외됩니다. 따라서 NULL 값이 있는 데이터를 변환하면 원본과 차이가 발생할 수 있습니다.', 120, 25),
	(248, 2, '[요구사항]\n1. 부서별, 직급별 평균 급여를 매트릭스 형태로 표시\n2. 직급이 없는 경우 \'미지정\'으로 표시\n3. 평균 급여는 천 단위 구분 표시', 2, NULL, '다음과 같은 분석이 필요할 때 가장 적절한 방법은?', 'DECODE를 사용하여 NULL 값을 처리하고 평균 급여를 천 단위로 변환하는 방식이 가장 적절합니다.', 120, 25),
	(249, 2, '-- 동적으로 IN절의 값 목록을 생성해야 함\nSELECT *\nFROM sales_data\nPIVOT (\n    SUM(amount)\n    FOR YYYYMM IN (???)\n);', 3, NULL, '다음과 같은 동적 PIVOT 쿼리가 필요할 때 가장 적절한 방법은?', 'XML을 사용하여 동적으로 IN절의 값을 생성하면 실행 시점에 컬럼을 결정할 수 있습니다.', 180, 25),
	(250, 2, NULL, 3, NULL, 'PIVOT과 UNPIVOT 사용 시 성능상 고려사항으로 가장 적절한 것은?', 'PIVOT/UNPIVOT 성능 최적화를 위해 사전 필터링으로 처리 데이터를 최소화하는 것이 가장 중요합니다.', 180, 25),
	(251, 2, NULL, 1, NULL, '다음 중 정규 표현식의 기본 패턴에 대한 설명으로 틀린 것은?', '`.`는 줄바꿈 문자를 제외한 모든 단일 문자와 매치됩니다. "정확히 한 글자만"이 아니라 "어떤 문자든 한 글자"를 의미합니다. 예를 들어, \'a.c\'는 \'abc\', \'a1c\', \'a#c\' 등과 매치됩니다.', 60, 26),
	(252, 2, '```sql\nSELECT employee_name, phone_number\nFROM employees\nWHERE REGEXP_LIKE(phone_number, \'^(010|011)-[0-9]{4}-[0-9]{4}$\');\n```', 2, NULL, '다음 SQL문의 실행 결과로 적절한 것은?', '해당 정규 표현식은 다음과 같은 패턴을 검색합니다:\n1. ^(010|011): 010 또는 011로 시작\n2. -: 하이픈\n3. [0-9]{4}: 4자리 숫자\n4. -: 하이픈\n5. [0-9]{4}$: 4자리 숫자로 끝남', 120, 26),
	(253, 2, NULL, 2, NULL, '다음 중 이메일 주소를 검증하는 정규 표현식으로 가장 적절한 것은?', '이메일 주소 패턴의 특징은 다음과 같습니다:\n1. 아이디 부분: 영문자, 숫자, 특수문자(._%+-)를 허용\n2. @ 기호\n3. 도메인 부분: 영문자, 숫자, 점(.), 하이픈(-)을 허용\n4. 최상위 도메인: 2자 이상의 영문자\n따라서 ②가 가장 적절한 패턴입니다.', 120, 26),
	(254, 2, '```sql\nSELECT *\nFROM products\nWHERE REGEXP_LIKE(product_code, \'^[A-Z]{2}-[0-9]{4}(R|G|B)?$\');\n```', 3, NULL, '다음 정규 표현식 패턴의 결과로 매치되지 않는 것은?', '이 정규 표현식은 다음 패턴을 검색합니다:\n1. ^[A-Z]{2}: 대문자 2개로 시작\n2. -: 하이픈\n3. [0-9]{4}: 4자리 숫자\n4. (R|G|B)?: R, G, B 중 하나가 있거나 없음\n5. $: 문자열 끝\n\'GH-345G\'는 숫자가 3자리만 있으므로 매치되지 않습니다.', 180, 26),
	(255, 2, '[요구사항]\n- 주민등록번호 형식 검증\n- YYMMDD-1234567 형식\n- 첫 번째 숫자(YYMMDD)는 실제 존재하는 날짜여야 함\n- 두 번째 숫자의 첫 자리는 1,2,3,4 중 하나여야 함', 3, NULL, '다음과 같은 데이터 검증이 필요할 때, 가장 적절한 정규 표현식은?', '가장 정확한 검증을 제공하는 정규 표현식은 ②입니다. 각 부분의 의미는 다음과 같습니다:\n1. [0-9]{2}: 연도 2자리\n2. (0[1-9]|1[0-2]): 월(01~12)\n3. (0[1-9]|[12][0-9]|3[01]): 일(01~31)\n4. -: 하이픈\n5. [1-4]: 성별 구분 숫자(1,2,3,4)\n6. [0-9]{6}: 나머지 6자리', 180, 26),
	(256, 2, NULL, 1, NULL, '다음 중 정규 표현식에서 수량자(Quantifier)에 대한 설명으로 틀린 것은?', '‘*?’는 게으른(lazy) 수량자로, 가능한 적은 문자와 매칭됩니다. 반면 ‘*’는 탐욕적(greedy) 수량자로 가능한 많은 문자와 매칭됩니다.', 60, 26),
	(257, 2, '```sql\nSELECT REGEXP_REPLACE(text, \'([0-9]{3})([0-9]{4})([0-9]{4})\', \'\\1-\\2-\\3\') as formatted_number\nFROM sample_data;\n```', 2, NULL, '다음 SQL문의 실행 결과로 가장 적절한 것은?', 'REGEXP_REPLACE를 사용한 이 패턴은:\n1. ([0-9]{3}): 첫 번째 그룹 - 3자리 숫자\n2. ([0-9]{4}): 두 번째 그룹 - 4자리 숫자\n3. ([0-9]{4}): 세 번째 그룹 - 4자리 숫자\n4. \\1-\\2-\\3: 각 그룹 사이에 하이픈 추가', 120, 26),
	(258, 2, '[검색 대상]\n- 파일명.txt\n- 파일명.doc\n- 파일명.docx\n- 파일명.pdf', 2, NULL, '다음과 같은 데이터를 검색하기 위한 정규 표현식으로 가장 적절한 것은?', '‘^\\w+\\.(txt|doc.?|pdf)$’ 패턴이 가장 적절합니다:\n1. ^\\w+: 파일명(영문, 숫자, 언더스코어)\n2. \\.: 점(확장자 구분자)\n3. (txt|doc.?|pdf): 확장자 그룹\n   - txt: txt 확장자\n   - doc.?: doc 또는 docx\n   - pdf: pdf 확장자\n4. $: 문자열 끝', 120, 26),
	(259, 2, '[요구사항]\n- URL 형식 검증\n- http 또는 https로 시작\n- www는 있을 수도 있고 없을 수도 있음\n- 도메인은 영문자와 숫자, 점, 하이픈 허용\n- 최상위 도메인은 2~6자의 영문자', 3, NULL, '다음과 같은 요구사항을 만족하는 정규 표현식으로 가장 적절한 것은?', '요구사항을 만족하는 패턴 분석:\n1. ^https?: http 또는 https로 시작\n2. (www\\.)?: www. 가 있을 수도 있고 없을 수도 있음\n3. [a-zA-Z0-9-]+: 도메인 이름\n4. (\\.[a-zA-Z0-9-]+)*: 서브도메인(여러 개 가능)\n5. \\.[a-zA-Z]{2,6}$: 최상위 도메인', 180, 26),
	(260, 2, NULL, 3, NULL, 'REGEXP_LIKE 사용 시 성능 개선 방안으로 가장 부적절한 것은?', '정규 표현식 성능 최적화:\n1. 여러 개의 REGEXP_LIKE로 분리하면:\n   - 더 많은 처리 시간 필요\n   - 중복 검사 발생\n   - 리소스 낭비\n2. 대신 권장되는 방법:\n   - 하나의 최적화된 패턴 사용\n   - 인덱스 활용 가능한 조건 선처리\n   - 명확한 시작/끝점 지정\n   - 구체적 패턴 사용', 180, 26),
	(261, 2, NULL, 1, NULL, '다음 중 DML(Data Manipulation Language)에 대한 설명으로 가장 부적절한 것은?', 'DROP 문은 DML이 아닌 DDL(Data Definition Language)에 속합니다. DROP은 테이블 구조 자체를 삭제하는 명령어입니다. 테이블의 모든 데이터를 삭제하는 DML 명령어는 TRUNCATE 또는 DELETE입니다.', 60, 27),
	(262, 2, '-- Table: EMPLOYEES\n-- Columns: EMPLOYEE_ID(PK), FIRST_NAME, LAST_NAME, HIRE_DATE, SALARY', 2, NULL, '다음 INSERT 문 중 올바르게 작성된 것은?', 'INSERT 문은 컬럼 목록과 VALUES의 값 개수가 일치해야 하며, 데이터 타입도 일치해야 합니다. ②는 모든 컬럼을 명시하고, 날짜 형식도 올바르게 변환하여 입력하고 있습니다.', 120, 27),
	(263, 2, NULL, 2, NULL, '다음 UPDATE 문의 실행 결과로 적절한 것은?', '이 UPDATE 문은 급여가 3000 미만인 직원을 대상으로, 각 직원이 속한 부서의 평균 급여로 해당 직원의 급여를 변경합니다. 상호연관 서브쿼리를 사용하여 각 직원의 부서별 평균 급여를 계산합니다.', 120, 27),
	(264, 2, NULL, 3, NULL, '다음 중 DELETE 문의 실행 결과가 다른 하나는?', 'NOT IN 연산자와 NULL 값의 처리 방식 때문에 Query 1의 결과가 다릅니다. departments 테이블의 department_id에 NULL이 포함되어 있다면, Query 1은 어떤 행도 삭제하지 않습니다. 나머지 쿼리들은 NULL을 적절히 처리하여 부서가 없는 직원을 삭제합니다.', 180, 27),
	(265, 2, NULL, 3, NULL, '다음과 같은 DML 작업 시 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '대용량 데이터를 한 번에 처리할 경우 다음과 같은 문제가 발생할 수 있습니다:\n1. 트랜잭션 로그 공간 부족\n2. 락(Lock)으로 인한 다른 트랜잭션 대기\n3. 롤백 시 복구 시간 증가\n따라서 데이터를 적절한 크기로 분할하여 처리하는 것이 바람직합니다. 예를 들어 월별이나 특정 건수로 나누어 처리할 수 있습니다.', 180, 27),
	(266, 2, NULL, 1, NULL, '다음 중 MERGE 문의 특징으로 가장 부적절한 것은?', 'MERGE 문은 WHEN MATCHED THEN DELETE 절을 사용하여 DELETE 작업도 수행할 수 있습니다. 한 번의 MERGE 문으로 INSERT, UPDATE, DELETE 작업을 모두 처리할 수 있는 것이 MERGE 문의 장점입니다.', 60, 27),
	(267, 2, NULL, 2, NULL, '다음 MERGE 문의 실행 결과로 가장 적절한 것은?', '이 MERGE 문은:\n1. 동일한 id가 있는 경우(MATCHED): value가 다른 경우만 UPDATE\n2. id가 없는 경우(NOT MATCHED): 새로 INSERT\n3. value가 같은 경우: 아무 작업도 하지 않음', 120, 27),
	(268, 2, NULL, 2, NULL, '다음과 같은 DML 작업의 성능을 개선하는 방법으로 가장 적절한 것은?', 'INSERT /*+ APPEND */ 힌트 사용의 장점:\n1. Direct-path insert 수행\n2. 데이터 버퍼 캐시 우회\n3. REDO 로그 최소화\n4. 대량 데이터 입력 시 성능 향상', 120, 27),
	(269, 2, NULL, 3, NULL, '다음과 같은 트랜잭션이 필요할 때, 가장 적절한 구현 방법은?', '트랜잭션 처리가 적절한 이유:\n1. 모든 작업을 하나의 트랜잭션으로 처리\n2. 예외 발생 시 전체 롤백\n3. BEGIN-END 블록으로 논리적 단위 구성\n4. 원자성(Atomicity) 보장', 180, 27),
	(270, 2, NULL, 3, NULL, '다음 DML 작업의 동시성 제어 방안으로 가장 적절한 것은?', 'SELECT FOR UPDATE 선행 처리의 장점:\n1. 데이터 일관성 보장\n2. Lost Update 방지\n3. 교착상태(Deadlock) 최소화', 180, 27),
	(271, 2, NULL, 1, NULL, '다음 중 TCL(Transaction Control Language)에 대한 설명으로 틀린 것은?', 'COMMIT이 수행되면 해당 트랜잭션의 변경사항은 데이터베이스에 영구적으로 반영되며, ROLLBACK으로도 되돌릴 수 없습니다. ROLLBACK은 마지막 COMMIT 이후의 변경사항만 취소할 수 있습니다.', 60, 28),
	(272, 2, '```sql\nUPDATE accounts SET balance = balance - 1000 WHERE account_no = \'A001\';\nSAVEPOINT sp1;\nUPDATE accounts SET balance = balance + 1000 WHERE account_no = \'A002\';\nSAVEPOINT sp2;\nUPDATE accounts SET balance = balance + 500 WHERE account_no = \'A003\';\nROLLBACK TO sp1;\nCOMMIT;\n```', 2, NULL, '다음 트랜잭션 수행 결과로 올바른 것은?', 'ROLLBACK TO sp1을 수행하면 sp1 이후의 변경사항(A002, A003의 변경)이 취소되고, COMMIT을 수행하면 sp1 이전의 변경사항(A001의 변경)만 영구 반영됩니다.', 120, 28),
	(273, 2, '```sql\n-- Session 1\nUPDATE employees SET salary = salary * 1.1 WHERE department_id = 10;\n\n-- Session 2 (동시 실행)\nSELECT SUM(salary) FROM employees WHERE department_id = 10;\n```', 2, NULL, '다음 상황에서 발생할 수 있는 문제점과 해결방안으로 가장 적절한 것은?', '이 상황에서는 더티 리드가 발생할 수 있습니다. 해결방안으로는 COMMIT 후 SELECT를 실행하거나, 적절한 트랜잭션 격리 수준을 설정해야 합니다.', 120, 28),
	(274, 2, '```sql\n-- Transaction Log\n10:01:00 - INSERT INTO orders VALUES (1, \'A001\', 1000);\n10:01:05 - SAVEPOINT sp1;\n10:01:10 - UPDATE orders SET amount = 2000 WHERE order_id = 1;\n10:01:15 - SAVEPOINT sp2;\n10:01:20 - DELETE FROM orders WHERE order_id = 1;\n10:01:25 - ROLLBACK TO sp2;\n10:01:30 - UPDATE orders SET amount = 3000 WHERE order_id = 1;\n10:01:35 - ROLLBACK TO sp1;\n10:01:40 - COMMIT;\n```', 3, NULL, '다음 트랜잭션 로그의 실행 결과로 옳은 것은?', 'ROLLBACK TO sp1을 수행하면 sp1 이후의 모든 변경사항(UPDATE 2000, UPDATE 3000, DELETE)이 취소되고, 최초 INSERT만 남게 됩니다.', 180, 28),
	(275, 2, '```sql\n[요구사항]\n1. 계좌 A에서 출금\n2. 계좌 B로 입금\n3. 거래 내역 기록\n4. 모든 처리가 실패하면 전체 취소\n5. 부분 실패 시 처리된 내용까지는 유지\n```', 3, NULL, '다음과 같은 뱅킹 시스템의 트랜잭션 처리에서 가장 적절한 구현 방식은?', '계좌 이체와 같은 원자적 처리가 필요한 경우, 모든 작업을 하나의 트랜잭션으로 묶고 실패 시 전체 롤백하는 것이 바람직합니다.', 180, 28),
	(276, 2, NULL, 1, NULL, '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Isolation(고립성)은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리되어야 함을 의미합니다. 반드시 순차적으로 실행될 필요는 없으며, 적절한 격리 수준에서 동시에 실행될 수 있습니다.', 60, 28),
	(277, 2, '```sql\nBEGIN;\n    INSERT INTO table1 VALUES (1);\n    SAVEPOINT sp1;\n    UPDATE table1 SET col1 = 2;\n    SAVEPOINT sp2;\n    DELETE FROM table1;\n    ROLLBACK;\nEND;\n```', 2, NULL, '다음과 같은 트랜잭션에서 ROLLBACK의 범위는?', 'ROLLBACK 명령어가 SAVEPOINT를 지정하지 않고 사용되면, 현재 트랜잭션의 모든 변경사항이 취소됩니다.', 120, 28),
	(278, 2, '```sql\n[요구사항]\n- 대량의 데이터 처리\n- 중간에 오류 발생 시 처리된 데이터는 유지\n- 진행 상황 모니터링 필요\n```', 2, NULL, '다음과 같은 트랜잭션 처리가 필요한 상황에서 가장 적절한 구현 방법은?', '대량 데이터 처리 시 배치 단위로 처리하고 각 배치마다 COMMIT을 수행하여 성능을 최적화할 수 있습니다.', 120, 28),
	(279, 2, '```sql\n-- Session 1\nBEGIN;\n    SELECT balance FROM accounts WHERE id = 1 FOR UPDATE;\n    UPDATE accounts SET balance = balance - 500 WHERE id = 1;\n    COMMIT;\n\n-- Session 2 (동시 실행)\nBEGIN;\n    SELECT balance FROM accounts WHERE id = 1;\n    UPDATE accounts SET balance = balance - 300 WHERE id = 1;\n    COMMIT;\n```', 3, NULL, '다음과 같은 동시 실행 트랜잭션의 문제점과 해결방안으로 가장 적절한 것은?', '이 경우 SELECT FOR UPDATE가 적절한 이유는 데이터 일관성을 보장하고 Lost Update를 방지할 수 있기 때문입니다.', 180, 28),
	(280, 2, '```sql\n-- Transaction 1\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSELECT * FROM products WHERE price < 1000;  -- Time 1\nSELECT * FROM products WHERE price < 1000;  -- Time 3\n\n-- Transaction 2\nUPDATE products SET price = price * 1.1;    -- Time 2\nCOMMIT;\n```', 3, NULL, '다음 트랜잭션의 격리 수준(Isolation Level)에 따른 실행 결과로 가장 적절한 것은?', 'READ COMMITTED 격리 수준에서는 Non-repeatable Read가 발생할 수 있습니다. 즉, 첫 번째 SELECT 이후에 다른 트랜잭션에서 COMMIT된 변경사항이 반영될 수 있습니다.', 180, 28),
	(281, 2, NULL, 1, NULL, '다음 중 DDL(Data Definition Language)에 대한 설명으로 틀린 것은?', 'DDL 명령어는 실행과 동시에 자동으로 COMMIT되며, ROLLBACK이 불가능합니다. 따라서 DROP으로 삭제된 객체는 복구할 수 없습니다.', 60, 29),
	(282, 2, NULL, 2, NULL, '다음 테이블 생성문 중 문제가 있는 것은?', '외래키 제약조건의 문법이 잘못되었습니다. REFERENCES 뒤에 참조할 컬럼을 명시해야 합니다.', 120, 29),
	(283, 2, NULL, 2, NULL, '다음과 같은 테이블 변경 작업 중 실행 결과가 다른 것은?', 'MODIFY 절로 NOT NULL 제약조건을 추가할 때, 이미 NULL 값이 있는 경우 오류가 발생합니다.', 120, 29),
	(284, 2, '[요구사항]\n1. 주문 테이블 생성\n2. 주문번호는 시퀀스를 사용하여 자동 생성\n3. 주문상태는 접수, 처리중, 완료 중 하나\n4. 주문일자는 기본값으로 현재 시간 지정\n5. 삭제된 주문은 이력 테이블에 자동 저장', 3, NULL, '다음과 같은 상황에서 가장 적절한 DDL문은?', '요구사항을 모두 만족하는 트리거를 포함한 테이블 생성문이 가장 적절합니다.', 180, 29),
	(285, 2, NULL, 3, NULL, '다음 중 테이블 생성 후 수정이 불가능한 작업은?', '기본키 구조 변경이 필요한 경우, 기존 테이블을 백업한 후 새로운 구조로 테이블을 재생성해야 합니다.', 180, 29),
	(286, 2, NULL, 1, NULL, '다음 중 CREATE TABLE의 서브쿼리에 대한 설명으로 가장 부적절한 것은?', 'CREATE TABLE의 서브쿼리에서는 ORDER BY 절을 사용할 수 없습니다. ORDER BY는 결과 집합을 정렬하는 용도로만 사용되며, 테이블의 물리적 저장 순서를 결정하지 않습니다.', 60, 29),
	(287, 2, NULL, 2, NULL, '다음과 같은 ALTER TABLE 문의 실행 순서로 가장 적절한 것은?', '제약조건 추가 시, 데이터 무결성과 의존성을 고려하여 올바른 순서로 실행해야 합니다.', 120, 29),
	(288, 2, NULL, 2, NULL, '다음과 같은 데이터가 있을 때, TRUNCATE와 DELETE의 차이점으로 가장 적절한 것은?', 'DELETE는 ROLLBACK이 가능하지만, TRUNCATE는 자동 COMMIT이 발생하며 ROLLBACK이 불가능합니다.', 120, 29),
	(289, 2, '[요구사항]\n1. 파티션 테이블 생성\n2. 년도별로 데이터 분할\n3. 과거 데이터는 자동 삭제\n4. 범위 파티션 사용', 3, NULL, '다음과 같은 테이블을 생성할 때 가장 적절한 DDL문은?', '인터벌 파티션을 사용하면 자동으로 연도별 파티션이 생성되며, 과거 데이터 삭제가 용이합니다.', 180, 29),
	(290, 2, NULL, 3, NULL, 'DDL 실행 시 고려해야 할 성능 관련 사항으로 가장 부적절한 것은?', '파티션 테이블의 성능은 상황에 따라 다르며, 항상 더 나은 성능을 제공하는 것은 아닙니다.', 180, 29),
	(291, 2, NULL, 1, NULL, '다음 중 DCL(Data Control Language)에 대한 설명으로 틀린 것은?', 'CREATE USER는 DCL이 아닌 DDL(Data Definition Language)에 속합니다. DCL의 주요 명령어는 GRANT와 REVOKE입니다. 사용자 생성, 수정, 삭제와 관련된 명령어는 DDL에 속합니다.', 60, 30),
	(292, 2, NULL, 2, NULL, '다음 권한 부여 문장 중 올바르지 않은 것은?', 'GRANT 명령어로는 특정 조건(WHERE절)을 포함한 권한 부여가 불가능합니다. 행 수준의 접근 제어가 필요한 경우에는 뷰(VIEW)를 생성하여 권한을 부여하거나, VPD(Virtual Private Database)와 같은 별도의 보안 메커니즘을 사용해야 합니다.', 120, 30),
	(293, 2, NULL, 2, NULL, '다음과 같은 권한 부여가 순차적으로 실행될 때, 최종적으로 USER3가 가지게 되는 권한으로 올바른 것은?', 'REVOKE는 CASCADE 효과가 있지만, 직접 부여받은 권한은 영향을 받지 않습니다. USER3는 USER1으로부터 권한을 부여받은 것이 아니라 직접 권한을 부여받았으므로, USER1의 권한이 취소되어도 USER3의 SELECT 권한은 유지됩니다.', 120, 30),
	(294, 2, '[상황]\n- 회사의 개발팀에 신입 사원 10명이 입사\n- 각자는 개발 DB의 특정 테이블들에 대해 SELECT, INSERT 권한이 필요\n- 일부 테이블은 UPDATE 권한도 필요\n- 3개월 후 권한을 재검토할 예정', 3, NULL, '다음 상황에서 가장 적절한 권한 관리 방안은?', 'ROLE을 사용하는 것이 가장 효율적인 방법입니다. ROLE의 장점은 다음과 같습니다:\n1. 권한 관리가 용이함\n2. 권한의 일관성 유지 가능\n3. 권한 변경 시 ROLE만 수정하면 됨\n4. 권한 감사(Audit)가 용이함', 180, 30),
	(295, 2, NULL, 3, NULL, '다음 중 데이터베이스 보안 관리와 관련된 설명으로 가장 부적절한 것은?', 'ROLE에 부여된 권한은 해당 ROLE이 부여된 사용자 세션에서 바로 사용할 수 없습니다. 사용자가 새로운 세션을 시작하거나, SET ROLE 명령어를 실행해야 ROLE의 권한을 사용할 수 있습니다.', 180, 30),
	(296, 2, NULL, 1, NULL, '다음 중 데이터베이스 사용자 유형에 대한 설명으로 틀린 것은?', 'PUBLIC은 모든 사용자에게 적용되는 권한입니다. 특정 사용자가 아닌 데이터베이스의 모든 사용자에게 공통적으로 부여되는 권한을 의미합니다.', 60, 30),
	(297, 2, NULL, 2, NULL, '다음의 권한 부여 상황에서 발생할 수 있는 문제점으로 가장 적절한 것은?', 'ROLE을 먼저 생성하지 않고 권한을 부여하려 하면 오류가 발생합니다. 올바른 순서는:\n1. ROLE 생성\n2. ROLE에 권한 부여\n3. 사용자에게 ROLE 부여', 120, 30),
	(298, 2, '[요구사항]\n- 개발팀: 테이블 생성, 수정 권한\n- QA팀: 데이터 조회, 수정 권한\n- 운영팀: 데이터 조회만 가능\n- 3개월마다 권한 재검토', 2, NULL, '다음과 같은 권한 관리가 필요할 때 가장 적절한 방식은?', 'ROLE 기반 권한 관리의 장점:\n1. 팀별 권한 그룹화 가능\n2. 권한 변경 시 ROLE만 수정\n3. 권한 관리 용이\n4. 감사(Audit) 용이', 120, 30),
	(299, 2, '[시나리오]\n1. USER1이 테이블 생성 권한을 가짐\n2. USER1이 USER2에게 해당 테이블의 SELECT 권한을 부여\n3. USER2가 USER3에게 같은 권한을 부여 (WITH GRANT OPTION)\n4. USER1의 테이블 생성 권한을 취소해야 하는 상황', 3, NULL, '다음과 같은 권한 취소 시나리오에서 가장 적절한 처리 방법은?', 'CASCADE 옵션을 사용한 REVOKE가 필요한 이유:\n1. 권한의 연쇄적 취소 필요\n2. USER2, USER3에게 부여된 권한도 자동 취소\n3. 권한 관리의 일관성 유지\n4. 누락 없는 권한 취소 보장', 180, 30),
	(300, 2, NULL, 3, NULL, '다음 중 DCL 관련 보안 감사(Audit)를 위한 가장 적절한 설정은?', '효율적인 보안 감사 방안:\n1. ROLE 단위 감사:\n   - 중요 작업 위주 로깅\n   - 저장 공간 효율화\n   - 분석 용이성 확보\n2. 부적절한 방안:\n   - 전체 로깅: 리소스 낭비\n   - DDL만 로깅: 보안 사각지대 발생\n   - 로깅 없음: 추적 불가능', 180, 30),
	(301, 1, NULL, 2, NULL, '다음 중 데이터 모델링의 3단계가 올바르게 나열된 것은?', '개념적 모델링 → 논리적 모델링 → 물리적 모델링', 60, 1),
	(302, 1, NULL, 2, NULL, '데이터 모델링에서 \'추상화\'의 의미로 가장 적절한 것은?', '현실 세계의 복잡한 내용을 정해진 표기법에 의해 표현하는 과정', 60, 1),
	(303, 1, NULL, 1, NULL, '다음 중 데이터 모델링의 특징으로 올바르지 않은 것은?', '복잡화 (Complication)', 50, 1),
	(304, 1, NULL, 1, NULL, '엔터티-관계 모델(Entity-Relationship Model)에서 사용되는 기본 요소가 아닌 것은?', '인덱스 (Index)', 50, 1),
	(305, 1, NULL, 2, NULL, '다음 중 개념적 데이터 모델의 특징으로 가장 적절한 것은?', '업무 중심의 포괄적인 수준의 모델링을 제공한다.', 60, 1),
	(306, 1, NULL, 2, NULL, '다음 중 논리적 데이터 모델링 단계에서 수행되는 작업이 아닌 것은?', '인덱스 설계', 60, 1),
	(307, 1, NULL, 2, NULL, '데이터 모델링에서 \'일관성\'이 의미하는 바로 가장 적절한 것은?', '데이터 모델이 모든 사용자에게 같은 의미로 이해되는 것', 60, 1),
	(308, 1, NULL, 2, NULL, '다음 중 물리적 데이터 모델링의 특징으로 올바른 것은?', '실제 데이터베이스 구현을 위한 스키마를 생성한다.', 60, 1),
	(309, 1, NULL, 2, NULL, '데이터 모델링에서 \'무결성\'이 의미하는 바는?', '데이터가 정확하고 유효한 상태를 유지하는 것', 60, 1),
	(310, 1, NULL, 1, NULL, '다음 중 데이터 모델링의 중요성으로 가장 적절하지 않은 것은?', '파일 구조의 최적화', 50, 1),
	(311, 1, NULL, 2, NULL, '데이터 모델링에서 \'유연성\'이 의미하는 바는?', '데이터 구조를 쉽게 변경하고 확장할 수 있는 능력', 60, 1),
	(312, 1, NULL, 2, NULL, '다음 중 개념적 데이터 모델의 산출물로 가장 적절한 것은?', 'ERD (Entity-Relationship Diagram)', 60, 1),
	(313, 1, NULL, 2, NULL, '데이터 모델링에서 \'재사용성\'이 의미하는 바는?', '이미 정의된 데이터 모델을 다른 영역에서도 사용할 수 있는 것', 60, 1),
	(314, 1, NULL, 2, NULL, '다음 중 데이터 모델링의 절차로 가장 적절한 것은?', '요구사항 수집 → 개념적 모델링 → 논리적 모델링 → 물리적 모델링', 60, 1),
	(315, 1, NULL, 1, NULL, '다음 중 엔터티(Entity)의 정의로 가장 적절한 것은?', '업무에서 관리해야 하는 데이터 단위', 50, 2),
	(316, 1, NULL, 2, NULL, '다음 중 엔터티의 특징으로 올바르지 않은 것은?', '반드시 물리적인 형태로 존재해야 한다', 60, 2),
	(317, 1, NULL, 2, NULL, '다음 중 엔터티 타입(Entity Type)과 엔터티 인스턴스(Entity Instance)의 관계를 가장 잘 설명한 것은?', '엔터티 타입은 클래스이고, 엔터티 인스턴스는 객체이다', 60, 2),
	(318, 1, NULL, 2, NULL, '다음 중 약한 엔터티(Weak Entity)의 특징으로 가장 적절한 것은?', '다른 엔터티의 존재에 의존적이다', 60, 2),
	(319, 1, NULL, 3, NULL, '엔터티를 식별하는 방법으로 가장 적절하지 않은 것은?', '테이블 이름이 명사인가?', 70, 2),
	(320, 1, NULL, 1, NULL, '다음 중 엔터티 관계 다이어그램(ERD)에서 엔터티를 표현하는 일반적인 기호는?', '사각형', 50, 2),
	(321, 1, NULL, 2, NULL, '엔터티의 인스턴스 집합을 무엇이라고 하는가?', '엔터티 셋', 60, 2),
	(322, 1, NULL, 3, NULL, '다음 중 엔터티 타입을 결정하는 기준으로 가장 적절하지 않은 것은?', '테이블의 컬럼 수가 10개 이상인가?', 70, 2),
	(323, 1, NULL, 2, NULL, '다음 중 물리적 엔터티와 논리적 엔터티의 차이점으로 가장 적절한 것은?', '물리적 엔터티는 테이블로 구현되고, 논리적 엔터티는 개념적 모델에서 사용된다', 60, 2),
	(324, 1, NULL, 3, NULL, '다음 중 엔터티의 명명 규칙으로 가장 적절하지 않은 것은?', '반드시 영문으로 작성해야 한다', 70, 2),
	(325, 1, NULL, 2, NULL, '다음 중 엔터티의 분류 기준으로 가장 적절하지 않은 것은?', '스토리지 유형에 따른 분류 (파일 엔터티, 테이블 엔터티)', 60, 2),
	(326, 1, NULL, 2, NULL, '다음 중 행위 엔터티(Action Entity)의 특징으로 가장 적절한 것은?', '두 개 이상의 엔터티로부터 발생되는 엔터티', 60, 2),
	(327, 1, NULL, 2, NULL, '다음 중 슈퍼타입 엔터티(Supertype Entity)와 서브타입 엔터티(Subtype Entity)의 관계를 가장 잘 설명한 것은?', '슈퍼타입은 서브타입의 공통 속성을 가지며, 서브타입은 고유한 속성을 추가로 가진다', 60, 2),
	(328, 1, NULL, 2, NULL, '다음 중 엔터티의 생명주기(Life Cycle)를 올바르게 나열한 것은?', '생성 → 추가 → 수정 → 삭제', 60, 2),
	(329, 1, NULL, 1, NULL, '다음 중 속성(Attribute)의 정의로 가장 적절한 것은?', '엔터티를 구성하는 더 이상 분리되지 않는 최소의 데이터 단위', 50, 3),
	(330, 1, NULL, 2, NULL, '다음 중 기본 속성(Basic Attribute)의 특징으로 가장 적절한 것은?', '업무에서 기본적으로 도출되는 속성', 60, 3),
	(331, 1, NULL, 2, NULL, '다음 중 복합 속성(Composite Attribute)에 대한 설명으로 올바른 것은?', '하나의 의미로 사용되는 여러 개의 속성들의 집합', 60, 3),
	(332, 1, NULL, 2, NULL, '다음 중 단일 값 속성(Single-valued Attribute)과 다중 값 속성(Multi-valued Attribute)의 차이점으로 가장 적절한 것은?', '단일 값 속성은 하나의 값만 가질 수 있고, 다중 값 속성은 여러 개의 값을 가질 수 있다', 60, 3),
	(333, 1, NULL, 1, NULL, '다음 중 유도 속성(Derived Attribute)의 예로 가장 적절한 것은?', '주문의 총액 (단가 * 수량)', 50, 3),
	(334, 1, NULL, 3, NULL, '다음 중 속성의 명명 규칙으로 가장 적절하지 않은 것은?', '반드시 영문으로 작성해야 한다', 70, 3),
	(335, 1, NULL, 2, NULL, '다음 중 null 속성에 대한 설명으로 올바르지 않은 것은?', '모든 속성은 null 값을 가질 수 있다', 60, 3),
	(336, 1, NULL, 2, NULL, '다음 중 속성의 도메인(Domain)에 대한 설명으로 가장 적절한 것은?', '속성이 가질 수 있는 모든 가능한 값들의 집합', 60, 3),
	(337, 1, NULL, 3, NULL, '다음 중 속성의 데이터 타입을 결정할 때 고려해야 할 사항이 아닌 것은?', '속성의 이름', 70, 3),
	(338, 1, NULL, 2, NULL, '다음 중 대체 속성(Alternative Attribute)에 대한 설명으로 가장 적절한 것은?', '다른 속성을 대신하여 엔터티를 식별할 수 있는 속성', 60, 3),
	(339, 1, NULL, 2, NULL, '다음 중 슈퍼타입 엔터티와 서브타입 엔터티 사이의 속성 상속에 대한 설명으로 올바른 것은?', '서브타입 엔터티는 슈퍼타입 엔터티의 속성을 상속받고 추가적인 고유 속성을 가질 수 있다', 60, 3),
	(340, 1, NULL, 2, NULL, '다음 중 외래 식별자 속성(Foreign Identifier Attribute)에 대한 설명으로 가장 적절한 것은?', '다른 엔터티와의 관계에서 부모 엔터티의 주식별자를 자신의 주식별자로 이용하는 속성', 60, 3),
	(341, 1, NULL, 3, NULL, '다음 중 속성의 정규화(Normalization)에 대한 설명으로 올바르지 않은 것은?', '항상 성능을 향상시킨다', 70, 3),
	(342, 1, NULL, 3, NULL, '다음 중 속성의 물리적 설계 시 고려해야 할 사항으로 가장 적절하지 않은 것은?', '엔터티와의 관계', 70, 3),
	(343, 1, NULL, 1, NULL, '다음 중 관계형 데이터베이스에서 \'관계\'의 의미로 가장 적절한 것은?', '데이터베이스 내의 테이블', 60, 4),
	(344, 1, NULL, 1, NULL, '다음 중 INNER JOIN의 특징으로 가장 적절한 것은?', '조인 조건을 만족하는 데이터만 결과에 포함한다', 60, 4),
	(345, 1, NULL, 2, NULL, '다음 중 LEFT OUTER JOIN의 결과에 대한 설명으로 가장 적절한 것은?', '왼쪽 테이블의 모든 행이 결과에 포함된다', 70, 4),
	(346, 1, NULL, 2, NULL, '다음 중 FULL OUTER JOIN의 특징으로 가장 적절한 것은?', '두 테이블의 모든 데이터를 포함하며, 매치되지 않는 행은 NULL로 채운다', 70, 4),
	(347, 1, NULL, 2, NULL, '다음 중 CROSS JOIN의 결과로 가장 적절한 것은?', '두 테이블의 모든 가능한 조합을 만든다 (카테시안 곱)', 70, 4),
	(348, 1, NULL, 1, NULL, '다음 중 SELF JOIN의 정의로 가장 적절한 것은?', '같은 테이블을 자기 자신과 조인하는 것', 60, 4),
	(349, 1, NULL, 2, NULL, '다음 중 NATURAL JOIN의 특징으로 가장 적절한 것은?', '동일한 이름을 가진 모든 열을 기준으로 자동으로 조인한다', 70, 4),
	(350, 1, NULL, 2, NULL, '다음 중 NON-EQUI JOIN에 대한 설명으로 가장 적절한 것은?', '= 연산자가 아닌 다른 비교 연산자를 사용하여 조인 조건을 지정하는 방식', 70, 4),
	(351, 1, NULL, 1, NULL, '다음 중 OUTER JOIN을 사용하는 주된 이유로 가장 적절한 것은?', '조인 조건을 만족하지 않는 데이터도 결과에 포함시키기 위해', 60, 4),
	(352, 1, NULL, 2, NULL, '다음 중 INNER JOIN과 OUTER JOIN의 주요 차이점으로 가장 적절한 것은?', 'INNER JOIN은 조건을 만족하는 행만 반환하고, OUTER JOIN은 조건을 만족하지 않는 행도 포함하여 반환할 수 있다', 70, 4),
	(353, 1, NULL, 2, NULL, '다음 중 조인 연산의 성능에 가장 큰 영향을 미치는 요소는?', '조인되는 테이블의 크기와 인덱스 유무', 70, 4),
	(354, 1, NULL, 2, NULL, '다음 중 ANTI JOIN의 목적으로 가장 적절한 것은?', '첫 번째 테이블에는 있지만 두 번째 테이블에는 없는 데이터를 찾기 위해', 70, 4),
	(355, 1, NULL, 2, NULL, '다음 중 SEMI JOIN의 특징으로 가장 적절한 것은?', '조인 조건을 만족하는 왼쪽 테이블의 데이터만 반환하며, 오른쪽 테이블의 열은 포함하지 않는다', 70, 4),
	(356, 1, NULL, 3, NULL, '다음 중 EQUI JOIN과 NATURAL JOIN의 차이점으로 가장 적절한 것은?', 'EQUI JOIN은 조인 조건을 명시적으로 지정하고, NATURAL JOIN은 같은 이름의 열을 자동으로 조인한다', 80, 4),
	(357, 1, NULL, 1, NULL, '다음 중 식별자(Identifier)의 정의로 가장 적절한 것은?', '엔터티 내에서 인스턴스를 유일하게 구분할 수 있는 속성 또는 속성의 집합', 60, 5),
	(358, 1, NULL, 1, NULL, '다음 중 후보키(Candidate Key)에 대한 설명으로 올바른 것은?', '엔터티를 유일하게 식별할 수 있는 속성들의 집합', 60, 5),
	(359, 1, NULL, 2, NULL, '다음 중 기본키(Primary Key)의 특성으로 가장 적절하지 않은 것은?', '널(NULL) 허용', 70, 5),
	(360, 1, NULL, 1, NULL, '다음 중 대체키(Alternate Key)에 대한 설명으로 가장 적절한 것은?', '기본키로 선택되지 않은 후보키', 60, 5),
	(361, 1, NULL, 1, NULL, '다음 중 복합키(Composite Key)의 정의로 가장 적절한 것은?', '두 개 이상의 속성으로 구성된 키', 60, 5),
	(362, 1, NULL, 2, NULL, '다음 중 외래키(Foreign Key)에 대한 설명으로 올바르지 않은 것은?', '항상 해당 엔터티의 기본키의 일부가 되어야 한다', 70, 5),
	(363, 1, NULL, 1, NULL, '다음 중 인조식별자(Surrogate Key)의 특징으로 가장 적절한 것은?', '인위적으로 생성한 식별자', 60, 5),
	(364, 1, NULL, 2, NULL, '다음 중 식별자 선정 시 고려사항으로 가장 적절하지 않은 것은?', '길이의 최대화', 70, 5),
	(365, 1, NULL, 2, NULL, '다음 중 본질식별자(Natural Key)의 특징으로 가장 적절한 것은?', '업무적으로 의미 있는 식별자', 70, 5),
	(366, 1, NULL, 2, NULL, '다음 중 식별자 관계와 비식별자 관계의 차이점으로 가장 적절한 것은?', '식별자 관계는 부모 엔터티의 키가 자식 엔터티의 키의 일부가 되고, 비식별자 관계는 그렇지 않다', 70, 5),
	(367, 1, NULL, 2, NULL, '다음 중 복합식별자(Composite Identifier)를 사용할 때의 단점으로 가장 적절한 것은?', '인덱스 크기가 커질 수 있다', 70, 5),
	(368, 1, NULL, 2, NULL, '다음 중 식별자의 대체 방법(Identifier Substitution)을 고려해야 하는 경우로 가장 적절하지 않은 것은?', '식별자가 업무적 의미를 가지는 경우', 70, 5),
	(369, 1, NULL, 3, NULL, '다음 중 식별자 선정 시 일반적으로 우선순위가 가장 높은 것은?', '단일식별자', 80, 5),
	(370, 1, NULL, 2, NULL, '다음 중 식별자와 관련된 참조 무결성(Referential Integrity)에 대한 설명으로 가장 적절한 것은?', '외래키는 참조하는 테이블의 기본키에 없는 값을 가질 수 없다', 70, 5),
	(371, 1, NULL, 1, NULL, '다음 중 정규화(Normalization)의 주요 목적으로 가장 적절한 것은?', '데이터의 중복 제거와 일관성 확보', 60, 6),
	(372, 1, NULL, 1, NULL, '다음 중 제1정규형(1NF)의 정의로 가장 적절한 것은?', '모든 속성의 원자값화', 60, 6),
	(373, 1, NULL, 1, NULL, '다음 중 제2정규형(2NF)의 특징으로 가장 적절한 것은?', '모든 비주요 속성이 주요 속성에 완전 함수적 종속', 60, 6),
	(374, 1, NULL, 1, NULL, '다음 중 제3정규형(3NF)의 정의로 가장 적절한 것은?', '이행적 함수 종속 제거', 60, 6),
	(375, 1, NULL, 1, NULL, '다음 중 BCNF(Boyce-Codd Normal Form)의 조건으로 가장 적절한 것은?', '모든 결정자가 후보키인 경우', 60, 6),
	(376, 1, NULL, 1, NULL, '다음 중 함수적 종속성(Functional Dependency)의 정의로 가장 적절한 것은?', 'X의 값에 따라 Y의 값이 유일하게 정해지는 관계', 60, 6),
	(377, 1, NULL, 1, NULL, '다음 중 정규화 과정에서 발생할 수 있는 단점으로 가장 적절한 것은?', '조인 연산의 증가로 인한 성능 저하 가능성', 60, 6),
	(378, 1, NULL, 1, NULL, '다음 중 제4정규형(4NF)이 다루는 주요 이슈는?', '다치 종속(Multi-valued Dependency)', 60, 6),
	(379, 1, NULL, 1, NULL, '다음 중 정규화 과정에서 사용되는 \'결정자\'의 의미로 가장 적절한 것은?', '다른 속성의 값을 유일하게 결정하는 속성', 60, 6),
	(380, 1, NULL, 2, NULL, '다음 중 역정규화(Denormalization)를 고려해야 하는 상황으로 가장 적절한 것은?', '조인으로 인한 성능 저하가 심각할 때', 70, 6),
	(381, 1, NULL, 2, NULL, '다음 중 정규화 과정에서 사용되는 \'이행적 함수 종속\'의 의미로 가장 적절한 것은?', 'A→B이고 B→C일 때, A→C가 성립하는 경우', 70, 6),
	(382, 1, NULL, 2, NULL, '다음 중 제5정규형(5NF)의 주요 목적으로 가장 적절한 것은?', '조인 종속성 제거', 70, 6),
	(383, 1, NULL, 2, NULL, '다음 중 정규화 과정에서 \'함수적 종속성 다이어그램\'을 사용하는 주된 이유는?', '속성 간의 종속 관계를 시각적으로 표현하기 위해', 70, 6),
	(384, 1, NULL, 2, NULL, '다음 중 \'완전 함수적 종속\'과 \'부분 함수적 종속\'을 구분하는 기준으로 가장 적절한 것은?', '복합키의 전체 또는 일부 사용 여부', 70, 6),
	(385, 1, NULL, 1, NULL, '다음 중 관계(Relationship)의 정의로 가장 적절한 것은?', '엔터티의 인스턴스들 사이의 논리적인 연관성', 60, 7),
	(386, 1, NULL, 1, NULL, '다음 중 관계의 차수(Degree)에 대한 설명으로 올바른 것은?', '관계에 참여하는 엔터티의 수', 60, 7),
	(387, 1, NULL, 1, NULL, '다음 중 1:N 관계에 대한 설명으로 가장 적절한 것은?', '한 쪽 엔터티의 하나의 인스턴스가 다른 쪽 엔터티의 여러 인스턴스와 관계를 맺을 수 있다', 60, 7),
	(388, 1, NULL, 1, NULL, '다음 중 M:N 관계를 해소하는 방법으로 가장 적절한 것은?', '중간에 연결 엔터티를 추가한다', 60, 7),
	(389, 1, NULL, 1, NULL, '다음 중 필수적 관계(Mandatory Relationship)와 선택적 관계(Optional Relationship)를 구분하는 기준은?', '관계 참여의 필수 여부', 60, 7),
	(390, 1, NULL, 1, NULL, '다음 중 순환 관계(Recursive Relationship)에 대한 설명으로 가장 적절한 것은?', '하나의 엔터티가 자기 자신과 관계를 맺는 것', 60, 7),
	(391, 1, NULL, 1, NULL, '다음 중 식별 관계(Identifying Relationship)의 특징으로 올바른 것은?', '부모 엔터티의 기본키가 자식 엔터티의 기본키의 일부로 사용된다', 60, 7),
	(392, 1, NULL, 1, NULL, '다음 중 ERD(Entity-Relationship Diagram)에서 관계를 표현하는 일반적인 기호는?', '마름모', 60, 7),
	(393, 1, NULL, 1, NULL, '다음 중 관계의 정의 시 고려해야 할 사항이 아닌 것은?', '관계의 색상', 60, 7),
	(394, 1, NULL, 1, NULL, '다음 중 비식별 관계(Non-Identifying Relationship)의 특징으로 가장 적절한 것은?', '부모 엔터티의 기본키가 자식 엔터티의 일반 속성으로 사용된다', 60, 7),
	(395, 1, NULL, 1, NULL, '다음 중 카디널리티(Cardinality)에 대한 설명으로 가장 적절한 것은?', '관계에 참여하는 각 엔터티의 인스턴스 수의 최대치', 60, 7),
	(396, 1, NULL, 2, NULL, '다음 중 관계의 정규화(Normalization)에 대한 설명으로 올바르지 않은 것은?', '항상 조회 성능을 향상시킨다', 60, 7),
	(397, 1, NULL, 2, NULL, '다음 중 관계의 종속성(Dependency)에 대한 설명으로 가장 적절한 것은?', '한 엔터티의 존재가 다른 엔터티의 존재에 의존하는 것', 60, 7),
	(398, 1, NULL, 1, NULL, '다음 중 관계 모델링 시 주의해야 할 사항으로 가장 적절하지 않은 것은?', '모든 관계는 반드시 M:N으로 설정해야 한다', 60, 7),
	(399, 1, NULL, 2, NULL, '데이터 모델에서 \'트랜잭션\'의 의미로 가장 적절한 것은?', '데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위', 60, 8),
	(400, 1, NULL, 2, NULL, '다음 중 트랜잭션의 특성(ACID)에 포함되지 않는 것은?', '확장성(Scalability)', 60, 8),
	(401, 1, NULL, 2, NULL, '데이터 모델에서 트랜잭션을 표현하는 방법으로 가장 적절하지 않은 것은?', '테이블의 색상 지정', 60, 8),
	(402, 1, NULL, 2, NULL, '다음 중 트랜잭션의 격리 수준(Isolation Level)과 관련이 없는 것은?', 'Distributed Read', 60, 8),
	(403, 1, NULL, 2, NULL, '데이터 모델에서 트랜잭션의 동시성을 고려할 때 가장 중요한 개념은?', '락킹(Locking)', 60, 8),
	(404, 1, NULL, 2, NULL, '다음 중 트랜잭션 모델링 시 고려해야 할 사항으로 가장 적절하지 않은 것은?', '테이블의 물리적 위치', 60, 8),
	(405, 1, NULL, 2, NULL, '트랜잭션의 원자성(Atomicity)을 데이터 모델에서 표현하는 방법으로 가장 적절한 것은?', '롤백(Rollback) 메커니즘 설계', 60, 8),
	(406, 1, NULL, 2, NULL, '다음 중 트랜잭션의 일관성(Consistency)을 유지하기 위한 방법으로 가장 적절한 것은?', '제약조건과 무결성 규칙 정의', 60, 8),
	(407, 1, NULL, 2, NULL, '트랜잭션의 독립성(Isolation)을 데이터 모델에서 고려할 때 중요한 개념은?', '동시성 제어(Concurrency Control)', 60, 8),
	(408, 1, NULL, 2, NULL, '다음 중 트랜잭션의 지속성(Durability)을 보장하기 위한 방법으로 가장 적절한 것은?', '로깅(Logging) 메커니즘 구현', 60, 8),
	(409, 1, NULL, 2, NULL, '데이터 모델에서 동시성 문제를 해결하기 위한 방법으로 가장 적절하지 않은 것은?', '모든 트랜잭션을 순차적으로 실행', 60, 8),
	(410, 1, NULL, 2, NULL, '다음 중 트랜잭션 모델링에서 \'긴 트랜잭션(Long Transaction)\'을 처리하는 방법으로 가장 적절한 것은?', '트랜잭션을 더 작은 단위로 분할', 60, 8),
	(411, 1, NULL, 2, NULL, '다음 중 관계 모델링 시 주의해야 할 사항으로 가장 적절하지 않은 것은?', '모든 관계를 다대다(M:N)로 설정해야 한다', 60, 8),
	(412, 1, NULL, 2, NULL, '다음 중 분산 트랜잭션(Distributed Transaction)을 모델링할 때 고려해야 할 사항으로 가장 적절한 것은?', '2단계 커밋(Two-Phase Commit) 프로토콜', 60, 8),
	(413, 1, NULL, 1, NULL, '다음 중 NULL의 의미로 가장 적절한 것은?', '알 수 없는 값 또는 해당 없음', 60, 9),
	(414, 1, NULL, 2, NULL, 'NULL 값과 관련하여 다음 중 올바른 설명은?', 'NULL과의 모든 비교 연산 결과는 UNKNOWN이다', 70, 9),
	(415, 1, NULL, 2, NULL, '다음 중 NULL을 포함한 열에 대해 집계 함수를 사용할 때의 설명으로 올바른 것은?', 'COUNT(*) 함수는 NULL을 포함한 모든 행을 계산한다', 70, 9),
	(416, 1, NULL, 1, NULL, 'NOT NULL 제약조건에 대한 설명으로 가장 적절한 것은?', '해당 열에 NULL 값을 허용하지 않는다', 60, 9),
	(417, 1, NULL, 2, NULL, 'NULL 값을 다른 값으로 대체하는 함수로 가장 적절한 것은?', 'COALESCE()', 70, 9),
	(418, 1, NULL, 1, NULL, '다음 중 NULL 값과 관련된 3가지 논리값 체계에서 사용되는 값이 아닌 것은?', 'MAYBE', 60, 9),
	(419, 1, NULL, 2, NULL, 'NULL 값이 포함된 열에 대해 DISTINCT를 사용할 때의 결과로 가장 적절한 것은?', 'NULL 값은 하나의 고유한 값으로 취급된다', 70, 9),
	(420, 1, NULL, 2, NULL, '다음 중 NULL 값을 포함한 열에 대한 인덱스 사용에 대해 올바른 설명은?', 'NULL 값의 인덱스 처리는 DBMS에 따라 다를 수 있다', 70, 9),
	(421, 1, NULL, 1, NULL, 'WHERE 절에서 NULL 값을 찾기 위해 사용해야 하는 연산자는?', 'IS NULL', 60, 9),
	(422, 1, NULL, 2, NULL, '다음 중 NULL 값과 관련하여 UNIQUE 제약조건의 동작에 대한 설명으로 가장 적절한 것은?', 'NULL 값은 UNIQUE 제약조건과 관계없이 여러 개 허용될 수 있다', 70, 9),
	(423, 1, NULL, 2, NULL, '복합 기본키(Composite Primary Key)에서 NULL 값 처리에 대한 설명으로 가장 적절한 것은?', '복합 기본키의 어떤 열에도 NULL 값이 허용되지 않는다', 70, 9),
	(424, 1, NULL, 2, NULL, 'NULL 값이 포함된 열에 대해 GROUP BY를 수행할 때의 결과로 가장 적절한 것은?', 'NULL 값은 별도의 그룹으로 처리된다', 70, 9),
	(425, 1, NULL, 3, NULL, '다음 중 NULL 값과 관련하여 외래 키(Foreign Key) 제약조건의 동작에 대한 설명으로 가장 적절한 것은?', '외래 키의 NULL 허용 여부는 설계자가 지정할 수 있다', 80, 9),
	(426, 1, NULL, 2, NULL, 'NULL 값을 포함한 데이터에 대해 UNION 연산을 수행할 때의 결과로 가장 적절한 것은?', 'NULL 값은 하나의 고유한 값으로 취급된다', 70, 9),
	(427, 1, NULL, 1, NULL, '다음 중 본질 식별자(Natural Key)의 정의로 가장 적절한 것은?', '업무적으로 의미 있는 데이터를 식별자로 사용하는 것', 60, 10),
	(428, 1, NULL, 2, NULL, '다음 중 인조 식별자(Surrogate Key)의 특징으로 가장 적절하지 않은 것은?', '업무적 의미를 가지고 있다', 70, 10),
	(429, 1, NULL, 2, NULL, '다음 중 본질 식별자의 장점으로 가장 적절한 것은?', '업무적 의미를 파악하기 쉽다', 70, 10),
	(430, 1, NULL, 2, NULL, '다음 중 인조 식별자를 사용할 때의 단점으로 가장 적절한 것은?', '데이터의 의미를 파악하기 어려울 수 있다', 70, 10),
	(431, 1, NULL, 2, NULL, '다음 중 인조 식별자를 사용하기 적합한 상황은?', '식별자로 사용할 만한 본질적인 속성이 없을 때', 70, 10),
	(432, 1, NULL, 2, NULL, '다음 중 본질 식별자를 사용할 때 주의해야 할 점으로 가장 적절한 것은?', '의미 있는 데이터의 변경 가능성', 70, 10),
	(433, 1, NULL, 1, NULL, '다음 중 인조 식별자의 예로 가장 적절한 것은?', '자동 증가하는 일련번호', 60, 10),
	(434, 1, NULL, 3, NULL, '다음 중 본질 식별자와 인조 식별자를 함께 사용하는 방식의 장점으로 가장 적절한 것은?', '업무적 의미와 시스템 효율성을 모두 고려할 수 있다', 80, 10),
	(435, 1, NULL, 2, NULL, '다음 중 인조 식별자를 생성하는 방법으로 가장 적절하지 않은 것은?', '기본키의 모든 칼럼을 연결하여 사용', 70, 10),
	(436, 1, NULL, 2, NULL, '다음 중 본질 식별자를 사용할 때의 장점으로 가장 적절하지 않은 것은?', '항상 최고의 검색 성능을 보장한다', 70, 10),
	(437, 1, NULL, 3, NULL, '다음 중 인조 식별자 사용이 데이터 모델링에 미치는 영향으로 가장 적절한 것은?', '물리적 모델과 논리적 모델의 차이를 줄일 수 있다', 80, 10),
	(438, 1, NULL, 2, NULL, '다음 중 본질 식별자와 인조 식별자의 선택 기준으로 가장 적절하지 않은 것은?', '개발 팀의 선호도', 70, 10),
	(439, 1, NULL, 2, NULL, '다음 중 인조 식별자 사용이 데이터 조회 성능에 미치는 영향으로 가장 적절한 것은?', '일반적으로 단순한 구조로 인해 성능이 향상될 수 있다', 70, 10),
	(440, 1, NULL, 3, NULL, '다음 중 본질 식별자와 인조 식별자의 병행 사용에 대한 설명으로 가장 적절한 것은?', '업무적 요구사항과 시스템 효율성을 모두 고려할 수 있는 방식이다', 80, 10),
	(441, 1, NULL, 1, NULL, '관계형 데이터베이스의 기본 구성 요소가 아닌 것은?', '포인터(Pointer)', 60, 11),
	(442, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'관계\'의 의미로 가장 적절한 것은?', '테이블 간의 논리적 연관성', 70, 11),
	(443, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 특징이 아닌 것은?', '계층적 구조로 데이터를 저장한다', 70, 11),
	(444, 1, NULL, 2, NULL, '관계형 데이터베이스에서 테이블의 다른 용어로 적절한 것은?', '릴레이션', 70, 11),
	(445, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 키(Key)가 아닌 것은?', '복합키(Composite Key)', 70, 11),
	(446, 1, NULL, 2, NULL, '관계형 데이터베이스의 무결성 제약조건과 가장 관련이 없는 것은?', '병행 무결성', 70, 11),
	(447, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 정규화 과정에서 다루는 주요 이슈가 아닌 것은?', '암호화 이상', 70, 11),
	(448, 1, NULL, 1, NULL, '관계형 데이터베이스에서 \'NULL\'의 의미로 가장 적절한 것은?', '알 수 없거나 해당 없음', 60, 11),
	(449, 1, NULL, 1, NULL, '다음 중 관계형 데이터베이스 관리 시스템(RDBMS)의 예가 아닌 것은?', 'MongoDB', 60, 11),
	(450, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'트랜잭션\'의 특성을 나타내는 약어로 알려진 것은?', 'ACID', 70, 11),
	(451, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 장점이 아닌 것은?', '대용량 비정형 데이터 처리에 최적화', 70, 11),
	(452, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'뷰(View)\'의 주요 목적으로 가장 적절한 것은?', '데이터 접근 제어 및 복잡한 쿼리 단순화', 70, 11),
	(453, 1, NULL, 2, NULL, '다음 중 관계형 데이터베이스의 스키마(Schema)에 대한 설명으로 가장 적절한 것은?', '데이터베이스의 논리적 구조와 제약조건의 정의', 70, 11),
	(454, 1, NULL, 2, NULL, '관계형 데이터베이스에서 \'참조 무결성\'을 유지하기 위한 주요 메커니즘은?', '외래키(Foreign Key) 제약조건', 70, 11),
	(455, 1, NULL, 2, NULL, 'SELECT 문의 기본 구조에서 올바른 순서는?', 'SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY', 70, 12),
	(456, 1, NULL, 1, NULL, '다음 중 SELECT 문에서 별칭(Alias)을 지정하는 올바른 방법은?', 'SELECT column_name AS alias_name', 60, 12),
	(457, 1, NULL, 1, NULL, 'SELECT 문에서 중복된 행을 제거하기 위해 사용하는 키워드는?', 'DISTINCT', 60, 12),
	(458, 1, NULL, 2, NULL, '다음 중 WHERE 절에서 사용할 수 없는 연산자는?', 'HAVING', 70, 12),
	(459, 1, NULL, 1, NULL, 'SELECT 문에서 여러 테이블을 조인할 때 사용하는 절은?', 'JOIN', 60, 12),
	(460, 1, NULL, 2, NULL, '다음 중 GROUP BY 절의 특징으로 올바르지 않은 것은?', 'ORDER BY 절 다음에 위치한다', 70, 12),
	(461, 1, NULL, 1, NULL, 'SELECT 문에서 결과를 정렬하기 위해 사용하는 절은?', 'ORDER BY', 60, 12),
	(462, 1, NULL, 2, NULL, '다음 중 HAVING 절의 용도로 가장 적절한 것은?', '그룹화된 결과에 조건을 적용한다', 70, 12),
	(463, 1, NULL, 3, NULL, 'SELECT 문에서 서브쿼리(Subquery)를 사용할 수 있는 위치가 아닌 것은?', 'ORDER BY 절', 80, 12),
	(464, 1, NULL, 2, NULL, '다음 중 SELECT 문에서 사용되는 집계 함수가 아닌 것은?', 'MEDIAN', 70, 12),
	(465, 1, NULL, 2, NULL, 'SELECT 문에서 LIKE 연산자와 함께 사용되는 와일드카드 문자가 아닌 것은?', '*', 70, 12),
	(466, 1, NULL, 3, NULL, '다음 중 SELECT 문의 실행 순서로 올바른 것은?', 'FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY', 80, 12),
	(467, 1, NULL, 1, NULL, 'SELECT 문에서 NULL 값을 찾기 위해 사용하는 올바른 구문은?', 'WHERE column_name IS NULL', 60, 12),
	(468, 1, NULL, 2, NULL, '다음 중 SELECT 문에서 UNION 연산자의 특징으로 올바르지 않은 것은?', '결과를 자동으로 오름차순 정렬한다', 70, 12),
	(469, 1, NULL, 1, NULL, '다음 중 문자열 함수가 아닌 것은?', 'ROUND', 60, 13),
	(470, 1, NULL, 2, NULL, 'NULL 값을 다른 값으로 대체하는 함수는?', 'COALESCE', 70, 13),
	(471, 1, NULL, 2, NULL, '날짜 간의 개월 수 차이를 계산하는 함수는?', 'MONTHS_BETWEEN', 70, 13),
	(472, 1, NULL, 2, NULL, '다음 중 집계 함수가 아닌 것은?', 'DECODE', 70, 13),
	(473, 1, NULL, 2, NULL, '문자열에서 특정 문자의 위치를 찾는 함수는?', '위의 모든 것', 70, 13),
	(474, 1, NULL, 1, NULL, '숫자를 반올림하는 함수는?', 'ROUND', 60, 13),
	(475, 1, NULL, 2, NULL, '현재 날짜와 시간을 반환하는 함수는?', '위의 모든 것 (DBMS에 따라 다름)', 70, 13),
	(476, 1, NULL, 2, NULL, '조건에 따라 다른 결과를 반환하는 함수는?', 'CASE', 70, 13),
	(477, 1, NULL, 2, NULL, '문자열의 길이를 반환하는 함수는?', 'b와 c 모두 (DBMS에 따라 다름)', 70, 13),
	(478, 1, NULL, 2, NULL, '두 값 중 큰 값을 반환하는 함수는?', 'GREATEST', 70, 13),
	(479, 1, NULL, 1, NULL, '숫자의 절대값을 반환하는 함수는?', 'ABS', 60, 13),
	(480, 1, NULL, 2, NULL, '문자열에서 특정 부분을 추출하는 함수는?', 'b와 c 모두 (DBMS에 따라 다름)', 70, 13),
	(481, 1, NULL, 2, NULL, '날짜에 특정 기간을 더하는 함수는?', '위의 모든 것 (DBMS에 따라 다름)', 70, 13),
	(482, 1, NULL, 2, NULL, '다음 중 윈도우 함수(분석 함수)가 아닌 것은?', 'ROUND', 70, 13),
	(483, 1, NULL, 1, NULL, 'WHERE 절의 주요 목적은 무엇인가?', '조건에 맞는 행을 선택한다', 60, 14),
	(484, 1, NULL, 2, NULL, '다음 중 WHERE 절에서 사용할 수 없는 연산자는?', 'HAVING', 70, 14),
	(485, 1, NULL, 2, NULL, 'WHERE 절에서 여러 조건을 결합할 때 사용하는 논리 연산자가 아닌 것은?', 'XOR', 70, 14),
	(486, 1, NULL, 1, NULL, 'NULL 값을 찾기 위해 WHERE 절에서 사용해야 하는 올바른 구문은?', 'WHERE column_name IS NULL', 60, 14),
	(487, 1, NULL, 1, NULL, 'WHERE 절에서 특정 범위의 값을 선택할 때 사용하는 연산자는?', 'BETWEEN', 60, 14),
	(488, 1, NULL, 1, NULL, '다음 중 WHERE 절에서 와일드카드 문자와 함께 사용되는 연산자는?', 'LIKE', 60, 14),
	(489, 1, NULL, 1, NULL, 'WHERE 절에서 여러 값 중 하나와 일치하는지 확인할 때 사용하는 연산자는?', 'IN', 60, 14),
	(490, 1, NULL, 2, NULL, 'WHERE 절에서 부정(NOT)을 표현하는 방법이 아닌 것은?', 'column_name ISNOT value', 70, 14),
	(491, 1, NULL, 2, NULL, 'WHERE 절에서 서브쿼리를 사용할 때, 서브쿼리가 여러 행을 반환하는 경우 사용할 수 없는 연산자는?', '=', 70, 14),
	(492, 1, NULL, 2, NULL, 'WHERE 절에서 날짜를 비교할 때 주의해야 할 점은?', '날짜 형식이 데이터베이스 설정과 일치해야 한다', 70, 14),
	(493, 1, NULL, 2, NULL, 'WHERE 절에서 대소문자를 구분하지 않고 비교하려면 어떻게 해야 하는가?', 'LOWER() 또는 UPPER() 함수를 사용한다', 70, 14),
	(494, 1, NULL, 2, NULL, 'WHERE 절에서 정규 표현식을 사용하기 위한 연산자는? (DBMS에 따라 다를 수 있음)', 'REGEXP 또는 RLIKE', 70, 14),
	(495, 1, NULL, 2, NULL, 'WHERE 절에서 계산된 열(Calculated Column)에 대한 조건을 지정할 때의 올바른 방법은?', '계산식을 그대로 WHERE 절에 사용한다', 70, 14),
	(496, 1, NULL, 2, NULL, 'WHERE 절에서 OR 조건과 AND 조건을 함께 사용할 때 주의해야 할 점은?', '괄호를 사용하여 우선순위를 명확히 해야 한다', 70, 14),
	(497, 1, NULL, 1, NULL, 'GROUP BY 절의 주요 목적은 무엇인가?', '데이터를 그룹화한다', 60, 15),
	(498, 1, NULL, 1, NULL, 'HAVING 절의 주요 목적은 무엇인가?', '그룹화된 결과를 필터링한다', 60, 15),
	(499, 1, NULL, 2, NULL, 'GROUP BY 절과 HAVING 절의 실행 순서로 올바른 것은?', 'GROUP BY → HAVING', 70, 15),
	(500, 1, NULL, 2, NULL, 'GROUP BY 절에서 사용할 수 없는 것은?', '별칭(Alias)', 70, 15),
	(501, 1, NULL, 2, NULL, '다음 중 HAVING 절에서 사용할 수 있는 것은?', '집계 함수', 70, 15),
	(502, 1, NULL, 2, NULL, 'GROUP BY 절을 사용할 때, SELECT 문에서 집계 함수를 사용하지 않은 칼럼은 어떻게 처리해야 하는가?', '반드시 GROUP BY 절에 포함시켜야 한다', 70, 15),
	(503, 1, NULL, 2, NULL, 'GROUP BY 절에서 여러 칼럼을 사용할 때의 결과는?', '모든 칼럼의 조합으로 그룹화된다', 70, 15),
	(504, 1, NULL, 2, NULL, 'HAVING 절과 WHERE 절의 차이점으로 올바른 것은?', 'HAVING은 그룹화 결과, WHERE은 개별 행에 대해 조건을 적용한다', 70, 15),
	(505, 1, NULL, 2, NULL, 'GROUP BY 절에서 NULL 값은 어떻게 처리되는가?', '별도의 그룹으로 처리된다', 70, 15),
	(506, 1, NULL, 1, NULL, '다음 중 GROUP BY 절과 함께 자주 사용되는 집계 함수가 아닌 것은?', 'SUBSTR', 60, 15),
	(507, 1, NULL, 2, NULL, 'GROUP BY 절을 사용하지 않고 HAVING 절을 사용할 수 있는가?', '가능하며, 전체 집합을 하나의 그룹으로 취급한다', 70, 15),
	(508, 1, NULL, 3, NULL, 'GROUP BY 절에서 \'WITH ROLLUP\'의 기능은? (MySQL 기준)', '부분 합계를 생성한다', 80, 15),
	(509, 1, NULL, 2, NULL, 'HAVING 절에서 서브쿼리를 사용할 수 있는가?', '가능하다', 70, 15),
	(510, 1, NULL, 3, NULL, 'GROUP BY 절을 사용할 때 발생할 수 있는 성능 문제를 해결하기 위한 방법으로 적절하지 않은 것은?', 'GROUP BY 절 제거', 80, 15),
	(511, 1, NULL, 1, NULL, 'ORDER BY 절의 주요 목적은 무엇인가?', '결과를 정렬한다', 60, 16),
	(512, 1, NULL, 1, NULL, 'ORDER BY 절의 기본 정렬 순서는?', '오름차순 (ASC)', 60, 16),
	(513, 1, NULL, 2, NULL, '여러 열을 기준으로 정렬할 때, 정렬 우선순위는 어떻게 결정되는가?', 'ORDER BY 절에 나열된 순서대로', 70, 16),
	(514, 1, NULL, 2, NULL, 'NULL 값은 ORDER BY 절에서 어떻게 처리되는가? (기본적으로)', 'DBMS에 따라 다르다', 70, 16),
	(515, 1, NULL, 2, NULL, 'ORDER BY 절에서 별칭(Alias)을 사용할 수 있는가?', '가능하다', 70, 16),
	(516, 1, NULL, 2, NULL, 'ORDER BY 절에서 사용할 수 없는 것은?', 'WHERE 절', 70, 16),
	(517, 1, NULL, 2, NULL, 'ORDER BY 절에서 숫자를 사용하는 것의 의미는?', 'SELECT 문의 칼럼 위치', 70, 16),
	(518, 1, NULL, 2, NULL, '다음 중 대소문자 구분 없이 정렬하는 방법으로 올바른 것은?', 'ORDER BY LOWER(column)', 70, 16),
	(519, 1, NULL, 2, NULL, 'ORDER BY 절에서 함수를 사용할 때의 영향은?', '정렬 속도가 느려질 수 있다', 70, 16),
	(520, 1, NULL, 2, NULL, 'ORDER BY 절의 실행 순서는 SQL 문의 다른 절들과 비교하여 어떠한가?', '가장 마지막에 실행된다', 70, 16),
	(521, 1, NULL, 3, NULL, 'ORDER BY 절에서 서브쿼리를 사용할 수 있는가?', '가능하다', 80, 16),
	(522, 1, NULL, 3, NULL, 'NULLS FIRST 또는 NULLS LAST 구문의 용도는?', 'NULL 값의 정렬 위치를 지정한다', 80, 16),
	(523, 1, NULL, 3, NULL, 'ORDER BY 절을 사용할 때 발생할 수 있는 성능 문제의 원인으로 가장 적절한 것은?', '대용량 데이터를 정렬할 때 메모리 사용량이 증가할 수 있어서', 80, 16),
	(524, 1, NULL, 3, NULL, 'ORDER BY 절에서 CASE 문을 사용하는 주된 목적은?', '조건부 정렬을 수행하기 위해', 80, 16),
	(525, 1, NULL, 1, NULL, '조인(Join)의 주요 목적은 무엇인가?', '여러 테이블의 데이터를 결합한다', 60, 17),
	(526, 1, NULL, 1, NULL, '다음 중 내부 조인(Inner Join)의 특징으로 가장 적절한 것은?', '조인 조건을 만족하는 데이터만 반환한다', 60, 17),
	(527, 1, NULL, 2, NULL, '외부 조인(Outer Join) 중 LEFT OUTER JOIN의 결과에 포함되는 것은?', '왼쪽 테이블의 모든 행', 70, 17),
	(528, 1, NULL, 2, NULL, 'FULL OUTER JOIN의 특징으로 가장 적절한 것은?', '양쪽 테이블의 모든 행을 반환하며, 매치되지 않는 행은 NULL로 채운다', 70, 17),
	(529, 1, NULL, 2, NULL, '셀프 조인(Self Join)의 정의로 가장 적절한 것은?', '동일한 테이블을 두 번 이상 조인하는 것', 70, 17),
	(530, 1, NULL, 2, NULL, '다음 중 비등가 조인(Non-Equi Join)의 예로 가장 적절한 것은?', 'ON A.price BETWEEN B.min_price AND B.max_price', 70, 17),
	(531, 1, NULL, 2, NULL, 'NATURAL JOIN의 특징으로 올바르지 않은 것은?', '동일한 이름을 가진 모든 열을 기준으로 자동으로 조인한다', 70, 17),
	(532, 1, NULL, 2, NULL, '크로스 조인(Cross Join)의 결과로 가장 적절한 것은?', '첫 번째 테이블의 모든 행과 두 번째 테이블의 모든 행을 조합한다 (카테시안 곱)', 70, 17),
	(533, 1, NULL, 2, NULL, '다음 중 조인 성능 최적화 방법으로 가장 적절하지 않은 것은?', '가능한 한 많은 테이블을 조인', 70, 17),
	(534, 1, NULL, 3, NULL, '세 개 이상의 테이블을 조인할 때 주의해야 할 점으로 가장 적절한 것은?', '조인 순서가 결과에 영향을 미칠 수 있다', 80, 17),
	(535, 1, NULL, 2, NULL, 'USING 절을 사용한 조인의 특징으로 올바른 것은?', '조인 칼럼의 이름이 같을 때 사용할 수 있다', 70, 17),
	(536, 1, NULL, 2, NULL, '다음 중 조인 조건이 없는 조인 방식은?', 'CROSS JOIN', 70, 17),
	(537, 1, NULL, 3, NULL, '안티 조인(Anti Join)의 목적으로 가장 적절한 것은?', '첫 번째 테이블에는 있지만 두 번째 테이블에는 없는 데이터를 찾는 것', 80, 17),
	(538, 1, NULL, 3, NULL, '조인을 사용할 때 NULL 값 처리에 대한 설명으로 가장 적절한 것은?', 'NULL 값의 처리는 조인 유형과 조건에 따라 다르다', 80, 17),
	(539, 1, NULL, 1, NULL, 'SQL 표준에서 정의하는 표준 조인 구문은?', 'FROM 절의 INNER JOIN, OUTER JOIN 등', 60, 18),
	(540, 1, NULL, 1, NULL, '다음 중 표준 내부 조인(INNER JOIN) 구문으로 올바른 것은?', 'FROM table1 INNER JOIN table2 ON table1.col = table2.col', 60, 18),
	(541, 1, NULL, 2, NULL, '표준 조인에서 ON 절과 WHERE 절의 차이점으로 가장 적절한 것은?', 'ON 절은 조인 조건을, WHERE 절은 필터 조건을 명시한다', 70, 18),
	(542, 1, NULL, 2, NULL, '표준 SQL의 NATURAL JOIN의 특징으로 올바르지 않은 것은?', '조인 결과에 중복 열이 포함된다', 70, 18),
	(543, 1, NULL, 2, NULL, '표준 SQL에서 USING 절을 사용한 조인의 특징은?', '조인 칼럼의 이름이 같을 때 사용할 수 있다', 70, 18),
	(544, 1, NULL, 2, NULL, '다음 중 표준 SQL의 외부 조인(OUTER JOIN) 구문으로 올바른 것은?', 'FROM table1 LEFT OUTER JOIN table2 ON table1.col = table2.col', 70, 18),
	(545, 1, NULL, 3, NULL, '표준 SQL에서 FULL OUTER JOIN이 지원되지 않을 때, 이를 구현하는 방법은?', 'LEFT OUTER JOIN과 RIGHT OUTER JOIN의 UNION을 사용한다', 80, 18),
	(546, 1, NULL, 2, NULL, '표준 SQL의 CROSS JOIN의 특징으로 가장 적절한 것은?', '두 테이블의 곱집합(Cartesian Product)을 반환한다', 70, 18),
	(547, 1, NULL, 2, NULL, '다음 중 표준 SQL의 셀프 조인(Self Join)을 설명한 것으로 가장 적절한 것은?', '동일한 테이블을 두 번 이상 조인하는 것', 70, 18),
	(548, 1, NULL, 2, NULL, '표준 SQL에서 비등가 조인(Non-Equi Join)을 구현하는 방법은?', 'ON 절에서 범위 조건 등을 사용한다', 70, 18),
	(549, 1, NULL, 2, NULL, '표준 SQL의 조인에서 ON 절과 USING 절을 동시에 사용할 수 있는가?', '불가능하다', 70, 18),
	(550, 1, NULL, 2, NULL, '다음 중 표준 SQL의 조인에서 지원하지 않는 기능은?', 'CONNECT BY', 70, 18),
	(551, 1, NULL, 3, NULL, '표준 SQL의 NATURAL JOIN과 USING 절을 사용한 조인의 차이점은?', 'NATURAL JOIN은 모든 공통 열을 사용하고, USING은 특정 열만 지정할 수 있다', 80, 18),
	(552, 1, NULL, 2, NULL, '표준 SQL 조인에서 여러 테이블을 조인할 때의 올바른 방법은?', '여러 개의 JOIN 키워드를 연속해서 사용한다', 70, 18),
	(553, 1, NULL, 1, NULL, '서브 쿼리(Subquery)의 정의로 가장 적절한 것은?', '메인 쿼리 내에 포함된 또 다른 쿼리', 60, 19),
	(554, 1, NULL, 2, NULL, '다음 중 서브 쿼리를 사용할 수 있는 위치가 아닌 것은?', 'CREATE TABLE 문', 70, 19),
	(555, 1, NULL, 2, NULL, '단일 행 서브 쿼리와 함께 사용할 수 있는 연산자는?', '=', 70, 19),
	(556, 1, NULL, 2, NULL, '다중 행 서브 쿼리와 함께 사용할 수 없는 연산자는?', '=', 70, 19),
	(557, 1, NULL, 3, NULL, '상관 서브 쿼리(Correlated Subquery)의 특징으로 가장 적절한 것은?', '메인 쿼리의 각 행마다 서브 쿼리가 실행된다', 80, 19),
	(558, 1, NULL, 2, NULL, '인라인 뷰(Inline View)의 정의로 가장 적절한 것은?', 'FROM 절에 사용된 서브 쿼리', 70, 19),
	(559, 1, NULL, 2, NULL, '스칼라 서브 쿼리(Scalar Subquery)의 특징으로 올바른 것은?', '단일 값을 반환한다', 70, 19),
	(560, 1, NULL, 2, NULL, '다음 중 서브 쿼리의 성능을 향상시키는 방법으로 가장 적절하지 않은 것은?', '모든 쿼리를 서브 쿼리로 변환한다', 70, 19),
	(561, 1, NULL, 2, NULL, 'EXISTS 연산자를 사용한 서브 쿼리의 특징으로 가장 적절한 것은?', '서브 쿼리의 결과가 존재하는지 여부만 확인한다', 70, 19),
	(562, 1, NULL, 2, NULL, '다음 중 서브 쿼리를 사용할 때의 장점이 아닌 것은?', '항상 쿼리의 성능을 향상시킨다', 70, 19),
	(563, 1, NULL, 3, NULL, '서브 쿼리에서 UNION을 사용할 수 있는 위치로 가장 적절한 것은?', 'FROM 절', 80, 19),
	(564, 1, NULL, 3, NULL, '다음 중 중첩 서브 쿼리(Nested Subquery)의 특징으로 가장 적절한 것은?', '서브 쿼리 안에 또 다른 서브 쿼리가 포함되어 있다', 80, 19),
	(565, 1, NULL, 3, NULL, '서브 쿼리에서 ORDER BY 절을 사용할 수 있는 경우는?', '인라인 뷰에서만 사용 가능하다', 80, 19),
	(566, 1, NULL, 3, NULL, '다음 중 서브 쿼리와 조인의 선택 기준으로 가장 적절한 것은?', '데이터의 특성과 쿼리의 목적에 따라 선택해야 한다', 80, 19),
	(567, 1, NULL, 1, NULL, 'SQL에서 사용되는 집합 연산자가 아닌 것은?', 'JOIN', 60, 20),
	(568, 1, NULL, 1, NULL, 'UNION 연산자의 특징으로 가장 적절한 것은?', '두 쿼리 결과의 합집합을 반환하며, 중복을 제거한다', 60, 20),
	(569, 1, NULL, 2, NULL, '다음 중 UNION ALL 연산자의 특징으로 올바른 것은?', '중복을 허용한다', 70, 20),
	(570, 1, NULL, 2, NULL, 'INTERSECT 연산자의 기능은?', '두 쿼리 결과의 교집합을 반환한다', 70, 20),
	(571, 1, NULL, 2, NULL, 'Oracle에서 MINUS 연산자와 동일한 기능을 하는 SQL Server의 연산자는?', 'EXCEPT', 70, 20),
	(572, 1, NULL, 2, NULL, '집합 연산자를 사용할 때 주의해야 할 점으로 가장 적절한 것은?', '연산 대상이 되는 쿼리들의 SELECT 절의 칼럼 개수가 동일해야 한다', 70, 20),
	(573, 1, NULL, 2, NULL, '다음 중 집합 연산자를 사용한 쿼리의 ORDER BY 절에 대한 설명으로 올바른 것은?', '맨 마지막 쿼리에만 ORDER BY를 사용할 수 있다', 70, 20),
	(574, 1, NULL, 1, NULL, 'UNION 연산자와 UNION ALL 연산자의 주요 차이점은?', 'UNION은 중복을 제거하고, UNION ALL은 중복을 허용한다', 60, 20),
	(575, 1, NULL, 2, NULL, '다음 중 집합 연산자의 성능 특성으로 가장 적절한 것은?', 'UNION ALL이 UNION보다 일반적으로 빠르다', 70, 20),
	(576, 1, NULL, 2, NULL, '집합 연산자를 사용할 때 데이터 타입에 관한 규칙으로 올바른 것은?', '대응되는 칼럼의 데이터 타입이 반드시 같을 필요는 없지만 호환 가능해야 한다', 70, 20),
	(577, 1, NULL, 2, NULL, '다음 중 MINUS 연산자(또는 EXCEPT)의 특징으로 올바른 것은?', '첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 뺀 차집합을 반환한다', 70, 20),
	(578, 1, NULL, 2, NULL, '집합 연산자를 사용한 쿼리에서 ALIAS를 지정할 때의 규칙으로 올바른 것은?', '첫 번째 쿼리의 ALIAS만 사용된다', 70, 20),
	(579, 1, NULL, 3, NULL, '다음 중 여러 개의 집합 연산자를 함께 사용할 때의 실행 순서로 올바른 것은?', '왼쪽에서 오른쪽으로 순차적으로 실행된다', 80, 20),
	(580, 1, NULL, 3, NULL, '집합 연산자를 사용할 때 NULL 값 처리 방식으로 올바른 것은?', 'NULL 값 처리는 DBMS와 연산자에 따라 다를 수 있다', 80, 20),
	(581, 1, NULL, 1, NULL, '다음 중 그룹 함수가 아닌 것은?', 'SUBSTR', 60, 21),
	(582, 1, NULL, 2, NULL, 'COUNT 함수에 대한 설명으로 옳지 않은 것은?', 'COUNT()는 항상 NULL을 반환한다', 70, 21),
	(583, 1, NULL, 2, NULL, '다음 중 NULL 값을 포함하여 계산하는 그룹 함수는?', 'COUNT(*)', 70, 21),
	(584, 1, NULL, 3, NULL, 'GROUP BY 절을 사용할 때 다음 중 옳은 설명은?', 'GROUP BY 절에 지정되지 않은 열이라도 SELECT 절에 사용할 수 있다', 80, 21),
	(585, 1, NULL, 2, NULL, 'HAVING 절의 용도로 가장 적절한 것은?', '그룹화된 결과에 조건을 적용한다', 70, 21),
	(586, 1, NULL, 2, NULL, '다음 중 그룹 함수를 중첩해서 사용할 수 있는 것은?', '그룹 함수는 중첩해서 사용할 수 없다', 70, 21),
	(587, 1, NULL, 2, NULL, 'ROLLUP 함수의 주요 용도는?', '소계와 총계를 계산', 70, 21),
	(588, 1, NULL, 3, NULL, '다음 중 CUBE 함수와 ROLLUP 함수의 차이점으로 가장 적절한 것은?', 'CUBE는 다차원 소계를 생성하고, ROLLUP은 계층적 소계를 생성한다', 80, 21),
	(589, 1, NULL, 3, NULL, 'GROUP BY 절에서 GROUPING SETS의 주요 기능은?', '여러 개의 GROUP BY 쿼리를 UNION ALL로 수행한 결과와 동일한 결과 생성', 80, 21),
	(590, 1, NULL, 2, NULL, '다음 중 DISTINCT 키워드를 사용할 수 있는 그룹 함수는?', 'COUNT', 70, 21),
	(591, 1, NULL, 2, NULL, '그룹 함수를 사용할 때 NULL 값 처리 방식으로 옳은 것은?', 'COUNT(*)는 NULL 값을 포함하여 계산한다', 70, 21),
	(592, 1, NULL, 3, NULL, '다음 중 LISTAGG 함수의 주요 용도는?', '그룹별로 데이터를 연결하여 하나의 열로 표시', 80, 21),
	(593, 1, NULL, 2, NULL, 'GROUP BY 절을 사용하지 않고 그룹 함수를 사용할 경우 결과는?', '전체 데이터에 대한 하나의 결과만 반환된다', 70, 21),
	(594, 1, NULL, 3, NULL, '다음 중 그룹 함수의 성능 최적화 방법으로 가장 적절하지 않은 것은?', '가능한 한 많은 열을 GROUP BY에 포함', 80, 21),
	(595, 1, NULL, 1, NULL, '윈도우 함수의 일반적인 구문 형식은?', '함수명() OVER (PARTITION BY 열 ORDER BY 열)', 60, 22),
	(596, 1, NULL, 1, NULL, '다음 중 순위 관련 윈도우 함수가 아닌 것은?', 'CONCAT()', 60, 22),
	(597, 1, NULL, 2, NULL, 'PARTITION BY 절의 주요 목적은?', '윈도우를 그룹화한다', 70, 22),
	(598, 1, NULL, 2, NULL, 'ROW_NUMBER()와 RANK() 함수의 주요 차이점은?', 'ROW_NUMBER()는 중복 값에 대해 다른 번호를 부여하고, RANK()는 같은 순위를 부여한다', 70, 22),
	(599, 1, NULL, 2, NULL, 'LEAD() 함수의 주요 용도는?', '현재 행을 기준으로 다음 행의 값을 참조한다', 70, 22),
	(600, 1, NULL, 3, NULL, '다음 중 윈도우 함수에서 사용할 수 없는 프레임 지정 옵션은?', 'COLUMNS', 80, 22),
	(601, 1, NULL, 2, NULL, 'FIRST_VALUE() 함수의 기능으로 가장 적절한 것은?', '윈도우의 첫 번째 행 값을 반환한다', 70, 22),
	(602, 1, NULL, 3, NULL, '윈도우 함수와 GROUP BY 절의 주요 차이점으로 가장 적절한 것은?', '윈도우 함수는 행 수를 줄이지 않고 계산을 수행하며, GROUP BY는 행 수를 줄인다', 80, 22),
	(603, 1, NULL, 2, NULL, 'NTILE() 함수의 주요 용도는?', '데이터를 지정된 수의 그룹으로 나눈다', 70, 22),
	(604, 1, NULL, 2, NULL, '다음 중 집계 윈도우 함수로 사용할 수 없는 것은?', 'SUBSTR()', 70, 22),
	(605, 1, NULL, 3, NULL, 'CUME_DIST() 함수의 반환 값 범위로 올바른 것은?', '0 초과 1 이하', 80, 22),
	(606, 1, NULL, 3, NULL, '윈도우 함수에서 ROWS와 RANGE의 차이점으로 가장 적절한 것은?', 'ROWS는 물리적 행 기준, RANGE는 논리적 값 기준으로 행을 지정한다', 80, 22),
	(607, 1, NULL, 2, NULL, 'LAG() 함수와 LEAD() 함수를 동시에 사용하는 주된 목적은?', '현재 행과 이전 행, 다음 행의 값을 한 번에 비교하기 위해', 70, 22),
	(608, 1, NULL, 3, NULL, '윈도우 함수의 성능 최적화 방법으로 가장 적절하지 않은 것은?', '모든 쿼리에 윈도우 함수 적용', 80, 22),
	(609, 1, NULL, 1, NULL, 'Oracle에서 Top N 쿼리를 구현하는 가장 일반적인 방법은?', 'ROWNUM 사용', 60, 23),
	(610, 1, NULL, 1, NULL, 'SQL Server에서 Top N 쿼리를 구현하는 가장 일반적인 방법은?', 'TOP 절 사용', 60, 23),
	(611, 1, NULL, 1, NULL, 'MySQL에서 Top N 쿼리를 구현하는 가장 일반적인 방법은?', 'LIMIT 절 사용', 60, 23),
	(612, 1, NULL, 2, NULL, '다음 중 Top N 쿼리의 일반적인 용도가 아닌 것은?', '모든 데이터의 평균 계산', 70, 23),
	(613, 1, NULL, 2, NULL, 'Oracle에서 ROWNUM을 사용한 Top N 쿼리의 주의사항으로 가장 적절한 것은?', 'ORDER BY 절과 함께 사용할 때 서브쿼리가 필요할 수 있다', 70, 23),
	(614, 1, NULL, 2, NULL, '다음 중 Top N 쿼리 최적화 방법으로 가장 적절하지 않은 것은?', '가능한 많은 데이터 추출', 70, 23),
	(615, 1, NULL, 3, NULL, 'Top N 쿼리에서 동점자 처리 방법으로 가장 적절한 것은?', 'a와 b 모두 가능', 80, 23),
	(616, 1, NULL, 3, NULL, '다음 중 페이지네이션(Pagination)을 구현하는데 사용될 수 있는 Top N 쿼리 기법은?', '모든 답변이 정확하다', 80, 23),
	(617, 1, NULL, 2, NULL, 'Top N 쿼리에서 WITH TIES 옵션(SQL Server)의 역할은?', '동점인 경우 추가 행을 포함한다', 70, 23),
	(618, 1, NULL, 2, NULL, '다음 중 Top N 쿼리와 관련이 없는 함수는?', 'CONCAT()', 70, 23),
	(619, 1, NULL, 2, NULL, 'Oracle에서 Top N 쿼리 결과의 범위를 지정할 때 사용하는 절은?', 'FETCH FIRST ROWS ONLY', 70, 23),
	(620, 1, NULL, 2, NULL, 'Top N 쿼리에서 윈도우 함수(Window Function)를 사용할 때의 장점은?', '복잡한 순위 지정 로직을 간단히 구현할 수 있다', 70, 23),
	(621, 1, NULL, 3, NULL, 'Top N 쿼리의 성능에 가장 큰 영향을 미치는 요소는?', 'ORDER BY 절의 존재 여부와 정렬 기준 열의 인덱스', 80, 23),
	(622, 1, NULL, 2, NULL, 'Top N 쿼리에서 PERCENT 옵션(SQL Server)의 역할은?', '전체 결과 중 상위 N%를 반환한다', 70, 23),
	(623, 1, NULL, 1, NULL, 'Oracle에서 계층형 질의를 작성할 때 사용하는 키워드는?', 'CONNECT BY', 60, 24),
	(624, 1, NULL, 1, NULL, '셀프 조인(Self Join)의 정의로 가장 적절한 것은?', '같은 테이블을 자기 자신과 조인하는 것', 60, 24),
	(625, 1, NULL, 2, NULL, '계층형 질의에서 CONNECT_BY_ISLEAF 의사 열(Pseudo Column)의 역할은?', '현재 행이 리프 노드인지 확인한다', 70, 24),
	(626, 1, NULL, 2, NULL, '다음 중 셀프 조인의 일반적인 사용 사례가 아닌 것은?', '테이블의 행 개수 계산', 70, 24),
	(627, 1, NULL, 2, NULL, 'Oracle의 계층형 질의에서 CONNECT_BY_ROOT 연산자의 기능은?', '현재 행의 루트 노드 값을 반환한다', 70, 24),
	(628, 1, NULL, 2, NULL, '계층형 질의에서 순환 관계(Cycle)를 방지하기 위해 사용하는 옵션은?', 'NOCYCLE', 70, 24),
	(629, 1, NULL, 2, NULL, '셀프 조인을 사용할 때 주의해야 할 점으로 가장 적절한 것은?', '같은 테이블의 별칭을 다르게 지정해야 한다', 70, 24),
	(630, 1, NULL, 2, NULL, 'Oracle의 계층형 질의에서 START WITH 절의 역할은?', '계층 구조의 시작점을 지정한다', 70, 24),
	(631, 1, NULL, 2, NULL, '다음 중 계층형 질의의 결과를 정렬하는 데 사용되는 함수는?', 'ORDER SIBLINGS BY', 70, 24),
	(632, 1, NULL, 3, NULL, '셀프 조인과 계층형 질의의 주요 차이점으로 가장 적절한 것은?', '셀프 조인은 모든 DBMS에서 지원하지만, 계층형 질의는 일부 DBMS에서만 지원한다', 80, 24),
	(633, 1, NULL, 3, NULL, 'Oracle의 계층형 질의에서 CONNECT_BY_ISCYCLE 의사 열의 용도는?', '현재 행이 사이클을 형성하는지 확인한다', 80, 24),
	(634, 1, NULL, 2, NULL, '다음 중 셀프 조인을 사용하여 구현할 수 있는 기능으로 가장 적절하지 않은 것은?', '테이블 백업', 70, 24),
	(635, 1, NULL, 3, NULL, 'Oracle의 SYS_CONNECT_BY_PATH 함수의 주요 용도는?', '계층 구조의 전체 경로를 문자열로 표현한다', 80, 24),
	(636, 1, NULL, 3, NULL, '다음 중 계층형 질의의 성능을 향상시키는 방법으로 가장 적절하지 않은 것은?', '가능한 한 깊은 레벨까지 탐색하도록 설정', 80, 24),
	(637, 1, NULL, 1, NULL, 'PIVOT 연산의 주요 목적은 무엇인가?', '행 데이터를 열 데이터로 변환한다', 60, 25),
	(638, 1, NULL, 1, NULL, 'UNPIVOT 연산의 주요 목적은 무엇인가?', '열 데이터를 행 데이터로 변환한다', 60, 25),
	(639, 1, NULL, 2, NULL, 'PIVOT 절을 사용할 때 반드시 필요한 것은?', '집계 함수', 70, 25),
	(640, 1, NULL, 2, NULL, '다음 중 PIVOT 절에서 사용할 수 없는 집계 함수는?', 'RANK', 70, 25),
	(641, 1, NULL, 2, NULL, 'UNPIVOT 절을 사용할 때 NULL 값 처리 방법으로 옳은 것은?', 'INCLUDE NULLS 옵션을 사용하면 NULL 값을 포함할 수 있다', 70, 25),
	(642, 1, NULL, 2, NULL, 'PIVOT 절의 일반적인 사용 사례가 아닌 것은?', '데이터 정규화', 70, 25),
	(643, 1, NULL, 2, NULL, 'PIVOT 절을 사용할 때 FOR 절의 역할은?', '피벗할 열을 지정한다', 70, 25),
	(644, 1, NULL, 2, NULL, 'UNPIVOT 절에서 IN 절의 역할은?', '언피벗할 열을 지정한다', 70, 25),
	(645, 1, NULL, 3, NULL, 'PIVOT 절을 사용할 때 동적으로 열을 생성하는 방법은?', 'PIVOT XML 사용', 80, 25),
	(646, 1, NULL, 3, NULL, 'UNPIVOT 절을 사용할 때 여러 열을 동시에 언피벗하는 방법은?', '괄호로 열 이름을 그룹화', 80, 25),
	(647, 1, NULL, 3, NULL, 'PIVOT 절의 성능을 향상시키는 방법으로 가장 적절한 것은?', '피벗하기 전에 데이터를 미리 집계한다', 80, 25),
	(648, 1, NULL, 3, NULL, 'UNPIVOT 절과 CROSS JOIN의 관계로 가장 적절한 설명은?', 'UNPIVOT과 CROSS JOIN은 완전히 다른 연산이다', 80, 25),
	(649, 1, NULL, 3, NULL, 'PIVOT 절을 지원하지 않는 DBMS에서 유사한 결과를 얻는 방법은?', 'CASE 문과 집계 함수 조합 사용', 80, 25),
	(650, 1, NULL, 3, NULL, 'PIVOT과 UNPIVOT을 연속해서 사용할 때의 결과로 가장 적절한 것은?', '원본 데이터와 다른 형태가 될 수 있으며, 사용 방식에 따라 결과가 달라진다', 80, 25),
	(651, 1, NULL, 1, NULL, '정규 표현식에서 \'.\'(점)의 의미는?', '정확히 한 개의 문자와 일치', 60, 26),
	(652, 1, NULL, 2, NULL, '정규 표현식 패턴 \'[0-9]+\'의 의미로 가장 적절한 것은?', '0에서 9까지의 숫자가 한 번 이상 반복', 70, 26),
	(653, 1, NULL, 1, NULL, 'Oracle에서 정규 표현식을 지원하는 함수는?', 'REGEXP_LIKE', 60, 26),
	(654, 1, NULL, 1, NULL, '정규 표현식에서 \'^\'의 의미는?', '문자열의 시작', 60, 26),
	(655, 1, NULL, 2, NULL, '정규 표현식 \'\\d\'와 동일한 의미를 가진 것은?', '[0-9]', 70, 26),
	(656, 1, NULL, 2, NULL, '정규 표현식에서 \'?\'의 의미는?', '0번 또는 1번 일치', 70, 26),
	(657, 1, NULL, 3, NULL, '이메일 주소를 검증하는 정규 표현식으로 가장 적절한 것은?', '^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$', 80, 26),
	(658, 1, NULL, 2, NULL, 'SQL에서 정규 표현식을 사용할 때의 장점이 아닌 것은?', '항상 LIKE 연산자보다 빠른 성능을 제공한다', 70, 26),
	(659, 1, NULL, 2, NULL, '정규 표현식 \'[^0-9]\'의 의미로 가장 적절한 것은?', '0에서 9까지의 숫자가 아닌 문자', 70, 26),
	(660, 1, NULL, 2, NULL, '정규 표현식에서 \'\\b\'의 의미는?', '단어 경계', 70, 26),
	(661, 1, NULL, 2, NULL, 'Oracle에서 정규 표현식을 사용한 문자열 치환에 사용되는 함수는?', 'REGEXP_REPLACE', 70, 26),
	(662, 1, NULL, 2, NULL, '정규 표현식 \'(ab)+\'의 의미로 가장 적절한 것은?', '\'ab\'가 한 번 이상 반복', 70, 26),
	(663, 1, NULL, 3, NULL, 'SQL Server에서 정규 표현식과 유사한 기능을 제공하는 것은?', 'PATINDEX 함수', 80, 26),
	(664, 1, NULL, 3, NULL, '정규 표현식 사용 시 성능 최적화 방법으로 가장 적절하지 않은 것은?', '모든 문자열에 대해 항상 정규 표현식 사용', 80, 26),
	(665, 1, NULL, 1, NULL, '다음 중 DML(Data Manipulation Language)에 해당하지 않는 명령어는?', 'CREATE', 60, 27),
	(666, 1, NULL, 2, NULL, 'INSERT 문에서 VALUES 절을 사용하지 않고 데이터를 삽입하는 방법은?', 'INSERT INTO 테이블명 SELECT 문;', 70, 27),
	(667, 1, NULL, 2, NULL, 'UPDATE 문에서 서브쿼리를 사용할 수 있는 위치가 아닌 곳은?', 'ORDER BY 절', 70, 27),
	(668, 1, NULL, 2, NULL, 'DELETE 문과 TRUNCATE 문의 차이점으로 올바른 것은?', 'DELETE는 DML이고, TRUNCATE는 DDL이다', 70, 27),
	(669, 1, NULL, 2, NULL, 'MERGE 문의 주요 용도로 가장 적절한 것은?', '조건에 따라 INSERT, UPDATE, DELETE를 한 번에 수행', 70, 27),
	(670, 1, NULL, 2, NULL, 'INSERT 문에서 여러 행을 한 번에 삽입하는 방법으로 올바른 것은?', 'INSERT INTO 테이블명 VALUES (값1, 값2), (값3, 값4);', 70, 27),
	(671, 1, NULL, 3, NULL, 'UPDATE 문에서 다른 테이블의 데이터를 참조하여 업데이트하는 방법으로 가장 적절한 것은?', 'a, b, c 모두 가능 (DBMS에 따라 다를 수 있음)', 80, 27),
	(672, 1, NULL, 2, NULL, 'DELETE 문을 실행한 후 삭제된 행의 수를 확인하는 방법으로 가장 적절한 것은?', 'a와 b 모두 가능 (DBMS에 따라 다름)', 70, 27),
	(673, 1, NULL, 2, NULL, 'INSERT 문에서 AUTO INCREMENT 열(또는 시퀀스)에 명시적으로 값을 지정하는 것의 영향으로 가장 적절한 것은?', '지정한 값이 이미 존재하면 오류가 발생할 수 있다', 70, 27),
	(674, 1, NULL, 2, NULL, 'UPDATE 문에서 WHERE 절을 생략했을 때 발생하는 결과로 가장 적절한 것은?', '테이블의 모든 행이 업데이트된다', 70, 27),
	(675, 1, NULL, 2, NULL, 'MERGE 문에서 WHEN NOT MATCHED THEN 절의 역할은?', '조건에 일치하는 데이터가 없을 때 INSERT를 수행', 70, 27),
	(676, 1, NULL, 3, NULL, 'DML 문 실행 시 암시적 트랜잭션(Implicit Transaction)의 의미로 가장 적절한 것은?', '각 DML 문이 자동으로 하나의 트랜잭션으로 처리된다', 80, 27),
	(677, 1, NULL, 3, NULL, 'INSERT 문에서 ON CONFLICT(PostgreSQL) 또는 ON DUPLICATE KEY UPDATE(MySQL) 절의 주요 용도는?', '중복 키 발생 시 오류를 방지하고 대체 작업을 수행', 80, 27),
	(678, 1, NULL, 3, NULL, 'DML 문의 실행 속도를 향상시키는 방법으로 가장 적절하지 않은 것은?', '모든 DML 문을 트랜잭션으로 묶어 실행한다', 80, 27),
	(679, 1, NULL, 1, NULL, '다음 중 TCL(Transaction Control Language)에 해당하는 명령어가 아닌 것은?', 'UPDATE', 60, 27),
	(680, 1, NULL, 2, NULL, '트랜잭션의 특성을 나타내는 ACID에서 \'A\'가 의미하는 것은?', 'Atomicity', 70, 27),
	(681, 1, NULL, 1, NULL, 'COMMIT 명령어의 주요 기능으로 가장 적절한 것은?', '트랜잭션의 변경사항을 영구적으로 반영한다', 60, 27),
	(682, 1, NULL, 2, NULL, 'ROLLBACK 명령어를 실행했을 때 발생하는 결과로 가장 적절한 것은?', '마지막 COMMIT 이후의 모든 변경사항이 취소된다', 70, 27),
	(683, 1, NULL, 2, NULL, 'SAVEPOINT의 주요 용도로 가장 적절한 것은?', '트랜잭션 내의 중간 지점 표시', 70, 27),
	(684, 1, NULL, 2, NULL, '암시적 트랜잭션 종료가 발생하는 경우가 아닌 것은?', 'SELECT 문 실행', 70, 27),
	(685, 1, NULL, 2, NULL, '트랜잭션 격리 수준 중 가장 낮은 수준은?', 'READ UNCOMMITTED', 70, 27),
	(686, 1, NULL, 3, NULL, '다음 중 ROLLBACK TO SAVEPOINT 명령어의 영향으로 가장 적절한 것은?', '지정된 SAVEPOINT 이후의 변경사항만 취소한다', 80, 27),
	(687, 1, NULL, 3, NULL, '트랜잭션의 ACID 특성 중 \'Isolation\'이 보장하는 것은?', '동시에 실행되는 트랜잭션 간의 상호 영향 방지', 80, 27),
	(688, 1, NULL, 2, NULL, 'AUTO COMMIT 모드에서 다음 중 자동으로 커밋되지 않는 명령은?', 'BEGIN TRANSACTION', 70, 27),
	(689, 1, NULL, 3, NULL, '장기 트랜잭션(Long Transaction)의 문제점으로 가장 적절하지 않은 것은?', '데이터의 일관성 향상', 80, 27),
	(690, 1, NULL, 3, NULL, '분산 트랜잭션에서 사용되는 프로토콜로 가장 적절한 것은?', 'Two-Phase Commit', 80, 27),
	(691, 1, NULL, 3, NULL, 'READ COMMITTED 격리 수준에서 방지할 수 있는 현상은?', 'Dirty Read', 80, 27),
	(692, 1, NULL, 3, NULL, '트랜잭션 처리 시 데드락(Deadlock)을 방지하기 위한 방법으로 가장 적절하지 않은 것은?', '트랜잭션의 크기를 가능한 한 크게 유지', 80, 27),
	(693, 1, NULL, 1, NULL, '다음 중 DDL(Data Definition Language)에 해당하는 명령어가 아닌 것은?', 'INSERT', 60, 29),
	(694, 1, NULL, 2, NULL, '테이블 생성 시 기본키(Primary Key)를 지정하는 올바른 문법은?', 'a와 b 모두 가능', 70, 29),
	(695, 1, NULL, 2, NULL, 'ALTER TABLE 명령어로 수행할 수 없는 작업은?', '테이블의 모든 데이터 삭제', 70, 29),
	(696, 1, NULL, 2, NULL, '인덱스를 생성하는 명령어로 올바른 것은?', 'a와 b 모두 가능 (DBMS에 따라 다름)', 70, 29),
	(697, 1, NULL, 2, NULL, 'TRUNCATE 명령어의 특징으로 가장 적절하지 않은 것은?', '롤백이 가능하다', 70, 29),
	(698, 1, NULL, 2, NULL, '뷰(View)를 생성하는 올바른 문법은?', 'CREATE VIEW view_name AS SELECT 문;', 70, 29),
	(699, 1, NULL, 2, NULL, '다음 중 제약조건(Constraint)이 아닌 것은?', 'INDEX', 70, 29),
	(700, 1, NULL, 2, NULL, '테이블 스페이스(Tablespace)를 생성하는 명령어로 가장 적절한 것은?', 'CREATE TABLESPACE', 70, 29),
	(701, 1, NULL, 2, NULL, 'DROP TABLE 명령 실행 시 발생하는 결과로 가장 적절한 것은?', '테이블의 데이터와 구조 모두 삭제된다', 70, 29),
	(702, 1, NULL, 2, NULL, '시퀀스(Sequence) 객체의 주요 용도로 가장 적절한 것은?', '유일한 숫자 값 자동 생성', 70, 29),
	(703, 1, NULL, 3, NULL, 'ALTER TABLE 명령으로 수행할 수 있는 작업이 아닌 것은?', '테이블의 모든 행 복제', 80, 29),
	(704, 1, NULL, 2, NULL, 'COMMENT ON 명령어의 주요 용도는?', '데이터베이스 객체에 주석 추가', 70, 29),
	(705, 1, NULL, 3, NULL, '파티션(Partition) 테이블 생성 시 고려해야 할 사항으로 가장 적절하지 않은 것은?', '파티션 테이블의 인덱스 생성 불가능', 80, 29),
	(706, 1, NULL, 2, NULL, 'DDL 문 실행 시 발생하는 암시적 동작으로 가장 적절한 것은?', '자동 커밋(Auto Commit)', 70, 29),
	(707, 1, NULL, 1, NULL, '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'GRANT', 60, 30),
	(708, 1, NULL, 2, NULL, '사용자에게 특정 테이블에 대한 SELECT 권한을 부여하는 올바른 문법은?', 'GRANT SELECT ON table_name TO user_name;', 70, 30),
	(709, 1, NULL, 1, NULL, 'REVOKE 명령어의 주요 목적은?', '사용자로부터 권한을 제거한다', 60, 30),
	(710, 1, NULL, 2, NULL, '다음 중 시스템 권한이 아닌 것은?', 'INSERT ON employees', 70, 30),
	(711, 1, NULL, 2, NULL, '역할(Role)의 주요 용도로 가장 적절한 것은?', '권한들의 집합을 관리', 70, 30),
	(712, 1, NULL, 2, NULL, 'WITH GRANT OPTION의 의미로 가장 적절한 것은?', '부여받은 권한을 다른 사용자에게 부여할 수 있는 권한', 70, 30),
	(713, 1, NULL, 3, NULL, '데이터베이스 관리자(DBA) 권한에 일반적으로 포함되지 않는 것은?', '일반 사용자의 비밀번호 확인', 80, 30),
	(714, 1, NULL, 2, NULL, 'GRANT 명령어로 부여할 수 없는 권한은?', 'COMMENT', 70, 30),
	(715, 1, NULL, 2, NULL, 'public 역할(Role)의 특징으로 가장 적절한 것은?', '모든 사용자에게 자동으로 부여되는 역할', 70, 30),
	(716, 1, NULL, 3, NULL, '객체 권한을 취소할 때 CASCADE 옵션의 효과는?', '해당 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소한다', 80, 30),
	(717, 1, NULL, 2, NULL, '다음 중 DCL 명령어 실행 시 자동 커밋(Auto Commit)이 발생하는 DBMS는?', '모든 DBMS에서 자동 커밋이 발생한다', 70, 30),
	(718, 1, NULL, 2, NULL, '사용자에게 여러 개의 권한을 한 번에 부여하는 방법으로 가장 적절한 것은?', 'a와 b 모두 가능', 70, 30),
	(719, 1, NULL, 2, NULL, '데이터베이스 보안에서 \'권한의 최소화 원칙\'이 의미하는 바는?', '사용자에게 필요한 최소한의 권한만 부여한다', 70, 30),
	(720, 1, NULL, 3, NULL, 'REVOKE 명령어 실행 시 주의해야 할 점으로 가장 적절한 것은?', '잘못된 REVOKE 실행 시 의도치 않게 다른 사용자의 권한도 제거될 수 있다', 80, 30),
	(721, 3, NULL, 2, '1회차', '다음은 A사의 제품 리뷰 시스템 개발 프로젝트에서 도출된 엔터티들이다. 이 중 실무적으로 개선이 필요한 엔터티 설계는?', '리뷰내용변경이력 테이블이 복합키(리뷰번호, 변경일자)로 설계되어 있는데, 이는 이력 관리의 정확성을 보장하기 어렵습니다. 별도의 이력번호를 추가하여 기본키로 사용하는 것이 더 적절합니다.', NULL, 2),
	(722, 3, NULL, 2, '1회차', '다음 중 트랜잭션의 특성을 고려할 때 제약조건(Constraint) 설계가 잘못된 것은?', '계좌잔고는 트랜잭션의 일관성(Consistency)을 보장해야 하는 중요한 속성입니다. DEFAULT 제약조건만으로는 부적절하며, CHECK 제약조건으로 잔액이 0 이상이 되도록 보장해야 합니다.', NULL, 8),
	(723, 3, '고객은 여러 번 주문할 수 있으며, 한 번 주문 시 여러 상품을 주문할 수 있다. 각 상품의 주문수량과 주문 당시의 단가를 반드시 기록해야 하며, 주문이 취소될 경우 취소 사유와 취소 시각을 기록해야 한다.', 3, '1회차', '다음 요구사항에 대한 가장 적절한 모델링 방식은?', '이력 관리가 필요한 데이터는 별도 엔터티로 분리하는 것이 좋습니다. 주문상세와 주문취소이력을 분리함으로써 취소 이력의 독립적인 관리가 가능하고, 취소되지 않은 주문의 데이터 구조가 단순해지며, 향후 취소 관련 요구사항 변경 시 유연한 대응이 가능합니다.', NULL, 3),
	(724, 3, '배송지관리\n  - 회원번호: 숫자(10)\n  - 배송지명: 문자(50)\n  - 우편번호: 문자(5)\n  - 기본주소: 문자(200)\n  - 상세주소: 문자(200)\n  - 연락처: 문자(20)\n  - 기본배송지여부: 문자(1)', 2, '1회차', '배송지관리 테이블에서 기본키를 가장 적절하게 지정한 것은?', '배송지관리 테이블에서는 한 회원이 여러 배송지를 가질 수 있고, 배송지명은 사용자가 변경할 수 있어 식별자로 부적절하며, 주소 정보는 길이가 길고 변경 가능성이 있어 식별자로 부적절합니다. 따라서 별도의 배송지번호를 추가하여 기본키로 사용하는 것이 가장 적절합니다.', NULL, 5),
	(725, 3, '진료예약(예약번호, 환자번호, 진료과코드, 진료과명, 의사번호, 의사명, 진료일자, 진료시간)\n환자(환자번호, 환자명, 생년월일, 연락처, 최근진료일자, 누적진료횟수)\n진료과(진료과코드, 진료과명, 층수, 전화번호, 과장의사번호)', 3, '1회차', 'H병원의 진료 예약 시스템에서 제3정규형 관점에서 가장 문제가 되는 것은?', '제3정규형은 이행적 종속을 제거해야 합니다. 진료예약 테이블의 진료과명은 진료과코드에 종속되고, 진료과코드는 예약번호에 종속되는 이행적 종속관계가 존재합니다. 이는 진료과 테이블에서 관리되어야 할 정보입니다.', NULL, 6),
	(726, 3, '고객 ----0<---- 주문 ----0<---- 주문상품\n  ㅣ             ㅣ              ㅣ\n  ㅣ             ㅣ              ㅣ\n  >-------- 배송지              상품', 2, '1회차', 'ERD에서 잘못 표현된 관계를 고르시오.', '고객과 배송지의 관계에서 한 고객이 여러 배송지를 가질 수 있으므로, 현재 표현된 1:1 관계가 아닌 1:N 관계로 표현되어야 합니다.', NULL, 4),
	(727, 3, NULL, 3, '1회차', '다음 중 슈퍼타입-서브타입 관계를 잘못 설계한 것은?', '회원등급은 슈퍼타입-서브타입 관계가 아닌 속성으로 관리되어야 합니다. 등급은 회원의 상태를 나타내는 것이며, 한 회원이 시간에 따라 등급이 변경될 수 있기 때문입니다.', NULL, 3),
	(728, 3, NULL, 2, '1회차', '다음 중 반정규화를 고려해야 하는 상황으로 가장 부적절한 것은?', '배송완료된 주문의 상세 정보는 자주 변경되지 않는 데이터이며, 조회 빈도가 높지 않을 것으로 예상됩니다. 따라서 반정규화를 고려할 필요가 없습니다.', NULL, 6),
	(729, 3, NULL, 2, '1회차', '온라인 쇼핑몰의 로그인 이력 데이터를 설계할 때 가장 적절한 식별자 선택 방식은?', '로그인 이력은 빈번한 입력이 발생하는 이력성 데이터이며, 데이터 정합성이 중요하고, 조회 시 성능이 중요합니다. 따라서 별도의 로그인이력번호를 기본키로 사용하는 것이 가장 적절합니다.', NULL, 5),
	(730, 3, NULL, 3, '1회차', '다음은 여행사 패키지 상품 예약 시스템의 일부이다. 가장 적절하지 않은 모델링은?', '여행자정보 테이블의 회원번호는 불필요한 중복입니다. 예약번호만으로 충분히 식별이 가능하며, 회원번호는 예약 테이블과의 관계에서 조회할 수 있습니다. 또한 한 예약에 대해 여러 여행자가 존재할 수 있으므로, 별도의 여행자번호가 필요할 수 있습니다.', NULL, 2),
	(731, 3, 'SALES_MONTHLY\nSALES_MONTH    TOTAL_AMOUNT\n--------------------------\n202301         15000000\n202302         16500000\n202303         19000000\n202304         20000000\n202305         21000000', 3, '1회차', '월별 매출액이 직전 월 대비 10% 이상 증가한 월을 조회하는 SQL문으로 가장 적절한 것은?', 'LAG 함수를 사용하여 이전 월의 매출액과 비교하는 방식이 가장 효율적입니다. 윈도우 함수를 사용함으로써 자기 조인이나 서브쿼리 없이 간단하게 구현 가능하며 성능상 이점이 있고 코드의 가독성이 좋습니다.', NULL, 22),
	(732, 3, '[EMPLOYEE]\nEMP_NO  DEPT_NO  SALARY   BONUS\n--------------------------------\n1001    10       5000     1000\n1002    20       4000     NULL\n1003    10       3000     NULL\n1004    30       4500     700\n1005    20       2800     NULL', 2, '1회차', 'GROUP BY로 부서별 집계를 수행하는 SQL의 실행 결과는?', 'GROUP BY 절로 부서별 집계를 수행하고, COUNT(*)로 부서별 직원 수, SUM(SALARY)로 급여 합계, AVG(NVL(BONUS,0))로 NULL을 0으로 처리한 보너스 평균을 계산합니다.', NULL, 15),
	(733, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       2800', 3, '1회차', '부서별로 평균 급여보다 높은 급여를 받는 직원의 정보를 조회하려고 한다. 올바른 SQL문은?', '부서별 평균 급여를 구하고 이를 원래 테이블과 조인하는 방식이 가장 적절합니다. 인라인 뷰로 부서별 평균을 한 번만 계산하여 효율적입니다.', NULL, 19),
	(734, 3, NULL, 2, '1회차', 'UNION 연산에 대한 설명으로 틀린 것은?', 'UNION 연산에서는 칼럼 이름이 달라도 데이터 타입과 칼럼 개수가 일치하면 사용할 수 있습니다. ALIAS를 사용하여 결과 칼럼명을 지정할 수 있습니다.', NULL, 20),
	(735, 3, '[ORDERS]\nORDER_DATE\n----------\n2023-01-01\n2023-01-02\n2023-01-03\n2023-01-07\n2023-01-08\n2023-01-12\n2023-01-13', 3, '1회차', '연속으로 3일 이상 주문이 없는 기간을 찾으려고 한다. 적절한 SQL문은?', 'LEAD 함수를 사용하여 다음 주문일자와의 차이를 계산하는 방식이 가장 효율적입니다. date_diff를 통해 날짜 간격을 직접 계산하고, 윈도우 함수를 사용하여 복잡한 조인 없이 구현할 수 있으며, 결과가 명확하고 이해하기 쉽습니다.', NULL, 22),
	(736, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       4800', 3, '1회차', '각 부서별로 급여가 가장 높은 직원을 조회하는 SQL문 중 성능상 가장 효율적인 것은?', '부서별 최대 급여를 먼저 구하고 이를 원본 테이블과 조인하는 방식이 가장 효율적입니다. 인라인 뷰로 부서별 최대 급여를 한 번만 계산하고, 단순 조인으로 최종 결과를 도출하며, 불필요한 중복 계산이나 비교 작업이 없습니다.', NULL, 17),
	(737, 3, '[STOCK_HISTORY]\nPROD_ID  TRX_DATE    TRX_TYPE    QUANTITY\n----------------------------------------\nA001     2023-01-01  IN          100\nA001     2023-01-03  OUT         30\nA001     2023-01-05  IN          50\nA002     2023-01-02  IN          200\nA002     2023-01-04  OUT         100', 3, '1회차', '제품별 일별 재고 현황을 파악하려고 한다. 해당 일자에 입출고 내역이 없는 경우에도 직전 재고수량을 표시해야 한다. 적절한 SQL문은?', 'WITH 절과 CONNECT BY를 사용하여 모든 날짜를 생성하고, 이를 기준으로 재고 이력을 조회하는 방식이 가장 적절합니다. 날짜 연속성을 보장하고, 입출고 내역이 없는 날짜도 포함하며, 누적 재고 계산이 정확합니다.', NULL, 19),
	(738, 3, NULL, 2, '1회차', '다음 중 INSERT 문장에 대한 설명으로 올바르지 않은 것은?', 'INSERT 문장에서도 ORDER BY 절을 사용할 수 있습니다. INSERT SELECT 구문에서 ORDER BY 사용이 가능하며, 데이터의 삽입 순서가 중요한 경우 사용됩니다.', NULL, 27),
	(739, 3, '[DEPARTMENT]\nDEPT_ID   PARENT_DEPT_ID   DEPT_NAME\n----------------------------------------\n1         NULL             총무부\n2         1                인사팀\n3         1                총무팀\n4         NULL             영업부\n5         4                국내영업팀\n6         4                해외영업팀', 2, '1회차', '계층형 쿼리를 실행한 결과로 적절하지 않은 것은?', 'START WITH DEPT_ID IN (2,3)와 CONNECT BY PRIOR PARENT_DEPT_ID = DEPT_ID는 역방향 계층 구조를 잘못 구현한 예입니다. 하위에서 상위로 탐색하려면 PRIOR를 올바르게 사용해야 하며, 현재 구문은 논리적 오류가 있습니다.', NULL, 24),
	(740, 3, NULL, 2, '1회차', '다음 트랜잭션 관련 설명 중 틀린 것은?', 'TRUNCATE 문은 DDL이므로 ROLLBACK이 불가능합니다. AUTO COMMIT 되는 명령어이며, 로그를 남기지 않고, 복구가 불가능합니다.', NULL, 27),
	(741, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       4800', 2, '1회차', '다음 중 부서별 급여 순위를 구하는 가장 적절한 SQL문은?', 'RANK() 함수와 PARTITION BY를 사용하여 부서별로 급여 순위를 매기는 것이 가장 적절합니다. PARTITION BY로 부서별 그룹화하고, RANK()로 동일 순위 처리하며, ORDER BY SALARY DESC로 높은 급여순 정렬합니다.', NULL, 22),
	(742, 3, '[SALES]\nORDER_DATE  PRODUCT_ID  QUANTITY\n--------------------------------\n2023-01-01  A001        10\n2023-01-01  A002        15\n2023-01-01  A003         5\n2023-01-02  A001         8\n2023-01-02  A002        12', 3, '1회차', '주문일자별로 가장 많이 판매된 상품의 정보를 조회하려고 한다. 적절한 SQL문은?', 'RANK() 함수를 사용한 방식이 가장 효율적입니다. 윈도우 함수로 주문일자별 수량 순위를 계산하고 서브쿼리 중첩을 최소화하여 성능과 가독성이 우수합니다.', NULL, 22),
	(743, 3, NULL, 2, '1회차', '다음 중 데이터 정의어(DDL)에 해당하지 않는 것은?', 'UPDATE문은 DML(Data Manipulation Language)에 해당합니다. DDL은 CREATE, ALTER, DROP, TRUNCATE, RENAME 등의 명령어입니다.', NULL, 27),
	(744, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       8000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       7500\n1005    JUNG    20       4800\n1006    KANG    10       5500', 2, '1회차', '부서별 최대 급여와 최소 급여의 차이가 5000 이상인 부서를 조회하는 SQL문을 작성하시오.', 'GROUP BY와 HAVING절을 사용한 방식이 올바릅니다. WHERE절은 그룹함수를 사용할 수 없고, HAVING절에서 그룹 조건을 처리하며, MAX(), MIN() 함수로 급여차이를 계산해야 합니다.', NULL, 15),
	(745, 3, '[TARGET_TBL]\nPROD_ID  PROD_NAME  STOCK_QTY\n--------------------------------\nA001     Product1   100\nA002     Product2   150\n\n[SOURCE_TBL]\nPROD_ID  PROD_NAME  STOCK_QTY\n--------------------------------\nA001     Product1   120\nA003     Product3   200', 3, '1회차', '다음 테이블의 데이터를 MERGE 문을 사용하여 갱신하려고 한다. 올바른 구문은?', 'MERGE문의 기본 구문을 정확히 사용했습니다. USING절로 소스 테이블을 지정하고, ON절로 매칭 조건을 정의하며, MATCHED/NOT MATCHED로 각각의 경우를 처리합니다.', NULL, 27),
	(746, 3, '[LOGIN_HISTORY]\nUSER_ID    LOGIN_DT            SUCCESS_YN\n------------------------------------------\nUSER01    2024-01-01 09:00:00    N\nUSER01    2024-01-01 09:01:00    N\nUSER01    2024-01-01 09:02:00    N\nUSER02    2024-01-01 09:03:00    N\nUSER02    2024-01-01 09:04:00    Y', 3, '1회차', '연속으로 3회 이상 로그인 실패한 사용자를 찾으려고 한다. 적절한 SQL문은?', '연속된 실패를 찾기 위해서는 로그인 시도의 순서를 고려해야 합니다. 자기 조인으로 연속된 실패를 확인하고, 시간 순서를 고려하며, 동일 사용자의 연속된 실패만 카운트해야 합니다.', NULL, 22),
	(747, 3, '[PURCHASES]\nCUST_ID  PROD_ID  PURCHASE_DATE\n--------------------------------\nC001     A001     2024-01-01\nC001     B001     2024-01-02\nC002     B001     2024-01-01\nC002     C001     2024-01-02\nC003     A001     2024-01-03\nC003     B001     2024-01-04', 3, '1회차', '한 번이라도 A001 상품을 구매한 이력이 있는 고객이 구매한 다른 상품들의 정보를 조회하려 한다. 적절한 SQL문은?', 'EXISTS를 사용한 방식이 가장 효율적입니다. 불필요한 조인이나 중복 제거 없이 A001 상품 구매 여부 확인이 명확하고 성능상 이점이 있습니다.', NULL, 19),
	(748, 3, NULL, 2, '1회차', '다음 중 인덱스를 효과적으로 사용할 수 있는 WHERE 절 작성 방법으로 적절하지 않은 것은?', 'salary * 12와 같은 연산은 인덱스를 사용할 수 없습니다. 컬럼에 대한 연산은 인덱스 활용이 불가능하며, 순수 컬럼 비교만 인덱스 활용이 가능합니다.', NULL, 17),
	(749, 3, '[SALES]\nSALES_MONTH    AMOUNT\n----------------------\n202401         1000000\n202402         1200000\n202403         950000\n202404         1300000', 3, '1회차', '월별 매출액과 전월 대비 증감률을 계산하려고 한다. 적절한 SQL문은?', 'LAG 함수와 CASE문을 조합한 방식이 가장 적절합니다. 0으로 나누는 경우를 처리하고, 증감률 계산이 정확하며, 코드가 간결하고 명확합니다.', NULL, 22),
	(750, 3, NULL, 2, '1회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 틀린 것은?', 'FOREIGN KEY의 데이터 타입은 반드시 동일할 필요는 없습니다. 자동 형변환이 가능한 경우 다른 타입도 가능하며, 참조 무결성만 보장되면 됩니다.', NULL, 17),
	(751, 3, 'SELECT dept_no, job_id FROM emp_2023\nUNION\nSELECT dept_no, job_id FROM emp_2024\nINTERSECT\nSELECT dept_no, job_id FROM emp_2022;', 2, '1회차', '아래의 집합 연산자 실행 결과를 바르게 예측한 것은?', 'SQL 집합 연산자의 우선순위는 INTERSECT > UNION 순입니다. 따라서 2024년과 2022년 데이터의 교집합을 먼저 구하고, 그 결과와 2023년 데이터의 합집합을 구합니다.', NULL, 20),
	(752, 3, '[EMPLOYEE]\nEMP_NO  NAME    DEPT_NO  SALARY\n--------------------------------\n1001    KIM     10       5000\n1002    LEE     20       4000\n1003    PARK    10       3000\n1004    CHOI    30       4500\n1005    JUNG    20       4800', 3, '1회차', '부서별로 평균 급여보다 높은 급여를 받는 사원의 수를 조회하는 SQL문으로 가장 효율적인 것은?', 'WITH절을 사용한 방식이 가장 효율적입니다. 평균 급여를 한 번만 계산하고, 명확한 코드 구조를 가지며, 성능상 이점이 있습니다.', NULL, 19),
	(753, 3, '[BOARD]\nPOST_ID   PARENT_ID   TITLE          REG_DATE\n-------------------------------------------\n1         NULL        첫번째글       2024-01-01\n2         1           ㄴRE:답글1     2024-01-02\n3         1           ㄴRE:답글2     2024-01-03\n4         NULL        두번째글       2024-01-04\n5         4           ㄴRE:답글1     2024-01-05', 2, '1회차', '각 게시글의 답글 수를 조회하려고 한다. 적절한 SQL문은?', 'LEFT JOIN과 GROUP BY를 사용하여 각 원본 게시글의 답글 수를 정확히 계산할 수 있습니다. NULL 처리와 집계가 모두 올바르게 동작합니다.', NULL, 19),
	(754, 3, NULL, 2, '1회차', '다음 중 SELECT 문장에서 GROUP BY를 사용할 때의 규칙으로 올바르지 않은 것은?', 'GROUP BY절의 컬럼 순서는 결과에 영향을 주지 않습니다. 그룹화의 결과는 순서와 무관하며, ORDER BY로 정렬 순서를 지정할 수 있습니다.', NULL, 15),
	(755, 3, '[EMPLOYEE]\nEMP_NO  DEPT_NO  SALARY_GRADE\n---------------------------\n1001    10       A\n1002    20       B\n1003    10       A\n1004    30       C\n1005    20       B', 3, '1회차', '부서별 급여 등급 분포를 PIVOT을 사용하여 조회하려고 한다. 적절한 SQL문은?', 'PIVOT 절을 사용하면 행으로 출력되는 데이터를 열로 변환할 수 있습니다. 부서별 급여 등급의 분포를 보기 좋게 표현할 수 있습니다.', NULL, 19),
	(756, 3, '[SALES]\nREGION  PRODUCT  QUANTITY\n-------------------------\n서울    A        100\n서울    B        150\n부산    A        200\n부산    B        120\n대구    A         80', 2, '1회차', '지역별, 상품별 판매량을 ROLLUP을 사용하여 집계하려고 한다. 적절한 SQL문은?', 'ROLLUP을 사용한 계층적 집계가 가장 적절합니다. 전체 합계, 지역별 합계, 지역+상품별 합계 모두 계산되며, 계층 구조가 명확하고 코드가 간결합니다.', NULL, 21),
	(757, 3, '[EMPLOYEE]\nEMP_NO  HIRE_DATE   RESIGN_DATE\n--------------------------------\n1001    2020-01-01  NULL\n1002    2019-06-01  2023-12-31\n1003    2021-03-01  NULL\n1004    2018-01-01  2022-06-30', 2, '1회차', '퇴사일자(RESIGN_DATE)가 NULL인 현재 재직자들의 근속연수를 계산하려 한다. 적절한 SQL문은?', 'MONTHS_BETWEEN 함수를 사용한 방식이 가장 정확합니다. 월 단위 계산이 정확하고, TRUNC로 소수점 처리가 되며, 날짜 계산이 명확합니다.', NULL, 13),
	(758, 3, NULL, 2, '1회차', '다음 중 데이터베이스 트랜잭션의 ACID 속성에 대한 설명으로 틀린 것은?', 'Durability는 지속성으로, 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함을 의미합니다. 다른 트랜잭션 접근 제한은 Isolation의 특성입니다.', NULL, 27),
	(759, 3, NULL, 2, '1회차', '다음 중 인덱스 생성 시 고려사항으로 적절하지 않은 것은?', '조인 조건으로 자주 사용되는 컬럼에는 오히려 인덱스를 생성하는 것이 좋습니다. 조인 성능 향상을 위해 인덱스가 필요하고, 외래키에 대한 인덱스는 유용하며, 조인 최적화에 도움이 됩니다.', NULL, 17),
	(760, 3, '[PURCHASES]\nORDER_DATE  CUST_ID  PROD_ID\n------------------------------\n2024-01-01  C001     P001\n2024-01-02  C001     P002\n2024-01-03  C002     P003\n\n[PRODUCTS]\nPROD_ID  CATEGORY  PROD_NAME\n------------------------------\nP001     A         상품1\nP002     B         상품2\nP003     A         상품3\nP004     A         상품4', 3, '1회차', '가장 최근에 구매한 상품과 동일한 카테고리의 다른 상품들을 추천하려고 한다. 적절한 SQL문은?', 'WITH절을 사용한 방식이 가장 명확하고 효율적입니다. 마지막 구매 정보를 명확히 식별하고, 동일 카테고리 상품 추출이 용이하며, 코드의 가독성이 우수합니다.', NULL, 19),
	(761, 3, '[ATTENDANCE]\nSTUDENT_ID  ATT_DATE    STATUS\n--------------------------------\nS001        2024-01-01  출석\nS001        2024-01-02  결석\nS001        2024-01-03  결석\nS001        2024-01-04  결석\nS001        2024-01-05  출석\nS002        2024-01-01  결석\nS002        2024-01-02  결석', 3, '1회차', '연속된 결석일수가 3일 이상인 학생을 찾으려고 한다. 적절한 SQL문은?', '윈도우 함수를 사용하여 이전 2일과 현재를 포함한 3일간의 결석 수를 계산합니다.\n\nWITH절과 윈도우 함수를 사용하여 연속된 결석을 정확하게 찾을 수 있습니다.\n\nROWS BETWEEN 2 PRECEDING AND CURRENT ROW로 연속된 3일을 확인합니다.\n\nCOUNT와 CASE문을 조합하여 결석만 카운트합니다.', NULL, 24),
	(762, 3, '[EMPLOYEE]\nEMP_NO   DEPT_NO   POSITION   SALARY\n-----------------------------------\n1001     10        사원       3000\n1002     20        대리       4000\n1003     10        대리       3500\n1004     20        과장       5000\n1005     10        과장       4500', 3, '1회차', '부서별 직급별 평균 급여를 PIVOT을 사용하여 조회하려고 한다.', 'PIVOT을 사용하여 행으로 되어있는 직급별 정보를 열로 변환할 수 있습니다.\n\n부서별로 각 직급의 인원수를 한눈에 파악할 수 있게 됩니다.\n\nFOR절에서 직급을 지정하고 AS를 사용하여 열 이름을 설정합니다.\n\n결과는 부서별로 각 직급의 인원수가 열 형태로 표시됩니다.', NULL, 26),
	(763, 3, '[DAILY_SALES]\nSALES_DATE    AMOUNT\n----------------------\n2024-01-01    1000000\n2024-01-02    1200000\n2024-01-03     950000\n2024-01-04    1100000\n2024-01-05    1300000\n2024-01-06    1400000\n2024-01-07    1800000\n2024-01-08    1600000', 3, '1회차', '일 매출이 직전 일주일 평균 매출보다 20% 이상 높은 날짜를 찾으려고 한다.', '윈도우 함수를 사용하여 직전 7일간의 평균 매출을 계산합니다.\n\nPARTITION BY로 기준 단위를 정의합니다.\n\nROWS BETWEEN 7 PRECEDING AND 1 PRECEDING으로 정확한 기간을 지정합니다.\n\n현재 매출과 평균 매출을 비교하여 20% 이상 높은 날짜를 식별합니다.', NULL, 22),
	(764, 3, '[SALARY_HISTORY]\nDEPT_NO    SALARY_MONTH    MIN_SALARY\n-------------------------------------\n10         202401          3000000\n10         202402          3200000\n10         202403          3100000\n20         202401          2800000\n20         202402          3000000\n20         202403          3200000', 3, '1회차', '각 부서의 월별 최소 급여가 전월 최소 급여보다 증가한 경우를 찾으려고 한다.', 'LAG 함수를 사용하여 이전 월의 최소 급여와 비교하는 것이 가장 효율적입니다.\n\nPARTITION BY DEPT_NO로 부서별 처리를 합니다.\n\nORDER BY SALARY_MONTH로 월별 순서를 정렬합니다.\n\n서브쿼리나 자기조인 없이 단순하게 구현 가능합니다.', NULL, 22),
	(765, 3, '[EMPLOYEE]\nEMP_NO    DEPT_NO    SALARY\n----------------------------\n1001      10         5000\n1002      10         5000\n1003      10         4000\n1004      20         6000\n1005      20         5000\n1006      20         5000', 3, '1회차', '부서별로 급여가 높은 순서대로 등수를 매기되, 같은 급여는 같은 등수로 처리하고 다음 등수는 건너뛰어야 한다.', 'RANK() 함수가 요구사항에 가장 적합합니다.\n\n같은 급여는 같은 등수로 처리합니다.\n\n다음 등수는 동일 순위 개수만큼 건너뜁니다.\n\nPARTITION BY DEPT_NO로 부서별 순위를 매깁니다.', NULL, 22),
	(766, 3, '[USER_LOGIN]\nUSER_ID     LAST_LOGIN_DATE\n-----------------------------\nuser1       2024-01-01\nuser2       2023-12-01\nuser3       2024-01-15\nuser4       2023-11-30', 2, '1회차', '30일 이상 미접속한 사용자를 찾으려고 한다.', 'TRUNC를 사용하여 시간을 제외한 순수 일자 차이를 계산하는 것이 정확합니다.\n\n날짜 간의 차이를 정확하게 계산할 수 있습니다.\n\nTRUNC 함수로 시간 정보를 제거합니다.\n\n정확한 일수 차이를 구할 수 있습니다.', NULL, 13),
	(767, 3, '[CUSTOMER_PURCHASE]\nCUST_ID    PURCHASE_DATE    AMOUNT\n---------------------------------\nC001       2024-01-01      10000\nC002       2024-01-15      20000\nC001       2024-02-01      15000\nC003       2024-02-15      25000\nC002       2024-02-28      30000', 3, '1회차', '월별로 처음 구매한 고객과 마지막으로 구매한 고객의 수를 집계하려고 한다.', 'ROW_NUMBER와 PARTITION BY를 사용하여 고객별 첫 구매와 마지막 구매를 식별합니다.\n\n월별로 그룹화하여 첫 구매와 마지막 구매 고객 수를 집계합니다.\n\nCASE문을 활용하여 첫 구매와 마지막 구매를 구분합니다.\n\n코드가 명확하고 유지보수가 용이합니다.', NULL, 19),
	(768, 3, '[SALES]\nPROD_ID    SALES_MONTH    QUANTITY\n--------------------------------\nP001       202401         100\nP001       202402         120\nP001       202403         90\nP001       202404         110\nP002       202401         200\nP002       202402         180\nP002       202403         220', 3, '1회차', '각 상품의 월별 판매량과 직전 3개월 평균 판매량을 구하려고 한다.', 'ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING을 사용하여 직전 3개월의 평균을 정확하게 계산합니다.\n\nPARTITION BY로 상품별로 구분합니다.\n\nORDER BY로 월별 순서를 정렬합니다.\n\n현재 월을 제외한 이전 3개월의 평균을 구할 수 있습니다.', NULL, 22),
	(769, 3, '[DAILY_SALES]\nSALES_DATE     AMOUNT\n----------------------\n2024-01-01     1000000\n2024-01-02     1200000\n2024-01-03     950000\n2024-01-04     1100000\n2024-01-05     1300000\n2024-01-06     1400000\n2024-01-07     1800000\n2024-01-08     1600000', 3, '1회차', '일 매출이 직전 일주일 평균 매출보다 20% 이상 높은 날짜를 찾으려고 한다.', '서브쿼리를 사용하여 직전 일주일의 평균을 정확히 계산하는 것이 가장 적절합니다.\n\nBETWEEN 연산자로 정확한 날짜 범위를 지정할 수 있습니다.\n\n현재 날짜를 제외하고 이전 7일만 계산합니다.\n\n평균값에 1.2를 곱하여 20% 증가를 계산합니다.', NULL, 22),
	(770, 3, '[MONTHLY_SALARY]\nDEPT_NO    YM        AVG_SALARY\n--------------------------------\n10         202401    3000000\n10         202402    3100000\n10         202403    3200000\n10         202404    3150000\n20         202401    2800000\n20         202402    2900000\n20         202403    3000000\n20         202404    3100000', 3, '1회차', '각 부서별로 연속된 3개월 이상 평균 급여가 증가한 기간을 찾으려고 한다.', '세 개의 연속된 월을 JOIN으로 연결하여 비교하는 것이 가장 명확합니다.\n\n연속된 월을 명시적으로 조인하여 비교할 수 있습니다.\n\n증가 여부를 직접 비교할 수 있어 이해하기 쉽습니다.\n\n복잡한 윈도우 함수 없이 구현이 가능합니다.\n\n결과가 명확하고 유지보수가 용이합니다.', NULL, 22),
	(771, 3, NULL, 2, '2회차', '다음 중 엔터티를 도출하는 방법으로 가장 적절하지 않은 것은?', '엔터티 도출 시에는 정보의 가치와 중요성을 고려해야 합니다. 모든 통계 데이터를 무조건 엔터티로 도출하는 것은 적절하지 않으며, 업무적 필요성과 데이터의 활용도를 고려하여 도출해야 합니다.', NULL, 2),
	(772, 3, NULL, 2, '2회차', '엔터티와 인스턴스의 관계에 대한 설명으로 가장 옳지 않은 것은?', '엔터티는 0개 이상의 인스턴스를 가질 수 있습니다. 예를 들어, 새로 설립된 회사의 \'직원\' 엔터티는 초기에 인스턴스가 없을 수 있으며, 이는 정상적인 상황입니다.', NULL, 2),
	(773, 3, NULL, 3, '2회차', '다음 중 정규화에 대한 설명으로 가장 옳은 것은?', '정규화가 진행될수록 테이블은 더 작은 단위로 분해되므로 테이블의 수가 증가합니다. 이는 데이터의 중복을 제거하고 데이터 정합성을 향상시키는 과정입니다.', NULL, 6),
	(774, 3, NULL, 2, '2회차', '다음 중 속성의 특징으로 가장 적절하지 않은 것은?', '주식별자는 단일 속성 또는 여러 속성의 조합(복합 식별자)으로 구성될 수 있습니다. 예를 들어, \'주문상세\' 엔터티의 경우 \'주문번호\'와 \'상품번호\'의 조합으로 주식별자를 구성할 수 있습니다.', NULL, 3),
	(775, 3, NULL, 2, '2회차', '다음 중 관계(Relationship)에 대한 설명으로 가장 옳은 것은?', '관계는 업무적으로 연관된 엔터티 간의 논리적 연결을 표현합니다. 관계는 선택적으로 참여 여부가 결정될 수 있으며, 양방향성이 필수는 아닙니다.', NULL, 4),
	(776, 3, NULL, 3, '2회차', '다음 중 식별자 관계에 대한 설명으로 가장 적절한 것은?', '식별 관계에서는 부모 엔터티의 주식별자가 자식 엔터티의 주식별자의 구성요소가 됩니다. 이는 두 엔터티 간의 강한 연관관계를 나타냅니다.', NULL, 5),
	(777, 3, NULL, 3, '2회차', '다음 중 슈퍼타입/서브타입 모델링에 대한 설명으로 옳지 않은 것은?', '서브타입은 슈퍼타입의 속성을 상속받지만, 자신만의 고유한 속성을 추가로 가질 수 있습니다. 모든 속성을 포함해야 한다는 것은 잘못된 설명입니다.', NULL, 2),
	(778, 3, '기본 엔터티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가되는 엔터티', 2, '2회차', '엔터티의 유형 중 다음 설명에 해당하는 것은?', '행위 엔터티는 기본 엔터티로부터 발생되는 트랜잭션의 결과로 생성되는 엔터티입니다. 주문, 거래, 계약 등이 대표적인 예시이며, 업무적 프로세스의 실행 결과로 발생됩니다.', NULL, 2),
	(779, 3, NULL, 2, '2회차', '다음 중 논리적 데이터 모델링 단계에서 수행하는 작업이 아닌 것은?', '인덱스 설계는 물리적 데이터 모델링 단계에서 수행하는 작업입니다. 논리적 데이터 모델링 단계에서는 업무적 관점에서의 데이터 구조 설계에 중점을 둡니다.', NULL, 8),
	(780, 3, NULL, 1, '2회차', '다음 중 ERD(Entity Relationship Diagram)의 표기법으로 올바르지 않은 것은?', 'ERD에서 식별자 표현에 특정 색상을 강제하는 표준은 없습니다. 식별자는 일반적으로 밑줄이나 \'#\' 등의 표기로 구분하며, 색상은 표기법에 따라 다양하게 사용될 수 있습니다.', NULL, 5),
	(781, 3, NULL, 1, '2회차', '다음 중 Oracle의 데이터 정의어(DDL)에 해당하지 않는 것은?', 'UPDATE는 DML(데이터 조작어)에 속합니다. DDL(데이터 정의어)에는 CREATE, ALTER, DROP, TRUNCATE, RENAME 등이 포함됩니다.', NULL, 30),
	(782, 3, 'SELECT SUBSTR(\'SQLD자격검정\', 5, 2) FROM DUAL;', 2, '2회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'SUBSTR(\'SQLD자격검정\', 5, 2)는 5번째 위치에서 2개의 문자를 추출합니다. 한글도 한 문자로 계산되어 \'자격\'이 추출됩니다.', NULL, 13),
	(783, 3, NULL, 3, '2회차', '다음 중 GROUP BY절에 대한 설명으로 옳지 않은 것은?', 'GROUP BY절에서는 SELECT절에서 정의한 Alias를 사용할 수 없습니다. Alias는 ORDER BY절에서만 사용 가능합니다.', NULL, 15),
	(784, 3, '[EMPLOYEE]\nID NAME SALARY DEPT_ID\n------------------------\n1 Kim 3000 10\n2 Lee 3500 20\n3 Park 2800 10\n4 Choi 4000 30\n5 Jung 3200 20\n\nSELECT DEPT_ID, COUNT(*), MAX(SALARY)\nFROM EMPLOYEE\nGROUP BY DEPT_ID\nHAVING COUNT(*) >= 2;', 3, '2회차', '다음 테이블에서 SQL문의 실행 결과를 고르시오.', 'DEPT_ID별로 그룹화하고 COUNT(*) >= 2 조건을 적용하면, 2명 이상의 직원이 있는 부서 10, 20만 출력됩니다.', NULL, 15),
	(785, 3, NULL, 2, '2회차', '다음 중 NULL 관련 함수에 대한 설명으로 틀린 것은?', 'NVL2 함수는 첫 번째 인자가 NULL이 아니면 두 번째 인자를, NULL이면 세 번째 인자를 반환합니다.', NULL, 13),
	(786, 3, '2024\n2023\n2022', 3, '2회차', '다음과 같은 결과를 출력하는 SQL문으로 적절한 것은?', 'CONNECT BY LEVEL을 사용하여 현재 년도부터 3개의 연도를 내림차순으로 출력합니다.', NULL, 13),
	(787, 3, '[TABLE_A]\nID NAME\n--------\n1 AAA\n2 BBB\n3 CCC\n\n[TABLE_B]\nID VALUE\n---------\n1 100\n2 200\n4 400', 2, '2회차', '다음 두 테이블의 OUTER JOIN 결과를 바르게 나타낸 것은?', 'LEFT OUTER JOIN 시 TABLE_A의 모든 행(3개)과 TABLE_B에만 존재하는 ID=4인 행이 추가되어 총 4행이 됩니다.', NULL, 17),
	(788, 3, NULL, 3, '2회차', 'WINDOW 함수에 대한 설명으로 옳지 않은 것은?', 'DENSE_RANK는 동일한 값에 대해 동일한 순위를 부여하고, 다음 순위는 이전 순위+1로 계산합니다.', NULL, 22),
	(789, 3, NULL, 2, '2회차', '다음 중 UNION 연산자에 대한 설명으로 옳지 않은 것은?', 'UNION 연산자 사용 시 두 SELECT문의 칼럼 개수는 반드시 동일해야 하며, 데이터 타입도 호환 가능해야 합니다.', NULL, 20),
	(790, 3, '[SCORE]\nVALUE\n-----\n10\n20\nNULL\n30\nNULL', 2, '2회차', '다음 테이블에서 최댓값을 구하는 SQL문으로 옳은 것은?', 'MAX 함수는 자동으로 NULL을 제외하고 최댓값을 계산합니다. 별도의 NULL 처리가 필요하지 않습니다.', NULL, 13),
	(791, 3, NULL, 1, '2회차', '다음 중 DCL(Data Control Language)에 해당하는 것은?', 'DCL에는 GRANT(권한 부여)와 REVOKE(권한 회수)가 포함됩니다. COMMIT은 TCL, CREATE는 DDL, INSERT는 DML입니다.', NULL, 30),
	(792, 3, '[SALES]\nMONTH AMOUNT\n-------------\n01 1000\n02 2000\n02 3000\n03 1500\n03 2500\n\nSELECT MONTH, SUM(AMOUNT)\nFROM SALES\nGROUP BY ROLLUP(MONTH);', 2, '2회차', '다음 테이블에 대한 SQL 실행 결과로 알맞은 것은?', 'ROLLUP은 지정된 칼럼의 소계와 총계를 생성합니다. 월별 합계 5행과 전체 합계 1행이 추가되어 총 6행이 됩니다.', NULL, 21),
	(793, 3, NULL, 2, '2회차', '계층형 질의에 사용되는 가상 칼럼이 아닌 것은?', 'ROWID는 Oracle의 물리적 주소를 나타내는 의사열(Pseudo Column)이며, 계층형 질의의 가상 칼럼이 아닙니다.', NULL, 24),
	(794, 3, NULL, 2, '2회차', '다음 중 PIVOT 함수를 사용할 때 반드시 지정해야 하는 것이 아닌 것은?', 'PIVOT 함수 사용 시 반드시 필요한 요소는 집계함수, FOR절, IN절입니다. WHERE절은 선택적으로 사용할 수 있습니다.', NULL, 26),
	(795, 3, '[EMPLOYEE]\nEMP_ID SALARY DEPT_ID\n-----------------------\n1 3000 10\n2 4000 20\n3 3500 10\n4 5000 30', 3, '2회차', '다음과 같은 테이블이 있을 때, 서브쿼리를 이용한 SQL문 중 틀린 것은?', 'NULL 비교는 = 연산자가 아닌 IS NULL을 사용해야 합니다.', NULL, 19),
	(796, 3, NULL, 2, '2회차', '트랜잭션의 특성(ACID)이 아닌 것은?', '트랜잭션의 특성은 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성)입니다.', NULL, 28),
	(797, 3, NULL, 2, '2회차', 'Oracle의 날짜 연산에 대한 설명으로 틀린 것은?', 'Oracle에는 NEXT_MONTH 함수가 없습니다. 다음 달의 첫 날을 구하려면 ADD_MONTHS 함수를 사용해야 합니다.', NULL, 13),
	(798, 3, NULL, 2, '2회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 옳지 않은 것은?', '참조 무결성 제약조건에 의해 참조되는 테이블(부모 테이블)은 참조하는 테이블(자식 테이블)이 먼저 삭제되어야 삭제할 수 있습니다.', NULL, 30),
	(799, 3, 'RANK VALUE\n-----------\n1 100\n1 100\n3 90\n4 80\n4 80', 3, '2회차', '다음과 같은 결과를 출력하는 SQL문으로 적절한 것은?', 'RANK 함수는 동일한 값에 대해 동일한 순위를 부여하고, 다음 순위는 동일한 순위의 개수만큼 건너뜁니다.', NULL, 22),
	(800, 3, '[PRODUCT]\nID NAME PRICE\n---------------\n1 A 1000\n2 B 2000\n3 C 3000\n\nSELECT NAME,\n       LAG(PRICE, 1) OVER (ORDER BY PRICE) AS PREV_PRICE,\n       LEAD(PRICE, 1) OVER (ORDER BY PRICE) AS NEXT_PRICE\nFROM PRODUCT;', 2, '2회차', '다음 테이블에 대한 SQL문의 실행 결과로 옳은 것은?', 'LAG는 이전 행의 값, LEAD는 다음 행의 값을 가져옵니다. 첫 행의 LAG와 마지막 행의 LEAD는 NULL이 됩니다.', NULL, 22),
	(801, 3, NULL, 3, '2회차', 'WITH절(별칭 지정)에 대한 설명으로 옳지 않은 것은?', 'WITH절은 재귀적 호출이 가능하며, 이를 재귀적 CTE(Common Table Expression)라고 합니다.', NULL, 19),
	(802, 3, '[SCORE]\nID VALUE\n---------\n1 NULL\n2 50\n3 NULL\n4 80\n\nSELECT COALESCE(MAX(VALUE), AVG(VALUE), MIN(VALUE), 0)\nFROM SCORE;', 2, '2회차', '다음 테이블에서 SQL의 실행 결과는?', 'COALESCE는 NULL이 아닌 첫 번째 값을 반환합니다. MAX(VALUE)가 80으로 NULL이 아니므로 80이 반환됩니다.', NULL, 13),
	(803, 3, NULL, 2, '2회차', '다음 중 인덱스에 대한 설명으로 틀린 것은?', '인덱스는 데이터의 특성과 사용 패턴에 따라 오히려 성능을 저하시킬 수 있습니다.', NULL, 30),
	(804, 3, 'SELECT CASE\n         WHEN NULL = NULL THEN \'A\'\n         WHEN NULL IS NULL THEN \'B\'\n         ELSE \'C\'\n       END AS RESULT\nFROM DUAL;', 2, '2회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'NULL은 = 연산자로 비교할 수 없으며, IS NULL 연산자를 사용해야 합니다. 따라서 두 번째 조건이 TRUE가 되어 \'B\'가 반환됩니다.', NULL, 13),
	(805, 3, NULL, 3, '2회차', '다음 중 SELECT 문장 실행 순서가 올바른 것은?', 'SQL 문장의 논리적 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY입니다.', NULL, 12),
	(806, 3, '[DEPT]\nID NAME\n---------\n10 HR\n20 IT\n30 SALES\n\nSELECT *\nFROM DEPT\nSTART WITH ID = 20\nCONNECT BY PRIOR ID = ID;', 2, '2회차', '다음 테이블의 조회 결과로 적절한 것은?', '계층형 쿼리에서 PRIOR가 없으면 자기 자신과 연결되어 순환이 발생하므로 데이터가 출력되지 않습니다.', NULL, 24),
	(807, 3, NULL, 3, '2회차', '다음 중 윈도우 함수의 PARTITION BY절에 대한 설명으로 옳은 것은?', 'PARTITION BY는 윈도우 함수에서 연산을 수행할 그룹을 지정하는 역할을 합니다.', NULL, 22),
	(808, 3, 'SELECT ROUND(3.45678, 2),\n       ROUND(3.45678, 0),\n       ROUND(345.678, -2)\nFROM DUAL;', 2, '2회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'ROUND(3.45678, 2)는 소수점 2자리, ROUND(3.45678, 0)는 정수, ROUND(345.678, -2)는 100단위로 반올림합니다.', NULL, 13),
	(809, 3, '[EMPLOYEE]\nEMP_ID NAME SALARY\n--------------------\n1 Kim 3000\n2 Lee 4000\n3 Park 3500\n4 Choi 5000\n5 Jung 4500', 3, '2회차', '다음과 같은 테이블이 있을 때, 전체 행의 20%를 추출하는 SQL문으로 옳은 것은?', '전체 행수의 20%를 구하기 위해서는 서브쿼리로 전체 행수를 먼저 계산해야 합니다.', NULL, 23),
	(810, 3, NULL, 2, '2회차', '다음 중 트리거(Trigger)에 대한 설명으로 틀린 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 사용할 수 없습니다. 이는 트리거의 원자성을 보장하기 위함입니다.', NULL, 28),
	(811, 3, NULL, 2, '2회차', '다음 중 DML 트리거의 시점(Timing)으로 올바르지 않은 것은?', 'DML 트리거의 시점은 BEFORE, AFTER, INSTEAD OF만 존재합니다. DURING은 존재하지 않는 시점입니다. INSTEAD OF는 주로 뷰에 대한 DML 작업을 다른 방식으로 처리하고자 할 때 사용됩니다.', NULL, 28),
	(812, 3, '[SALES]\nYEAR QUARTER AMOUNT\n----------------------\n2023 Q1 1000\n2023 Q2 2000\n2023 Q3 1500\n2023 Q4 3000\n2024 Q1 2500\n\nSELECT YEAR,\n       SUM(AMOUNT) OVER (ORDER BY YEAR, QUARTER\n           ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS MOVING_SUM\nFROM SALES;', 3, '2회차', '다음 테이블에서 SQL문의 실행 결과는?', 'ROWS BETWEEN 1 PRECEDING AND CURRENT ROW는 현재 행과 이전 행의 값을 합산합니다. 모든 행에 대해 이전 행과의 합계가 계산되며, 첫 번째 행은 자기 자신만의 값이 출력됩니다. 총 5개의 행이 출력됩니다.', NULL, 22),
	(813, 3, NULL, 2, '2회차', '다음 중 Oracle의 이전 버전과의 호환성을 위해 새로운 기능을 비활성화하는 힌트는?', 'OLD_PLAN_GENERATOR 힌트는 Oracle의 이전 버전의 실행 계획 생성 방식을 사용하도록 지정합니다. 다른 보기의 힌트들은 각각 특정 최적화 전략을 지정하는 힌트들입니다.', NULL, 19),
	(814, 3, '[EMPLOYEE]\nEMP_ID NAME SALARY DEPT_ID\n--------------------------\n1 Kim 3000 10\n2 Lee 3500 20\n3 Park 2800 10\n4 Choi 4000 20\n5 Jung 3200 30', 3, '2회차', '다음과 같은 테이블이 있을 때, 각 부서별로 급여가 가장 높은 사원을 조회하는 SQL문으로 올바른 것은?', '부서별 최고 급여를 받는 사원을 찾기 위해서는 DEPT_ID로 그룹화하고, 해당 그룹의 최대 급여를 받는 사원을 찾아야 합니다. IN 절에서 복합 칼럼 조건을 사용하여 정확한 결과를 얻을 수 있습니다.', NULL, 19),
	(815, 3, NULL, 2, '2회차', '다음 중 SQL Server의 TOP 절과 Oracle의 ROWNUM의 차이점으로 옳지 않은 것은?', 'ROWNUM은 WHERE 절 외에도 SELECT 절에서도 사용할 수 있습니다. 단, ORDER BY와 함께 사용할 때는 인라인 뷰를 사용해야 합니다.', NULL, 19),
	(816, 3, 'SELECT DEPTNO, JOB, AVG(SAL)\nFROM EMP\nWHERE AVG(SAL) > 3000\nGROUP BY DEPTNO, JOB;', 2, '2회차', '다음 SQL문에서 실행되지 않는 이유로 가장 적절한 것은?', '집계함수는 WHERE 절에서 사용할 수 없습니다. 집계함수를 이용한 조건은 HAVING 절에서 사용해야 합니다.', NULL, 15),
	(817, 3, NULL, 2, '2회차', '다음 중 Oracle의 계층형 쿼리에서 사용되는 연산자가 아닌 것은?', 'Oracle의 계층형 쿼리에서는 CONNECT_BY_ROOT(루트 노드 값 표시), SYS_CONNECT_BY_PATH(경로 표시), CONNECT_BY_DEPTH(깊이 표시)를 사용할 수 있습니다. CONNECT_BY_LENGTH는 존재하지 않는 연산자입니다.', NULL, 24),
	(818, 3, '[PRODUCT]\nNAME      PRICE\n---------------\nApple     1000\nOrange    1500\nBanana    2000\n\nSELECT REGEXP_REPLACE(NAME, \'[aeiou]\', \'*\')\nFROM PRODUCT;', 3, '2회차', '다음 테이블에서 SQL문의 실행 결과는?', 'REGEXP_REPLACE 함수는 정규표현식 패턴에 매칭되는 모든 문자를 지정된 문자로 치환합니다. [aeiou]는 모든 소문자 모음을 의미하며, 이를 \'*\'로 치환합니다.', NULL, 26),
	(819, 3, NULL, 2, '2회차', '다음 중 MERGE 문에 대한 설명으로 틀린 것은?', 'MERGE 문에서 WHEN MATCHED와 WHEN NOT MATCHED 절은 선택적으로 사용할 수 있습니다. 둘 중 하나만 사용하거나 둘 다 사용할 수 있으며, 필수 절이 아닙니다.', NULL, 27),
	(820, 3, NULL, 2, '2회차', 'Oracle에서 테이블의 특정 칼럼을 암호화하기 위한 방법으로 적절하지 않은 것은?', 'DECODE 함수는 데이터를 암호화하는 함수가 아니라 조건에 따라 값을 변환하는 함수입니다. 실제 데이터 암호화를 위해서는 TDE, ENCRYPT 키워드, VPD 등의 보안 기능을 사용해야 합니다.', NULL, 30),
	(821, 3, NULL, 2, '3회차', '다음 중 엔터티(Entity)의 특징으로 가장 부적절한 것은?', '엔터티는 반드시 두 개 이상의 속성을 가져야 합니다. 하나의 속성만으로는 엔터티로 정의할 수 없습니다. 엔터티의 특징은 업무에서 필요한 정보여야 하고, 식별 가능한 이름이 있어야 하며, 두 개 이상의 속성을 가져야 하고, 한 개 이상의 인스턴스가 존재해야 합니다.', NULL, 2),
	(822, 3, '직원은 부서에 속한다.', 2, '3회차', '아래의 관계에 대한 설명으로 가장 적절한 것은?', '직원과 부서의 관계에서 "직원은 부서에 속한다"는 관계는 IE 표기법에서 실선으로 표현됩니다. 이는 비식별자 관계이며, 관계 차수는 N:1 관계가 됩니다(여러 직원이 하나의 부서에 속함). Barker 표기법은 이와 다른 표기 방식을 사용합니다.', NULL, 4),
	(823, 3, NULL, 2, '3회차', '다음 중 속성(Attribute)의 유형으로 가장 거리가 먼 것은?', '속성의 유형은 기본속성(업무로부터 추출한 모든 속성), 설계속성(업무를 규칙화하기 위해 새로 만든 속성), 파생속성(다른 속성에서 계산되어 생성되는 속성)으로 구분됩니다. 임시속성이라는 개념은 없습니다.', NULL, 3),
	(824, 3, NULL, 2, '3회차', '엔터티 도출 시 가장 부적절한 것은?', '엔터티는 반드시 두 개 이상의 속성을 가져야 하므로, 한 개의 속성만으로는 엔터티가 될 수 없습니다. 업무에서 관리되는 정보의 집합이어야 하며, 명사형으로 정의되고, 복수의 인스턴스가 존재해야 합니다.', NULL, 2),
	(825, 3, '사원번호 + 성명" → "사원번호 + 성명 + 부서코드 + 부서명', 3, '3회차', '아래의 예시가 나타내는 정규화 단계는?', '제시된 예시는 3차 정규화를 나타냅니다. 부서코드가 결정자이고 부서명이 종속자인 이행적 함수 종속을 제거하는 과정을 보여주고 있습니다.', NULL, 6),
	(826, 3, NULL, 2, '3회차', '다음 중 속성의 특징으로 올바르지 않은 것은?', '모든 속성이 반드시 엔터티를 식별할 수 있어야 하는 것은 아닙니다. 이는 식별자의 특성이지 일반 속성의 특성이 아닙니다. 속성은 하나의 값만 가져야 하고, 업무적으로 관리되어야 하며, 주식별자의 구성요소가 될 수 있습니다.', NULL, 3),
	(827, 3, '주문(주문번호, 주문일자) - 주문상세(상품번호, 수량)', 2, '3회차', '다음 관계에서 적절한 식별자 관계 표현은?', '주문상세의 기본키가 주문의 기본키를 포함하는 식별자 관계이므로 실선으로 표현됩니다. 주문상세는 주문번호와 상품번호를 복합키로 가지게 됩니다.', NULL, 4),
	(828, 3, NULL, 2, '3회차', '엔터티의 특징이 아닌 것은?', '엔터티가 반드시 다른 엔터티와 관계를 가져야 하는 것은 아닙니다. 독립적으로 존재하는 엔터티도 있을 수 있습니다. 나머지 특징들은 모두 엔터티의 올바른 특징입니다.', NULL, 2),
	(829, 3, NULL, 3, '3회차', '다음 중 슈퍼타입/서브타입 모델링에 대한 설명으로 부적절한 것은?', '슈퍼타입과 서브타입은 1:1 관계가 아닌 1:N 관계를 가질 수 있습니다. 서브타입은 슈퍼타입의 속성을 상속받으며, 배타적/포괄적 관계에 따라 서브타입 선택이 달라질 수 있습니다.', NULL, 2),
	(830, 3, '고객(고객번호, 고객명, 주소, 가입일자) → 고객(고객번호, 고객명, 우편번호, 가입일자) + 우편번호(우편번호, 주소)', 3, '3회차', '아래의 정규화 과정에 대한 설명으로 가장 적절한 것은?', '제시된 예시는 이행적 함수 종속성을 제거하는 과정을 보여줍니다. 우편번호가 주소를 결정하는 이행적 함수 종속을 제거하여 두 개의 테이블로 분리하는 것은 3차 정규화의 예입니다.', NULL, 6),
	(831, 3, NULL, 2, '3회차', '다음 중 NULL에 대한 설명으로 가장 부적절한 것은?', 'NULL과의 비교연산 결과는 FALSE가 아닌 UNKNOWN입니다. NULL은 알 수 없는 값을 의미하므로 비교 자체가 불가능합니다. 따라서 NULL과의 모든 비교 연산은 UNKNOWN을 반환합니다.', NULL, 9),
	(832, 3, NULL, 2, '3회차', '다음 중 SQL문의 실행 순서로 올바른 것은?', 'SQL의 논리적 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY입니다. 이 순서는 SQL 최적화 및 실행 계획 수립에 중요한 의미를 갖습니다.', NULL, 12),
	(833, 3, 'SELECT SUBSTR(\'SQL Programming\', 5, 3) FROM DUAL;', 2, '3회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SUBSTR(\'SQL Programming\', 5, 3)은 5번째 위치에서부터 3개의 문자를 추출합니다. \'SQL Programming\'에서 5번째 위치는 \'P\'이며, 여기서 3글자를 추출하면 \'Pro\'가 됩니다.', NULL, 13),
	(834, 3, 'SELECT dept_id, COUNT(*) FROM employee GROUP BY dept_id', 3, '3회차', '다음 중 아래의 GROUP BY절에 사용할 수 있는 HAVING절 조건으로 적절하지 않은 것은?', 'HAVING절은 GROUP BY로 그룹화된 결과에 대한 조건을 지정할 때 사용합니다. dept_id는 그룹화 칼럼이므로 WHERE절에서 사용해야 합니다. HAVING절에는 집계함수를 포함한 조건이 와야 합니다.', NULL, 15),
	(835, 3, NULL, 2, '3회차', '아래의 집계함수 중 NULL을 제외하고 연산하는 함수가 아닌 것은?', 'COUNT(*)는 NULL을 포함한 모든 행을 카운트합니다. 반면 다른 집계함수들(COUNT(column), AVG, MAX 등)은 NULL을 제외하고 연산을 수행합니다.', NULL, 21),
	(836, 3, NULL, 2, '3회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'DCL(Data Control Language)은 데이터베이스의 접근 권한과 관련된 명령어로, GRANT(권한 부여)와 REVOKE(권한 회수)가 있습니다. COMMIT/ROLLBACK은 TCL, CREATE/ALTER는 DDL, INSERT/UPDATE는 DML입니다.', NULL, 30),
	(837, 3, 'SELECT name FROM employee ORDER BY name ASC;', 2, '3회차', '아래의 테이블에서 ORDER BY절의 결과로 맨 마지막에 출력되는 것은?', 'Oracle에서 ORDER BY절을 사용할 때 NULL은 오름차순(ASC)에서 마지막에 위치합니다. 내림차순(DESC)에서는 첫 번째에 위치합니다.', NULL, 16),
	(838, 3, NULL, 2, '3회차', '다음 중 데이터 무결성을 위한 제약조건이 아닌 것은?', 'DEFAULT는 제약조건이 아니라 기본값을 지정하는 속성입니다. 데이터 무결성을 위한 제약조건에는 PRIMARY KEY, FOREIGN KEY, UNIQUE, NOT NULL, CHECK가 있습니다.', NULL, 29),
	(839, 3, NULL, 3, '3회차', '다음 중 UNION 연산자에 대한 설명으로 틀린 것은?', 'UNION 연산자 사용 시 두 SELECT문의 컬럼 개수와 데이터 타입이 일치해야 합니다. 일치하지 않으면 오류가 발생합니다.', NULL, 20),
	(840, 3, 'SELECT ROUND(123.456, 1) FROM DUAL;', 2, '3회차', '다음 SQL문의 실행 결과는?', 'ROUND(123.456, 1)은 소수점 첫째자리까지 반올림하므로 123.5가 됩니다.', NULL, 13),
	(841, 3, NULL, 3, '3회차', '다음 중 Self Join에 대한 설명으로 가장 적절한 것은?', 'Self Join은 하나의 테이블을 두 번 이상 참조하여 조인하는 것을 말합니다. 주로 조직도나 게시판의 답변 구조 등을 표현할 때 사용됩니다.', NULL, 24),
	(842, 3, NULL, 2, '3회차', '다음 중 트랜잭션의 특성(ACID)이 아닌 것은?', '트랜잭션의 특성(ACID)은 Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성)입니다. Integrity(무결성)는 ACID 특성에 포함되지 않습니다.', NULL, 28),
	(843, 3, NULL, 2, '3회차', 'CASE문을 사용할 때 주의사항으로 올바르지 않은 것은?', 'CASE문에서 END 뒤의 별칭 지정은 선택사항이며, 필수가 아닙니다. 별칭은 필요한 경우에만 지정하면 됩니다.', NULL, 13),
	(844, 3, 'SELECT DISTINCT column1 FROM table1 WHERE column2 > 10 ORDER BY column1;', 2, '3회차', '아래의 SQL문에서 실행 순서가 가장 마지막인 것은?', 'SQL의 실행 순서는 FROM → WHERE → SELECT → DISTINCT → ORDER BY 순입니다. ORDER BY는 항상 마지막에 실행됩니다.', NULL, 16),
	(845, 3, NULL, 2, '3회차', 'INSERT문에 대한 설명으로 올바르지 않은 것은?', '칼럼 리스트를 생략하면 테이블에 정의된 칼럼 순서대로 모든 값을 입력해야 합니다. 자동으로 NULL이 입력되는 것이 아닙니다.', NULL, 27),
	(846, 3, NULL, 3, '3회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', '모든 윈도우 함수에 ORDER BY절이 필수는 아닙니다. SUM, COUNT 등의 집계 함수를 윈도우 함수로 사용할 때는 ORDER BY절 없이도 사용 가능합니다.', NULL, 22),
	(847, 3, NULL, 2, '3회차', '다음 중 SQL의 JOIN 유형이 아닌 것은?', 'VERTICAL JOIN은 존재하지 않는 조인 유형입니다. SQL에서 지원하는 JOIN의 유형에는 INNER JOIN, OUTER JOIN(LEFT/RIGHT/FULL), CROSS JOIN, NATURAL JOIN 등이 있습니다.', NULL, 18),
	(848, 3, NULL, 2, '3회차', 'DDL(Data Definition Language)에 해당하지 않는 것은?', 'DELETE는 DML(Data Manipulation Language)에 속합니다. DDL에는 CREATE, ALTER, DROP, TRUNCATE, RENAME 등이 있습니다.', NULL, 29),
	(849, 3, 'SELECT NVL(NULL, \'Empty\') FROM DUAL;', 2, '3회차', '아래 SQL문의 실행 결과로 맞는 것은?', 'NVL 함수는 첫 번째 인자가 NULL이면 두 번째 인자를 반환합니다. 따라서 NVL(NULL, \'Empty\')는 \'Empty\'를 반환합니다.', NULL, 13),
	(850, 3, NULL, 3, '3회차', '다음 중 인덱스를 생성하기에 가장 적절한 경우는?', '인덱스는 WHERE절에서 자주 사용되는 칼럼에 생성하는 것이 가장 효과적입니다. 테이블의 행 수가 적거나, INSERT가 빈번하거나, NULL값이 많은 칼럼은 인덱스 생성의 적절한 대상이 아닙니다.', NULL, 29),
	(851, 3, NULL, 3, '3회차', '서브쿼리의 특징으로 올바르지 않은 것은?', '서브쿼리의 SELECT절에는 여러 개의 칼럼을 지정할 수 있습니다. 단, 비교 연산자와 함께 사용될 때는 단일 칼럼이어야 합니다.', NULL, 19),
	(852, 3, NULL, 3, '3회차', 'MERGE 문에 대한 설명으로 틀린 것은?', 'MERGE문에서 DELETE절을 사용할 수 있습니다. MATCHED 조건에서 UPDATE 또는 DELETE를 선택적으로 수행할 수 있습니다.', NULL, 27),
	(853, 3, 'SELECT DECODE(column1, 1, \'ONE\', 2, \'TWO\', \'OTHER\') FROM table1 WHERE column1 = 3;', 2, '3회차', '다음의 SQL 실행 결과는?', 'DECODE 함수에서 조건값과 일치하는 것이 없을 경우 마지막 인자가 반환됩니다. column1이 3이므로 \'OTHER\'가 반환됩니다.', NULL, 13),
	(854, 3, NULL, 3, '3회차', '아래와 같은 계층형 쿼리에서 사용할 수 없는 함수는?', 'RANK 함수는 계층형 쿼리에서 사용할 수 없습니다. 계층형 쿼리에서는 LEVEL, CONNECT_BY_ROOT, SYS_CONNECT_BY_PATH 등의 특수 함수를 사용할 수 있습니다.', NULL, 24),
	(855, 3, NULL, 3, '3회차', 'WITH절(별칭지정)의 특징으로 올바르지 않은 것은?', 'WITH절은 다른 WITH절 내에서도 사용할 수 있습니다. 단, 순환 참조가 발생하지 않도록 주의해야 합니다.', NULL, 19),
	(856, 3, 'TRUNCATE TABLE employee; ROLLBACK;', 2, '3회차', '아래 SQL문에서 실행되지 않는 것은?', 'TRUNCATE는 DDL이므로 ROLLBACK이 불가능합니다. 실행 즉시 모든 데이터가 삭제되고 자동 COMMIT됩니다.', NULL, 29),
	(857, 3, NULL, 2, '3회차', '다음 중 VIEW에 대한 설명으로 틀린 것은?', 'VIEW는 원본 테이블의 구조에 종속적입니다. 원본 테이블의 구조가 바뀌면 VIEW도 영향을 받습니다.', NULL, 29),
	(858, 3, NULL, 2, '3회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 맞는 것은?', 'FOREIGN KEY는 참조 무결성을 보장하기 위한 제약조건입니다. NULL을 허용하며, 중복된 값도 허용됩니다.', NULL, 29),
	(859, 3, NULL, 2, '3회차', '다음 중 DELETE문과 TRUNCATE문의 차이점으로 올바르지 않은 것은?', 'DELETE문은 WHERE절을 사용하여 조건을 지정할 수 있지만, TRUNCATE문은 조건절을 사용할 수 없습니다.', NULL, 27),
	(860, 3, NULL, 3, '3회차', '다음 중 데이터베이스 트랜잭션 격리 수준(Isolation Level)이 아닌 것은?', '데이터베이스의 트랜잭션 격리 수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE입니다. READ ONLY는 격리 수준이 아닙니다.', NULL, 28),
	(861, 3, NULL, 3, '3회차', '다음 중 ROLLUP 함수에 대한 설명으로 틀린 것은?', 'ROLLUP 함수는 인수의 순서에 따라 다른 결과를 생성합니다. 인수 순서가 계층 구조를 결정하기 때문에 순서가 바뀌면 결과도 달라집니다.', NULL, 21),
	(862, 3, 'SELECT employee_id, salary, RANK() OVER (ORDER BY salary) rank, DENSE_RANK() OVER (ORDER BY salary DESC) dense_rank, ROW_NUMBER() OVER (ORDER BY salary) row_num WHERE row_num <= 3 FROM employees;', 3, '3회차', '아래의 SQL문에서 발생하는 오류는?', '윈도우 함수는 WHERE절에서 사용할 수 없습니다. 이러한 조건을 적용하려면 서브쿼리를 사용해야 합니다.', NULL, 22),
	(863, 3, NULL, 2, '3회차', '다음 중 데이터베이스 파티셔닝(Partitioning)의 장점이 아닌 것은?', '파티셔닝은 테이블의 전체 크기를 감소시키지 않습니다. 오히려 파티션 관리를 위한 추가 공간이 필요할 수 있습니다.', NULL, 29),
	(864, 3, '-- SALES 테이블\n-- SALES_DATE: 판매일자\n-- AMOUNT: 매출액', 3, '3회차', '아래의 테이블에서 월별 매출액과 작년 동월 매출액을 함께 조회하는 SQL문으로 가장 적절한 것은?', 'LAG 함수를 사용하여 12개월 이전의 데이터를 가져오는 방식이 가장 효율적입니다. GROUP BY로 월별 집계 후 LAG 함수로 작년 동월 데이터를 조회합니다.', NULL, 22),
	(865, 3, NULL, 3, '3회차', '다음 중 EXISTS와 IN 연산자의 차이점으로 틀린 것은?', 'EXISTS가 항상 IN보다 성능이 좋은 것은 아닙니다. 데이터의 특성과 조건에 따라 성능이 달라질 수 있습니다.', NULL, 19),
	(866, 3, NULL, 3, '3회차', 'WITH절(WITH RECURSIVE)를 사용할 수 없는 경우는?', 'WITH RECURSIVE는 계층 구조 조회, 연속 데이터 생성, 반복 집계에 사용됩니다. 단순 테이블 조인에는 WITH RECURSIVE를 사용할 필요가 없습니다.', NULL, 19),
	(867, 3, '-- 1번\nSELECT deptno, SUM(salary) FROM emp GROUP BY deptno;\n\n-- 2번\nSELECT deptno, SUM(salary) FROM emp GROUP BY ROLLUP(deptno);\n\n-- 3번\nSELECT deptno, SUM(salary) FROM emp GROUP BY CUBE(deptno);\n\n-- 4번\nSELECT deptno, SUM(salary) FROM emp GROUP BY GROUPING SETS(deptno);', 3, '3회차', '아래의 SQL문에서 실행 결과가 다른 하나는?', 'ROLLUP은 소계와 총계를 함께 생성하므로, 다른 쿼리들과 다른 결과를 반환합니다. 나머지 쿼리들은 부서별 합계만 계산합니다.', NULL, 21),
	(868, 3, NULL, 2, '3회차', '다음 중 테이블 스페이스(Tablespace)에 대한 설명으로 틀린 것은?', '하나의 테이블을 여러 테이블 스페이스에 분산하여 저장할 수 있습니다(예: 파티션별로 다른 테이블 스페이스 사용).', NULL, 29),
	(869, 3, NULL, 2, '3회차', '다음 중 실행 계획(Execution Plan)에 대한 설명으로 옳지 않은 것은?', '실행 계획이 항상 최적의 성능을 보장하지는 않습니다. 데이터의 특성이나 통계 정보의 정확성에 따라 실제 성능은 달라질 수 있습니다.', NULL, 29),
	(870, 3, NULL, 2, '3회차', '아래의 WHERE절에서 인덱스를 사용할 수 있는 조건은?', 'dept_id = 10과 같이 컬럼에 대한 직접적인 비교만 인덱스를 사용할 수 있습니다. 함수를 사용하거나 연산을 수행하는 경우에는 인덱스를 사용할 수 없습니다.', NULL, 29),
	(871, 3, NULL, 2, '4회차', '다음 중 엔터티의 특징으로 올바르지 않은 것은?', '엔터티는 물리적 형태뿐만 아니라 개념적으로 존재하는 것도 포함됩니다. 예를 들어 \'거래\', \'계약\' 등은 물리적 형태는 없지만 업무적으로 관리해야 할 엔터티입니다.', NULL, 2),
	(872, 3, NULL, 2, '4회차', '다음 중 식별자가 가져야 할 특성이 아닌 것은?', '식별자의 주요 특성은 유일성(Unique), 최소성(Minimal), 불변성(Stable), 존재성(Existence)입니다. 대체성은 식별자의 필수 특성이 아닙니다.', NULL, 5),
	(873, 3, NULL, 2, '4회차', '두 개의 엔터티간 관계에서 참여하는 수를 표현하는 것을 무엇이라 하는가?', '관계차수는 두 개의 엔터티간 관계에서 참여자의 수를 표현하는 것을 의미합니다. 예를 들어 1:1, 1:N, N:M 등으로 표현합니다.', NULL, 4),
	(874, 3, NULL, 3, '4회차', '다음 중 약한 엔터티 타입에 대한 설명으로 올바른 것은?', '약한 엔터티 타입은 상위 엔터티 타입의 존재 여부에 따라 종속적인 엔터티 타입을 의미합니다. 독립적으로 존재할 수 없으며, 상위 엔터티와의 관계가 필수적입니다.', NULL, 2),
	(875, 3, NULL, 2, '4회차', '다음 중 속성의 특성이 아닌 것은?', '제시된 보기 중 "하나의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다"는 엔터티의 특성이며, 속성의 특성이 아닙니다. 나머지는 모두 속성의 특성입니다.', NULL, 3),
	(876, 3, NULL, 2, '4회차', '다음 중 정규화에 대한 설명으로 틀린 것은?', '정규화는 조회 시 조인이 필요할 수 있어 항상 조회 성능이 향상되는 것은 아닙니다. 정규화의 주된 목적은 데이터의 중복을 제거하고 일관성을 보장하는 것입니다.', NULL, 6),
	(877, 3, NULL, 3, '4회차', '다음 중 반정규화를 고려해야 하는 경우가 아닌 것은?', '데이터의 일관성이 중요한 경우는 오히려 정규화를 유지해야 합니다. 반정규화는 성능 향상이 필요한 경우에 고려되어야 합니다.', NULL, 6),
	(878, 3, NULL, 3, '4회차', '다음 중 슈퍼타입과 서브타입 관계에서 올바르지 않은 것은?', '슈퍼타입과 서브타입은 1:N 관계가 가능합니다. 즉, 하나의 슈퍼타입이 여러 서브타입을 가질 수 있으며, 반드시 1:1 관계일 필요는 없습니다.', NULL, 2),
	(879, 3, NULL, 2, '4회차', '다음 중 엔터티를 도출하는 방법이 아닌 것은?', '엔터티는 먼저 도출한 후 관계를 정의해야 합니다. 관계를 먼저 정의하는 것은 올바른 엔터티 도출 방법이 아닙니다.', NULL, 2),
	(880, 3, NULL, 3, '4회차', '다음 중 식별자 관계를 설정하는 기준으로 가장 적절하지 않은 것은?', '식별자 관계 설정은 업무적 이용 빈도가 아닌, 엔터티 간의 존재 종속성과 식별자 상속 여부를 기준으로 결정해야 합니다.', NULL, 5),
	(881, 3, 'EMPLOYEE (EMP_ID, EMP_NAME, DEPT_ID, SALARY)', 3, '4회차', '다음과 같은 테이블이 있을 때, 부서별 평균 급여가 전체 평균 급여보다 높은 부서를 조회하는 SQL문으로 올바른 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 GROUP BY와 서브쿼리를 함께 사용해야 합니다. HAVING 절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 것이 올바른 방법입니다.', NULL, 19),
	(882, 3, NULL, 3, '4회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', 'RANK 함수는 중복 순위를 포함하여 순위를 부여합니다. 중복 순위를 제외하고 순차적으로 순위를 부여하는 것은 DENSE_RANK 함수입니다.', NULL, 22),
	(883, 3, 'SELECT SUBSTR(\'\'SQLD자격검정\'\', 5, 2) FROM DUAL;', 2, '4회차', '다음 테이블에서 SUBSTR 함수를 사용한 SQL의 실행 결과를 고르시오.', 'SUBSTR(\'SQLD자격검정\', 5, 2)는 5번째 위치에서 2글자를 추출합니다. 따라서 \'자격\'이 출력됩니다.', NULL, 13),
	(884, 3, NULL, 2, '4회차', '다음 중 Oracle의 JOIN 구문에 대한 설명으로 틀린 것은?', 'CROSS JOIN은 조인 조건이 필요없는 조인입니다. WHERE 절에서 조인 조건을 지정하는 것은 CROSS JOIN의 특성이 아닙니다.', NULL, 17),
	(885, 3, '-- ORDERS 테이블\n-- ORDER_ID: 주문번호\n-- ORDER_DATE: 주문일자 (DATE)\n-- AMOUNT: 주문금액', 3, '4회차', '다음과 같은 테이블이 있을 때, 2023년 월별 주문금액의 합계를 조회하는 SQL문으로 올바른 것은?', 'GROUP BY절에서 사용한 표현식은 SELECT절에서도 동일하게 사용해야 하며, 결과의 정렬을 위해 ORDER BY절이 필요합니다. EXTRACT 함수를 사용하여 연도와 월을 추출하는 방식이 가장 적절합니다.', NULL, 13),
	(886, 3, NULL, 2, '4회차', '다음 중 NULL 값에 대한 설명으로 틀린 것은?', 'NULL과의 비교연산은 TRUE나 FALSE가 아닌 UNKNOWN을 반환합니다. 이는 3-valued logic의 특성입니다.', NULL, 9),
	(887, 3, NULL, 2, '4회차', '다음 중 DELETE문에 대한 설명으로 가장 적절한 것은?', 'DELETE문은 DML문으로 트랜잭션 제어가 가능합니다. 따라서 COMMIT 전에는 ROLLBACK이 가능합니다.', NULL, 27),
	(888, 3, NULL, 3, '4회차', '다음 중 계층형 질의문의 실행 순서로 올바른 것은?', '계층형 질의문의 실행 순서는 START WITH → CONNECT BY → WHERE → ORDER SIBLINGS BY 순입니다.', NULL, 24),
	(889, 3, 'WITH TEMP AS (SELECT DEPTNO, AVG(SAL) AS AVG_SAL FROM EMP GROUP BY DEPTNO) SELECT * FROM TEMP WHERE AVG_SAL > 3000;', 2, '4회차', '다음 테이블에서 WITH절을 사용한 SQL문의 실행 결과로 옳은 것은?', 'WITH절(임시 테이블)에서 부서별 평균 급여를 구한 후, 그 중 평균 급여가 3000 이상인 부서를 조회합니다.', NULL, 19),
	(890, 3, NULL, 2, '4회차', '다음 중 GROUP BY절에 대한 설명으로 틀린 것은?', 'Oracle 11g R2 버전부터는 GROUP BY절에도 Alias를 사용할 수 있습니다. 따라서 이 설명은 틀린 것입니다.', NULL, 15),
	(891, 3, NULL, 2, '4회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE 문은 DML문으로 트랜잭션을 발생시킵니다. 따라서 COMMIT이나 ROLLBACK의 대상이 됩니다.', NULL, 27),
	(892, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- SAL: 급여', 3, '4회차', '다음과 같은 테이블에서 사원별로 급여가 전체 평균급여와 비교하여 평균 이상인지 이하인지를 조회하는 SQL문을 고르시오.', '전체 평균 급여는 서브쿼리를 통해 구해야 하며, CASE문을 사용하여 비교 결과를 표시할 수 있습니다.', NULL, 13),
	(893, 3, NULL, 3, '4회차', 'PIVOT 절에 대한 설명으로 틀린 것은?', 'PIVOT 절은 GROUP BY절과 함께 사용할 수 없습니다. PIVOT 절 자체가 그룹화와 집계 기능을 수행합니다.', NULL, 25),
	(894, 3, NULL, 2, '4회차', '다음 중 데이터베이스 트랜잭션의 특성(ACID)이 아닌 것은?', '데이터베이스 트랜잭션의 특성은 ACID(Atomicity, Consistency, Isolation, Durability)입니다. Duplication(중복성)은 트랜잭션의 특성이 아닙니다.', NULL, 28),
	(895, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- DEPTNO: 부서번호\n-- SAL: 급여', 3, '4회차', '다음 테이블에서 부서별 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최고 급여를 구한 후, 해당 결과와 원본 테이블을 조인하여 최고 급여를 받는 사원의 정보를 조회할 수 있습니다. 서브쿼리와 조인을 사용한 방식이 가장 효율적입니다.', NULL, 17),
	(896, 3, NULL, 3, '4회차', 'ROLLUP과 CUBE의 차이점에 대한 설명으로 틀린 것은?', 'ROLLUP은 인수의 순서에 따라 다른 결과가 나옵니다. 계층적 구조로 순서대로 소계를 생성하기 때문입니다.', NULL, 21),
	(897, 3, NULL, 2, '4회차', '다음 중 인덱스에 대한 설명으로 옳지 않은 것은?', '테이블에는 여러 개의 인덱스를 생성할 수 있습니다. 단, 과도한 인덱스 생성은 성능에 영향을 줄 수 있습니다.', NULL, 29),
	(898, 3, 'SELECT LEVEL, EMPNO, ENAME, MGR FROM EMP START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;', 3, '4회차', '다음과 같은 계층형 쿼리의 실행 결과로 알맞은 것은?', 'START WITH MGR IS NULL은 최상위 관리자부터 시작하여, CONNECT BY PRIOR EMPNO = MGR은 해당 사원의 하위 사원을 찾아가는 TOP-DOWN 방식의 계층 구조 쿼리입니다.', NULL, 24),
	(899, 3, NULL, 3, '4회차', '다음 중 윈도우 함수의 프레임(FRAME) 절에서 사용할 수 없는 것은?', '윈도우 함수의 프레임절에서는 ROWS, RANGE, BETWEEN을 사용할 수 있으나, HAVING은 사용할 수 없습니다.', NULL, 22),
	(900, 3, NULL, 2, '4회차', '다음 중 트리거(TRIGGER)에 대한 설명으로 틀린 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 실행할 수 없습니다. 이는 트리거의 자동 실행 특성과 관련된 제약사항입니다.', NULL, 29),
	(901, 3, '-- SALES 테이블\n-- ORDER_DATE: 주문일자 (DATE)\n-- AMOUNT: 주문금액', 3, '4회차', '다음 테이블에서 연도별, 월별 주문금액의 누적합계를 구하는 SQL문으로 올바른 것은?', '연도별로 파티션을 나누고, 월별로 정렬하여 누적합계를 계산해야 합니다. PARTITION BY와 ORDER BY를 함께 사용하는 윈도우 함수가 적절합니다.', NULL, 22),
	(902, 3, NULL, 3, '4회차', '다음 중 EXISTS와 IN의 차이점에 대한 설명으로 틀린 것은?', 'IN 연산자에서 NULL 값을 포함할 경우 결과는 UNKNOWN이 되며, 항상 FALSE를 반환하는 것은 아닙니다.', NULL, 19),
	(903, 3, NULL, 2, '4회차', '다음 중 데이터베이스 뷰(View)에 대한 설명으로 올바른 것은?', '뷰는 특정 사용자에게 테이블의 일부 데이터만 보여주거나 접근을 제한하는 용도로 사용할 수 있습니다.', NULL, 29),
	(904, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- DEPTNO: 부서번호\n-- SAL: 급여', 3, '4회차', '다음과 같은 테이블에서 자신의 급여가 자신이 속한 부서의 평균 급여보다 많은 사원을 조회하는 SQL문으로 옳은 것은?', '상관 서브쿼리를 사용하여 각 사원이 속한 부서의 평균 급여를 구하고, 이와 비교하여 조회할 수 있습니다.', NULL, 19),
	(905, 3, NULL, 2, '4회차', '다음 중 Oracle의 DECODE 함수와 동일한 기능을 하는 ANSI 표준 구문은?', 'Oracle의 DECODE 함수는 ANSI 표준의 CASE 문과 동일한 기능을 수행합니다.', NULL, 13),
	(906, 3, NULL, 3, '4회차', '다음 중 데이터베이스 트랜잭션 격리수준(Isolation Level)을 낮은 순서대로 올바르게 나열한 것은?', '트랜잭션 격리수준은 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 격리성이 강화됩니다.', NULL, 28),
	(907, 3, NULL, 2, '4회차', '다음 명령어 중 DML(Data Manipulation Language)이 아닌 것은?', 'TRUNCATE는 DDL(Data Definition Language)에 속하며, 테이블의 모든 데이터를 삭제하고 저장 공간을 해제합니다.', NULL, 29),
	(908, 3, NULL, 2, '4회차', 'FOREIGN KEY 제약조건에서 부모 테이블의 데이터가 삭제될 때 자식 테이블의 데이터도 함께 삭제되도록 설정하는 옵션은?', 'CASCADE 옵션은 부모 테이블의 데이터가 삭제될 때 관련된 자식 테이블의 데이터도 함께 삭제되도록 설정합니다.', NULL, 29),
	(909, 3, '-- EMP 테이블\n-- EMPNO: 사원번호\n-- ENAME: 사원이름\n-- DEPTNO: 부서번호\n-- SAL: 급여', 3, '4회차', '다음과 같은 테이블에서 각 부서별로 급여 순위가 1위인 사원을 조회하는 SQL문으로 올바른 것은?', 'ROW_NUMBER() 함수를 사용하여 부서별로 급여 순위를 매기고, 순위가 1인 데이터만 조회하면 됩니다.', NULL, 22),
	(910, 3, NULL, 2, '4회차', '다음 중 데이터베이스 인덱스의 장점이 아닌 것은?', '인덱스는 데이터 수정, 삭제, 입력 시 인덱스도 함께 수정해야 하므로 오히려 작업 속도가 저하될 수 있습니다.', NULL, 29),
	(911, 3, NULL, 2, '4회차', '다음 중 데이터베이스 백업 방식에 대한 설명으로 틀린 것은?', '로그 백업은 다른 백업 방식과 함께 사용할 수 있으며, 일반적으로 전체 백업이나 증분 백업과 함께 사용하여 특정 시점으로의 복구를 가능하게 합니다.', NULL, 29),
	(912, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '4회차', '아래의 테이블에서 2023년 월별 매출액과 전월 대비 증감률을 계산하는 SQL문으로 올바른 것은?', '월별 매출액 합계를 구하고 LAG 함수를 사용하여 전월 대비 증감률을 계산합니다. TO_CHAR 함수를 사용하여 연월을 정확하게 표현하고, ROUND 함수로 소수점을 처리합니다.', NULL, 22),
	(913, 3, NULL, 2, '4회차', '다음 중 데이터베이스 테이블의 파티셔닝(Partitioning)에 대한 설명으로 틀린 것은?', '파티셔닝된 테이블도 인덱스를 사용할 수 있습니다. 로컬 파티션 인덱스와 글로벌 파티션 인덱스 모두 사용 가능합니다.', NULL, 29),
	(914, 3, NULL, 2, '4회차', '다음 중 데이터베이스 Object의 권한이 아닌 것은?', 'GRANT는 시스템 권한이며, 테이블이나 뷰와 같은 데이터베이스 Object에 대한 권한이 아닙니다.', NULL, 30),
	(915, 3, '-- EMPLOYEE 테이블\n-- EMP_ID: 직원ID\n-- EMP_NAME: 직원명\n-- DEPT_ID: 부서ID\n-- HIRE_DATE: 입사일자', 3, '4회차', '아래 테이블에서 부서별로 가장 최근에 입사한 직원 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최근 입사일자를 구한 후, 이를 원본 테이블과 조인하여 해당 직원의 정보를 조회합니다. 서브쿼리와 조인을 사용한 방식이 가장 효율적입니다.', NULL, 17),
	(916, 3, NULL, 2, '4회차', '다음 중 데이터베이스 락(Lock)에 대한 설명으로 틀린 것은?', '테이블 락은 테이블 전체에 대한 락으로, 로우 락보다 더 큰 범위의 락입니다. 로우 락이 더 세분화된 락입니다.', NULL, 28),
	(917, 3, '-- SCORE 테이블\n-- STUDENT_ID: 학생ID\n-- SCORE: 점수', 3, '4회차', '다음과 같은 테이블에서 범위를 지정하여 순위를 부여하는 SQL문으로 올바른 것은?', 'WIDTH_BUCKET 함수는 지정된 범위를 균등하게 나누어 등급을 부여합니다. 0-100점을 4개의 구간으로 나누어 등급을 매기는데 적합합니다.', NULL, 22),
	(918, 3, NULL, 2, '4회차', '다음 중 데이터베이스 인덱스의 종류가 아닌 것은?', '스캔 인덱스는 존재하지 않는 인덱스 유형입니다. 일반적인 인덱스 유형은 B-tree, 비트맵, 해시 인덱스 등이 있습니다.', NULL, 29),
	(919, 3, NULL, 2, '4회차', '다음 중 Oracle의 ROWNUM과 관련된 설명으로 옳은 것은?', 'ROWNUM은 조회되는 행의 순서대로 1부터 순차적으로 번호를 부여합니다. 단, ORDER BY 절 이전에 할당되므로 정렬 후 번호를 부여하려면 서브쿼리를 사용해야 합니다.', NULL, 12),
	(920, 3, NULL, 2, '4회차', '다음 중 데이터베이스 저장 프로시저(Stored Procedure)의 특징이 아닌 것은?', '저장 프로시저는 자동으로 트랜잭션을 롤백하지 않습니다. 트랜잭션의 커밋이나 롤백은 프로시저 내에서 명시적으로 처리해야 합니다.', NULL, 29),
	(921, 3, NULL, 2, '5회차', '다음 중 엔터티(Entity)의 분류 방식으로 가장 부적절한 것은?', '기본 엔터티와 중심 엔터티는 일반적인 엔터티 분류 방식이 아닙니다. 일반적인 엔터티 분류는 유형/개념 엔터티, 기초/중심/행위 엔터티, 실체/가상 엔터티 등이 있습니다.', NULL, 2),
	(922, 3, '두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가진다.', 2, '5회차', '아래의 설명에 해당하는 것은?', '설명은 행위 엔터티의 특징을 나타냅니다. 행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 이력 정보를 저장하며, 주문, 계약, 거래 등이 대표적인 예입니다.', NULL, 2),
	(923, 3, NULL, 2, '5회차', '다음 중 관계(Relationship)의 표기법에 포함되지 않는 것은?', '관계의 표기법에는 관계명, 관계차수, 관계선택사양이 포함됩니다. 관계스키마는 관계형 데이터베이스의 구조를 나타내는 용어로, 관계 표기법에 포함되지 않습니다.', NULL, 4),
	(924, 3, NULL, 2, '5회차', 'PK 컬럼을 FK로 사용하여 관계를 맺을 때, 부모 테이블의 PK 컬럼이 자식 테이블의 PK 컬럼으로 전이되는 관계는?', '식별관계는 부모 테이블의 기본키가 자식 테이블의 기본키의 일부로 전이되는 관계를 말합니다.', NULL, 4),
	(925, 3, NULL, 2, '5회차', '다음 중 속성의 특성으로 옳지 않은 것은?', '속성은 물리적으로 존재하지 않는 개념적인 성질도 가질 수 있습니다. 예를 들어 나이, 할인율, 등급 등은 물리적으로 존재하지 않는 속성입니다.', NULL, 3),
	(926, 3, NULL, 3, '5회차', '다음 중 슈퍼타입/서브타입 데이터 모델의 변환 타입이 아닌 것은?', '슈퍼타입/서브타입 변환 타입은 OneToOne Type, Single Type, Mix Type이 있습니다. Plus Type은 존재하지 않습니다.', NULL, 2),
	(927, 3, NULL, 2, '5회차', '엔터티-관계(E-R) 모델에서 차수(Cardinality)의 표현으로 올바르지 않은 것은?', 'M:N 관계와 N:N 관계는 같은 의미이므로, 둘 다 표기할 필요가 없습니다. 일반적으로 M:N으로 표기합니다.', NULL, 4),
	(928, 3, NULL, 3, '5회차', '정규화에 대한 설명으로 틀린 것은?', 'BCNF는 결정자가 후보키가 아닌 함수 종속을 제거합니다. 이는 모든 결정자가 후보키가 되도록 하는 것이 BCNF의 목적입니다.', NULL, 6),
	(929, 3, NULL, 2, '5회차', '다음 중 식별자의 분류 기준이 아닌 것은?', '식별자는 대표성 여부, 스스로 생성 여부, 속성의 수, 대체 여부에 따라 분류됩니다. 업무적 활용도에 따른 분류는 일반적인 식별자 분류 기준이 아닙니다.', NULL, 5),
	(930, 3, NULL, 2, '5회차', '반정규화를 고려해야 하는 경우로 가장 부적절한 것은?', '데이터의 일관성과 정합성이 중요한 경우에는 오히려 정규화를 유지해야 합니다. 반정규화는 조회 성능 향상이 필요한 경우에 고려해야 합니다.', NULL, 6),
	(931, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- SALARY: 급여', 2, '5회차', '다음 테이블에서 부서별로 평균 급여를 구하되, 평균 급여가 3000 이상인 부서만 조회하는 SQL문 중 잘못된 것은?', 'WHERE절에서는 집계함수를 사용할 수 없습니다. 집계함수를 이용한 조건은 HAVING절에서 사용해야 합니다.', NULL, 15),
	(932, 3, NULL, 2, '5회차', '다음 중 CASE문에 대한 설명으로 틀린 것은?', 'CASE문에서 여러 조건이 있을 때는 먼저 만족하는 조건의 결과값이 채택되며, 이후의 조건은 무시됩니다.', NULL, 13),
	(933, 3, NULL, 3, '5회차', '다음 중 서브쿼리의 특징으로 옳은 것은?', '상관 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있으며, 이는 상관 서브쿼리의 주요 특징입니다.', NULL, 19),
	(934, 3, 'SELECT SUBSTR(\'SQL전문가\', 2, 2) FROM DUAL;', 2, '5회차', '아래의 SQL문을 실행했을 때의 결과로 옳은 것은?', 'SUBSTR(\'SQL전문가\', 2, 2)는 두 번째 위치에서 2글자를 추출합니다. 따라서 \'L전\'이 출력됩니다.', NULL, 13),
	(935, 3, NULL, 2, '5회차', '다음 중 DISTINCT 키워드에 대한 설명으로 틀린 것은?', 'DISTINCT는 SELECT절에서만 사용할 수 있으며, ORDER BY절 이후에는 사용할 수 없습니다.', NULL, 12),
	(936, 3, '-- ORDERS 테이블\n-- ORDER_DATE: 주문일자 (DATE)\n-- ORDER_AMOUNT: 주문금액', 3, '5회차', '다음과 같은 테이블이 있을 때, 2024년 1월의 일자별 주문금액 합계를 구하되, 주문이 없는 날의 주문금액은 0으로 표시하는 SQL문으로 올바른 것은?', '계층 쿼리로 1월의 모든 날짜를 생성한 후, LEFT OUTER JOIN을 통해 주문 데이터와 조인하고 NVL 함수로 NULL을 0으로 변환하는 방식이 가장 적절합니다.', NULL, 17),
	(937, 3, NULL, 2, '5회차', '다음 중 NULL 값과 관련된 설명으로 틀린 것은?', 'GROUP BY절에서 NULL 값도 하나의 그룹으로 취급됩니다. NULL 값이 제외되지 않습니다.', NULL, 9),
	(938, 3, NULL, 2, '5회차', '다음 중 조인에 대한 설명으로 옳은 것은?', 'CROSS JOIN은 조인 조건 없이 두 테이블의 모든 행을 조합한 카테시안 곱(Cartesian Product)을 반환합니다.', NULL, 17),
	(939, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- HIRE_DATE: 입사일자', 3, '5회차', '다음과 같은 테이블에서 부서별 최근 입사한 직원을 조회하는 SQL문으로 적절한 것은?', '(DEPT_NO, HIRE_DATE) IN (Subquery) 형태로 복합 조건을 사용하면 부서별 최근 입사자를 정확하게 조회할 수 있습니다.', NULL, 19),
	(940, 3, NULL, 2, '5회차', '다음 중 Oracle의 집계함수 사용시 특징으로 틀린 것은?', 'HAVING절에는 GROUP BY절에 명시되지 않은 컬럼도 집계함수와 함께 사용할 수 있습니다.', NULL, 15),
	(941, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '5회차', '다음과 같은 테이블에서 연도별, 분기별 매출액과 전년 동기 대비 증감률을 계산하는 SQL문으로 올바른 것은?', '연도와 분기로 그룹화한 후, LAG 함수를 사용하여 4분기 전(전년 동기) 데이터와 비교하여 증감률을 계산합니다.', NULL, 22),
	(942, 3, NULL, 2, '5회차', '다음 중 데이터베이스 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Isolation(독립성)은 트랜잭션 수행 시 다른 트랜잭션의 연산 작업에 끼어들 수 없음을 의미합니다. 반드시 대기해야 하는 것은 아닙니다.', NULL, 28),
	(943, 3, NULL, 2, '5회차', 'Oracle의 JOIN 구문에 대한 설명으로 올바른 것은?', 'USING절을 사용할 때는 컬럼에 테이블 별칭을 사용할 수 없습니다. 이는 USING절의 특성입니다.', NULL, 17),
	(944, 3, 'SELECT * FROM TABLE_A\nUNION\nSELECT * FROM TABLE_B;\n\nSELECT * FROM TABLE_A\nUNION ALL\nSELECT * FROM TABLE_B;', 2, '5회차', '아래의 테이블에서 UNION과 UNION ALL의 실행 결과가 같은 경우는?', '두 테이블 간에 중복되는 데이터가 없을 경우, UNION과 UNION ALL의 결과가 동일합니다.', NULL, 20),
	(945, 3, NULL, 2, '5회차', '다음 중 인덱스(Index)를 사용하기 적절한 경우가 아닌 것은?', '데이터가 자주 변경되는 컬럼에 인덱스를 생성하면 인덱스 갱신 오버헤드가 커져 성능이 저하될 수 있습니다.', NULL, 29),
	(946, 3, NULL, 2, '5회차', '다음 중 데이터베이스 락(Lock)에 대한 설명으로 틀린 것은?', '로우 락은 특정 행에만 적용되며, 테이블의 모든 행에 동시에 적용되는 것은 테이블 락입니다.', NULL, 28),
	(947, 3, 'SELECT LEVEL, EMPNO, MGR, CONNECT_BY_ISLEAF FROM EMP START WITH MGR IS NULL CONNECT BY PRIOR EMPNO = MGR;', 3, '5회차', '다음과 같은 계층형 쿼리의 결과로 알맞은 것은?', '주어진 쿼리는 TOP-DOWN 방식으로 순방향 전개되며, CONNECT_BY_ISLEAF는 해당 노드가 리프 노드일 때 1을 반환합니다.', NULL, 24),
	(948, 3, NULL, 2, '5회차', '다음 중 데이터베이스 테이블 파티셔닝(Partitioning)의 장점이 아닌 것은?', '파티셔닝은 데이터의 물리적인 저장 공간을 감소시키지 않습니다. 오히려 파티션 관리를 위한 추가 공간이 필요할 수 있습니다.', NULL, 29),
	(949, 3, NULL, 2, '5회차', '다음 중 PL/SQL의 특징으로 옳지 않은 것은?', 'PL/SQL에서 SELECT문의 결과를 변수에 저장하기 위해서는 INTO절을 명시적으로 사용해야 합니다.', NULL, 29),
	(950, 3, NULL, 2, '5회차', '다음 중 데이터베이스 저장 프로시저(Stored Procedure)의 장점이 아닌 것은?', '저장 프로시저는 트랜잭션을 자동으로 롤백하지 않습니다. 트랜잭션의 롤백은 명시적으로 처리해야 합니다.', NULL, 29),
	(951, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- HIRE_DATE: 입사일자', 3, '5회차', '다음과 같은 테이블에서 부서별로 입사일자가 빠른 순서대로 순번을 매기는 SQL문 중 틀린 것은?', 'COUNT(*) OVER절은 누적 건수를 반환하므로 순번을 매기는 용도로 적절하지 않습니다. ROW_NUMBER(), RANK(), DENSE_RANK()가 순번 매기기에 적합한 함수입니다.', NULL, 22),
	(952, 3, NULL, 2, '5회차', '다음 중 DROP TABLE과 TRUNCATE TABLE의 차이점으로 틀린 것은?', 'DROP TABLE과 TRUNCATE TABLE 모두 DDL 명령어이므로 롤백이 불가능합니다. DROP TABLE은 테이블 구조를 포함하여 완전히 삭제하고, TRUNCATE TABLE은 데이터만 삭제합니다.', NULL, 29),
	(953, 3, 'SELECT EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM DATE \'2020-12-25\') AS RESULT FROM DUAL;', 2, '5회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SYSDATE는 현재 날짜를 반환하므로, 실행 시점에 따라 결과가 달라집니다. 2024년에 실행하면 4가 반환되고, 2025년에 실행하면 5가 반환됩니다.', NULL, 13),
	(954, 3, NULL, 2, '5회차', '다음 중 데이터베이스 트리거(Trigger)에 대한 설명으로 옳지 않은 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 실행할 수 없습니다. 이는 트리거의 자동 실행 특성으로 인한 제약사항입니다.', NULL, 29),
	(955, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '5회차', '다음과 같은 테이블이 있을 때, 2024년 상반기(1~6월) 중 매출이 발생하지 않은 월을 찾는 SQL문으로 가장 적절한 것은?', '1부터 6까지의 월 리스트를 생성한 후, 실제 매출이 발생한 월과 LEFT OUTER JOIN하여 매출이 없는 월(B.MONTH IS NULL)을 찾는 방식이 가장 적절합니다.', NULL, 19),
	(956, 3, NULL, 2, '5회차', '다음 중 Oracle의 DCL(Data Control Language)에 속하는 명령어가 아닌 것은?', 'ALTER는 DDL(Data Definition Language)에 속하는 명령어입니다. DCL에는 GRANT, REVOKE, AUDIT 등이 포함됩니다.', NULL, 30),
	(957, 3, NULL, 2, '5회차', '다음 중 데이터베이스 뷰(View)의 장점이 아닌 것은?', '뷰는 실제 데이터를 저장하지 않는 가상 테이블이므로, 원본 테이블보다 빠른 검색 성능을 제공하지 않습니다.', NULL, 29),
	(958, 3, 'WITH TEMP AS (\n    SELECT \'A\' AS COL1, 1 AS COL2 FROM DUAL UNION ALL\n    SELECT \'A\' AS COL1, 2 AS COL2 FROM DUAL UNION ALL\n    SELECT \'B\' AS COL1, 3 AS COL2 FROM DUAL UNION ALL\n    SELECT \'B\' AS COL1, 4 AS COL2 FROM DUAL\n)\nSELECT COL1, LISTAGG(COL2, \',\') WITHIN GROUP (ORDER BY COL2) AS RESULT\nFROM TEMP\nGROUP BY COL1;', 3, '5회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'LISTAGG 함수는 GROUP BY로 그룹화된 데이터를 지정된 구분자로 연결합니다. ORDER BY 절에 의해 COL2가 오름차순으로 정렬되어 연결됩니다.', NULL, 21),
	(959, 3, NULL, 2, '5회차', '다음 중 Oracle의 MERGE 문에 대한 설명으로 틀린 것은?', 'MERGE 문의 WHEN NOT MATCHED 절에서는 INSERT만 수행할 수 있습니다. DELETE는 WHEN MATCHED 절에서만 사용 가능합니다.', NULL, 27),
	(960, 3, '-- SALARY_HISTORY 테이블\n-- DEPT_NO: 부서번호\n-- PAY_MONTH: 지급월 (YYYYMM)\n-- SALARY: 급여', 3, '5회차', '다음과 같은 테이블에서 각 부서의 월별 평균 급여를 Pivot하여 조회하는 SQL문으로 올바른 것은?', 'PIVOT절을 사용하여 월별 평균 급여를 컬럼으로 변환할 때는, FOR절에 변환할 컬럼(PAY_MONTH)과 해당 값을 명시해야 합니다.', NULL, 25),
	(961, 3, NULL, 3, '5회차', '다음 중 SQL 성능과 관련된 설명으로 틀린 것은?', 'IN 절이 항상 EXISTS 절보다 성능이 우수한 것은 아닙니다. 데이터의 특성과 조건에 따라 성능이 달라질 수 있으며, EXISTS가 더 효율적인 경우도 있습니다.', NULL, 29),
	(962, 3, '-- ORDERS 테이블\n-- ORDER_NO: 주문번호\n-- MEMBER_ID: 회원ID\n-- ORDER_DATE: 주문일자\n-- AMOUNT: 주문금액', 3, '5회차', '다음과 같은 테이블에서 회원별 최근 3개의 주문 정보를 조회하는 SQL문으로 올바른 것은?', 'ROW_NUMBER() 함수를 사용하여 회원별로 주문일자 순으로 순번을 매긴 후, 상위 3건을 조회하는 방식이 가장 적절합니다.', NULL, 22),
	(963, 3, NULL, 2, '5회차', '다음 중 데이터베이스 인덱스의 성능이 저하될 수 있는 경우가 아닌 것은?', '선택도가 높다는 것은 고유한 값의 비율이 높다는 의미로, 이는 인덱스 성능을 향상시키는 요인입니다. 나머지는 모두 인덱스 성능을 저하시키는 요인입니다.', NULL, 29),
	(964, 3, 'SELECT TO_CHAR(SYSDATE, \'YYYY-MM-DD HH24:MI:SS\') AS NOW, TO_CHAR(SYSDATE + INTERVAL \'2\' HOUR, \'YYYY-MM-DD HH24:MI:SS\') AS AFTER_2HOUR FROM DUAL;', 2, '5회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'INTERVAL 키워드를 사용하여 시간을 더하는 것이 가능하며, 결과적으로 현재 시간과 2시간 후의 시간이 각각 출력됩니다.', NULL, 13),
	(965, 3, NULL, 2, '5회차', '다음 중 Oracle의 집합 연산자에 대한 설명으로 틀린 것은?', 'MINUS는 첫 번째 집합에서 두 번째 집합을 뺀 결과에서 중복된 행을 제거합니다. 중복을 허용하지 않습니다.', NULL, 20),
	(966, 3, '-- SALES 테이블\n-- SALE_DATE: 판매일자 (DATE)\n-- AMOUNT: 매출액', 3, '5회차', '다음과 같은 테이블이 있을 때, 월별 누적 매출액을 계산하는 SQL문으로 올바른 것은?', '연도와 월로 그룹화한 후, SUM OVER절을 사용하여 누적 합계를 계산합니다. ORDER BY절에 연도와 월을 모두 포함해야 정확한 누적 합계가 계산됩니다.', NULL, 22),
	(967, 3, NULL, 2, '5회차', '다음 중 데이터베이스 설계시 고려사항이 아닌 것은?', '데이터베이스 설계시 데이터의 중복성은 최소화해야 하는 대상이지, 고려해야 할 특성이 아닙니다.', NULL, 29),
	(968, 3, NULL, 2, '5회차', '다음 중 Oracle의 날짜 함수 사용법으로 틀린 것은?', 'NEXT_DAY 함수는 지정된 날짜 다음에 오는 특정 요일의 날짜를 반환합니다. 모든 날짜를 반환하는 것이 아닙니다.', NULL, 13),
	(969, 3, '-- EMPLOYEE 테이블\n-- EMP_NO: 직원번호\n-- EMP_NAME: 직원명\n-- DEPT_NO: 부서번호\n-- SALARY: 급여', 3, '5회차', '다음과 같은 테이블에서 부서별로 급여 순위가 1위인 직원의 급여보다 많이 받는 직원을 조회하는 SQL문으로 알맞은 것은?', '윈도우 함수를 사용하여 부서별 급여 순위를 구한 후, 1위 급여와 비교하여 더 많이 받는 직원을 조회합니다.', NULL, 22),
	(970, 3, NULL, 3, '5회차', '다음 중 데이터베이스 트랜잭션 격리 수준(Isolation Level)에 대한 설명으로 틀린 것은?', 'SERIALIZABLE은 가장 엄격한 격리 수준으로, 동시성이 크게 저하됩니다. 트랜잭션들이 순차적으로 실행되어 동시 처리가 제한됩니다.', NULL, 28),
	(971, 3, NULL, 2, '6회차', '다음 중 엔터티의 정의로 가장 부적절한 것은?', '엔터티는 정적인 데이터뿐만 아니라 주문, 거래 등과 같은 동적인 데이터도 포함할 수 있습니다. 업무상 관리가 필요한 모든 데이터의 집합이 엔터티가 될 수 있습니다.', NULL, 2),
	(972, 3, NULL, 2, '6회차', '다음 중 식별자의 특징으로 가장 부적절한 것은?', '식별자는 반드시 업무상 대표성을 가질 필요는 없습니다. 예를 들어 인조식별자(Surrogate Key)는 업무적 의미와 관계없이 식별을 위해 인위적으로 만든 식별자입니다. 식별자의 필수 특성은 유일성, 최소성, 불변성, 존재성입니다.', NULL, 5),
	(973, 3, '하나의 부서는 여러 명의 사원을 가질 수 있고, 하나의 사원은 반드시 하나의 부서에 소속되어야 한다.', 1, '6회차', '다음은 엔터티 A와 엔터티 B의 관계에 대한 설명이다. 가장 적절한 관계 차수는?', '하나의 부서는 여러 명의 사원을 가질 수 있고(1:M), 하나의 사원은 반드시 하나의 부서에 소속(1:1)이므로 1:M 관계입니다.', NULL, 4),
	(974, 3, NULL, 1, '6회차', '다음 중 데이터 모델에서 NULL의 의미로 가장 부적절한 것은?', 'NULL은 아직 값이 할당되지 않음, 값이 입력되었으나 삭제됨, 해당 없음의 의미를 가질 수 있지만, 값이 0임은 NULL과 다른 의미입니다. 0은 명확한 값이므로 NULL과는 다른 개념입니다.', NULL, 9),
	(975, 3, NULL, 2, '6회차', '엔터티를 도출하는 방법으로 가장 부적절한 것은?', '엔터티는 물리적 형태로 존재하는 것뿐만 아니라 계약, 거래 등과 같이 개념적으로 존재하는 것도 포함됩니다.', NULL, 2),
	(976, 3, NULL, 2, '6회차', '다음 중 정규화 과정에서 나타날 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상에는 삭제 이상, 삽입 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않는 개념입니다.', NULL, 6),
	(977, 3, NULL, 3, '6회차', '다음 중 반정규화를 고려해야 하는 경우로 가장 부적절한 것은?', '데이터의 일관성이 매우 중요한 경우에는 오히려 정규화를 유지해야 합니다. 반정규화는 데이터의 중복을 허용하므로 일관성이 깨질 위험이 있습니다.', NULL, 6),
	(978, 3, NULL, 3, '6회차', '엔터티의 속성 중 설계 속성(Designed Attribute)에 대한 설명으로 가장 적절한 것은?', '설계 속성은 업무상 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하기 위해 만든 속성을 의미합니다. 예를 들어 상태코드, 순번 등이 이에 해당합니다.', NULL, 3),
	(979, 3, NULL, 2, '6회차', '다음 중 슈퍼타입/서브타입 모델링 변환 시 고려사항이 아닌 것은?', '슈퍼타입/서브타입 모델링 변환 시 고려사항은 데이터 검색의 효율성, 데이터의 볼륨, 트랜잭션의 유형 등입니다. 테이블명의 길이는 고려사항이 아닙니다.', NULL, 2),
	(980, 3, NULL, 2, '6회차', '다음 중 관계에서 참여도(참여 여부)가 필수적(Mandatory)인 것은?', '필수적 참여(Mandatory)는 반드시 관계에 참여해야 하는 것을 의미합니다. 보기 중 "직원은 반드시 하나의 부서에 속해야 한다"만이 필수적 참여에 해당합니다. 나머지는 선택적 참여(Optional)입니다.', NULL, 4),
	(981, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | SALARY\n-------|---------|--------\n1001   | 10      | 5000\n1002   | 20      | 6000\n1003   | 10      | 4500\n1004   | 30      | 5500\n\n"부서별 평균 급여가 전체 평균 급여보다 높은 부서의 부서ID와 부서 평균급여를 조회하시오."', 2, '6회차', '다음과 같은 테이블이 있을 때, 가장 적절한 SQL문은?', '부서별 평균 급여를 계산하고 이를 전체 평균 급여와 비교하기 위해서는 GROUP BY절과 서브쿼리를 함께 사용해야 합니다. HAVING절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 것이 올바른 방법입니다.', NULL, 15),
	(982, 3, NULL, 2, '6회차', '다음 중 NULL 관련 설명으로 가장 부적절한 것은?', 'NULL과 \'\'(빈문자)는 다릅니다. \'\'는 길이가 0인 문자열이고, NULL은 값이 없음을 의미합니다. Oracle에서는 \'\'를 NULL로 자동 변환하지만, SQL Server에서는 다른 값으로 취급합니다.', NULL, 9),
	(983, 3, 'SELECT SUBSTR(\'SQLD자격검정\', 5, 2) FROM DUAL;', 1, '6회차', '다음 SQL문의 실행 결과는?', 'SUBSTR(\'SQLD자격검정\', 5, 2)는 5번째 위치에서 2글자를 추출합니다. 따라서 \'자격\'이 출력됩니다.', NULL, 13),
	(984, 3, NULL, 2, '6회차', '다음 중 NATURAL JOIN에 대한 설명으로 가장 적절하지 않은 것은?', 'NATURAL JOIN에서는 조인되는 칼럼을 식별자 없이 사용합니다. 즉, 테이블명이나 alias를 붙이지 않고 칼럼명만으로 사용합니다.', NULL, 17),
	(985, 3, '[SALES]\nSALE_DATE  | AMOUNT\n-----------|--------\n2023-01-01 | 1000\n2023-01-15 | 2000\n2023-02-01 | 1500\n2024-01-01 | 3000', 2, '6회차', '다음과 같은 테이블에서 연도별, 월별 매출액의 합계를 구하는 SQL문으로 가장 적절한 것은?', 'GROUP BY절에서 사용한 표현식은 SELECT절에서도 동일하게 사용해야 하며, 결과의 정렬을 위해 ORDER BY절이 필요합니다. EXTRACT 함수를 사용하여 연도와 월을 추출하는 방식이 가장 적절합니다.', NULL, 13),
	(986, 3, NULL, 1, '6회차', '다음 중 SELECT 문장 실행 순서로 올바른 것은?', 'SELECT 문장의 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다.', NULL, 12),
	(987, 3, '[ORGANIZATION]\nEMP_ID | MGR_ID | NAME\n-------|--------|\n1      | NULL   | 김사장\n2      | 1      | 이부장\n3      | 2      | 박과장\n4      | 2      | 최과장', 3, '6회차', '다음과 같은 테이블에서 계층형 쿼리를 이용해 조직도를 역방향으로 출력하고자 할 때, 적절한 SQL문은?', '역방향 계층 조회를 위해서는 START WITH로 시작점을 지정하고, CONNECT BY절에서 MGR_ID = PRIOR EMP_ID 형태로 작성해야 합니다.', NULL, 24),
	(988, 3, NULL, 2, '6회차', '다음 중 ROLLUP과 CUBE에 대한 설명으로 가장 부적절한 것은?', 'CUBE는 모든 가능한 조합의 소계를 생성하므로 ROLLUP보다 더 많은 연산이 필요하며, 실행 속도가 더 느립니다.', NULL, 21),
	(989, 3, NULL, 1, '6회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'DCL(Data Control Language)에는 GRANT(권한 부여)와 REVOKE(권한 회수)가 포함됩니다.', NULL, 30),
	(990, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME | SALARY\n-------|---------|------|--------\n1001   | 10      | Kim  | 5000\n1002   | 20      | Lee  | 6000\n1003   | 10      | Park | 5500\n1004   | 20      | Choi | 5800', 2, '6회차', '다음과 같은 테이블에서 부서별 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 최고 급여를 받는 사원을 찾기 위해서는, (DEPT_ID, SALARY) 쌍이 부서별 최대 급여와 일치하는 데이터를 찾아야 합니다. IN 절을 사용한 서브쿼리가 가장 적절한 방법입니다.', NULL, 19),
	(991, 3, '[EMPLOYEE]\n- NAME VARCHAR2(10)을 VARCHAR2(20)으로 변경\n- NOT NULL 제약조건 추가', 2, '6회차', '다음과 같은 테이블의 칼럼을 변경하고자 할 때, 적절한 SQL문은?', 'Oracle에서 칼럼을 변경할 때는 MODIFY 절을 사용하며, 여러 속성을 동시에 변경할 수 있습니다.', NULL, 29),
	(992, 3, NULL, 2, '6회차', '다음 중 윈도우 함수(Window Function)의 설명으로 가장 부적절한 것은?', '윈도우 함수는 GROUP BY 절과 함께 사용할 수 없습니다. 윈도우 함수는 결과 집합이 만들어진 후에 적용됩니다.', NULL, 22),
	(993, 3, '[SALES]\nMONTH | AMOUNT\n------|--------\n01    | 100\n02    | 150\n03    | 200\n04    | 250\n\nSELECT MONTH, AMOUNT, LAG(AMOUNT, 1, 0) OVER (ORDER BY MONTH) AS PREV_AMOUNT FROM SALES WHERE MONTH = \'02\';', 2, '6회차', '다음과 같은 테이블에서 LAG 함수를 사용한 SQL의 결과는?', 'LAG 함수는 이전 행의 값을 가져옵니다. 현재 행(MONTH=02)의 이전 행(MONTH=01)의 AMOUNT 값인 100이 반환됩니다.', NULL, 22),
	(994, 3, '[SCORE]\nNAME  | SCORE\n------|-------\nKim   | 90\nLee   | 90\nPark  | 85\nChoi  | 90\nJung  | 80', 2, '6회차', '다음과 같은 테이블에서 RANK 함수와 DENSE_RANK 함수의 결과가 다른 경우는?', 'RANK는 동일한 값에 대해 동일한 순위를 부여하고 다음 순위는 건너뛰지만, DENSE_RANK는 건너뛰지 않고 다음 순위를 부여합니다.', NULL, 22),
	(995, 3, NULL, 2, '6회차', 'GROUP BY 절에 대한 설명으로 가장 부적절한 것은?', 'Oracle 11g R2부터는 GROUP BY 절에서도 Alias를 사용할 수 있습니다.', NULL, 15),
	(996, 3, NULL, 2, '6회차', '다음 중 집합 연산자(Set Operator)의 설명으로 가장 부적절한 것은?', 'MINUS는 순서에 따라 결과가 달라집니다. A MINUS B와 B MINUS A는 다른 결과를 반환할 수 있습니다.', NULL, 20),
	(997, 3, 'SELECT 1/2*3 FROM DUAL;', 1, '6회차', '다음 SQL문의 실행 결과는?', 'Oracle에서 숫자 연산은 왼쪽에서 오른쪽으로 수행됩니다. 따라서 1/2*3은 0.5*3 = 1.5가 됩니다.', NULL, 13),
	(998, 3, NULL, 2, '6회차', '다음 중 서브쿼리(Subquery)에 대한 설명으로 가장 부적절한 것은?', '서브쿼리에서도 ORDER BY절을 사용할 수 있습니다. 특히 TOP-N 쿼리나 ROW_NUMBER() 함수와 함께 사용될 때 유용합니다.', NULL, 19),
	(999, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME\n--------|---------|-------\n1001    | 10      | Kim\n1002    | 20      | Lee\n1003    | 10      | Park\n1004    | 30      | Choi', 2, '6회차', '다음과 같은 테이블에서 사원수가 2명 이상인 부서의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '그룹함수를 조건으로 사용할 때는 HAVING절을 사용해야 하며, GROUP BY절이 필요합니다.', NULL, 15),
	(1000, 3, NULL, 1, '6회차', '다음 중 트랜잭션(Transaction)의 특성이 아닌 것은?', '트랜잭션의 특성은 ACID(원자성, 일관성, 독립성, 지속성(Durability))입니다. 확장성은 트랜잭션의 특성이 아닙니다.', NULL, 28),
	(1001, 3, '[ORDERS]\nORDER_ID | CUSTOMER_ID | ORDER_DATE | AMOUNT\n---------|-------------|------------|--------\n1        | A          | 2024-01-01 | 1000\n2        | B          | 2024-01-02 | 2000\n3        | A          | 2024-01-03 | 1500\n4        | C          | 2024-01-04 | 3000', 2, '6회차', '다음과 같은 테이블에서 고객별 최근 주문 정보를 조회하는 SQL문으로 가장 적절한 것은?', '상관 서브쿼리를 사용하여 각 고객별로 최근 주문일자를 찾고, 해당 주문 정보를 조회하는 것이 가장 적절한 방법입니다.', NULL, 19),
	(1002, 3, 'SELECT LENGTH(\'한글\'), LENGTHB(\'한글\') FROM DUAL;', 2, '6회차', '다음 SQL문의 실행 결과는?', 'LENGTH는 문자의 개수를, LENGTHB는 바이트 수를 반환합니다. 한글은 일반적으로 한 글자당 3바이트를 차지하므로, \'한글\'은 2글자, 6바이트가 됩니다.', NULL, 13),
	(1003, 3, 'SELECT TO_CHAR(SYSDATE, \'YYYY/MM/DD HH24:MI:SS\') FROM DUAL;', 1, '6회차', 'Oracle에서 다음 SQL문의 결과는?', 'TO_CHAR 함수에서 \'YYYY/MM/DD HH24:MI:SS\' 형식을 지정했으므로, \'2024/12/16 14:30:00\' 형태로 출력됩니다.', NULL, 13),
	(1004, 3, NULL, 2, '6회차', '다음 중 MERGE 문에 대한 설명으로 가장 부적절한 것은?', 'MERGE 문에서는 MATCHED와 NOT MATCHED 조건을 모두 사용할 필요는 없습니다. 상황에 따라 하나만 사용할 수도 있습니다.', NULL, 27),
	(1005, 3, 'SELECT DECODE(NULL, NULL, \'A\', \'B\') FROM DUAL;', 2, '6회차', '다음과 같은 데이터가 있을 때, 결과로 적절하지 않은 것은?', 'DECODE(NULL, NULL, \'A\', \'B\')에서 첫 번째와 두 번째 파라미터가 모두 NULL이므로 \'A\'가 반환됩니다.', NULL, 13),
	(1006, 3, NULL, 2, '6회차', '다음 중 Oracle의 날짜 연산에 대한 설명으로 가장 부적절한 것은?', 'NEXT_DAY 함수는 숫자로도 요일을 지정할 수 있습니다(1=일요일, 2=월요일, ..., 7=토요일).', NULL, 13),
	(1007, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME | SALARY\n-------|---------|------|--------\n1001   | 10      | Kim  | 5000\n1002   | 20      | Lee  | 6000\n1003   | 10      | Park | 5500\n1004   | 20      | Choi | 5800', 3, '6회차', '다음과 같은 테이블에서 부서별로 가장 높은 급여를 받는 사원의 정보를 조회할 때, 인라인 뷰를 사용한 가장 적절한 SQL문은?', '인라인 뷰를 사용하여 부서별 최고 급여를 구하고, 이를 원본 테이블과 조인하여 해당 사원의 정보를 조회하는 방법이 가장 적절합니다.', NULL, 19),
	(1008, 3, NULL, 2, '6회차', '다음 중 EXISTS와 IN의 차이점으로 가장 부적절한 것은?', 'EXISTS와 IN의 성능은 데이터의 특성과 양에 따라 달라질 수 있으며, 항상 EXISTS가 더 좋은 것은 아닙니다.', NULL, 19),
	(1009, 3, '[SALES]\nYEAR | QUARTER | AMOUNT\n-----|---------|--------\n2023 | Q1      | 100\n2023 | Q2      | 200\n2023 | Q3      | 300\n2023 | Q4      | 400\n\nSELECT * FROM (SELECT YEAR, QUARTER, AMOUNT FROM SALES) PIVOT (SUM(AMOUNT) FOR QUARTER IN (\'Q1\',\'Q2\',\'Q3\',\'Q4\'))', 3, '6회차', '다음과 같은 테이블에서 PIVOT을 사용한 SQL문의 실행 결과로 가장 적절한 것은?', 'PIVOT 절은 행을 열로 변환합니다. 결과적으로 각 분기별 금액이 별도의 열로 표시됩니다.', NULL, 25),
	(1010, 3, NULL, 2, '6회차', '다음 중 인덱스(Index)에 대한 설명으로 가장 부적절한 것은?', '인덱스가 많을수록 조회 성능이 반드시 향상되는 것은 아닙니다. 오히려 너무 많은 인덱스는 INSERT, UPDATE, DELETE 성능을 저하시키고 저장 공간을 많이 사용하게 됩니다.', NULL, 29),
	(1011, 3, '[DEPARTMENT]\nDEPT_ID | PARENT_DEPT_ID | DEPT_NAME\n--------|----------------|------------\n1       | NULL           | 영업부\n2       | 1              | 국내영업팀\n3       | 1              | 해외영업팀\n4       | 2              | 서울영업소\n5       | 2              | 부산영업소\n\nSELECT DEPT_ID, LEVEL, DEPT_NAME\nFROM DEPARTMENT\nSTART WITH PARENT_DEPT_ID IS NULL\nCONNECT BY PRIOR DEPT_ID = PARENT_DEPT_ID;', 3, '6회차', '다음과 같은 테이블에서 계층형 쿼리의 실행 결과로 가장 적절한 것은?', 'START WITH PARENT_DEPT_ID IS NULL로 최상위 노드부터 시작하여, CONNECT BY PRIOR DEPT_ID = PARENT_DEPT_ID로 하위 방향으로 계층 구조를 전개합니다.', NULL, 24),
	(1012, 3, NULL, 2, '6회차', '다음 중 ROWNUM의 특성으로 가장 부적절한 것은?', 'ROWNUM은 ORDER BY 절 이전에 순번이 부여됩니다. 따라서 ORDER BY로 정렬된 결과에 대해 순번을 부여하려면 인라인 뷰를 사용해야 합니다.', NULL, 23),
	(1013, 3, 'SELECT ROUND(123.456, 2), \nROUND(123.456, 0), \nROUND(123.456, -1)\nFROM DUAL;', 2, '6회차', '다음 SQL문의 실행 결과는?', 'ROUND(숫자, n)은 소수점 n자리까지 반올림합니다. n이 0이면 정수로, 음수이면 정수부분에서 반올림합니다.', NULL, 13),
	(1014, 3, '[TABLE_A]        [TABLE_B]\nCOL1             COL1\n----             ----\n1                2\n2                3\n3                4', 2, '6회차', '다음과 같은 테이블에서 UNION과 UNION ALL의 결과가 같은 경우는?', '두 집합이 서로 중복되는 데이터가 없을 때는 UNION과 UNION ALL의 결과가 동일합니다.', NULL, 20),
	(1015, 3, NULL, 2, '6회차', '다음 중 트랜잭션 격리성 수준(Transaction Isolation Level)이 아닌 것은?', '트랜잭션 격리성 수준은 READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, SERIALIZABLE이 있습니다.', NULL, 28),
	(1016, 3, 'CREATE TABLE TEST (\n    ID NUMBER PRIMARY KEY,\n    REG_DATE DATE DEFAULT SYSDATE,\n    STATUS VARCHAR2(10) CHECK (STATUS IN (\'A\',\'B\',\'C\'))\n);\n\nINSERT INTO TEST (ID, STATUS) VALUES (1, \'D\');', 2, '6회차', '다음 SQL문에서 발생하는 오류는?', 'STATUS 컬럼의 CHECK 제약조건은 \'A\', \'B\', \'C\'만 허용하는데, \'D\'를 입력하려고 했으므로 CHECK 제약조건을 위배합니다.', NULL, 29),
	(1017, 3, NULL, 2, '6회차', '다음 중 데이터베이스 트랜잭션의 특성(ACID)과 그 설명이 잘못 연결된 것은?', 'Durability(지속성)는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나도 영구적으로 반영되어야 한다는 특성입니다.', NULL, 28),
	(1018, 3, NULL, 2, '6회차', '다음 중 DELETE, TRUNCATE, DROP의 차이점으로 가장 부적절한 것은?', 'TRUNCATE는 롤백이 불가능합니다. 자동으로 커밋되며 DML이 아닌 DDL문이기 때문입니다.', NULL, 27),
	(1019, 3, NULL, 2, '6회차', 'GROUP BY절과 관련된 다음 설명 중 가장 부적절한 것은?', 'GROUP BY절에는 SELECT절에 있는 집계함수를 제외한 모든 컬럼이 포함되어야 하며, SELECT절에 있는 모든 컬럼이 GROUP BY절에 포함될 필요는 없습니다.', NULL, 15),
	(1020, 3, NULL, 2, '6회차', '다음 중 뷰(View)에 대한 설명으로 가장 부적절한 것은?', 'WITH CHECK OPTION은 뷰의 조건절을 위배하는 DML만 금지하며, 모든 DML을 금지하는 것은 아닙니다. 모든 DML을 금지하려면 WITH READ ONLY를 사용해야 합니다.', NULL, 29),
	(1021, 3, NULL, 1, '7회차', '엔터티(Entity)의 특징으로 가장 부적절한 것은?', '엔터티는 반드시 물리적 형태로 존재할 필요는 없습니다. \'거래\', \'계약\' 등과 같이 개념적으로만 존재하는 것도 엔터티가 될 수 있습니다. 중요한 것은 업무적으로 관리가 필요한 정보의 집합이라는 점입니다.', NULL, 2),
	(1022, 3, NULL, 2, '7회차', '다음 중 정규화에 대한 설명으로 가장 부적절한 것은?', '정규화는 데이터의 일관성과 무결성을 보장하기 위한 과정이며, 조회 성능이 항상 향상되는 것은 아닙니다. 오히려 정규화로 인해 테이블이 분리되면 조회 시 조인이 필요해져 성능이 저하될 수 있습니다.', NULL, 6),
	(1023, 3, NULL, 2, '7회차', '엔터티를 물리적 모델로 구현할 때 주의사항으로 가장 부적절한 것은?', '테이블명은 반드시 영문 대문자로만 작성할 필요는 없습니다. 각 조직의 네이밍 규칙에 따라 소문자나 혼용도 가능합니다. 중요한 것은 일관성 있는 네이밍 규칙을 적용하는 것입니다.', NULL, 2),
	(1024, 3, NULL, 3, '7회차', '다음 중 슈퍼타입과 서브타입에 대한 설명으로 가장 부적절한 것은?', '서브타입 엔터티는 슈퍼타입에 종속적이며 독립적으로 존재할 수 없습니다. 서브타입은 항상 슈퍼타입의 인스턴스와 연관되어야 합니다.', NULL, 2),
	(1025, 3, NULL, 2, '7회차', '다음 중 식별자의 특징으로 가장 부적절한 것은?', '식별자의 특성에는 유일성, 최소성, 불변성, 존재성이 있습니다. 대체성은 식별자의 특성이 아니며, 오히려 식별자는 안정적이고 변하지 않아야 합니다.', NULL, 5),
	(1026, 3, '두 개 이상의 속성이 모여서 기본키를 이루는 경우, 일부 속성이 타 엔터티와의 관계를 위한 외부키이면서 동시에 자신의 엔터티를 식별하는 기본키의 구성요소인 경우', 2, '7회차', '아래의 설명에 해당하는 것은?', '설명은 복합식별자의 특징을 설명하고 있습니다. 복합식별자는 둘 이상의 속성으로 구성된 식별자를 의미하며, 이 중 일부가 외부키로 사용될 수 있습니다.', NULL, 5),
	(1027, 3, NULL, 1, '7회차', '다음 중 관계의 표현 요소로 가장 부적절한 것은?', '관계의 표현 요소는 관계명, 관계차수, 관계선택사양(필수/선택)이 있습니다. 관계스키마는 관계의 표현 요소가 아닌 데이터베이스 스키마의 한 종류입니다.', NULL, 4),
	(1028, 3, NULL, 2, '7회차', '다음 중 반정규화를 고려해야 하는 경우가 아닌 것은?', '데이터의 일관성이 매우 중요한 경우에는 오히려 정규화를 유지해야 합니다. 반정규화는 데이터의 중복을 허용하므로 일관성이 깨질 위험이 있습니다.', NULL, 6),
	(1029, 3, NULL, 2, '7회차', '다음 중 속성의 특징으로 가장 부적절한 것은?', '속성은 물리적으로 관찰 가능할 필요는 없습니다. \'평점\', \'등급\' 등과 같이 논리적이거나 개념적인 것도 속성이 될 수 있습니다.', NULL, 3),
	(1030, 3, NULL, 2, '7회차', 'PK 컬럼을 FK로 사용하여 관계를 맺을 때, 부모 테이블의 PK 컬럼이 자식 테이블의 일반 컬럼으로 전이되는 관계는?', '비식별관계는 부모 테이블의 기본키가 자식 테이블의 일반 속성(외래키)으로 전이되는 관계입니다. 이는 점선으로 표현되며, 자식 테이블의 PK에 포함되지 않습니다.', NULL, 4),
	(1031, 3, '[EMPLOYEE]\nEMP_NO | DEPT_NO | SALARY\n--------|---------|--------\n10001   | 10      | 5000\n10002   | 20      | 6000\n10003   | 10      | 4500\n10004   | 30      | 5500', 2, '7회차', '다음 테이블에서 부서별 평균 급여가 전체 평균 급여보다 큰 부서의 부서번호와 부서별 평균 급여를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 GROUP BY절과 서브쿼리를 함께 사용해야 합니다. HAVING절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 것이 올바른 방법입니다.', NULL, 15),
	(1032, 3, 'SELECT CASE WHEN NULL = NULL THEN \'T\'\n            WHEN NULL != NULL THEN \'F\'\n            ELSE \'N\'\n       END AS RESULT\nFROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'NULL과 NULL을 비교하는 연산은 항상 UNKNOWN을 반환합니다. 따라서 CASE문의 첫 번째, 두 번째 조건은 모두 FALSE가 되어 ELSE절의 \'N\'이 반환됩니다.', NULL, 9),
	(1033, 3, NULL, 2, '7회차', '다음 중 GROUP BY절의 특성으로 가장 부적절한 것은?', 'Oracle 11g R2 이후 버전부터는 GROUP BY절에서도 별칭(Alias)을 사용할 수 있습니다. 따라서 "GROUP BY절에서는 컬럼의 별칭을 사용할 수 없다"는 설명은 부적절합니다.', NULL, 15),
	(1034, 3, NULL, 3, '7회차', '다음 중 윈도우 함수(Window Function)에 대한 설명으로 가장 부적절한 것은?', 'PERCENT_RANK 함수는 최소값이 0, 최대값이 1입니다. 백분율로 표현하면 0%에서 100%가 되지만, 함수 자체의 반환값 범위는 0~1입니다.', NULL, 22),
	(1035, 3, '[ORGANIZATION]\nEMP_ID | MGR_ID | EMP_NAME\n--------|---------|----------\n1       | NULL    | 김사장\n2       | 1       | 이부장\n3       | 2       | 박과장\n4       | 2       | 최과장', 3, '7회차', '아래의 테이블에서 계층형 쿼리를 사용하여 조직도를 조회할 때, 최상위 노드부터 시작하는 순방향 전개를 위한 적절한 SQL문은?', '순방향 전개를 위해서는 START WITH로 최상위 노드(MGR_ID IS NULL)를 지정하고, CONNECT BY PRIOR EMP_ID = MGR_ID 형태로 작성해야 합니다.', NULL, 24),
	(1036, 3, NULL, 2, '7회차', '다음 중 테이블의 모든 데이터를 삭제하는 명령어에 대한 설명으로 가장 부적절한 것은?', 'TRUNCATE는 데이터와 할당된 공간을 모두 삭제하며, DDL문이므로 ROLLBACK이 불가능합니다. 자동으로 COMMIT이 수행됩니다.', NULL, 27),
	(1037, 3, NULL, 2, '7회차', '다음 중 VIEW에 대한 설명으로 가장 부적절한 것은?', '뷰는 가상의 테이블이므로 자체적인 인덱스를 가질 수 없습니다. 인덱스는 실제 테이블에만 생성할 수 있습니다.', NULL, 29),
	(1038, 3, 'SELECT SUBSTR(\'SQLD자격검정\', -3, 2) FROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'SUBSTR(\'SQLD자격검정\', -3, 2)는 뒤에서 3번째 위치에서 2글자를 추출합니다. 따라서 \'격검\'이 출력됩니다.', NULL, 13),
	(1039, 3, 'CREATE TABLE TEST (\n    ID NUMBER,\n    NAME VARCHAR2(10) NOT NULL,\n    AGE NUMBER DEFAULT 0\n);\n\nINSERT INTO TEST (ID) VALUES (1);', 2, '7회차', '다음 SQL문을 실행했을 때 발생하는 오류는?', 'NAME 컬럼은 NOT NULL 제약조건이 있으므로 반드시 값을 입력해야 합니다. AGE는 DEFAULT 값이 지정되어 있어 생략 가능하지만, NAME은 생략할 수 없습니다.', NULL, 29),
	(1040, 3, NULL, 2, '7회차', '다음 중 MERGE 문에 대한 설명으로 가장 부적절한 것은?', 'MERGE문에서 WHEN MATCHED THEN 절은 필수가 아닙니다. 상황에 따라 WHEN NOT MATCHED THEN 절만 사용할 수도 있습니다.', NULL, 27),
	(1041, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | NAME | SALARY\n-------|---------|------|--------\n1001   | 10      | Kim  | 5000\n1002   | 20      | Lee  | 6000\n1003   | 10      | Park | 5500\n1004   | 20      | Choi | 5800', 2, '7회차', '다음과 같은 테이블이 있을 때, 각 부서별 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 최고 급여를 받는 사원을 찾기 위해서는, (DEPT_ID, SALARY) 쌍이 부서별 최대 급여와 일치하는 데이터를 찾아야 합니다. IN 절을 사용한 서브쿼리가 가장 적절한 방법입니다.', NULL, 19),
	(1042, 3, 'SELECT NVL(MAX(SAL), 0), COUNT(*), COUNT(SAL)\nFROM EMP\nWHERE DEPTNO = 50;', 2, '7회차', '다음 SQL문의 실행 결과는?', '조건을 만족하는 행이 없을 경우, MAX는 NULL이 반환되지만 NVL(MAX(SAL), 0)에 의해 0으로 변환됩니다. COUNT(*)는 항상 0 이상의 값을 반환하며, COUNT(SAL)도 조건에 맞는 행이 없으면 0을 반환합니다.', NULL, 21),
	(1043, 3, NULL, 2, '7회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 가장 부적절한 것은?', 'FOREIGN KEY는 NULL 값을 허용합니다. 이는 선택적 참조의 경우에 필요한 기능입니다.', NULL, 29),
	(1044, 3, 'SELECT ENAME\nFROM EMP\nORDER BY SAL DESC, HIREDATE;', 1, '7회차', '다음의 SQL문을 실행했을 때, 어떤 순서로 결과가 출력되는가?', 'ORDER BY절에서 SAL DESC는 급여를 내림차순으로, HIREDATE는 별도의 정렬 방향이 없으므로 기본값인 오름차순으로 정렬됩니다.', NULL, 16),
	(1045, 3, NULL, 2, '7회차', '다음 중 EXISTS 연산자에 대한 설명으로 가장 부적절한 것은?', 'EXISTS의 서브쿼리에서는 SELECT 절의 컬럼이 결과에 영향을 미치지 않습니다. 따라서 와일드카드(*)보다는 상수값(예: SELECT 1)을 사용하는 것이 성능상 유리합니다.', NULL, 19),
	(1046, 3, NULL, 2, '7회차', '다음 중 UNION과 UNION ALL의 차이점으로 가장 적절한 것은?', 'UNION은 중복된 행을 제거하고 결과를 반환하지만, UNION ALL은 중복된 행을 포함하여 모든 결과를 반환합니다. 정렬 여부는 UNION의 특성이 아닙니다.', NULL, 20),
	(1047, 3, '[EMPLOYEE]\nEMP_ID | NAME  | SALARY\n-------|-------|--------\n1      | Kim   | 5000\n2      | Lee   | 6000\n3      | Park  | 5500\n4      | Choi  | 7000', 2, '7회차', '다음과 같은 테이블에서 ROWNUM을 이용해 급여 상위 3명을 조회하는 SQL문으로 가장 적절한 것은?', 'ROWNUM은 WHERE절 이전에 부여되므로, ORDER BY로 정렬된 결과에서 상위 N개를 추출하려면 인라인 뷰를 사용해야 합니다.', NULL, 23),
	(1048, 3, NULL, 2, '7회차', '다음 중 WITH 절(임시테이블)의 특징으로 가장 부적절한 것은?', 'WITH절로 생성된 임시 테이블은 해당 쿼리 내에서만 유효하며, 영구적으로 저장되지 않습니다. 다른 세션에서는 사용할 수 없습니다.', NULL, 19),
	(1049, 3, 'DECODE(JOB, \'MANAGER\', 1000,\n           \'SALESMAN\', 800,\n           \'CLERK\', 600,\n           0)', 2, '7회차', '다음 중 DECODE 함수를 CASE 문으로 변환한 것으로 가장 적절한 것은?', 'DECODE 함수는 단순 CASE 표현식으로 변환됩니다. CASE 표현식에서 비교 연산자를 생략하면 자동으로 등호(=) 비교가 적용됩니다.', NULL, 13),
	(1050, 3, NULL, 2, '7회차', '다음 중 인덱스(Index)를 사용하기 적절한 경우가 아닌 것은?', '일반적으로 테이블의 전체 행 중 15% 이상을 검색하는 경우에는 인덱스를 사용하는 것이 비효율적입니다. 이 경우 테이블 전체 스캔(Full Table Scan)이 더 효율적일 수 있습니다.', NULL, 29),
	(1051, 3, '[EMPLOYEE]\nEMP_ID | MGR_ID | NAME\n--------|---------|-------\n1      | NULL    | Kim\n2      | 1       | Lee\n3      | 1       | Park\n4      | 2       | Choi\n5      | 2       | Jung', 3, '7회차', '다음과 같은 테이블에서 계층형 쿼리를 사용할 때 리프(Leaf) 노드를 찾는 SQL문으로 가장 적절한 것은?', 'CONNECT_BY_ISLEAF = 1은 리프 노드(자식이 없는 노드)를 찾는 조건입니다. 리프 노드는 계층구조에서 가장 하위에 있는 노드를 의미합니다.', NULL, 24),
	(1052, 3, '[EMPLOYEE]\nEMP_ID | DEPT_ID | SALARY\n--------|---------|--------\n1      | 10      | 5000\n2      | 20      | 6000\n3      | 10      | 5500\n4      | 30      | 4500', 2, '7회차', '다음과 같은 테이블에서 각 부서의 평균 급여와 전체 평균 급여의 차이를 계산하는 SQL문으로 가장 적절한 것은?', '부서별 평균과 전체 평균의 차이를 구하기 위해서는 GROUP BY로 부서별 평균을 구하고, 서브쿼리로 전체 평균을 구해야 합니다.', NULL, 19),
	(1053, 3, 'SELECT INSTR(\'ORACLE SQL\', \'L\', 1, 2)\nFROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'INSTR 함수는 문자열에서 특정 문자의 위치를 찾습니다. 여기서는 \'L\'의 두 번째 출현 위치인 9를 반환합니다.', NULL, 13),
	(1054, 3, NULL, 2, '7회차', '다음 중 트랜잭션 격리 수준(Transaction Isolation Level)을 순서대로 나열한 것으로 가장 적절한 것은?', '트랜잭션 격리 수준은 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 격리성이 강화됩니다.', NULL, 28),
	(1055, 3, '[TABLE_A]\nCOL1\n----\n1\n2\n3\n\n[TABLE_B]\nCOL1\n----\n3\n4\n5', 2, '7회차', '다음과 같은 테이블에서 UNION과 UNION ALL의 실행 결과가 같은 경우는?', '두 집합에서 중복되는 데이터가 없는 경우 UNION과 UNION ALL의 결과가 동일합니다.', NULL, 20),
	(1056, 3, 'SELECT ROUND(123.456, -1), TRUNC(123.456, 1)\nFROM DUAL;', 2, '7회차', '다음 SQL문의 실행 결과는?', 'ROUND(-1)은 10의 자리에서 반올림하여 TRUNC(1)는 소수점 첫째자리까지 잘라서 123.4가 됩니다.', NULL, 13),
	(1057, 3, NULL, 2, '7회차', '다음 중 GRANT 명령어에 대한 설명으로 가장 부적절한 것은?', '부여된 권한은 REVOKE 명령어를 통해 회수할 수 있습니다.', NULL, 30),
	(1058, 3, NULL, 2, '7회차', '다음 중 NULL 관련 함수에 대한 설명으로 가장 부적절한 것은?', 'NVL2 함수는 첫 번째 인자가 NULL이 아니면 두 번째 인자를, NULL이면 세 번째 인자를 반환합니다.', NULL, 13),
	(1059, 3, '[SALES]\nDEPT_ID | AMOUNT\n--------|--------\n10      | 1000\n10      | 2000\n20      | 1500\n20      | 2500\n30      | 3000\n\nSELECT DEPT_ID, SUM(AMOUNT)\nFROM SALES\nGROUP BY DEPT_ID\nHAVING SUM(AMOUNT) > 3000;', 2, '7회차', '다음과 같은 테이블에서 HAVING 절을 사용한 SQL문의 결과로 가장 적절한 것은?', 'DEPT_ID별 AMOUNT 합계가 3000을 초과하는 부서는 20번 부서(4000)뿐입니다.', NULL, 15),
	(1060, 3, NULL, 2, '7회차', '다음 중 데이터베이스 트랜잭션의 ACID 특성과 그 설명이 잘못 연결된 것은?', 'Durability(지속성)는 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다는 특성입니다.', NULL, 28),
	(1061, 3, '[ORDERS]\nORDER_DATE\n----------\n2024-01-01', 2, '7회차', '다음과 같은 테이블에서 날짜 관련 함수를 사용한 결과로 가장 적절하지 않은 것은?', 'NEXT_DAY(\'2024-01-01\', \'월\')의 결과는 2024-01-08입니다. 다음 월요일을 반환하기 때문입니다.', NULL, 13),
	(1062, 3, NULL, 2, '7회차', '다음 중 윈도우 함수(분석 함수)에 대한 설명으로 가장 부적절한 것은?', '윈도우 함수는 WHERE 절에서 사용할 수 없고, SELECT 절이나 ORDER BY 절에서 사용할 수 있습니다.', NULL, 22),
	(1063, 3, NULL, 1, '7회차', '다음 중 서브쿼리의 특징으로 가장 부적절한 것은?', '서브쿼리에서 ORDER BY 절은 필수가 아니며, 대부분의 경우 사용할 수 없습니다.', NULL, 19),
	(1064, 3, NULL, 2, '7회차', '다음 중 인덱스(Index)에 대한 설명으로 가장 적절하지 않은 것은?', 'INSERT, UPDATE, DELETE가 빈번한 테이블의 컬럼에는 인덱스 생성을 신중히 고려해야 합니다. 잦은 데이터 변경은 인덱스 유지 비용을 증가시킵니다.', NULL, 29),
	(1065, 3, 'SELECT LPAD(\'SQL\', 5, \'*\'), RPAD(\'SQL\', 5, \'*\')\nFROM DUAL;', 1, '7회차', '다음 SQL문의 실행 결과는?', 'LPAD는 왼쪽을, RPAD는 오른쪽을 지정된 문자로 채웁니다.', NULL, 13),
	(1066, 3, NULL, 1, '7회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어끼리 올바르게 묶인 것은?', 'DCL은 데이터 제어어로 GRANT(권한 부여)와 REVOKE(권한 회수)가 포함됩니다.', NULL, 30),
	(1067, 3, '[SALES]\nYEAR | QUARTER | AMOUNT\n-----|---------|--------\n2023 | Q1      | 1000\n2023 | Q2      | 2000\n2024 | Q1      | 1500\n2024 | Q2      | 2500\n\nSELECT YEAR, QUARTER, SUM(AMOUNT)\nFROM SALES\nGROUP BY ROLLUP(YEAR, QUARTER);', 2, '7회차', '다음과 같은 테이블에서 ROLLUP을 사용한 SQL문의 결과행 수는?', 'ROLLUP(YEAR, QUARTER)은 (YEAR, QUARTER), (YEAR), () 순으로 그룹화하여 총 7개의 행을 생성합니다.', NULL, 21),
	(1068, 3, NULL, 2, '7회차', '다음 중 데이터베이스 테이블의 제약조건에 대한 설명으로 가장 부적절한 것은?', 'PRIMARY KEY 제약조건은 테이블당 하나만 설정할 수 있습니다.', NULL, 29),
	(1069, 3, NULL, 3, '7회차', '다음 중 트리거(Trigger)에 대한 설명으로 가장 부적절한 것은?', '트리거 내에서는 COMMIT, ROLLBACK을 사용할 수 없습니다. 이는 트리거의 자동성을 해치기 때문입니다.', NULL, 29),
	(1070, 3, 'SELECT REPLACE(\'ORACLE SQL\', \'L\', \'*L*\')\nFROM DUAL;', 1, '7회차', '다음 SQL문의 실행 결과는?', 'REPLACE 함수는 모든 \'L\'을 \'*L*\'로 대체하므로, \'ORAC*L*E SQ*L*\'이 됩니다.', NULL, 13),
	(1071, 3, NULL, 2, '8회차', '데이터 모델링 단계에서 각 엔터티를 도출하고 그들 간의 관계를 정의할 때, 가장 적절하지 않은 것은?', '엔터티는 업무프로세스에서 반드시 이용되어야 합니다. 업무프로세스에서 이용되지 않는 데이터는 엔터티로 선정될 수 없습니다. 나머지는 모두 엔터티의 올바른 특성입니다.', NULL, 2),
	(1072, 3, NULL, 2, '8회차', '아래의 식별자 특성 중 가장 부적절한 것은?', '식별자는 단일 속성으로만 구성되어야 한다는 제약은 없습니다. 복합 식별자도 가능하며, 이는 두 개 이상의 속성을 조합하여 식별자로 사용하는 것을 의미합니다.', NULL, 5),
	(1073, 3, NULL, 2, '8회차', '다음 중 ERD의 관계선택사양(Optionality)에 대한 설명으로 가장 옳은 것은?', '관계선택사양에서는 필수관계는 실선으로, 선택관계는 점선으로 표시합니다. \'O\'와 \'|\' 표기는 관계선택사양의 올바른 표기법이 아닙니다.', NULL, 4),
	(1074, 3, '학생번호 | 이름 | 수강과목 | 교수\n1001    | 김철수 | 수학   | 박교수\n1001    | 김철수 | 영어   | 이교수\n1002    | 이영희 | 수학   | 박교수', 2, '8회차', '아래와 같은 테이블이 있을 때, 이상현상(Anomaly)이 발생하지 않는 것은?', '제시된 테이블에서는 조회이상이 발생하지 않습니다. 학생별 수강과목 수는 GROUP BY를 통해 정상적으로 조회가 가능합니다. 나머지 보기들은 모두 발생 가능한 이상현상입니다.', NULL, 6),
	(1075, 3, NULL, 2, '8회차', '다음 중 엔터티의 특징으로 가장 부적절한 것은?', '엔터티가 다른 엔터티와 반드시 관계를 가져야 한다는 것은 잘못된 설명입니다. 독립적으로 존재하는 엔터티도 있을 수 있습니다.', NULL, 2),
	(1076, 3, '두 개의 엔터티 사이에서 엔터티 A의 하나의 인스턴스가 엔터티 B의 여러 개의 인스턴스와 관계를 가지고, 엔터티 B의 하나의 인스턴스도 엔터티 A의 여러 개의 인스턴스와 관계를 가진다.', 2, '8회차', '아래의 설명이 나타내는 관계유형은?', '설명은 M:N(다대다) 관계를 나타냅니다. 양쪽 엔터티 모두 서로에 대해 여러 개의 인스턴스와 관계를 맺을 수 있는 경우입니다.', NULL, 4),
	(1077, 3, NULL, 2, '8회차', '다음 중 정규화 과정에서 발생할 수 있는 단점으로 가장 적절한 것은?', '정규화를 수행하면 테이블이 분할되므로, 데이터 조회 시 조인이 필요할 수 있어 성능이 저하될 수 있습니다. 이는 정규화의 대표적인 단점입니다.', NULL, 6),
	(1078, 3, NULL, 1, '8회차', '두 개의 엔터티가 관계를 맺을 때 관계의 형태를 결정하는 것은?', '두 엔터티 간의 관계 형태는 관계차수(Cardinality)에 의해 결정됩니다. 관계차수는 1:1, 1:N, N:M 등의 수적인 관계를 나타냅니다.', NULL, 4),
	(1079, 3, NULL, 2, '8회차', '다음 중 속성의 분류 기준으로 가장 부적절한 것은?', '속성의 분류 기준에 \'크기에 따른 분류\'는 없습니다. 이는 잘못된 분류 기준입니다. 나머지는 모두 올바른 속성 분류 기준입니다.', NULL, 3),
	(1080, 3, NULL, 2, '8회차', '다음 중 슈퍼타입/서브타입 데이터 모델의 변환시 고려사항이 아닌 것은?', '슈퍼타입/서브타입 변환시 고려사항은 데이터 양, 조회 비중, 트랜잭션의 유형 등입니다. 테이블 이름의 길이는 변환시 고려사항이 아닙니다.', NULL, 2),
	(1081, 3, '[EMPLOYEE]\nEMP_NO    DEPT_NO    SALARY\n1001      10         5000\n1002      10         6000\n1003      20         4000\n1004      20         4500\n1005      30         3500', 2, '8회차', '다음과 같은 테이블이 있을 때, 부서별 평균 급여가 전체 평균 급여보다 높은 부서의 부서번호와 평균급여를 출력하는 SQL문으로 가장 적절한 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 GROUP BY절과 서브쿼리를 함께 사용해야 합니다. HAVING절에서 서브쿼리로 전체 평균을 구하고 이와 비교하는 2번이 올바른 답입니다.', NULL, 15),
	(1082, 3, NULL, 2, '8회차', '다음 중 RANK 함수에 대한 설명으로 올바르지 않은 것은?', 'RANK 함수는 NULL 값도 순위를 매깁니다. Oracle의 경우 기본적으로 NULL을 가장 큰 값으로 취급하여 ORDER BY ASC에서는 마지막 순위로, DESC에서는 처음 순위로 매깁니다.', NULL, 22),
	(1083, 3, 'SELECT SUBSTR(\'SQL전문가\',1,3) FROM DUAL;', 1, '8회차', '다음의 SQL문을 실행한 결과로 맞는 것은?', 'SUBSTR(\'SQL전문가\',1,3)는 첫 번째 위치에서 3개의 문자를 추출합니다. 따라서 \'SQL\'이 출력됩니다.', NULL, 13),
	(1084, 3, NULL, 2, '8회차', '다음 중 테이블 CROSS JOIN의 특징으로 가장 적절한 것은?', 'CROSS JOIN은 두 테이블의 모든 행을 조합하여 곱집합(Cartesian Product)을 반환합니다. 조인 조건이 필요없으며, 결과 행의 수는 두 테이블의 행의 수를 곱한 값이 됩니다.', NULL, 17),
	(1085, 3, '[ORDERS]\nORDER_DATE          ORDER_AMOUNT\n2023-01-01         1000\n2023-01-15         2000\n2023-02-01         1500\n2024-01-01         3000', 2, '8회차', '다음의 데이터에서 연도별, 월별 주문금액의 합계를 구하는 SQL문으로 가장 적절한 것은?', 'EXTRACT 함수를 사용하여 연도와 월을 추출하고, 이를 GROUP BY절에 동일하게 사용하여 그룹화해야 합니다. ORDER BY절로 정렬까지 수행하는 3번이 가장 적절합니다.', NULL, 13),
	(1086, 3, NULL, 2, '8회차', '다음 중 NULL 값과의 연산에 대한 설명으로 가장 적절한 것은?', 'NULL과의 모든 연산(산술, 비교 등)의 결과는 NULL입니다. 이는 \'NULL propagation\' 특성으로, NULL과 연산된 결과는 항상 NULL이 됩니다.', NULL, 9),
	(1087, 3, NULL, 2, '8회차', '다음 중 DELETE문에 대한 설명으로 옳지 않은 것은?', 'DELETE문은 DML문으로 트랜잭션 로그를 남깁니다. 이는 ROLLBACK이 가능한 이유이기도 합니다. 로그를 남기지 않는다는 설명은 잘못된 것입니다.', NULL, 27),
	(1088, 3, NULL, 3, '8회차', '계층형 질의문의 실행 순서로 올바른 것은?', '계층형 질의문의 실행 순서는 START WITH → CONNECT BY → WHERE → ORDER SIBLINGS BY 입니다. 이는 Oracle의 계층형 질의 처리 순서입니다.', NULL, 24),
	(1089, 3, '[EMPLOYEE]\nEMP_NO   DEPT_NO   SALARY\n1001     10        5000\n1002     10        4000\n1003     20        2000\n1004     20        2500', 2, '8회차', '다음의 테이블에서 부서별 평균 급여가 3000 이상인 부서를 조회하는 SQL문으로 가장 효율적인 것은?', 'WITH절(임시테이블)을 사용하여 부서별 평균 급여를 먼저 계산한 후, 그 결과에서 조건을 적용하는 방식이 가장 효율적입니다. 이는 중간 결과를 재사용할 수 있게 해주며, 쿼리의 가독성도 높여줍니다.', NULL, 19),
	(1090, 3, NULL, 2, '8회차', '다음 중 GROUP BY 절에 대한 설명으로 틀린 것은?', 'Oracle 11g R2 버전부터는 GROUP BY절에도 Alias를 사용할 수 있습니다. 따라서 "GROUP BY절에서 Alias를 사용할 수 없다"는 설명은 틀린 것입니다.', NULL, 15),
	(1091, 3, '[현재 테이블 구조]\nCREATE TABLE EMPLOYEE (\n    EMP_NO NUMBER(5),\n    NAME VARCHAR2(10)\n);', 2, '8회차', '다음 중 ALTER 문을 사용한 테이블 변경에 대한 올바른 구문은?', 'ALTER TABLE의 컬럼 변경은 MODIFY 구문을 사용합니다. 1번은 NOT NULL 제약조건을 가진 컬럼을 추가할 수 없고, 3번의 CHANGE는 MySQL 구문이며, 4번의 DELETE COLUMN은 잘못된 구문입니다(DROP COLUMN이 올바른 구문).', NULL, 29),
	(1092, 3, 'SELECT DISTINCT A.COL1, B.COL2, SUM(A.AMT)\nFROM TABLE1 A, TABLE2 B\nWHERE A.NO = B.NO\nGROUP BY A.COL1, B.COL2;', 2, '8회차', '다음의 SQL 문에서 잘못된 부분을 고르시오.', 'DISTINCT와 집계함수는 함께 사용할 수 있습니다. GROUP BY절에는 필요한 모든 컬럼이 포함되어 있고, WHERE절은 GROUP BY절 이전에 실행됩니다.', NULL, 15),
	(1093, 3, NULL, 2, '8회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', 'ROW_NUMBER() 함수는 중복값에 대해서도 고유한 순위를 부여합니다. 중복값에 대해 같은 순위를 부여하는 것은 RANK() 함수의 특징입니다.', NULL, 22),
	(1094, 3, NULL, 3, '8회차', 'EMPLOYEES 테이블에서 같은 부서 내에서 자신의 급여가 평균 급여보다 많은 직원을 조회하는 SQL문으로 가장 적절한 것은?', '부서별 평균 급여를 구하기 위해 상관 서브쿼리를 사용해야 합니다. E1.deptno = E2.deptno 조건으로 같은 부서 내에서의 평균 급여와 비교가 가능합니다.', NULL, 19),
	(1095, 3, NULL, 2, '8회차', '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Isolation(고립성)은 트랜잭션 실행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것입니다. 트랜잭션들이 서로 영향을 주면서 실행되어야 한다는 설명은 잘못되었습니다.', NULL, 28),
	(1096, 3, NULL, 1, '8회차', '다음 중 데이터 정의어(DDL)에 해당하는 것은?', 'DDL(Data Definition Language)은 데이터베이스 객체를 정의하는 명령어로 CREATE, ALTER, DROP, TRUNCATE 등이 포함됩니다. 1번은 TCL, 2번은 DCL, 3번은 DML에 해당합니다.', NULL, 29),
	(1097, 3, 'SELECT LPAD(\'SQL\', 5, \'#\') FROM DUAL;', 1, '8회차', '다음의 SQL문을 실행한 결과로 맞는 것은?', 'LPAD는 왼쪽에 지정한 문자를 채워넣는 함수입니다. \'SQL\'을 5자리로 만들기 위해 왼쪽에 \'#\'을 2개 채워넣으므로 \'##SQL\'이 됩니다.', NULL, 13),
	(1098, 3, NULL, 2, '8회차', '다음 중 인덱스(Index)에 대한 설명으로 틀린 것은?', 'Primary Key 제약조건을 생성하면 자동으로 인덱스가 생성됩니다. 제약조건이 생성될 때 인덱스가 삭제되는 것이 아닙니다.', NULL, 29),
	(1099, 3, '[ORDERS]\nORDER_DATE    ORDER_AMOUNT\n2023-01-01    1000\n2023-01-15    2000\n2023-02-01    1500\n2024-01-01    3000', 2, '8회차', '다음과 같은 테이블이 있을 때, 2023년도의 월별 주문금액 합계를 조회하는 SQL문으로 적절한 것은?', 'EXTRACT 함수를 사용하여 연도와 월을 추출하고, WHERE절에서 2023년도 데이터만 필터링한 후 월별로 그룹화하는 방식이 가장 적절합니다. HAVING절을 사용한 4번은 비효율적입니다.', NULL, 13),
	(1100, 3, NULL, 2, '8회차', '다음 중 View에 대한 설명으로 옳지 않은 것은?', '뷰는 물리적인 저장공간을 가지지 않는 가상 테이블이므로 직접적으로 인덱스를 생성할 수 없습니다. 인덱스는 실제 테이블에만 생성이 가능합니다.', NULL, 29),
	(1101, 3, NULL, 3, '8회차', '다음 중 Oracle의 계층형 질의에서 사용되는 가상 컬럼으로 올바르지 않은 것은?', 'Oracle의 계층형 질의에서 사용되는 가상 컬럼은 LEVEL, CONNECT_BY_ROOT, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE입니다. CONNECT_BY_ORDER는 존재하지 않는 가상 컬럼입니다.', NULL, 24),
	(1102, 3, 'SELECT ROUND(123.456, 2),\n       ROUND(123.456, 0),\n       ROUND(123.456, -1)\nFROM DUAL;', 2, '8회차', '아래의 SQL을 실행했을 때의 결과로 올바른 것은?', 'ROUND 함수의 두 번째 인자는 반올림할 소수점 자리를 지정합니다. ROUND(123.456, 2) → 123.46 (소수점 2자리까지), ROUND(123.456, 0) → 123 (정수), ROUND(123.456, -1) → 120 (10단위 반올림)', NULL, 13),
	(1103, 3, '[SCORES]\nNAME    SUBJECT    SCORE\n김철수   수학        90\n이영희   수학        85\n박지민   수학        95\n김철수   영어        85\n이영희   영어        90\n박지민   영어        80', 3, '8회차', '다음 데이터에서 과목별 최고점수를 가진 학생의 이름을 조회하는 SQL문으로 가장 적절한 것은?', '과목별 최고점수를 가진 학생을 찾기 위해서는 상관 서브쿼리를 사용합니다. 각 과목별로 최고점수를 구한 뒤, 해당 점수와 일치하는 학생을 찾는 방식입니다.', NULL, 19),
	(1104, 3, NULL, 2, '8회차', '다음 중 NULL 값과 관련된 설명으로 옳지 않은 것은?', 'NULL과 숫자 0은 전혀 다른 의미입니다. NULL은 \'알 수 없는 값\' 또는 \'해당없음\'을 의미하지만, 0은 숫자로서의 명확한 값을 의미합니다.', NULL, 9),
	(1105, 3, '[EMPLOYEES]\nEMP_NO    DEPT_NO    HIRE_DATE    NAME\n1001      10         2023-01-01   김철수\n1002      10         2023-03-15   이영희\n1003      20         2023-02-01   박지민\n1004      20         2023-04-01   최동욱', 3, '8회차', '다음과 같은 테이블이 있을 때, 부서별로 최근 입사한 직원의 정보를 조회하는 SQL문으로 가장 적절한 것은?', '부서별 최근 입사자를 찾기 위해서는 상관 서브쿼리를 사용하여 각 부서의 최대 입사일자와 일치하는 직원을 찾아야 합니다.', NULL, 19),
	(1106, 3, 'SELECT TO_CHAR(SYSDATE, \'YYYY/MM/DD HH24:MI:SS\'),\n       TO_CHAR(SYSDATE, \'YYYY-MM-DD DAY\'),\n       TO_CHAR(SYSDATE, \'YYYY.MM.DD\')\nFROM DUAL;', 2, '8회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'TO_CHAR 함수는 지정된 형식에 따라 날짜를 문자열로 변환합니다. YYYY: 4자리 연도, HH24: 24시간 형식, DAY: 요일 전체 이름.', NULL, 13),
	(1107, 3, NULL, 2, '8회차', '다음 중 GROUP BY 절과 집계 함수에 대한 설명으로 틀린 것은?', 'HAVING 절은 GROUP BY 절과 함께 사용해야 합니다. HAVING 절만 단독으로 사용할 수 없습니다. 이는 GROUP BY로 그룹화된 데이터에 대한 조건을 지정하는 절이기 때문입니다.', NULL, 15),
	(1108, 3, '[EMPLOYEES]\nEMP_NO    DEPT_NO    SALARY    NAME\n1001      10         5000      김철수\n1002      10         4000      이영희\n1003      20         3000      박지민\n1004      20         4500      최동욱', 3, '8회차', '다음과 같은 테이블에서 각 부서의 평균 급여보다 높은 급여를 받는 직원을 조회하는 SQL문으로 가장 적절한 것은?', '각 부서의 평균 급여를 구하고, 이와 비교하기 위해서는 상관 서브쿼리를 사용해야 합니다. 서브쿼리에서 현재 행의 부서와 같은 부서의 평균 급여를 구하고, 이를 현재 행의 급여와 비교합니다.', NULL, 19),
	(1109, 3, NULL, 2, '8회차', '다음 중 UNION과 UNION ALL의 차이점에 대한 설명으로 틀린 것은?', 'UNION이 자동으로 정렬을 수행한다는 것은 틀린 설명입니다. UNION은 중복을 제거하는 과정에서 정렬이 발생할 수 있지만, 이는 명시적인 정렬이 아닙니다. 명시적인 정렬을 위해서는 ORDER BY 절을 사용해야 합니다.', NULL, 20),
	(1110, 3, NULL, 2, '8회차', '다음 중 인덱스(Index)를 생성하는 것이 적절하지 않은 경우는?', '데이터가 자주 변경되는 컬럼에 인덱스를 생성하는 것은 적절하지 않습니다. 데이터가 변경될 때마다 인덱스도 함께 업데이트되어야 하므로 오버헤드가 발생하고 성능이 저하될 수 있습니다.', NULL, 29),
	(1111, 3, '[DEPT]\nDEPT_NO   DEPT_NAME\n10        인사부\n20        총무부\n30        영업부\n\n[EMP]\nEMP_NO    DEPT_NO    NAME\n1001      10         김철수\n1002      20         이영희\n1003      10         박지민', 3, '8회차', '다음과 같은 테이블에서 INNER JOIN과 LEFT OUTER JOIN의 결과가 같을 조건은?', 'INNER JOIN과 LEFT OUTER JOIN의 결과가 같으려면 EMP 테이블의 모든 직원이 DEPT 테이블에 존재하는 부서번호를 가지고 있어야 합니다. 즉, EMP 테이블의 DEPT_NO가 모두 DEPT 테이블에 존재하는 경우입니다.', NULL, 17),
	(1112, 3, 'SELECT DECODE(NULLIF(LENGTH(\'\'SQL\'\'), 3), NULL, \'\'SAME\'\', \'\'DIFFERENT\'\') FROM DUAL;', 2, '8회차', '다음의 SQL문을 실행했을 때의 결과로 올바른 것은?', 'NULLIF는 두 값이 같으면 NULL을 반환하고, 다르면 첫 번째 값을 반환합니다. LENGTH(\'SQL\')은 3이므로 NULLIF(3,3)은 NULL을 반환합니다. DECODE는 첫 번째 값이 NULL이면 \'SAME\'을 반환하므로 최종 결과는 \'SAME\'입니다.', NULL, 13),
	(1113, 3, NULL, 3, '8회차', '다음 중 윈도우 함수의 ROWS와 RANGE 옵션에 대한 설명으로 틀린 것은?', 'ROWS와 RANGE는 다른 결과를 반환할 수 있습니다. ROWS는 물리적 행의 수를 기준으로, RANGE는 논리적 값의 범위를 기준으로 행 집합을 지정하기 때문입니다.', NULL, 22),
	(1114, 3, '[ATTENDANCE]\nEMP_NO    ABSENT_DATE\n1001      2023-12-01\n1001      2023-12-02\n1001      2023-12-03\n1002      2023-12-01\n1002      2023-12-03', 3, '8회차', '아래와 같은 테이블이 있을 때, 연속된 결근일수를 계산하는 SQL문으로 가장 적절한 것은?', '연속된 결근일수를 계산하기 위해서는 ROW_NUMBER()와 날짜 차이를 이용하여 그룹을 만들고, 각 그룹별로 카운트를 구해야 합니다. 이 방식을 통해 날짜가 연속된 그룹을 식별할 수 있습니다.', NULL, 22),
	(1115, 3, NULL, 2, '8회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE문에서 WHEN NOT MATCHED THEN 절은 선택사항입니다. 필요한 경우에만 사용할 수 있으며, 필수적으로 포함되어야 하는 것은 아닙니다.', NULL, 27),
	(1116, 3, '[SALES]\nSALE_DATE    AMOUNT\n2023-01-01   1000\n2023-01-02   2000\n2023-01-03   1500', 2, '8회차', '다음의 테이블에서 누적 합계를 구하는 SQL문으로 가장 적절한 것은?', '누적 합계를 구하기 위해서는 윈도우 함수의 ROWS BETWEEN 절을 사용하는 것이 가장 명확합니다. UNBOUNDED PRECEDING AND CURRENT ROW는 처음부터 현재 행까지의 범위를 지정합니다.', NULL, 22),
	(1117, 3, NULL, 2, '8회차', '다음 중 Oracle의 PIVOT 절을 사용할 때의 제한사항으로 옳지 않은 것은?', 'PIVOT 절에서는 여러 개의 집계함수를 사용할 수 있습니다. 하나의 집계함수만 사용해야 한다는 제한은 없습니다.', NULL, 25),
	(1118, 3, '[EMPLOYEES]\nEMP_NO    DEPT_NO    SALARY    NAME\n1001      10         5000      김철수\n1002      10         4000      이영희\n1003      20         3000      박지민\n1004      20         4500      최동욱', 3, '8회차', '다음과 같은 테이블에서 부서별로 가장 높은 급여를 받는 상위 2명의 직원을 조회하는 SQL문으로 가장 적절한 것은?', '부서별로 급여 순위를 매기고 상위 2명을 선택하기 위해서는 ROW_NUMBER() 함수를 사용하는 것이 가장 적절합니다. PARTITION BY로 부서별로 분할하고 ORDER BY로 급여 순서를 정합니다.', NULL, 23),
	(1119, 3, 'WITH RECURSIVE NUMS AS (\n    SELECT 1 AS N\n    UNION ALL\n    SELECT N + 1\n    FROM NUMS\n    WHERE N < 5\n)\nSELECT * FROM NUMS;', 3, '8회차', '다음의 SQL문을 실행했을 때의 결과로 올바른 것은?', '재귀 CTE는 초기 값 1부터 시작하여 N < 5 조건을 만족할 때까지 N + 1 값을 생성합니다. 따라서 1부터 5까지의 숫자가 생성됩니다.', NULL, 19),
	(1120, 3, NULL, 2, '8회차', '다음 중 데이터베이스 트랜잭션 격리 수준(Isolation Level)에 대한 설명으로 틀린 것은?', 'READ COMMITTED 격리 수준에서는 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 없습니다. 커밋된 데이터만 읽을 수 있습니다. 커밋되지 않은 데이터를 읽을 수 있는 것은 READ UNCOMMITTED 격리 수준의 특징입니다.', NULL, 28),
	(1121, 3, NULL, 2, '9회차', '다음 중 엔터티(Entity)의 특성으로 가장 부적절한 것은?', '엔터티는 물리적 형태뿐만 아니라 개념적으로 존재하는 것도 포함됩니다. 예를 들어 \'거래\', \'계약\' 등은 물리적 형태는 없지만 업무적으로 관리해야 할 엔터티입니다.', NULL, 2),
	(1122, 3, NULL, 2, '9회차', '다음 중 식별자의 특징으로 가장 부적절한 것은?', '식별자의 주요 특성은 유일성(Unique), 최소성(Minimal), 불변성(Stable), 존재성(Existence)입니다. 대체성은 식별자의 필수 특성이 아닙니다.', NULL, 5),
	(1123, 3, '"두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가진다."', 3, '9회차', '아래의 설명에 해당하는 것은?', '행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가집니다.', NULL, 2),
	(1124, 3, NULL, 2, '9회차', '다음 중 관계(Relationship)의 표기법에 포함되지 않는 것은?', '관계의 표기법은 관계명, 관계차수, 관계선택사양이 있습니다. 관계스키마는 관계 표기법에 포함되지 않습니다.', NULL, 4),
	(1125, 3, NULL, 2, '9회차', '다음 중 정규화 과정에서 발생할 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상은 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않습니다.', NULL, 6),
	(1126, 3, NULL, 3, '9회차', '비식별관계에 대한 설명으로 가장 적절한 것은?', '비식별관계는 부모 테이블의 기본키가 자식 테이블의 일반 속성으로 전이되는 관계를 의미합니다.', NULL, 4),
	(1127, 3, NULL, 2, '9회차', '다음 중 정규화의 특징으로 부적절한 것은?', '정규화는 조회 시 조인이 필요할 수 있어 항상 조회 성능이 향상되는 것은 아닙니다.', NULL, 6),
	(1128, 3, NULL, 2, '9회차', '엔터티의 속성 중 스스로 생성된 값이 아닌, 다른 엔터티로부터 받아오는 값을 무엇이라고 하는가?', '다른 엔터티로부터 받아오는 속성을 외부 속성이라고 합니다.', NULL, 3),
	(1129, 3, NULL, 3, '9회차', '슈퍼타입/서브타입 모델링에 대한 설명으로 옳지 않은 것은?', '하나의 서브타입은 단 하나의 슈퍼타입만 가질 수 있습니다. 여러 개의 슈퍼타입을 가질 수 없습니다.', NULL, 3),
	(1130, 3, NULL, 2, '9회차', '도메인(Domain)에 대한 설명으로 가장 부적절한 것은?', '도메인은 테이블 생성 시 반드시 지정해야 하는 것이 아닙니다. 도메인은 속성이 가질 수 있는 값의 범위를 정의하는 것입니다.', NULL, 3),
	(1131, 3, NULL, 2, '9회차', '다음 중 GROUP BY절에 대한 설명으로 옳지 않은 것은?', 'Oracle 11g R2 버전부터는 GROUP BY절에도 별칭(Alias)을 사용할 수 있습니다.', NULL, 15),
	(1132, 3, '[EMPLOYEE]\nEMP_ID  SALARY\n-------------------\n101     3000\n102     3000\n103     4000\n104     5000\n105     4000\n\n```sql\nSELECT COUNT(DISTINCT SALARY) \nFROM EMPLOYEE;```', 2, '9회차', '다음 테이블에서 SQL 실행결과로 올바른 것은?', '중복을 제거한 SALARY 값은 3000, 4000, 5000으로 총 3개입니다.', NULL, 13),
	(1133, 3, NULL, 2, '9회차', '다음 중 NULL 처리 함수에 대한 설명으로 잘못된 것은?', 'ISNULL(A,B)는 A가 NULL이면 B를 반환합니다. A를 반환한다는 설명은 잘못되었습니다.', NULL, 13),
	(1134, 3, '```sql\nSELECT SUBSTR(\'SQL Developer\', -4, 2) \nFROM DUAL;```', 2, '9회차', '다음 중 SUBSTR 함수를 사용한 결과로 올바른 것은?', 'SUBSTR 함수에서 음수 위치는 뒤에서부터 계산합니다. -4는 뒤에서 4번째 위치에서 시작하여 2글자를 추출하므로 \'pe\'가 됩니다.', NULL, 13),
	(1135, 3, '[SALES]\nJOIN_DATE    MEMBER_ID   AMOUNT\n--------------------------------\n2023-01-01   A001        1000\n2023-01-15   A002        2000\n2023-02-01   A003        1500\n2022-12-31   A004        3000', 3, '9회차', '다음과 같은 테이블이 있을 때, 2023년에 가입한 회원의 월별 합계 금액을 구하는 SQL문으로 가장 적절한 것은?', 'EXTRACT 함수를 사용하여 연도와 월을 추출하고, GROUP BY와 ORDER BY를 적절히 사용한 쿼리가 가장 적절합니다.', NULL, 15),
	(1136, 3, '[DEPT]\nDEPT_ID   DEPT_NAME\n----------------------\n10        영업부\n20        개발부\n30        인사부\n\n[EMP]\nEMP_ID    DEPT_ID    EMP_NAME\n--------------------------------\n1         10         김사원\n2         10         박사원\n3         20         이사원\n4         NULL       최사원', 2, '9회차', '다음과 같은 테이블에서 LEFT OUTER JOIN의 결과행 수로 올바른 것은?', 'LEFT OUTER JOIN은 왼쪽 테이블(DEPT)의 모든 행과 오른쪽 테이블(EMP)의 매칭되는 행을 반환합니다. DEPT의 3행과 EMP의 매칭되는 행으로 총 3행이 됩니다.', NULL, 17),
	(1137, 3, NULL, 3, '9회차', '다음 중 계층형 질의문(Hierarchical Query)에서 사용되는 가상 컬럼이 아닌 것은?', 'CONNECT_BY_PARENT는 계층형 질의문의 가상 컬럼이 아닙니다. 실제 가상 컬럼은 LEVEL, CONNECT_BY_ROOT, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE 등이 있습니다.', NULL, 24),
	(1138, 3, NULL, 3, '9회차', '다음 중 ROLLUP과 CUBE에 대한 설명으로 옳지 않은 것은?', 'CUBE는 ROLLUP보다 더 많은 소계를 생성하며, 결과가 항상 동일하지 않습니다.', NULL, 21),
	(1139, 3, NULL, 2, '9회차', '다음 중 ORDER BY절에 대한 설명으로 옳지 않은 것은?', 'ORDER BY절은 GROUP BY절이 있더라도 사용할 수 있습니다.', NULL, 16),
	(1140, 3, '[EMP]\nEMP_ID    SALARY\n------------------\n101       5000\n102       5000\n103       4000\n104       3000', 3, '9회차', '다음과 같은 테이블에서 연봉 순위를 구하는 SQL문 중 잘못된 것은?', 'RANK() OVER절의 정렬 순서와 최종 결과의 정렬 순서가 일치하지 않아 순위가 올바르게 계산되지 않습니다.', NULL, 22),
	(1141, 3, '[EMP]\nEMP_ID    DEPT_ID    SALARY\n-----------------------------\n101       10         5000\n102       10         4000\n103       20         6000\n104       20         5500\n105       30         4500', 3, '9회차', '다음 테이블에서 부서별로 최고 급여를 받는 사원의 정보를 조회하는 SQL문으로 올바른 것은?', '상관 서브쿼리를 사용하여 각 부서별 최고 급여를 받는 사원의 모든 정보를 조회할 수 있습니다.', NULL, 19),
	(1142, 3, NULL, 2, '9회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE 문은 Oracle 10g부터 DELETE 절을 포함할 수 있습니다.', NULL, 27),
	(1143, 3, '[SALES]\nYEAR    MONTH    AMOUNT\n------------------------\n2023    01       1000\n2023    02       1500\n2023    03       2000\n2023    04       1800\n\n```sql\nSELECT YEAR, MONTH, AMOUNT,\n       LAG(AMOUNT, 1, 0) OVER (ORDER BY YEAR, MONTH) AS PREV_AMOUNT\nFROM SALES;```', 3, '9회차', '다음과 같은 테이블에서 WINDOW 함수를 사용한 결과로 올바른 것은?', 'LAG 함수는 이전 행의 값을 반환합니다. LAG(AMOUNT, 1, 0)는 이전 달의 판매액을 보여주며, 첫 번째 행은 0을 반환합니다.', NULL, 22),
	(1144, 3, NULL, 2, '9회차', '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Durability(영속성)는 성공적으로 완료된 트랜잭션의 결과가 영구적으로 반영되어야 한다는 의미입니다. 시스템 장애 발생 시 자동 롤백과는 관련이 없습니다.', NULL, 28),
	(1145, 3, '[ORGANIZATION]\nEMP_ID    MANAGER_ID    EMP_NAME\n---------------------------------\n1         NULL          김사장\n2         1             이부장\n3         1             박부장\n4         2             최과장\n5         2             정과장', 3, '9회차', '다음과 같은 계층형 구조의 데이터를 조회하는 SQL문으로 가장 적절한 것은?', '계층형 구조를 조회할 때는 START WITH로 시작점을 지정하고, CONNECT BY PRIOR로 부모-자식 관계를 정의합니다.', NULL, 24),
	(1146, 3, NULL, 2, '9회차', '다음 중 DCL(Data Control Language)에 해당하지 않는 것은?', 'COMMIT은 TCL(Transaction Control Language)에 속합니다. DCL은 GRANT, REVOKE, DENY 등이 있습니다.', NULL, 30),
	(1147, 3, '```sql\nSELECT ROUND(123.456, 2),\n       ROUND(123.456, 0),\n       ROUND(123.456, -1)\nFROM DUAL;```', 2, '9회차', '다음 SQL문의 실행 결과로 옳은 것은?', 'ROUND 함수는 지정된 소수점 자리에서 반올림합니다. 2는 소수점 둘째 자리, 0은 정수, -1은 십의 자리에서 반올림합니다.', NULL, 13),
	(1148, 3, '```sql\nSELECT DEPTNO, COUNT(*) \nFROM EMP \nWHERE SAL > 2000 \nGROUP BY DEPTNO \nHAVING COUNT(*) > 1 \nORDER BY DEPTNO;```', 2, '9회차', '다음 SQL문에서 실행 순서가 올바른 것은?', 'SQL 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 순입니다.', NULL, 12),
	(1149, 3, NULL, 2, '9회차', '다음 중 UNION과 UNION ALL의 차이점으로 옳지 않은 것은?', 'UNION과 UNION ALL 모두 열의 개수가 동일해야 하는 것은 맞는 설명입니다. 틀린 설명은 없습니다.', NULL, 20),
	(1150, 3, NULL, 2, '9회차', '다음 중 인덱스(Index)에 대한 설명으로 틀린 것은?', '인덱스가 있으면 DELETE 연산 시 인덱스도 함께 갱신해야 하므로 오히려 성능이 저하될 수 있습니다.', NULL, 11),
	(1151, 3, '[EMPLOYEE]\nEMP_ID    SALARY\n-------------------\n101       5000\n102       4000\n103       6000\n104       3000\n105       5500', 3, '9회차', '다음 테이블에서 ROWNUM을 사용한 쿼리 중 잘못된 것은?', 'ROWNUM을 WHERE 절에서 직접 사용하고 ORDER BY를 나중에 하면 원하는 결과를 얻을 수 없습니다. 정렬을 먼저 하고 ROWNUM을 적용해야 합니다.', NULL, 23),
	(1152, 3, NULL, 2, '9회차', '다음 중 NULL 값과 관련된 설명으로 올바르지 않은 것은?', 'NULL과 NULL은 서로 같다고 판단할 수 없습니다. NULL끼리의 비교는 UNKNOWN을 반환합니다.', NULL, 9),
	(1153, 3, '```sql\nSELECT LTRIM(\'***ORACLE***\', \'*\'),\n       RTRIM(\'***ORACLE***\', \'*\'),\n       TRIM(\'*\' FROM \'***ORACLE***\')\nFROM DUAL;```', 2, '9회차', '다음 SQL문의 실행 결과로 알맞은 것은?', 'LTRIM은 왼쪽에서, RTRIM은 오른쪽에서, TRIM은 양쪽에서 지정된 문자를 제거합니다.', NULL, 13),
	(1154, 3, '[SALES]\nDEPT    YEAR    AMOUNT\n------------------------\nA       2023    1000\nA       2024    2000\nB       2023    1500\nB       2024    2500\n\n```sql\nSELECT DEPT, YEAR, SUM(AMOUNT)\nFROM SALES\nGROUP BY ROLLUP(DEPT, YEAR);```', 3, '9회차', '다음과 같은 테이블이 있을 때, ROLLUP을 사용한 SQL문의 결과로 올바른 것은?', 'ROLLUP은 지정된 컬럼의 소계와 전체 합계를 생성합니다. DEPT, YEAR에 대한 개별 그룹(4행) + DEPT별 소계(2행) + 전체 합계(1행) = 총 7행이 출력됩니다.', NULL, 21),
	(1155, 3, NULL, 2, '9회차', '다음 중 WITH절(Common Table Expression)에 대한 설명으로 틀린 것은?', 'WITH절은 쿼리가 완전히 종료될 때까지 메모리에 유지됩니다. 즉시 삭제되지 않습니다.', NULL, 19),
	(1156, 3, '```sql\nWITH TEMP AS (\n    SELECT 1 AS NUM FROM DUAL UNION ALL\n    SELECT 2 FROM DUAL UNION ALL\n    SELECT 3 FROM DUAL\n)\nSELECT SUM(NUM) OVER (ORDER BY NUM\n    ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS RESULT\nFROM TEMP;```', 3, '9회차', '다음 SQL문의 실행 결과는?', '윈도우 절의 ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING은 현재 행을 중심으로 이전 행과 다음 행의 값을 합산합니다. 따라서 1+2=3, 1+2+3=6, 2+3=5가 됩니다.', NULL, 22),
	(1157, 3, NULL, 2, '9회차', '다음 중 윈도우 함수(Window Function)에 대한 설명으로 올바르지 않은 것은?', '윈도우 함수는 WHERE 절에서 사용할 수 없습니다. SELECT, ORDER BY 절에서만 사용 가능합니다.', NULL, 22),
	(1158, 3, '[PRODUCT]\nPROD_CD    STATUS\n--------------------\nA001       1\nA002       2\nA003       3\nA004       NULL', 2, '9회차', '다음과 같은 테이블에서 DECODE 함수를 사용한 결과로 잘못된 것은?', 'DECODE 함수에서 \'진행\', \'완료\'는 각각 독립된 조건과 결과값으로 해석되어 의도한 대로 동작하지 않습니다.', NULL, 13),
	(1159, 3, NULL, 2, '9회차', '다음 중 인라인 뷰(Inline View)에 대한 설명으로 틀린 것은?', '인라인 뷰에서도 ORDER BY 절을 사용할 수 있습니다. 특히 TOP-N 쿼리 등에서 자주 사용됩니다.', NULL, 19),
	(1160, 3, '```sql\nCREATE TABLE TEST (COL1 NUMBER);\nINSERT INTO TEST VALUES (1);\nINSERT INTO TEST VALUES (2);\nSAVEPOINT S1;\nINSERT INTO TEST VALUES (3);\nROLLBACK TO S1;\nINSERT INTO TEST VALUES (4);\nCOMMIT;\n\nSELECT COUNT(*) FROM TEST;```', 2, '9회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SAVEPOINT S1까지 2개의 행이 삽입되고, ROLLBACK TO S1으로 3번째 INSERT가 취소되며, 마지막 INSERT와 COMMIT으로 최종적으로 3개의 행이 남게 됩니다.', NULL, 28),
	(1161, 3, '[EMP]\nDEPT_ID    SALARY\n------------------\n10         5000\n10         4000\n20         3000\n20         3500\n30         4500', 3, '9회차', '다음과 같은 테이블에서 부서별 평균 급여가 전체 평균 급여보다 높은 부서를 조회하는 SQL문으로 올바른 것은?', '부서별 평균 급여와 전체 평균 급여를 비교하기 위해서는 HAVING 절에서 서브쿼리를 사용해야 합니다.', NULL, 19),
	(1162, 3, '[SALES]\nQUARTER    AMOUNT\n------------------\nQ1         1000\nQ2         2000\nQ1         1500\nQ2         2500', 3, '9회차', '다음 중 PIVOT 함수를 사용한 결과로 올바르지 않은 것은?', 'PIVOT 함수에서는 하나의 집계 함수만 사용할 수 있습니다. 여러 집계 함수를 동시에 사용할 수 없습니다.', NULL, 25),
	(1163, 3, NULL, 2, '9회차', '다음 중 트랜잭션 격리 수준(Transaction Isolation Level)에 대한 설명으로 틀린 것은?', '트랜잭션 격리 수준이 높을수록 동시성은 낮아지고 데이터 정합성은 높아집니다.', NULL, 28),
	(1164, 3, '```sql\nSELECT LEVEL, CONNECT_BY_ISLEAF\nFROM DUAL\nCONNECT BY LEVEL <= 3;```', 3, '9회차', '다음 SQL문의 실행 결과는?', 'CONNECT_BY_ISLEAF는 계층형 쿼리에서 리프 노드(자식이 없는 노드)일 경우 1, 아닐 경우 0을 반환합니다.', NULL, 24),
	(1165, 3, '[EMPLOYEE]\nEMP_ID    DEPT_ID    SALARY    BONUS\n----------------------------------------\n1         10         5000      NULL\n2         10         4000      500\n3         20         3000      NULL\n4         20         3500      300', 2, '9회차', '다음과 같은 테이블에서 올바른 SQL문은?', 'NULL 값이 포함된 계산을 할 때는 NVL 함수를 사용하여 NULL을 다른 값으로 대체해야 정확한 결과를 얻을 수 있습니다.', NULL, 13),
	(1166, 3, NULL, 2, '9회차', '다음 중 FOREIGN KEY 제약조건에 대한 설명으로 틀린 것은?', '외래키로 지정된 컬럼은 NULL 값을 가질 수 있습니다. 이는 선택적 참조 무결성을 지원하기 위한 것입니다.', NULL, 29),
	(1167, 3, NULL, 3, '9회차', '다음 중 DML(Data Manipulation Language) 성능을 향상시키는 방법으로 적절하지 않은 것은?', 'COMMIT을 자주 수행하면 UNDO 세그먼트를 자주 사용하게 되어 성능이 저하될 수 있습니다. 대량 DML 작업 시에는 적절한 COMMIT 주기를 설정해야 합니다.', NULL, 27),
	(1168, 3, '[NUMBERS]\nNUM\n----\n1\n2\n3\n5\n6\n8\n9', 3, '9회차', '다음과 같은 테이블이 있을 때, 연속된 숫자를 찾는 SQL문으로 올바른 것은?', 'ROW_NUMBER() 함수와 숫자의 차이값을 이용하면 연속된 숫자들을 그룹화할 수 있습니다.', NULL, 22),
	(1169, 3, NULL, 2, '9회차', '다음 중 VIEW에 대한 설명으로 틀린 것은?', '단순 뷰라도 집계 함수나 DISTINCT를 포함하는 경우 DML이 불가능할 수 있습니다.', NULL, 29),
	(1170, 3, '```sql\nSELECT CAST(\'2024-01-01\' AS DATE) + 1,\n       ADD_MONTHS(\'2024-01-01\', 2),\n       MONTHS_BETWEEN(\'2024-03-01\', \'2024-01-01\')\nFROM DUAL;```', 2, '9회차', '다음 SQL문의 실행 결과로 올바른 것은?', '날짜에 1을 더하면 하루가 증가하고, ADD_MONTHS는 지정된 개월 수를 더하며, MONTHS_BETWEEN은 두 날짜 간의 개월 수 차이를 반환합니다.', NULL, 13),
	(1171, 3, NULL, 2, '10회차', '다음 중 엔터티 도출 시 고려해야 할 사항으로 가장 부적절한 것은?', '엔터티는 물리적인 형태로 존재하지 않더라도, 업무적으로 관리가 필요한 개념적 정보라면 엔터티가 될 수 있습니다. 예를 들어 \'계약\', \'거래\' 등은 물리적 형태는 없지만 엔터티가 될 수 있습니다.', NULL, 2),
	(1172, 3, NULL, 2, '10회차', '다음 중 속성(Attribute)의 특성으로 올바른 것은?', '속성은 업무상 구체적인 의미를 가지는 더 이상 분리될 수 없는 데이터의 최소 단위입니다. 하나의 속성은 한 개의 값만 가질 수 있으며, 기본키는 NULL 값을 가질 수 없습니다.', NULL, 3),
	(1173, 3, '```\n[고객] -----○--< [주문]\n```', 2, '10회차', '다음 보기의 ERD에 대한 설명으로 가장 올바르지 않은 것은?', '주어진 ERD에서 실선으로 표시된 관계는 필수관계를 나타냅니다. 따라서 주문은 반드시 하나의 고객에 속해야 하며, 고객 없이 존재할 수 없습니다.', NULL, 4),
	(1174, 3, '"시간에 따라 변하는 값을 이력으로 관리하기 위한 속성으로, 실제 업무상 필요한 데이터가 아닌 데이터 모델링 시 필요에 따라 생성하는 속성"', 2, '10회차', '아래의 정의에 해당하는 것은 무엇인가?', '설계 속성은 업무상 필요한 데이터가 아닌, 데이터 모델링 시 필요에 따라 생성하는 속성을 의미합니다. 시작일자, 종료일자, 이력번호 등이 대표적인 예입니다.', NULL, 3),
	(1175, 3, NULL, 2, '10회차', '엔터티의 주식별자 도출 기준으로 가장 부적절한 것은?', '이름이나 설명과 같은 속성은 변경될 가능성이 높고 중복될 수 있으므로 주식별자로 적절하지 않습니다. 주식별자는 안정적이고 유일한 값을 가져야 합니다.', NULL, 5),
	(1176, 3, NULL, 2, '10회차', '다음 중 정규화에 대한 설명으로 가장 올바르지 않은 것은?', '정규화는 조회 시 조인을 유발할 수 있어 항상 성능이 향상되는 것은 아닙니다. 때로는 성능 향상을 위해 반정규화를 고려해야 할 수 있습니다.', NULL, 6),
	(1177, 3, NULL, 2, '10회차', '다음 중 슈퍼타입/서브타입 변환 시 고려사항이 아닌 것은?', '슈퍼타입/서브타입 변환 시 고려사항은 데이터 볼륨, 조회 성능, 트랜잭션의 유형, 확장성 등입니다. 테이블 이름은 주요 고려사항이 아닙니다.', NULL, 3),
	(1178, 3, NULL, 3, '10회차', '다음 중 관계 유형에 대한 설명으로 옳은 것은?', '식별관계에서는 부모 테이블의 기본키가 자식 테이블의 기본키의 일부로 전이됩니다. 비식별관계는 점선으로 표현되며, 항상 성능을 저하시키는 것은 아닙니다.', NULL, 4),
	(1179, 3, NULL, 2, '10회차', '다음 중 도메인(Domain)에 대한 설명으로 가장 부적절한 것은?', '도메인은 테이블 생성 시 반드시 지정해야 하는 것이 아닙니다. 도메인은 속성이 가질 수 있는 값의 범위를 정의하는 것입니다.', NULL, 3),
	(1180, 3, NULL, 2, '10회차', '다음 중 반정규화(Denormalization)를 고려해야 하는 경우가 아닌 것은?', '데이터의 일관성이 중요한 경우는 오히려 정규화를 유지해야 합니다. 반정규화는 데이터의 중복을 허용하므로 일관성이 저하될 수 있습니다.', NULL, 6),
	(1181, 3, '[EMPLOYEE]\nEMP_ID    DEPT_ID    NAME    SALARY\n----------------------------------------\n1001      10         김유신    5000\n1002      10         이순신    4500\n1003      20         강감찬    5500\n1004      20         을지문덕  4800\n1005      30         정약용    4700', 3, '10회차', '다음과 같은 테이블이 있을 때, 부서별 최고 급여자의 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최고 급여자의 모든 정보를 조회하기 위해서는 상관 서브쿼리(Correlated Subquery)를 사용해야 합니다. 각 직원의 급여가 자신이 속한 부서의 최대 급여와 같은지 비교합니다.', NULL, 19),
	(1182, 3, NULL, 2, '10회차', '다음 중 GROUP BY 절에 대한 설명으로 옳지 않은 것은?', 'GROUP BY 절에는 SELECT 목록에 있는 집계 함수를 제외한 모든 컬럼이 포함되어야 합니다. 반대로 GROUP BY 절에 있는 모든 컬럼이 SELECT 목록에 포함될 필요는 없습니다.', NULL, 15),
	(1183, 3, '```sql\nSELECT SUBSTR(\'ORACLE SQL\', -3, 2)\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'SUBSTR 함수에서 음수 위치는 문자열 끝에서부터 계산됩니다. -3은 뒤에서 3번째 위치(\'S\')에서 시작하여 2글자를 추출하므로 \'SQ\'가 됩니다.', NULL, 13),
	(1184, 3, '[DEPT]\nDEPT_ID    DEPT_NAME\n---------------------\n10         인사부\n20         영업부\n30         개발부\n\n[EMP]\nEMP_ID    DEPT_ID    EMP_NAME\n--------------------------------\n1         10         김사원\n2         20         이사원\n3         40         박사원\n\n```sql\nSELECT D.DEPT_NAME, E.EMP_NAME\nFROM DEPT D LEFT OUTER JOIN EMP E\nON D.DEPT_ID = E.DEPT_ID;```', 2, '10회차', '다음과 같은 테이블에서 올바른 조인 결과는?', 'LEFT OUTER JOIN은 왼쪽 테이블(DEPT)의 모든 행과 오른쪽 테이블(EMP)의 매칭되는 행을 반환합니다. 개발부(30)는 매칭되는 사원이 없으므로 NULL로 출력되어 총 3행이 조회됩니다.', NULL, 17),
	(1185, 3, NULL, 2, '10회차', '다음 중 윈도우 함수에 대한 설명으로 틀린 것은?', '윈도우 함수는 GROUP BY 절에서 사용할 수 없습니다. SELECT 절과 ORDER BY 절에서만 사용할 수 있습니다.', NULL, 22),
	(1186, 3, '```sql\nSELECT CASE WHEN NULL = NULL THEN \'TRUE\'\n            WHEN NULL IS NULL THEN \'IS NULL\'\n            ELSE \'FALSE\' END AS RESULT\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'NULL과 NULL의 비교는 알 수 없는 결과(UNKNOWN)를 반환하므로 첫 번째 조건은 FALSE가 됩니다. NULL IS NULL은 TRUE를 반환하므로 \'IS NULL\'이 결과가 됩니다.', NULL, 13),
	(1187, 3, NULL, 2, '10회차', '다음 중 MERGE 문에 대한 설명으로 옳지 않은 것은?', 'MERGE 문에서는 WHEN NOT MATCHED THEN DELETE를 사용할 수 없습니다. DELETE는 WHEN MATCHED THEN 절에서만 사용할 수 있습니다.', NULL, 27),
	(1188, 3, '```sql\nSELECT LEVEL\nFROM DUAL\nCONNECT BY LEVEL <= 3\nSTART WITH LEVEL = 1;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'CONNECT BY LEVEL <= 3은 1부터 3까지의 연속된 숫자를 생성합니다. START WITH LEVEL = 1은 시작점을 지정합니다.', NULL, 24),
	(1189, 3, NULL, 2, '10회차', '다음 중 집합 연산자에 대한 설명으로 옳은 것은?', 'UNION은 중복을 제거하고 자동으로 정렬된 결과를 반환합니다. INTERSECT는 교집합, MINUS는 차집합을 반환합니다.', NULL, 20),
	(1190, 3, '[ATTENDANCE]\nSTUDENT_ID   ABSENT_DATE\n--------------------------\nA001         2024-01-01\nA001         2024-01-02\nA001         2024-01-03\nA001         2024-01-05', 3, '10회차', '다음과 같은 테이블에서 연속된 결석일을 찾는 SQL문으로 가장 적절한 것은?', '연속된 날짜를 찾기 위해서는 날짜와 행 번호의 차이가 같은 그룹을 찾아야 합니다. ROW_NUMBER()와 GROUP BY를 활용한 방법이 가장 적절합니다.', NULL, 22),
	(1191, 3, '[EMPLOYEE]\nEMP_ID    SALARY    COMMISSION\n-------------------------------\n101       5000      1000\n102       4000      NULL\n103       3000      500\n\n```sql\nUPDATE EMPLOYEE\nSET SALARY = SALARY + COMMISSION;```', 2, '10회차', '다음과 같은 테이블에서 UPDATE문이 실행될 때 발생하는 결과로 올바른 것은?', 'NULL과 숫자의 연산은 NULL을 반환합니다. 따라서 NULL이 포함된 행의 연산 결과는 NULL이 되어 SALARY가 NULL이 되므로 오류가 발생합니다.', NULL, 27),
	(1192, 3, NULL, 2, '10회차', '다음 중 WITH절(Common Table Expression)의 특징으로 올바르지 않은 것은?', 'WITH절은 쿼리가 완전히 종료될 때까지 메모리에 유지됩니다. 즉시 삭제되지 않습니다.', NULL, 19),
	(1193, 3, '```sql\nSELECT REGEXP_REPLACE(\'SQL Developer 2024\', \'[0-9]\', \'*\')\nFROM DUAL;```', 2, '10회차', '아래의 SQL 실행 결과로 올바른 것은?', 'REGEXP_REPLACE 함수는 모든 숫자를 \'*\'로 치환합니다. 따라서 \'2024\'의 모든 숫자가 \'*\'로 바뀝니다.', NULL, 26),
	(1194, 3, '- 고객번호는 오름차순\n- 주문금액은 내림차순\n- 주문일자는 오름차순', 2, '10회차', '다음 조건을 만족하는 ORDER BY 절로 올바른 것은?', 'ORDER BY 절에서 여러 컬럼의 정렬 방향을 각각 지정할 수 있습니다. ASC는 생략 가능합니다.', NULL, 16),
	(1195, 3, NULL, 2, '10회차', '다음 중 인덱스를 사용할 수 없는 경우는?', '인덱스 컬럼에 함수가 적용되면 인덱스를 사용할 수 없습니다. 이를 방지하려면 함수 기반 인덱스를 별도로 생성해야 합니다.', NULL, 11),
	(1196, 3, '```sql\nCREATE TABLE TEST (\n    ID NUMBER,\n    CODE CHAR(2) DEFAULT \'01\',\n    NAME VARCHAR2(10) NOT NULL\n);```', 2, '10회차', '아래의 DDL문에서 발생하는 결과로 올바른 것은?', 'NAME 컬럼은 NOT NULL 제약조건이 있어 NULL 값을 입력할 수 없습니다. 두 번째 INSERT문은 이 제약조건을 위배합니다.', NULL, 29),
	(1197, 3, '```sql\nSELECT TO_CHAR(SYSDATE, \'YYYY/MM/DD HH24:MI:SS\') AS NOW,\n       TO_CHAR(SYSDATE + 1/24, \'YYYY/MM/DD HH24:MI:SS\') AS AFTER_1HOUR\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'SYSDATE + 1/24는 현재 시간에 1시간을 더한 결과를 반환합니다. 하루는 24시간이므로 1/24는 1시간을 의미합니다.', NULL, 13),
	(1198, 3, NULL, 2, '10회차', '다음 중 DISTINCT 키워드의 사용으로 올바르지 않은 것은?', 'DISTINCT는 함수가 아니라 키워드이므로 괄호로 묶어 사용하는 것은 문법적으로 올바르지 않습니다.', NULL, 12),
	(1199, 3, '[EMP]\nEMP_ID    DEPT_ID    SALARY\n---------------------------\n101       10         5000\n102       10         4000\n103       20         6000\n104       20         5500', 3, '10회차', '다음과 같은 테이블에서 부서별 최고 급여자를 찾는 SQL문 중 성능이 가장 좋은 것은?', '복합 IN 절을 사용하는 방식이 가장 효율적입니다. 그룹화된 결과를 한 번만 스캔하여 결과를 얻을 수 있기 때문입니다.', NULL, 19),
	(1200, 3, NULL, 2, '10회차', '다음 중 테이블 스페이스(Tablespace)에 대한 설명으로 올바르지 않은 것은?', '하나의 테이블은 하나의 테이블스페이스에만 저장됩니다. 여러 테이블스페이스에 나누어 저장될 수 없습니다.', NULL, 11),
	(1201, 3, '[EMPLOYEE]\nEMP_ID    MANAGER_ID    NAME    LEVEL\n----------------------------------------\n1         NULL          김사장    1\n2         1             박부장    2\n3         1             이부장    2\n4         2             최대리    3\n5         2             정과장    3', 3, '10회차', '다음과 같은 테이블에서 계층형 쿼리를 사용해 직원의 조직도를 출력하는 SQL문으로 가장 적절한 것은?', '계층형 쿼리에서 CONNECT BY PRIOR EMP_ID = MANAGER_ID는 현재 행의 EMP_ID를 상위 행의 MANAGER_ID와 연결하는 구문입니다. 이는 하향식 계층 구조를 만듭니다.', NULL, 24),
	(1202, 3, NULL, 2, '10회차', '다음 중 SEQUENCE에 대한 설명으로 옳지 않은 것은?', 'CURRVAL은 현재 세션에서 NEXTVAL을 최소 한 번 실행한 후에만 사용할 수 있습니다. NEXTVAL을 실행하지 않은 상태에서 CURRVAL을 사용하면 오류가 발생합니다.', NULL, 29),
	(1203, 3, '```sql\nSELECT GREATEST(3, NULL, 5, 2), \n       LEAST(3, NULL, 5, 2)\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'NULL이 포함된 계산에서 GREATEST와 LEAST는 모두 NULL을 반환합니다.', NULL, 13),
	(1204, 3, '[EMPLOYEE]\nDEPT_ID    EMP_NAME\n--------------------\n10         김사원\n10         이사원\n20         박사원\n20         최사원\n30         정사원\n\n```sql\nSELECT DEPT_ID,\n       LISTAGG(EMP_NAME, \',\') WITHIN GROUP (ORDER BY EMP_NAME)\nFROM EMPLOYEE\nGROUP BY DEPT_ID;```', 2, '10회차', '다음과 같은 테이블이 있을 때, LISTAGG 함수를 사용한 결과로 올바른 것은?', 'LISTAGG 함수는 그룹별로 데이터를 연결하여 하나의 문자열로 만듭니다. WITHIN GROUP절의 ORDER BY에 따라 정렬된 순서로 연결됩니다.', NULL, 21),
	(1205, 3, NULL, 2, '10회차', '다음 중 SELECT 문의 실행 순서로 올바른 것은?', 'SELECT 문의 논리적 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다.', NULL, 12),
	(1206, 3, '```sql\nSELECT CAST(\'2024-01-01\' AS DATE) + INTERVAL \'1\' HOUR,\n       CAST(\'2024-01-01\' AS DATE) + 1/24\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', '두 표현식 모두 현재 시간에 1시간을 더하는 것으로, 동일한 결과를 반환합니다.', NULL, 13),
	(1207, 3, '[TRANSACTIONS]\nTRANS_ID    TRANS_DATE    AMOUNT\n---------------------------------\n1           2024-01-01    1000\n2           2024-01-02    2000\n3           2024-01-03    1500\n4           2024-01-04    3000\n5           2024-01-05    2500', 2, '10회차', '다음과 같은 데이터가 있을 때, 가장 최근 3개의 거래내역만 조회하는 SQL문으로 올바른 것은?', '최근 3개의 거래내역을 조회하기 위해서는 먼저 정렬을 수행한 후 상위 3개를 선택해야 합니다. 따라서 인라인 뷰를 사용한 두 번째 방법이 올바릅니다.', NULL, 23),
	(1208, 3, NULL, 2, '10회차', '다음 중 NULL 값에 대한 설명으로 틀린 것은?', 'NULL과 NULL의 비교는 FALSE가 아닌 UNKNOWN을 반환합니다.', NULL, 9),
	(1209, 3, NULL, 2, '10회차', '다음 중 DCL(Data Control Language)에 해당하지 않는 것은?', 'TRUNCATE는 DDL(Data Definition Language)에 속합니다. DCL은 데이터베이스의 접근 권한과 관련된 명령어들입니다.', NULL, 30),
	(1210, 3, '```sql\nSELECT ROUND(123.456, 2),\n       ROUND(123.456, 0),\n       ROUND(123.456, -1)\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'ROUND 함수는 지정된 소수점 자리에서 반올림합니다. 양수는 소수점 오른쪽, 0은 정수, 음수는 정수 왼쪽을 의미합니다.', NULL, 13),
	(1211, 3, '[SALES]\nYEAR    DEPT    AMOUNT\n------------------------\n2023    A       1000\n2023    B       2000\n2024    A       1500\n2024    B       2500', 3, '10회차', '다음과 같은 테이블에서 년도별, 부서별 매출 합계를 PIVOT을 사용하여 조회하는 SQL문으로 올바른 것은?', 'PIVOT 절은 행을 열로 변환합니다. 부서별 매출을 열로 표시하려면 FOR절에 DEPT를 지정해야 합니다.', NULL, 25),
	(1212, 3, NULL, 2, '10회차', '다음 중 인덱스(Index)의 특징으로 옳지 않은 것은?', '인덱스가 있으면 INSERT 시 인덱스도 함께 갱신해야 하므로 오히려 성능이 저하됩니다.', NULL, 11),
	(1213, 3, '```sql\nSELECT LEVEL, \n       LPAD(\' \', 2*(LEVEL-1)) || ENAME AS EMPLOYEE\nFROM EMP\nSTART WITH MGR IS NULL\nCONNECT BY PRIOR EMPNO = MGR;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'LPAD 함수를 사용하여 LEVEL에 따라 공백을 추가함으로써 계층형 구조를 시각적으로 표현합니다.', NULL, 24),
	(1214, 3, NULL, 2, '10회차', '다음 중 DML 성능을 향상시키는 방법으로 가장 적절하지 않은 것은?', '자주 COMMIT하면 UNDO 세그먼트를 자주 사용하게 되어 오히려 성능이 저하될 수 있습니다.', NULL, 27),
	(1215, 3, '[SALES]\nSALE_DATE    AMOUNT\n--------------------\n2024-01-01   1000\n2024-01-02   2000\n2024-01-03   1500\n2024-01-04   3000', 2, '10회차', '다음과 같은 테이블에서 누적 합계를 구하는 SQL문으로 올바른 것은?', '윈도우 함수에서 ORDER BY를 사용하면 누적 합계를 계산할 수 있습니다.', NULL, 22),
	(1216, 3, NULL, 2, '10회차', '다음 중 VIEW에 대한 설명으로 틀린 것은?', '뷰를 통해 INSERT된 데이터는 원본 테이블에 반영됩니다. 뷰는 가상 테이블이므로 독립적인 데이터 저장소가 없습니다.', NULL, 29),
	(1217, 3, '```sql\nCREATE TABLE TEST (\n    ID NUMBER PRIMARY KEY,\n    NAME VARCHAR2(10) NOT NULL UNIQUE\n);\n\nINSERT INTO TEST VALUES (1, \'AAA\');\nINSERT INTO TEST VALUES (2, \'BBB\');\nINSERT INTO TEST VALUES (1, \'CCC\');```', 2, '10회차', '다음 SQL문에서 발생하는 결과는?', '첫 두 개의 INSERT는 제약조건을 위배하지 않지만, 세 번째 INSERT는 PRIMARY KEY 제약조건을 위배하여 실패합니다.', NULL, 29),
	(1218, 3, NULL, 2, '10회차', '다음 중 ROLLUP과 CUBE의 차이점으로 옳은 것은?', 'ROLLUP은 지정된 컬럼의 계층적 집계를 생성하고, CUBE는 가능한 모든 조합의 집계를 생성합니다.', NULL, 21),
	(1219, 3, '[EMP]\nEMP_ID    DEPT_ID    SALARY\n---------------------------\n1001      10         5000\n1002      10         4000\n1003      20         6000\n1004      20         5500', 3, '10회차', '다음과 같은 테이블에서 부서별 평균 연봉보다 높은 연봉을 받는 직원을 조회하는 SQL문으로 올바른 것은?', '상관 서브쿼리를 사용하여 각 부서별 평균 급여를 계산하고, 이와 비교하여 높은 급여를 받는 직원을 찾습니다.', NULL, 19),
	(1220, 3, '```sql\nSELECT DECODE(NULL, NULL, \'A\',\n                    1, \'B\',\n                    2, \'C\',\n                    \'D\')\nFROM DUAL;```', 2, '10회차', '다음 SQL문의 실행 결과는?', 'DECODE에서 첫 번째 비교값과 두 번째 비교값이 모두 NULL이므로 \'A\'를 반환합니다.', NULL, 13),
	(1221, 3, NULL, 1, '11회차', '데이터 모델링의 특징이 아닌 것은?', '명확화는 누구나 이해하기 쉽게 표현하는 것이지만, 하나의 엔터티에 대해 여러 관점을 제시하는 것은 오히려 혼란을 야기할 수 있습니다. 데이터 모델링은 단일하고 명확한 관점을 제시해야 합니다.', NULL, 1),
	(1222, 3, NULL, 2, '11회차', '다음 중 ERD에서 관계를 정의할 때 체크해야 할 사항이 아닌 것은?', '인덱스 전략은 물리적 설계 단계에서 고려할 사항이며, ERD에서 관계를 정의할 때 체크해야 할 사항이 아닙니다.', NULL, 1),
	(1223, 3, NULL, 2, '11회차', '주식별자의 특성으로 올바르지 않은 것은?', '주식별자의 특성 중 하나는 불변성입니다. 한번 정해진 값은 변하지 않아야 하므로, 변경성은 주식별자의 특성이 될 수 없습니다.', NULL, 4),
	(1224, 3, NULL, 2, '11회차', '다음 중 엔터티의 분류 기준이 아닌 것은?', '스키마에 따른 내부/외부 엔터티 분류는 일반적인 엔터티 분류 기준이 아닙니다.', NULL, 2),
	(1225, 3, NULL, 1, '11회차', '아래의 정의에 해당하는 속성 유형은?\n"업무를 수행하면서 생성되는 속성으로 다른 속성으로부터 계산되어 생성되는 속성"', '파생 속성은 다른 속성으로부터 계산이나 변형되어 생성되는 속성을 의미합니다. 예를 들어 나이(생년월일로부터 계산), 합계금액(수량*단가) 등이 있습니다.', NULL, 3),
	(1226, 3, NULL, 2, '11회차', '다음 중 정규화 과정에서 발생할 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상은 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않습니다.', NULL, 7),
	(1227, 3, NULL, 2, '11회차', '관계의 정의가 올바르지 않은 것은?', '관계는 엔터티 간의 논리적인 연관성을 표현하는 것으로, 물리적인 형태로 존재할 필요가 없습니다.', NULL, 5),
	(1228, 3, NULL, 2, '11회차', '다음 중 반정규화를 고려해야 하는 경우가 아닌 것은?', '입력, 수정, 삭제의 성능이 중요한 경우에는 오히려 정규화를 유지하는 것이 좋습니다. 반정규화는 조회 성능을 향상시키기 위해 고려됩니다.', NULL, 9),
	(1229, 3, NULL, 3, '11회차', '다음 중 식별자 관계를 사용해야 하는 경우로 가장 부적절한 것은?', '데이터의 양은 식별자 관계를 결정하는 기준이 되지 않습니다. 식별자 관계는 업무적 연관성과 존재 종속성에 기반하여 결정해야 합니다.', NULL, 4),
	(1230, 3, NULL, 2, '11회차', 'M:M 관계를 해소하기 위한 방법으로 가장 적절한 것은?', 'M:M 관계는 새로운 관계엔터티를 생성하여 1:M, M:1 관계로 해소하는 것이 일반적입니다. 이를 통해 두 엔터티 간의 관계를 명확하게 표현할 수 있습니다.', NULL, 5),
	(1231, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 각 부서별 최고 연봉자의 정보를 조회하는 SQL문으로 올바른 것은?', '부서별 최고 연봉자를 찾기 위해서는 상관 서브쿼리를 사용하여 각 부서별로 최대 급여와 비교해야 합니다.', NULL, 17),
	(1232, 3, NULL, 2, '11회차', '다음 중 ROLLUP 함수와 CUBE 함수의 차이점으로 올바른 것은?', 'ROLLUP은 지정된 컬럼의 계층 구조로 소계를 계산하고, CUBE는 지정된 컬럼들의 모든 가능한 조합으로 소계를 계산합니다.', NULL, 21),
	(1233, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과는?', 'REPLACE는 특정 문자열을 다른 문자열로 대체하고, TRANSLATE는 지정된 문자를 일대일로 변환합니다. \'BC\'를 \'DE\'로 변환하므로 각각의 문자가 대체됩니다.', NULL, 13),
	(1234, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 모든 부서와 사원 정보를 조회하는 SQL문으로 올바른 것은?', '모든 부서 정보와 해당 부서의 사원 정보를 조회하기 위해서는 LEFT OUTER JOIN을 사용해야 합니다.', NULL, 17),
	(1235, 3, NULL, 2, '11회차', '다음 중 DELETE문에 대한 설명으로 틀린 것은?', 'DELETE문으로 삭제된 데이터는 트랜잭션이 COMMIT되기 전에는 ROLLBACK으로 복구할 수 있습니다.', NULL, 26),
	(1236, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'LAG는 이전 행의 값을, LEAD는 다음 행의 값을 가져오며, 값이 없는 경우 지정된 기본값(0)을 반환합니다.', NULL, 22),
	(1237, 3, NULL, 1, '11회차', '다음 중 WHERE 절에서 사용할 수 있는 연산자가 아닌 것은?', 'GROUP BY는 WHERE 절에서 사용할 수 없는 구문입니다. GROUP BY는 독립적인 절로 사용됩니다.', NULL, 14),
	(1238, 3, NULL, 1, '11회차', '다음 중 날짜 함수에 대한 설명으로 틀린 것은?', 'NEXT_DAY는 지정된 날짜로부터 명시된 요일이 처음으로 도래하는 날짜를 반환합니다. 반드시 주말을 반환하는 것은 아닙니다.', NULL, 12),
	(1239, 3, NULL, 2, '11회차', '다음과 같은 테이블이 있을 때, 부서별 평균 연봉보다 높은 연봉을 받는 직원을 조회하는 SQL문으로 올바른 것은?', '부서별 평균 연봉과 비교하기 위해서는 상관 서브쿼리를 사용하여 각 직원이 속한 부서의 평균 연봉을 구해야 합니다.', NULL, 17),
	(1240, 3, NULL, 1, '11회차', '다음 중 NULL 값에 대한 설명으로 올바르지 않은 것은?', 'NULL과 NULL은 같다고 판단할 수 없습니다. NULL과의 비교는 항상 UNKNOWN을 반환합니다.', NULL, 9),
	(1241, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과는?', 'CONNECT_BY_ISLEAF는 해당 노드가 리프 노드(자식이 없는 노드)일 경우 1, 아닐 경우 0을 반환합니다. LEVEL이 2와 3인 노드는 리프 노드입니다.', NULL, 24),
	(1242, 3, NULL, 2, '11회차', '다음 중 WITH절(Common Table Expression)의 특징이 아닌 것은?', 'WITH절은 쿼리가 완전히 종료될 때까지 메모리에 유지됩니다. 즉시 삭제되지 않습니다.', NULL, 20),
	(1243, 3, NULL, 2, '11회차', '다음과 같은 테이블이 있을 때, MERGE문을 사용하는 가장 적절한 경우는?', 'MERGE문은 조건에 따라 UPDATE 또는 INSERT를 수행할 때 사용하는 것이 가장 적절합니다.', NULL, 27),
	(1244, 3, NULL, 2, '11회차', '다음 중 인덱스를 생성하는 것이 가장 부적절한 경우는?', 'NULL값이 많은 컬럼은 인덱스의 효율성이 떨어지므로 인덱스 생성이 부적절합니다.', NULL, 30),
	(1245, 3, NULL, 2, '11회차', '다음 SQL문이 실행될 때의 결과로 올바른 것은?', 'UNIQUE 제약조건으로 인해 동일한 NAME 값을 가진 두 번째 INSERT문은 실패합니다.', NULL, 28),
	(1246, 3, NULL, 2, '11회차', '다음 중 트랜잭션의 ACID 특성으로 올바르지 않은 것은?', 'Isolation(격리성)은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 보장하는 것을 의미합니다. 반드시 완료될 때까지 대기하는 것은 아닙니다.', NULL, 29),
	(1247, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과는?', 'TO_NUMBER(\'123.45\')는 오류가 발생합니다. 소수점이 있는 문자열은 TO_NUMBER 함수로 직접 변환할 수 없습니다.', NULL, 13),
	(1248, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 누적 합계를 구하는 SQL문으로 올바른 것은?', '윈도우 함수를 사용하여 ORDER BY와 함께 SUM을 적용하면 누적 합계를 구할 수 있습니다.', NULL, 22),
	(1249, 3, NULL, 1, '11회차', '다음 중 DDL(Data Definition Language)에 해당하지 않는 것은?', 'COMMIT은 TCL(Transaction Control Language)에 속합니다. DDL은 데이터베이스의 구조를 정의하는 명령어들입니다.', NULL, 30),
	(1250, 3, NULL, 2, '11회차', '다음 중 NULL 관련 함수의 설명으로 틀린 것은?', 'COALESCE는 지정된 표현식들 중에서 첫 번째로 NULL이 아닌 값을 반환합니다. 반드시 첫 번째 값이 아닐 수 있습니다.', NULL, 9),
	(1251, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 부서별로 급여 순위를 매기는 SQL문으로 올바른 것은?', '부서별로 급여 순위를 매기기 위해서는 PARTITION BY와 ORDER BY를 함께 사용해야 합니다.', NULL, 22),
	(1252, 3, NULL, 2, '11회차', '다음 중 EXISTS 연산자의 특징으로 올바르지 않은 것은?', 'EXISTS는 조건을 만족하는 행을 찾으면 즉시 검색을 중단합니다. 모든 행을 검색하지 않습니다.', NULL, 20),
	(1253, 3, NULL, 1, '11회차', '다음 SQL문의 실행 결과는?', 'MOD는 나머지(1), CEIL은 올림(4), FLOOR는 내림(3), ROUND는 반올림(3.6)을 반환합니다.', NULL, 13),
	(1254, 3, NULL, 1, '11회차', '다음 중 GROUP BY절에 대한 설명으로 틀린 것은?', 'GROUP BY절에 있는 컬럼이 SELECT절에 반드시 포함될 필요는 없습니다.', NULL, 15),
	(1255, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 중복된 데이터를 제거하는 SQL문으로 가장 효율적인 것은?', 'ROWID를 이용한 방법이 가장 효율적입니다. 각 행의 고유한 식별자를 사용하여 중복을 제거합니다.', NULL, 27),
	(1256, 3, NULL, 2, '11회차', '다음 중 조인(JOIN)의 특징으로 올바르지 않은 것은?', 'LEFT OUTER JOIN은 왼쪽 테이블의 모든 데이터를 포함합니다. 오른쪽 테이블의 모든 데이터를 포함하는 것은 RIGHT OUTER JOIN입니다.', NULL, 17),
	(1257, 3, NULL, 1, '11회차', '다음 SQL문의 실행 결과는?', 'EXTRACT 함수는 날짜에서 특정 부분을 숫자형으로 추출합니다.', NULL, 12),
	(1258, 3, NULL, 2, '11회차', '다음 중 서브쿼리의 특징으로 틀린 것은?', '서브쿼리에서는 ORDER BY절을 사용할 수 없습니다. ORDER BY는 전체 쿼리의 마지막 결과를 정렬할 때만 사용됩니다.', NULL, 20),
	(1259, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 PIVOT을 사용한 결과로 올바른 것은?', 'PIVOT은 행을 열로 변환하며, 지정된 그룹화 함수(SUM)의 결과를 표시합니다.', NULL, 25),
	(1260, 3, NULL, 3, '11회차', '다음 중 데이터베이스 트랜잭션의 격리 수준으로 가장 높은 것은?', '트랜잭션 격리 수준은 READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE 순으로 높아집니다.', NULL, 29),
	(1261, 3, NULL, 3, '11회차', '다음과 같은 테이블에서 각 월별 매출액과 전월 대비 증감률을 구하는 SQL문으로 올바른 것은?', 'LAG 함수를 사용하여 이전 월의 매출액을 가져오고, 이를 통해 증감률을 계산합니다.', NULL, 22),
	(1262, 3, NULL, 2, '11회차', '다음 중 테이블 스페이스(Tablespace)에 대한 설명으로 옳지 않은 것은?', '하나의 테이블은 하나의 테이블스페이스에만 저장됩니다. 여러 테이블스페이스에 분산 저장될 수 없습니다.', NULL, 30),
	(1263, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 계층형 질의를 사용한 결과로 올바른 것은?', 'LPAD 함수를 사용하여 레벨에 따른 들여쓰기를 적용하여 계층 구조를 표현합니다.', NULL, 24),
	(1264, 3, NULL, 2, '11회차', '다음과 같은 테이블이 있을 때, MERGE 문을 사용하는 적절한 경우는?', 'MERGE문은 데이터가 존재하면 UPDATE하고 없으면 INSERT하는 경우에 적절합니다.', NULL, 27),
	(1265, 3, NULL, 2, '11회차', '다음 중 인덱스(Index)의 특징으로 올바르지 않은 것은?', '데이터의 수정이 빈번한 컬럼에 인덱스를 생성하면 성능이 저하될 수 있습니다.', NULL, 30),
	(1266, 3, NULL, 3, '11회차', '다음과 같은 데이터가 있을 때, 부서별 최근 3명의 입사자를 조회하는 SQL문으로 옳은 것은?', 'ROW_NUMBER()와 PARTITION BY를 사용하여 부서별로 입사일자 순으로 순번을 부여하고 최근 3명을 선택합니다.', NULL, 22),
	(1267, 3, NULL, 2, '11회차', '다음 SQL문의 실행 결과로 올바른 것은?', 'INSTR은 문자열에서 특정 문자의 위치를 반환하며, 찾지 못한 경우 0을 반환합니다.', NULL, 13),
	(1268, 3, NULL, 2, '11회차', '다음 중 트랜잭션에 대한 설명으로 틀린 것은?', 'SAVEPOINT는 부분 ROLLBACK을 위한 것이며, 부분 COMMIT은 불가능합니다.', NULL, 29),
	(1269, 3, NULL, 2, '11회차', '다음과 같은 테이블에서 부서별 직급별 평균 급여를 조회하는 SQL문으로 올바른 것은?', '부서별, 직급별 평균 급여를 구하기 위해서는 GROUP BY절에 두 컬럼을 모두 지정해야 합니다.', NULL, 15),
	(1270, 3, NULL, 1, '11회차', '다음 중 PL/SQL의 특징이 아닌 것은?', 'PL/SQL에서는 COMMIT, ROLLBACK 등의 트랜잭션 제어가 가능합니다.', NULL, 26),
	(1271, 3, NULL, 2, '12회차', '다음 중 엔터티(Entity)의 분류 방식으로 가장 부적절한 것은?', '엔터티의 일반적인 분류는 유형/개념 엔터티, 기본/중심/행위 엔터티, 실체/가상 엔터티입니다. "기초 엔터티와 행위 엔터티"는 분류 기준으로 적절하지 않습니다.', NULL, 2),
	(1272, 3, NULL, 2, '12회차', '아래의 설명에 해당하는 것은?\n"두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가진다."', '행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 이력 데이터를 저장하기 위한 엔터티로, 자주 내용이 바뀌거나 데이터량이 증가되는 특징을 가집니다.', NULL, 2),
	(1273, 3, NULL, 2, '12회차', '다음 중 관계(Relationship)의 표기법에 포함되지 않는 것은?', '관계의 표기법에는 관계명, 관계차수, 관계선택사양이 포함됩니다. 관계스키마는 관계의 표기법에 포함되지 않습니다.', NULL, 5),
	(1274, 3, NULL, 2, '12회차', '다음 중 식별자가 가져야 할 특징이 아닌 것은?', '식별자의 특성에는 유일성, 최소성, 불변성, 존재성이 있습니다. 대체성은 식별자의 특성이 아닙니다.', NULL, 4),
	(1275, 3, NULL, 1, '12회차', '다음 중 정규화 과정에서 발생할 수 있는 이상현상이 아닌 것은?', '정규화 과정에서 발생할 수 있는 이상현상에는 삽입 이상, 삭제 이상, 갱신 이상이 있습니다. 조회 이상은 존재하지 않습니다.', NULL, 7),
	(1276, 3, NULL, 2, '12회차', '관계의 정의가 잘못된 것은?', '관계는 엔터티 간의 연관성을 표현하는 것으로, 반드시 동사나 동사구를 사용해야 한다는 것은 잘못된 설명입니다. 관계는 명사형으로도 표현될 수 있습니다.', NULL, 5),
	(1277, 3, NULL, 2, '12회차', '다음 중 도메인(Domain)에 대한 설명으로 옳지 않은 것은?', '도메인은 속성이 가질 수 있는 값의 범위를 의미하며, 반드시 물리적으로 구현될 필요는 없습니다.', NULL, 3),
	(1278, 3, NULL, 2, '12회차', '아래의 ER 다이어그램에서 적절하지 않은 관계 표현은?', '주어진 ER 다이어그램에서 하나의 과목은 여러 개의 수강내역과 연결될 수 있어야 합니다. 따라서 "하나의 과목은 하나의 수강내역에만 연결된다"는 설명은 잘못되었습니다.', NULL, 5),
	(1279, 3, NULL, 2, '12회차', '다음 중 비식별자 관계의 특징이 아닌 것은?', '비식별자 관계에서는 부모 테이블의 기본키가 자식 테이블의 기본키로 전이되지 않고 일반 컬럼으로 전이됩니다.', NULL, 5),
	(1280, 3, NULL, 2, '12회차', '슈퍼타입/서브타입 모델링에 대한 설명 중 틀린 것은?', '하나의 슈퍼타입은 여러 개의 서브타입을 가질 수 있습니다. 하나의 슈퍼타입이 반드시 하나의 서브타입만 가질 수 있다는 설명은 잘못되었습니다.', NULL, 5),
	(1281, 3, NULL, 2, '12회차', '다음 중 SELECT 문장의 실행 순서로 올바른 것은?', 'SQL 실행 순서는 FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY 입니다.', NULL, 11),
	(1282, 3, NULL, 2, '12회차', '다음의 테이블에서 SQL을 실행했을 때의 결과로 맞는 것은?', 'GROUP BY 절이 없는 집계함수는 전체 데이터를 하나의 그룹으로 처리합니다. COUNT(*)는 전체 행의 수(5), COUNT(DISTINCT SALARY)는 중복을 제거한 SALARY의 수(3)를 반환합니다.', NULL, 21),
	(1283, 3, NULL, 2, '12회차', '다음 중 NULL 관련 함수에 대한 설명으로 틀린 것은?', 'ISNULL은 SQL Server에서만 사용 가능한 함수입니다. Oracle에서는 NVL을 사용해야 합니다.', NULL, 9),
	(1284, 3, NULL, 2, '12회차', '다음의 SQL문에서 결과값이 다른 것은?', '첫 세 개의 쿼리는 동일한 결과를 반환하지만, 네 번째 쿼리는 SAL이 0보다 큰 부서만 출력하므로 다른 결과가 나올 수 있습니다.', NULL, 15),
	(1285, 3, NULL, 2, '12회차', '다음 중 WINDOW 함수의 프레임 절(Frame Clause)에 대한 설명으로 올바르지 않은 것은?', 'CURRENT ROW는 현재 행을 의미하며, 앞뒤 기준이 아닙니다.', NULL, 22),
	(1286, 3, NULL, 2, '12회차', '다음과 같은 테이블이 있을 때, 가장 많은 결과 행을 출력하는 JOIN은?', 'FULL OUTER JOIN은 양쪽 테이블의 모든 행을 포함하므로 가장 많은 결과 행을 출력합니다.', NULL, 17),
	(1287, 3, NULL, 2, '12회차', '다음 중 트랜잭션의 특성(ACID)에 대한 설명으로 틀린 것은?', 'Durability(영구성)는 트랜잭션이 성공적으로 완료된 후에는 영구적으로 반영되어야 함을 의미합니다.', NULL, 29),
	(1288, 3, NULL, 2, '12회차', '다음 중 계층형 질의문에서 사용되는 가상 칼럼이 아닌 것은?', 'CONNECT_BY_PARENT는 계층형 질의문의 가상 칼럼이 아닙니다. 실제 가상 칼럼은 LEVEL, CONNECT_BY_ROOT, CONNECT_BY_ISLEAF, CONNECT_BY_ISCYCLE 등이 있습니다.', NULL, 24),
	(1289, 3, NULL, 2, '12회차', '아래의 테이블에서 SQL을 실행한 결과로 맞는 것은?', 'CASE문을 사용한 조건부 집계에서 1,2분기 합계는 300(100+200), 3,4분기 합계는 700(300+400)이 됩니다.', NULL, 21),
	(1290, 3, NULL, 2, '12회차', '다음 중 인덱스에 대한 설명으로 부적절한 것은?', '모든 컬럼에 인덱스를 생성하면 오히려 성능이 저하될 수 있습니다. 인덱스는 필요한 컬럼에만 선별적으로 생성해야 합니다.', NULL, 30),
	(1291, 3, NULL, 2, '12회차', '다음 중 서브쿼리에 대한 설명으로 틀린 것은?', '서브쿼리는 제한 없이 중첩이 가능합니다. 단, 과도한 중첩은 성능에 영향을 줄 수 있으므로 적절히 사용해야 합니다.', NULL, 20),
	(1292, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 실행한 SQL의 결과는?', 'COUNT(*)는 NULL을 포함한 모든 행의 수(2), COUNT(SALARY)는 NULL을 제외한 행의 수(1)를 반환합니다.', NULL, 21),
	(1293, 3, NULL, 2, '12회차', '아래의 테이블에서 각 부서별로 가장 높은 급여를 받는 사원을 조회하는 SQL로 적절하지 않은 것은?', 'SAL > ANY는 하나라도 큰 값이 있으면 TRUE를 반환하므로, 각 부서에서 가장 높은 급여를 받는 사원을 찾는 조건으로 적절하지 않습니다.', NULL, 17),
	(1294, 3, NULL, 2, '12회차', '다음과 같은 테이블이 있을 때, MERGE 문을 실행한 후의 결과로 옳은 것은?', 'MERGE 문에서 MATCHED는 ID가 같은 경우 UPDATE를 수행하고(1,X), NOT MATCHED는 TARGET_TABLE에 없는 데이터를 INSERT합니다(3,C).', NULL, 27),
	(1295, 3, NULL, 2, '12회차', '다음 중 윈도우 함수에 대한 설명으로 잘못된 것은?', 'RANK는 동일한 값에 대해 동일한 순위를 부여하고 다음 순위는 건너뛰지만, DENSE_RANK는 다음 순위를 이어서 부여합니다.', NULL, 22),
	(1296, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 SELECT 문을 실행했을 때 결과는?', 'COUNT(*)는 NULL을 포함한 전체 행 수(3), COUNT(PRICE)는 NULL을 제외한 행 수(2), COUNT(DISTINCT PRICE)는 중복을 제거한 NULL이 아닌 값의 수(2)를 반환합니다.', NULL, 21),
	(1297, 3, NULL, 2, '12회차', '아래의 SQL을 실행했을 때, 실행되지 않는 것은?', 'NAME 컬럼이 NOT NULL 제약조건이 있으므로, NAME 값을 지정하지 않은 4번 INSERT문은 실행되지 않습니다.', NULL, 27),
	(1298, 3, NULL, 2, '12회차', '다음 중 데이터베이스 트랜잭션 격리수준(Isolation Level)에 대한 설명으로 틀린 것은?', 'READ COMMITTED는 Phantom Read를 방지할 수 없습니다. Phantom Read는 REPEATABLE READ 이상의 격리수준에서 방지됩니다.', NULL, 29),
	(1299, 3, NULL, 2, '12회차', '아래의 두 테이블을 JOIN할 때, 가장 많은 결과 행이 생성되는 경우는?', 'FULL OUTER JOIN은 양쪽 테이블의 모든 행을 포함하고 매칭되지 않는 행도 NULL로 포함하므로 가장 많은 결과 행이 생성됩니다.', NULL, 17),
	(1300, 3, NULL, 2, '12회차', '다음의 계층형 쿼리에 대한 설명으로 틀린 것은?', 'START WITH 절은 선택사항입니다. START WITH 절이 없으면 모든 노드가 루트 노드가 될 수 있습니다.', NULL, 24),
	(1301, 3, NULL, 2, '12회차', '다음 중 GROUP BY 절에 대한 설명으로 틀린 것은?', 'GROUP BY 절에서는 집계 함수를 사용할 수 있습니다.', NULL, 15),
	(1302, 3, NULL, 2, '12회차', '다음 테이블에서 SQL을 실행했을 때의 결과는?', 'GROUP BY MONTH로 그룹화하고, NVL 함수를 사용하여 NULL값을 \'00\'으로 변환합니다.', NULL, 21),
	(1303, 3, NULL, 2, '12회차', '다음 중 UNION과 UNION ALL의 차이점에 대한 설명으로 옳지 않은 것은?', 'UNION이 자동으로 정렬된다는 것은 잘못된 설명입니다. ORDER BY를 사용하지 않으면 정렬되지 않습니다.', NULL, 20),
	(1304, 3, NULL, 2, '12회차', '다음 중 테이블 생성 시 제약조건에 대한 설명으로 틀린 것은?', 'PRIMARY KEY 제약조건은 테이블당 하나만 설정할 수 있습니다.', NULL, 30),
	(1305, 3, NULL, 2, '12회차', '아래의 SQL문을 실행했을 때 결과로 적절한 것은?', 'SUBSTR 함수에서 음수 위치는 뒤에서부터 계산하므로, -3은 뒤에서 3번째 위치에서 시작하여 2개의 문자를 추출합니다.', NULL, 13),
	(1306, 3, NULL, 2, '12회차', '각 부서별 평균 급여보다 높은 급여를 받는 사원을 조회하는 SQL로 올바른 것은?', '상관 서브쿼리를 사용하여 각 부서별 평균 급여를 구하고, 이와 비교하는 것이 올바른 방법입니다.', NULL, 21),
	(1307, 3, NULL, 2, '12회차', '다음 중 데이터베이스 트랜잭션의 Commit과 Rollback에 대한 설명으로 틀린 것은?', 'Commit이 수행된 이후에는 Rollback을 통해 이전 상태로 되돌릴 수 없습니다.', NULL, 29),
	(1308, 3, NULL, 2, '12회차', '다음과 같은 계층형 쿼리에서 결과로 알맞은 것은?', 'LPAD 함수를 사용하여 LEVEL값에 따라 들여쓰기가 적용되어 계층 구조가 시각적으로 표현됩니다.', NULL, 24),
	(1309, 3, NULL, 2, '12회차', '다음 중 인덱스를 사용할 수 없는 경우는?', 'WHERE 절에서 컬럼에 함수를 적용하면 인덱스를 사용할 수 없습니다. 이를 함수 기반 인덱스로 해결할 수 있습니다.', NULL, 30),
	(1310, 3, NULL, 2, '12회차', '아래의 테이블에서 부서별로 최고 급여를 받는 직원을 조회하기 위한 SQL문 중 틀린 것은?', 'GROUP BY 절에서는 집계함수와 GROUP BY에 명시된 컬럼만 SELECT 할 수 있습니다. 또한 WHERE 절에서는 집계함수를 사용할 수 없습니다.', NULL, 17),
	(1311, 3, NULL, 2, '12회차', '다음 중 DCL(Data Control Language)에 해당하는 명령어는?', 'DCL(Data Control Language)은 데이터베이스에 대한 접근 권한을 제어하는 명령어로 GRANT(권한 부여)와 REVOKE(권한 회수)가 있습니다.', NULL, 30),
	(1312, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 윈도우 함수를 사용한 SQL의 결과로 옳은 것은?', 'ROWS BETWEEN 1 PRECEDING AND CURRENT ROW는 현재 행과 이전 행의 값을 합산합니다. 따라서 첫 행은 자신만의 값, 두 번째 행부터는 자신과 이전 행의 합이 됩니다.', NULL, 22),
	(1313, 3, NULL, 2, '12회차', '다음 중 테이블 변경(ALTER TABLE)에 대한 설명으로 틀린 것은?', '기본키를 삭제할 때 관련된 외래키가 있으면 오류가 발생합니다. 자동으로 삭제되지 않습니다.', NULL, 30),
	(1314, 3, NULL, 2, '12회차', '아래의 테이블에서 REGEXP_LIKE 함수를 사용한 SQL 결과로 올바른 것은?', '^[A-Z]+[0-9]+$는 처음에 대문자가 하나 이상, 그 다음에 숫자가 하나 이상 나오는 패턴을 의미합니다. 이 조건을 만족하는 것은 \'ABC123\'입니다.', NULL, 26),
	(1315, 3, NULL, 2, '12회차', '다음 중 데이터베이스 트랜잭션 격리 수준에서 발생할 수 있는 현상이 아닌 것은?', '트랜잭션 격리 수준에서 발생할 수 있는 현상은 Dirty Read, Non-Repeatable Read, Phantom Read입니다. Isolated Read는 존재하지 않는 용어입니다.', NULL, 29),
	(1316, 3, NULL, 2, '12회차', '다음의 DDL 문장을 실행했을 때, 오류가 발생하는 것은?', '하나의 테이블에 두 개의 PRIMARY KEY 제약조건을 정의할 수 없습니다.', NULL, 30),
	(1317, 3, NULL, 2, '12회차', '다음 중 Oracle의 날짜 함수에 대한 설명으로 틀린 것은?', 'NEXT_DAY는 명시된 날짜보다 크고 명시된 요일에 해당하는 첫 번째 날짜를 반환합니다. 반드시 다음 주의 같은 요일이 아닐 수 있습니다.', NULL, 13),
	(1318, 3, NULL, 2, '12회차', '다음과 같은 테이블에서 부서별 순위를 매기는 SQL문 중 틀린 것은?', 'RANK() OVER 절과 GROUP BY 절은 함께 사용할 수 없습니다. 또한 PARTITION BY를 사용하지 않으면 전체 데이터에 대한 순위가 매겨집니다.', NULL, 22),
	(1319, 3, NULL, 2, '12회차', '다음 중 TOP-N 쿼리에 대한 설명으로 틀린 것은?', 'TOP-N 쿼리에서 ORDER BY 절은 선택사항입니다. 정렬이 필요 없는 경우에는 사용하지 않을 수 있습니다.', NULL, 23),
	(1320, 3, NULL, 2, '12회차', '다음 중 데이터베이스 락(Lock)에 대한 설명으로 옳지 않은 것은?', '락의 크기가 작을수록 동시성은 증가하고 일관성은 감소합니다. 반대로 락의 크기가 클수록 동시성은 감소하고 일관성은 증가합니다.', NULL, 29);
/*!40000 ALTER TABLE `question` ENABLE KEYS */;

INSERT INTO `options` (`option_id`, `content`, `is_answer`, `option_order`, `question_id`) VALUES
	(1, '추상화(Abstraction): 현실 세계를 일정한 형식에 맞추어 표현한다', b'0', 1, 1),
	(2, '단순화(Simplification): 복잡한 현실 세계를 약속된 규약에 의해 단순하게 표현한다', b'0', 2, 1),
	(3, '명확성(Clarity): 누구나 이해하기 쉽게 표현해야 한다', b'0', 3, 1),
	(4, '독립성(Independence): 데이터 모델은 물리적인 저장 구조와 반드시 같아야 한다', b'1', 4, 1),
	(5, '1:1 관계 - 한 개체의 하나의 인스턴스가 다른 개체의 하나의 인스턴스와 관계를 갖는다', b'1', 1, 2),
	(6, '1:N 관계 - 한 개체의 하나의 인스턴스가 다른 개체의 하나의 인스턴스와만 관계를 갖는다', b'0', 2, 2),
	(7, 'M:N 관계 - 두 개체 중 한 개체가 반드시 다수의 관계를 가져야 한다', b'0', 3, 2),
	(8, 'N:1 관계 - 1:1 관계의 특수한 형태로, 항상 식별 관계를 의미한다', b'0', 4, 2),
	(9, '업무에서 필요로 하는 정보여야 한다', b'0', 1, 3),
	(10, '식별자에 의해 식별이 가능해야 한다', b'0', 2, 3),
	(11, '반드시 속성을 포함해야 한다', b'0', 3, 3),
	(12, '다른 엔터티와 최소 한 개 이상의 관계를 가져야 한다', b'1', 4, 3),
	(13, '제1정규형(1NF)은 복합 속성을 분해하고, 속성의 원자성을 확보하는 것이다', b'1', 1, 4),
	(14, '제2정규형(2NF)은 부분 함수적 종속성을 제거하는 것으로, 기본키가 복합키인 경우에는 적용되지 않는다', b'0', 2, 4),
	(15, '제3정규형(3NF)은 이행적 함수 종속성을 제거하는 것으로, 결정자가 후보키인 경우에는 정규화하지 않는다', b'0', 3, 4),
	(16, '제4정규형(4NF)은 다치 종속성을 제거하는 것으로, 제3정규형을 만족하지 않아도 적용할 수 있다', b'0', 4, 4),
	(17, '학번을 기본키로 설정한다', b'0', 1, 5),
	(18, '학번과 과목코드를 복합키로 설정한다', b'1', 2, 5),
	(19, '학번, 과목코드, 분반을 복합키로 설정한다', b'0', 3, 5),
	(20, '새로운 일련번호를 기본키로 설정하고, 학번과 과목코드에 유니크 제약을 설정한다', b'0', 4, 5),
	(21, '속성은 엔터티와 독립적으로 존재할 수 있다', b'0', 1, 6),
	(22, '속성은 하나의 엔터티에서 똑같은 이름으로 중복될 수 있다', b'0', 2, 6),
	(23, '속성은 업무에서 관리하고자 하는 항목을 의미한다', b'1', 3, 6),
	(24, '속성은 반드시 다른 엔터티의 속성과 연관관계를 가져야 한다', b'0', 4, 6),
	(25, '핵심 엔터티 도출', b'0', 1, 7),
	(26, '엔터티 간의 관계 설정', b'0', 2, 7),
	(27, '인덱스 정의', b'1', 3, 7),
	(28, '주요 속성 식별', b'0', 4, 7),
	(29, '서브타입 엔터티는 슈퍼타입의 속성을 상속받지 않는다', b'0', 1, 8),
	(30, '한 엔터티는 두 개 이상의 슈퍼타입을 가질 수 없다', b'0', 2, 8),
	(31, '서브타입 엔터티는 슈퍼타입 엔터티의 인스턴스와 반드시 1:1 관계를 가져야 한다', b'1', 3, 8),
	(32, '서브타입 엔터티 간에는 아무런 관계를 가질 수 없다', b'0', 4, 8),
	(33, '데이터의 무결성이 중요한 경우', b'0', 1, 9),
	(34, '항상 조인이 발생하는 테이블의 조회 성능 개선이 필요한 경우', b'1', 2, 9),
	(35, '데이터의 중복을 최소화하고자 하는 경우', b'0', 3, 9),
	(36, '저장 공간을 최소화하고자 하는 경우', b'0', 4, 9),
	(37, '부서 테이블 하나로 설계하고, 상위부서ID를 외래키로 자기참조하게 한다', b'1', 1, 10),
	(38, '상위부서와 하위부서를 별도의 테이블로 분리하여 설계한다', b'0', 2, 10),
	(39, '부서 계층별로 테이블을 각각 생성한다', b'0', 3, 10),
	(40, '부서 테이블과 별도로 부서관계 테이블을 생성하여 M:N 관계로 설계한다', b'0', 4, 10),
	(41, '업무에서 필요로 하는 정보여야 한다', b'0', 1, 11),
	(42, '식별자에 의해 식별이 가능해야 한다', b'0', 2, 11),
	(43, '반드시 속성을 가져야 한다', b'1', 3, 11),
	(44, '다른 엔터티와의 관계가 없어도 엔터티가 될 수 있다', b'0', 4, 11),
	(45, '기본 엔터티는 항상 발생 엔터티의 부모 엔터티가 된다', b'0', 1, 12),
	(46, '중심 엔터티는 업무에서 중요한 엔터티만을 의미한다', b'0', 2, 12),
	(47, '행위 엔터티는 두 개 이상의 엔터티로부터 발생되는 엔터티이다', b'1', 3, 12),
	(48, '코드 엔터티는 반드시 기본 엔터티여야 한다', b'0', 4, 12),
	(49, '기본 엔터티: 고객, 상품\n중심 엔터티: 주문\n행위 엔터티: 주문상품\n코드 엔터티: 주문상태', b'1', 1, 13),
	(50, '기본 엔터티: 고객, 주문상태\n중심 엔터티: 주문, 상품\n행위 엔터티: 주문상품', b'0', 2, 13),
	(51, '기본 엔터티: 고객, 상품, 주문상태\n중심 엔터티: 주문\n행위 엔터티: 배송', b'0', 3, 13),
	(52, '기본 엔터티: 고객\n중심 엔터티: 주문, 상품\n행위 엔터티: 주문상품, 배송\n코드 엔터티: 주문상태', b'0', 4, 13),
	(53, '주문 엔터티의 등급할인율은 중복 데이터이므로 제거해야 한다', b'0', 1, 14),
	(54, '회원 엔터티의 등급은 등급 엔터티를 참조하는 외래키로 변경해야 한다', b'1', 2, 14),
	(55, '등급 엔터티를 삭제하고 회원 엔터티에 등급 정보를 포함시켜야 한다', b'0', 3, 14),
	(56, '주문 엔터티에 회원의 등급 정보를 외래키로 추가해야 한다', b'0', 4, 14),
	(57, '기본 엔터티: 사용자\n중심 엔터티: 게시글, 댓글\n행위 엔터티: 첨부파일, 좋아요', b'0', 1, 15),
	(58, '기본 엔터티: 사용자, 게시글\n중심 엔터티: 댓글\n행위 엔터티: 첨부파일, 게시글좋아요, 댓글좋아요', b'0', 2, 15),
	(59, '기본 엔터티: 사용자\n중심 엔터티: 게시글\n행위 엔터티: 첨부파일, 댓글, 좋아요', b'0', 3, 15),
	(60, '기본 엔터티: 사용자\n중심 엔터티: 게시글, 댓글\n행위 엔터티: 게시글첨부파일, 게시글좋아요, 댓글좋아요', b'1', 4, 15),
	(61, '영속적으로 존재하는 정보인지 확인한다', b'0', 1, 16),
	(62, '업무 프로세스에서 관리하고자 하는 정보인지 확인한다', b'0', 2, 16),
	(63, '반드시 속성을 3개 이상 포함하고 있어야 한다', b'1', 3, 16),
	(64, '두 개 이상의 인스턴스가 존재하는지 확인한다', b'0', 4, 16),
	(65, '기본 엔터티로부터 발생되는 모든 엔터티를 의미한다', b'0', 1, 17),
	(66, '자신의 고유한 식별자를 반드시 가져야 한다', b'0', 2, 17),
	(67, '상위 엔터티의 속성을 상속받아 식별자로 사용한다', b'1', 3, 17),
	(68, '항상 M:N 관계를 해결하기 위해 생성된다', b'0', 4, 17),
	(69, '직원이력(직원번호, 부서코드, 시작일자, 직급코드)', b'0', 1, 18),
	(70, '직원이력(이력번호, 직원번호, 부서코드, 시작일자)', b'1', 2, 18),
	(71, '직원이력(직원번호, 시작일자, 부서코드, 직급코드)', b'0', 3, 18),
	(72, '직원이력(이력번호, 시작일자, 종료일자, 직원번호)', b'0', 4, 18),
	(73, 'PM정보 엔터티를 삭제하고 사원 엔터티에 PM 관련 속성을 추가한다', b'0', 1, 19),
	(74, 'PM정보를 프로젝트 엔터티의 속성으로 통합한다', b'0', 2, 19),
	(75, 'PM정보를 프로젝트인력 엔터티의 역할 속성으로 관리한다', b'0', 3, 19),
	(76, 'PM정보를 별도 엔터티로 유지하되, 사원 엔터티와 1:1 관계로 설정한다', b'1', 4, 19),
	(77, '예약 엔터티는 환자와 진료과의 관계로만 설계한다', b'0', 1, 20),
	(78, '의사일정 엔터티를 별도로 생성하여 요일별 진료시간을 관리한다', b'1', 2, 20),
	(79, '예약취소 정보는 예약상태 코드로만 관리한다', b'0', 3, 20),
	(80, '진료과와 의사는 하나의 엔터티로 통합하여 관리한다', b'0', 4, 20),
	(81, '업무에서 관리하고자 하는 의미상 더 이상 분리되지 않는 최소의 데이터 단위이다', b'0', 1, 21),
	(82, '엔터티에 대한 자세하고 구체적인 정보를 나타낸다', b'0', 2, 21),
	(83, '하나의 속성은 반드시 한 개 이상의 엔터티에 포함되어야 한다', b'1', 3, 21),
	(84, '속성은 관계로 기술될 수 있는 두 개 이상의 값을 가질 수 없다', b'0', 4, 21),
	(85, '기본속성 - 업무로부터 직접 생성된 속성이 아닌, 영업이익처럼 계산된 속성', b'0', 1, 22),
	(86, '설계속성 - 업무를 수행하며 생성되는 속성으로 주민번호, 이름 등이 해당', b'0', 2, 22),
	(87, '파생속성 - 다른 속성으로부터 계산되거나 변형되어 생성되는 속성', b'1', 3, 22),
	(88, '복합속성 - 업무상 반드시 필요한 구분자로 인조키가 대표적인 예시', b'0', 4, 22),
	(89, '주문번호', b'0', 1, 23),
	(90, '주문일자', b'0', 2, 23),
	(91, '배송비', b'0', 3, 23),
	(92, '적립포인트', b'1', 4, 23),
	(93, '주소를 하나의 복합속성으로 설계한다', b'0', 1, 24),
	(94, '평균평점을 기본속성으로 설계한다', b'0', 2, 24),
	(95, '주소 변경 이력을 리스트 속성으로 설계한다', b'0', 3, 24),
	(96, '도로명주소와 지번주소를 별도의 엔터티로 분리하고 이력관리를 위한 시작일자, 종료일자 속성을 추가한다', b'1', 4, 24),
	(97, '회원등급은 열거형(Enumeration) 도메인으로 정의한다', b'0', 1, 25),
	(98, '성별은 VARCHAR2(1)로 정의하고 M/F로 저장한다', b'0', 2, 25),
	(99, '재직여부는 CHAR(1)로 정의하고 CHECK 제약조건을 사용한다', b'0', 3, 25),
	(100, '부서코드는 코드성 속성이므로 반드시 숫자형으로 정의해야 한다', b'1', 4, 25),
	(101, '하나의 속성이 여러 개의 값을 가질 수 있다', b'0', 1, 26),
	(102, '주소처럼 여러 개의 의미를 지닌 속성을 의미한다', b'0', 2, 26),
	(103, '하나의 속성이 한 개의 값만을 가질 수 있다', b'1', 3, 26),
	(104, '다른 속성으로부터 유도되어 만들어진 속성이다', b'0', 4, 26),
	(105, '저자와 카테고리를 다중값 속성으로 설계한다', b'0', 1, 27),
	(106, 'ISBN을 설계속성으로 정의한다', b'0', 2, 27),
	(107, '저자와 카테고리를 별도의 엔터티로 설계한다', b'1', 3, 27),
	(108, '평점을 기본속성으로 설계한다', b'0', 4, 27),
	(109, '나이: NUMBER(3), 0 이상 150 이하의 정수', b'1', 1, 28),
	(110, '이메일: VARCHAR2(100), @를 포함하는 문자열', b'0', 2, 28),
	(111, '전화번호: VARCHAR2(13), -를 포함하는 숫자와 특수문자', b'0', 3, 28),
	(112, '생년월일: DATE, 현재일자보다 작아야 함', b'0', 4, 28),
	(113, '배송 관련 속성을 별도의 배송지 엔터티로 분리한다', b'1', 1, 29),
	(114, '수령자 전화번호는 하나의 속성으로 통합한다', b'0', 2, 29),
	(115, '주문상태는 문자형으로 변경한다', b'0', 3, 29),
	(116, '결제금액을 기본속성으로 유지한다', b'0', 4, 29),
	(117, '고객 엔터티에 포인트 관련 속성을 모두 포함한다', b'0', 1, 30),
	(118, '포인트 적립과 사용을 하나의 엔터티로 통합 관리한다', b'0', 2, 30),
	(119, '포인트 만료일을 파생속성으로 설계한다', b'0', 3, 30),
	(120, '포인트 이력을 별도 엔터티로 설계하고, 고객의 보유 포인트는 파생속성으로 관리한다', b'1', 4, 30),
	(121, '유일성: 하나의 엔터티 내에서 인스턴스를 유일하게 구분할 수 있어야 한다', b'0', 1, 31),
	(122, '최소성: 식별자를 구성하는 속성의 수는 최대한 많아야 한다', b'1', 2, 31),
	(123, '불변성: 식별자의 값은 자주 변경되지 않아야 한다', b'0', 3, 31),
	(124, '존재성: 모든 인스턴스는 반드시 식별자 값을 가져야 한다', b'0', 4, 31),
	(125, '이름 + 학과코드', b'0', 1, 32),
	(126, '학번', b'1', 2, 32),
	(127, '이름 + 전화번호', b'0', 3, 32),
	(128, '학년 + 입학일자', b'0', 4, 32),
	(129, 'CREATE TABLE orders ( order_date DATE, customer_id VARCHAR2(10), product_id VARCHAR2(10), PRIMARY KEY (order_date, customer_id, product_id) );', b'0', 1, 33),
	(130, 'CREATE TABLE orders ( order_id NUMBER PRIMARY KEY, customer_id VARCHAR2(10), order_date DATE ); CREATE TABLE order_items ( order_id NUMBER, product_id VARCHAR2(10), quantity NUMBER, price NUMBER, PRIMARY KEY (order_id, product_id) );', b'0', 2, 33),
	(131, 'CREATE TABLE orders ( order_no VARCHAR2(20) PRIMARY KEY, customer_id VARCHAR2(10), product_id VARCHAR2(10), quantity NUMBER );', b'0', 3, 33),
	(132, 'CREATE TABLE orders ( order_id NUMBER PRIMARY KEY, customer_id VARCHAR2(10), order_date DATE ); CREATE TABLE order_items ( order_item_id NUMBER PRIMARY KEY, order_id NUMBER, product_id VARCHAR2(10), quantity NUMBER, price NUMBER );', b'1', 4, 33),
	(133, 'CREATE TABLE POSTS ( BOARD_ID VARCHAR2(10), POST_ID NUMBER, TITLE VARCHAR2(200), CONTENT CLOB, PRIMARY KEY (BOARD_ID, POST_ID) ); CREATE TABLE FILES ( BOARD_ID VARCHAR2(10), POST_ID NUMBER, FILE_ID NUMBER, FILE_NAME VARCHAR2(100), FILE_PATH VARCHAR2(500), PRIMARY KEY (BOARD_ID, POST_ID, FILE_ID) );', b'0', 1, 34),
	(134, 'CREATE TABLE POSTS ( POST_ID NUMBER PRIMARY KEY, BOARD_ID VARCHAR2(10), TITLE VARCHAR2(200), CONTENT CLOB ); CREATE TABLE FILES ( FILE_ID NUMBER PRIMARY KEY, POST_ID NUMBER, FILE_NAME VARCHAR2(100), FILE_PATH VARCHAR2(500) );', b'1', 2, 34),
	(135, 'CREATE TABLE POSTS ( POST_ID NUMBER PRIMARY KEY, BOARD_ID VARCHAR2(10), TITLE VARCHAR2(200), CONTENT CLOB ); CREATE TABLE FILES ( POST_ID NUMBER, FILE_ID NUMBER, FILE_NAME VARCHAR2(100), FILE_PATH VARCHAR2(500), PRIMARY KEY (POST_ID, FILE_ID) );', b'0', 3, 34),
	(136, 'CREATE TABLE POSTS ( POST_ID VARCHAR2(20), BOARD_ID VARCHAR2(10), TITLE VARCHAR2(200), CONTENT CLOB, PRIMARY KEY (POST_ID) ); CREATE TABLE FILES ( FILE_ID VARCHAR2(20), POST_ID VARCHAR2(20), FILE_NAME VARCHAR2(100), FILE_PATH VARCHAR2(500), PRIMARY KEY (FILE_ID) );', b'0', 4, 34),
	(137, 'CREATE TABLE PROJECT_MEMBERS ( EMP_ID VARCHAR2(10), PROJECT_ID VARCHAR2(10), ROLE_CODE VARCHAR2(5), START_DATE DATE, END_DATE DATE, PRIMARY KEY (EMP_ID, PROJECT_ID) );', b'0', 1, 35),
	(138, 'CREATE TABLE PROJECT_MEMBERS ( EMP_ID VARCHAR2(10), PROJECT_ID VARCHAR2(10), ROLE_CODE VARCHAR2(5), START_DATE DATE, END_DATE DATE, PRIMARY KEY (EMP_ID, PROJECT_ID, START_DATE) );', b'0', 2, 35),
	(139, 'CREATE TABLE PROJECT_MEMBERS ( MEMBER_ID NUMBER PRIMARY KEY, EMP_ID VARCHAR2(10), PROJECT_ID VARCHAR2(10), ROLE_CODE VARCHAR2(5), START_DATE DATE, END_DATE DATE );', b'1', 3, 35),
	(140, 'CREATE TABLE PROJECT_MEMBERS ( EMP_ID VARCHAR2(10), PROJECT_ID VARCHAR2(10), ROLE_CODE VARCHAR2(5), START_DATE DATE, END_DATE DATE, CONSTRAINT PK_MEMBER PRIMARY KEY (EMP_ID, PROJECT_ID, ROLE_CODE) );', b'0', 4, 35),
	(141, '인조식별자로도 불린다', b'0', 1, 36),
	(142, '업무적 의미를 가지지 않는다', b'0', 2, 36),
	(143, '일련번호 형태로 자동 생성되는 경우가 많다', b'0', 3, 36),
	(144, '자연식별자보다 항상 더 나은 선택이다', b'1', 4, 36),
	(145, 'CREATE TABLE EMP_DEPT_HISTORY ( DEPT_CODE CHAR(3), EMP_NO CHAR(5), START_DATE DATE, PRIMARY KEY (DEPT_CODE, EMP_NO) );', b'0', 1, 37),
	(146, 'CREATE TABLE EMP_DEPT_HISTORY ( HISTORY_ID NUMBER PRIMARY KEY, DEPT_CODE CHAR(3), EMP_NO CHAR(5), START_DATE DATE );', b'1', 2, 37),
	(147, 'CREATE TABLE EMP_DEPT_HISTORY ( DEPT_CODE CHAR(3), EMP_NO CHAR(5), START_DATE DATE, PRIMARY KEY (DEPT_CODE, EMP_NO, START_DATE) );', b'0', 3, 37),
	(148, 'CREATE TABLE EMP_DEPT_HISTORY ( EMP_NO CHAR(5) PRIMARY KEY, DEPT_CODE CHAR(3), START_DATE DATE );', b'0', 4, 37),
	(149, '주문과 주문상품의 관계', b'0', 1, 38),
	(150, '부서와 직원의 관계', b'0', 2, 38),
	(151, '공통코드 테이블과 상세코드 테이블의 관계', b'1', 3, 38),
	(152, '회원과 게시글의 관계', b'0', 4, 38),
	(153, 'PRODUCTS 테이블의 복합키를 유지하고 ORDERS 테이블에도 복합 외래키를 사용한다', b'0', 1, 39),
	(154, 'PRODUCTS 테이블에 대체키를 도입하고 ORDERS 테이블은 이를 참조하게 한다', b'1', 2, 39),
	(155, 'CATEGORY_ID를 별도 테이블로 분리하고 PRODUCTS와 비식별관계로 설정한다', b'0', 3, 39),
	(156, 'ORDERS 테이블의 기본키도 복합키로 변경한다', b'0', 4, 39),
	(157, '배송지 테이블의 기본키를 고객ID와 배송지 일련번호의 복합키로 구성한다', b'0', 1, 40),
	(158, '배송지 테이블에 인조식별자를 사용하고, 이력 테이블을 별도로 생성한다', b'1', 2, 40),
	(159, '배송지 정보를 주문 테이블에 포함시킨다', b'0', 3, 40),
	(160, '배송지 테이블의 기본키를 고객ID로 설정한다', b'0', 4, 40),
	(161, '1:1 관계는 양쪽 엔터티가 서로 하나씩 대응되는 관계이다', b'0', 1, 41),
	(162, '1:N 관계는 한 쪽 엔터티의 하나의 인스턴스가 다른 쪽 엔터티의 여러 인스턴스와 대응되는 관계이다', b'0', 2, 41),
	(163, 'N:M 관계는 반드시 교차 엔터티(교차 테이블)로 해소해야 한다', b'0', 3, 41),
	(164, '1:1 관계에서는 항상 외래키를 양쪽 테이블에 모두 두어야 한다', b'1', 4, 41),
	(165, '식별 관계를 가진 1:1 관계', b'0', 1, 42),
	(166, '비식별 관계를 가진 1:N 관계', b'1', 2, 42),
	(167, '식별 관계를 가진 1:N 관계', b'0', 3, 42),
	(168, '비식별 관계를 가진 N:M 관계', b'0', 4, 42),
	(169, '한 직원이 여러 프로젝트에 참여할 수 없다', b'0', 1, 43),
	(170, '프로젝트별 직원의 역할을 관리할 수 없다', b'0', 2, 43),
	(171, '직원이 프로젝트에 참여한 기간을 알 수 없다', b'1', 3, 43),
	(172, '프로젝트에 참여하지 않은 직원은 저장할 수 없다', b'0', 4, 43),
	(173, '식별관계는 항상 1:1 관계에서만 사용할 수 있다', b'0', 1, 44),
	(174, '비식별관계는 항상 부모 테이블의 기본키를 자식 테이블의 일반 컬럼으로 사용한다', b'1', 2, 44),
	(175, '식별관계가 많은 데이터 모델이 더 유연한 구조를 가진다', b'0', 3, 44),
	(176, '비식별관계는 부모 테이블이 없어도 자식 테이블이 존재할 수 있다', b'0', 4, 44),
	(177, 'CREATE TABLE ORDER_ITEMS ( ORDER_ID NUMBER, PRODUCT_ID NUMBER, QUANTITY NUMBER, AMOUNT NUMBER, PRIMARY KEY (ORDER_ID, PRODUCT_ID) );', b'0', 1, 45),
	(178, 'CREATE TABLE ORDER_ITEMS ( ORDER_ID NUMBER, PRODUCT_ID NUMBER, QUANTITY NUMBER, PRICE NUMBER, PRIMARY KEY (ORDER_ID, PRODUCT_ID), FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS(PRODUCT_ID) );', b'0', 2, 45),
	(179, 'CREATE TABLE ORDERS ( ORDER_ID NUMBER PRIMARY KEY, PRODUCT_LIST VARCHAR2(4000), TOTAL_AMOUNT NUMBER );', b'0', 3, 45),
	(180, 'CREATE TABLE ORDER_ITEMS ( ORDER_ITEM_ID NUMBER PRIMARY KEY, ORDER_ID NUMBER, PRODUCT_ID NUMBER, QUANTITY NUMBER, UNIT_PRICE NUMBER, AMOUNT NUMBER GENERATED ALWAYS AS (QUANTITY * UNIT_PRICE), FOREIGN KEY (ORDER_ID) REFERENCES ORDERS(ORDER_ID), FOREIGN KEY (PRODUCT_ID) REFERENCES PRODUCTS(PRODUCT_ID) );', b'1', 4, 45),
	(181, '자식 테이블에서 외래키의 값은 부모 테이블의 기본키에 없는 값을 가질 수 없다', b'0', 1, 46),
	(182, '부모 테이블의 기본키가 변경될 때 자식 테이블의 외래키도 자동으로 변경된다', b'1', 2, 46),
	(183, '부모 테이블의 데이터가 삭제될 때 자식 테이블의 관련 데이터도 삭제되도록 설정할 수 있다', b'0', 3, 46),
	(184, '부모 테이블에 없는 외래키 값이 입력되는 것을 방지한다', b'0', 4, 46),
	(185, '재귀적 관계를 사용하여 하나의 테이블로 구성', b'0', 1, 47),
	(186, '각 레벨별로 별도의 테이블을 생성하여 1:N 관계로 연결', b'1', 2, 47),
	(187, '모든 카테고리를 하나의 테이블에 저장하고 레벨 컬럼으로 구분', b'0', 3, 47),
	(188, '대분류-중분류-소분류를 각각의 컬럼으로 저장', b'0', 4, 47),
	(189, '단일 테이블 전략 (한 테이블에 모든 속성을 통합)', b'1', 1, 48),
	(190, '각각의 테이블 전략 (회원 유형별로 별도 테이블 생성)', b'0', 2, 48),
	(191, '서브타입 테이블 전략 (슈퍼타입 테이블과 서브타입 테이블을 1:1 관계로 생성)', b'0', 3, 48),
	(192, '슈퍼타입 테이블 없이 서브타입 테이블만 생성', b'0', 4, 48),
	(193, '순환 참조로 인한 데이터 삭제 불가', b'1', 1, 49),
	(194, '프로젝트 매니저 변경 시 참조 무결성 위배', b'0', 2, 49),
	(195, '직원-관리자 관계의 깊이 제한 불가', b'0', 3, 49),
	(196, '프로젝트와 직원 간의 다중 관계 표현 불가', b'0', 4, 49),
	(197, 'CREATE TABLE CONTRACTS ( CUSTOMER_ID NUMBER, INSURANCE_ID NUMBER, START_DATE DATE, END_DATE DATE, PREMIUM NUMBER, PRIMARY KEY (CUSTOMER_ID, INSURANCE_ID) );', b'0', 1, 50),
	(198, 'CREATE TABLE CONTRACTS ( CONTRACT_ID NUMBER PRIMARY KEY, CUSTOMER_ID NUMBER, INSURANCE_ID NUMBER, START_DATE DATE, END_DATE DATE, PREMIUM NUMBER ); CREATE TABLE CONTRACT_HISTORY ( HISTORY_ID NUMBER PRIMARY KEY, CONTRACT_ID NUMBER, CHANGE_DATE DATE, PREMIUM NUMBER, FOREIGN KEY (CONTRACT_ID) REFERENCES CONTRACTS(CONTRACT_ID) );', b'0', 2, 50),
	(199, 'CREATE TABLE CONTRACTS ( CUSTOMER_ID NUMBER, INSURANCE_ID NUMBER, VERSION NUMBER, START_DATE DATE, END_DATE DATE, PREMIUM NUMBER, PRIMARY KEY (CUSTOMER_ID, INSURANCE_ID, VERSION) );', b'0', 3, 50),
	(200, 'CREATE TABLE CONTRACTS ( CONTRACT_ID NUMBER PRIMARY KEY, CUSTOMER_ID NUMBER, INSURANCE_ID NUMBER, START_DATE DATE, END_DATE DATE ); CREATE TABLE CONTRACT_PREMIUMS ( PREMIUM_ID NUMBER PRIMARY KEY, CONTRACT_ID NUMBER, PREMIUM NUMBER, EFFECTIVE_DATE DATE, EXPIRE_DATE DATE, FOREIGN KEY (CONTRACT_ID) REFERENCES CONTRACTS(CONTRACT_ID) );', b'1', 4, 50),
	(201, '1:N 관계에서는 N쪽 테이블이 외래키를 가진다', b'0', 1, 51),
	(202, '모든 N:M 관계는 반드시 교차 테이블로 해소해야 한다', b'1', 2, 51),
	(203, 'INNER JOIN은 양쪽 테이블에 모두 존재하는 데이터만 조회한다', b'0', 3, 51),
	(204, 'OUTER JOIN에서는 조인 조건을 만족하지 않는 행도 포함할 수 있다', b'0', 4, 51),
	(205, 'SELECT s.이름, c.과목명, r.성적 FROM 학생 s, 수강신청 r, 과목 c WHERE s.학번 = r.학번 AND r.과목코드 = c.과목코드;', b'0', 1, 52),
	(206, 'SELECT s.이름, c.과목명, r.성적 FROM 학생 s LEFT JOIN 수강신청 r ON s.학번 = r.학번 LEFT JOIN 과목 c ON r.과목코드 = c.과목코드;', b'1', 2, 52),
	(207, 'SELECT s.이름, c.과목명, r.성적 FROM 수강신청 r LEFT JOIN 학생 s ON r.학번 = s.학번 LEFT JOIN 과목 c ON r.과목코드 = c.과목코드;', b'0', 3, 52),
	(208, 'SELECT s.이름, c.과목명, r.성적 FROM 과목 c LEFT JOIN 수강신청 r ON c.과목코드 = r.과목코드 LEFT JOIN 학생 s ON r.학번 = s.학번;', b'0', 4, 52),
	(209, '모든 부서에 직원이 있는 경우', b'0', 1, 53),
	(210, '직원이 없는 부서가 있는 경우', b'1', 2, 53),
	(211, '부서가 없는 직원이 있는 경우', b'0', 3, 53),
	(212, '모든 부서의 직원 수가 1명 이상인 경우', b'0', 4, 53),
	(213, 'SELECT d.dept_name, NVL(AVG(e.salary), 0) as avg_salary FROM departments d LEFT OUTER JOIN employees e ON d.dept_id = e.dept_id GROUP BY d.dept_name ORDER BY d.dept_name;', b'0', 1, 54),
	(214, 'SELECT d.dept_name, NVL(AVG(e.salary), 0) as avg_salary FROM departments d FULL OUTER JOIN employees e ON d.dept_id = e.dept_id GROUP BY d.dept_name ORDER BY d.dept_name;', b'0', 2, 54),
	(215, 'SELECT COALESCE(d.dept_name, \'No Department\') as dept_name, NVL(AVG(e.salary), 0) as avg_salary FROM departments d FULL OUTER JOIN employees e ON d.dept_id = e.dept_id GROUP BY d.dept_name ORDER BY d.dept_name NULLS LAST;', b'1', 3, 54),
	(216, 'SELECT COALESCE(d.dept_name, \'No Department\') as dept_name, NVL(AVG(e.salary), 0) as avg_salary FROM employees e RIGHT OUTER JOIN departments d ON e.dept_id = d.dept_id GROUP BY d.dept_name ORDER BY d.dept_name;', b'0', 4, 54),
	(217, 'SELECT * FROM 주문 o, 주문상품 d, 상품 p WHERE o.주문ID = d.주문ID;', b'0', 1, 55),
	(218, 'SELECT * FROM 주문 o INNER JOIN 주문상품 d ON o.주문ID = d.주문ID INNER JOIN 상품 p ON d.상품ID = p.상품ID;', b'1', 2, 55),
	(219, 'SELECT * FROM 주문 o LEFT JOIN 주문상품 d ON o.주문ID = d.주문ID LEFT JOIN 상품 p ON d.상품ID = p.상품ID;', b'0', 3, 55),
	(220, 'SELECT * FROM 주문 o WHERE EXISTS (SELECT 1 FROM 주문상품 d WHERE o.주문ID = d.주문ID);', b'0', 4, 55),
	(221, '동일 테이블을 두 번 이상 조인하는 방식이다', b'0', 1, 56),
	(222, '계층 구조를 표현할 때 주로 사용된다', b'0', 2, 56),
	(223, '반드시 테이블 별칭(Alias)을 사용해야 한다', b'0', 3, 56),
	(224, 'SELF JOIN을 사용하면 항상 성능이 저하된다', b'1', 4, 56),
	(225, 'SELECT e.emp_name, m.emp_name as manager_name FROM employee e, employee m WHERE e.manager_id = m.emp_id(+);', b'0', 1, 57),
	(226, 'SELECT e.emp_name, m.emp_name as manager_name FROM employee e LEFT OUTER JOIN employee m ON e.manager_id = m.emp_id ORDER BY e.emp_id;', b'1', 2, 57),
	(227, 'SELECT e.emp_name, (SELECT m.emp_name FROM employee m WHERE m.emp_id = e.manager_id) as manager_name FROM employee e;', b'0', 3, 57),
	(228, 'SELECT e.emp_name, NVL(m.emp_name, \'대표\') as manager_name FROM employee e, employee m WHERE e.manager_id = m.emp_id;', b'0', 4, 57),
	(229, '모든 부서에 최소 1명의 직원이 있는 경우', b'0', 1, 58),
	(230, '부서가 없는 직원이 있는 경우', b'0', 2, 58),
	(231, '직원이 없는 부서가 있는 경우', b'1', 3, 58),
	(232, '모든 직원이 부서를 가지고 있는 경우', b'0', 4, 58),
	(233, 'SELECT e.emp_name, e.salary, d.dept_name FROM employees e LEFT JOIN departments d ON e.dept_id = d.dept_id WHERE e.salary > (SELECT AVG(salary) FROM employees WHERE dept_id = e.dept_id OR (dept_id IS NULL AND e.dept_id IS NULL)) ORDER BY d.dept_name NULLS LAST, e.salary DESC;', b'0', 1, 59),
	(234, 'SELECT e.emp_name, e.salary, d.dept_name FROM employees e LEFT JOIN departments d ON e.dept_id = d.dept_id WHERE e.salary > ALL (SELECT AVG(salary) FROM employees GROUP BY dept_id) ORDER BY d.dept_name, e.salary DESC;', b'0', 2, 59),
	(235, 'WITH dept_avg AS (SELECT dept_id, AVG(salary) as avg_salary FROM employees GROUP BY dept_id) SELECT e.emp_name, e.salary, d.dept_name FROM employees e LEFT JOIN departments d ON e.dept_id = d.dept_id LEFT JOIN dept_avg da ON e.dept_id = da.dept_id WHERE e.salary > COALESCE(da.avg_salary, (SELECT AVG(salary) FROM employees WHERE dept_id IS NULL)) ORDER BY d.dept_name NULLS LAST, e.salary DESC;', b'1', 3, 59),
	(236, 'SELECT e.emp_name, e.salary, d.dept_name FROM employees e LEFT JOIN departments d ON e.dept_id = d.dept_id JOIN (SELECT dept_id, AVG(salary) as avg_salary FROM employees GROUP BY dept_id) da ON e.dept_id = da.dept_id WHERE e.salary > da.avg_salary ORDER BY d.dept_name, e.salary DESC;', b'0', 4, 59),
	(237, '서브쿼리로 분리하여 처리', b'0', 1, 60),
	(238, '모든 LEFT JOIN을 INNER JOIN으로 변경', b'0', 2, 60),
	(239, '인라인 뷰를 사용하여 처리 대상 데이터 축소', b'1', 3, 60),
	(240, '조인 순서를 변경하여 products 테이블을 먼저 조인', b'0', 4, 60),
	(241, '정규화는 데이터의 중복을 제거하고 데이터 무결성을 보장하기 위한 과정이다', b'0', 1, 61),
	(242, '정규화가 진행될수록 조인의 필요성이 줄어들어 조회 성능이 향상된다', b'1', 2, 61),
	(243, '제1정규형은 모든 속성의 도메인이 원자값으로 구성되어야 한다', b'0', 3, 61),
	(244, '정규화는 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 안정성을 목표로 한다', b'0', 4, 61),
	(245, '제1정규형 위반으로 수강과목을 별도 테이블로 분리해야 한다', b'0', 1, 62),
	(246, '제2정규형 위반으로 학생정보를 별도 테이블로 분리해야 한다', b'1', 2, 62),
	(247, '제3정규형 위반으로 강의실 정보를 별도 테이블로 분리해야 한다', b'0', 3, 62),
	(248, 'BCNF 위반으로 교수정보를 별도 테이블로 분리해야 한다', b'0', 4, 62),
	(249, '수강신청', b'1', 1, 63),
	(250, '직원정보', b'0', 2, 63),
	(251, '강의실배정', b'0', 3, 63),
	(252, '학생정보', b'0', 4, 63),
	(253, '제1정규형 위반으로, 과목정보를 별도 테이블로 분리한다', b'1', 1, 64),
	(254, '제2정규형 위반으로, 학생정보를 별도 테이블로 분리한다', b'0', 2, 64),
	(255, '제3정규형 위반으로, 학과정보를 별도 테이블로 분리한다', b'0', 3, 64),
	(256, 'BCNF 위반으로, 강의실 정보를 별도 테이블로 분리한다', b'0', 4, 64),
	(257, '주문상세 테이블에 주문금액 합계 컬럼을 추가한다', b'0', 1, 65),
	(258, '게시글 테이블에 답글 개수 컬럼을 추가한다', b'1', 2, 65),
	(259, '상품 분류 테이블에 재고수량 컬럼을 추가한다', b'0', 3, 65),
	(260, '회원 테이블에 최근 로그인 시간 컬럼을 추가한다', b'0', 4, 65),
	(261, '기본키는 모든 속성을 함수적으로 결정한다', b'0', 1, 66),
	(262, '부분 함수적 종속은 복합키의 일부가 특정 속성을 결정하는 경우이다', b'0', 2, 66),
	(263, '이행적 함수 종속은 제3정규형에서 제거해야 하는 종속성이다', b'0', 3, 66),
	(264, '함수적 종속성이 많을수록 데이터의 일관성이 향상된다', b'1', 4, 66),
	(265, '고객ID → 고객등급 → 할인율의 이행적 함수 종속 제거', b'1', 1, 67),
	(266, '주문번호 → 고객ID의 부분 함수적 종속 제거', b'0', 2, 67),
	(267, '(주문번호, 고객ID) → 주문금액의 복합키 종속성 제거', b'0', 3, 67),
	(268, '주문금액 → 할인율의 결정자 종속성 제거', b'0', 4, 67),
	(269, 'A', b'1', 1, 68),
	(270, 'B', b'0', 2, 68),
	(271, 'C', b'0', 3, 68),
	(272, 'D', b'0', 4, 68),
	(273, '이력 관리를 위해 주문이력 테이블 별도 생성', b'1', 1, 69),
	(274, '상태 정보를 코드 테이블로 분리', b'0', 2, 69),
	(275, '모든 정보를 하나의 테이블로 유지', b'0', 3, 69),
	(276, '주문상태와 주문정보를 완전히 분리', b'0', 4, 69),
	(277, '작성자 정보 불일치 → 작성자 정보 뷰로 관리', b'0', 1, 70),
	(278, '댓글 수 불일치 → 트리거로 자동 갱신', b'1', 2, 70),
	(279, '조회 수 경합 → 캐시 테이블 별도 관리', b'0', 3, 70),
	(280, '부서명 변경 → 배치 프로그램으로 일괄 갱신', b'0', 4, 70),
	(281, '원자성(Atomicity)은 트랜잭션의 모든 연산이 성공하거나 전체가 실패해야 한다', b'0', 1, 71),
	(282, '일관성(Consistency)은 트랜잭션 실행 전과 후의 데이터베이스가 일관된 상태를 유지해야 한다', b'0', 2, 71),
	(283, '독립성(Isolation)은 모든 트랜잭션이 순차적으로만 실행되어야 한다', b'1', 3, 71),
	(284, '지속성(Durability)은 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다', b'0', 4, 71),
	(285, 'Phantom Read', b'0', 1, 72),
	(286, 'Dirty Read', b'1', 2, 72),
	(287, 'Non-repeatable Read', b'0', 3, 72),
	(288, 'Lost Update', b'0', 4, 72),
	(289, '주문 금액(TOTAL_AMOUNT)과 상세 금액(AMOUNT)의 합계가 불일치할 수 있다', b'1', 1, 73),
	(290, '주문상세 없는 주문이 발생할 수 있다', b'0', 2, 73),
	(291, '주문 날짜가 NULL이 될 수 있다', b'0', 3, 73),
	(292, '상품이 중복으로 주문될 수 있다', b'0', 4, 73),
	(293, '트랜잭션을 개별로 나누어 실행하고 COMMIT을 여러 번 수행한다', b'0', 1, 74),
	(294, '각 단계별로 SAVEPOINT를 설정하고 부분 롤백을 수행한다', b'0', 2, 74),
	(295, '트랜잭션을 여러 개로 나누고 각 작업을 개별적으로 처리한다', b'0', 3, 74),
	(296, '모든 작업을 하나의 트랜잭션에서 수행하며, 오류 발생 시 전체를 ROLLBACK 한다', b'1', 4, 74),
	(297, '트랜잭션의 범위는 가능한 한 크게 설정하여 데이터 일관성을 보장해야 한다', b'1', 1, 75),
	(298, '트랜잭션이 오래 걸리는 작업을 포함할 경우, 가능한 한 분리하여 처리해야 한다', b'0', 2, 75),
	(299, '읽기 작업과 쓰기 작업이 혼재된 경우, 적절한 격리 수준을 설정해야 한다', b'0', 3, 75),
	(300, '동시성이 중요한 경우, 레코드 잠금(Lock) 범위를 최소화해야 한다', b'0', 4, 75),
	(301, 'READ UNCOMMITTED는 다른 트랜잭션의 커밋되지 않은 데이터를 읽을 수 있다', b'1', 1, 76),
	(302, 'SERIALIZABLE은 모든 동시성 문제를 해결하지만 성능은 가장 좋다', b'0', 2, 76),
	(303, 'READ COMMITTED는 한 트랜잭션 내에서 동일한 조회 결과를 보장한다', b'0', 3, 76),
	(304, 'REPEATABLE READ는 새로운 레코드의 삽입을 허용하지 않는다', b'0', 4, 76),
	(305, 'SELECT FOR UPDATE 구문 사용으로 동시 업데이트 방지', b'1', 1, 77),
	(306, '트랜잭션 격리 수준을 SERIALIZABLE로 상향', b'0', 2, 77),
	(307, '트리거를 사용하여 자동으로 이력 기록', b'0', 3, 77),
	(308, '포인트 테이블과 이력 테이블을 통합', b'0', 4, 77),
	(309, '실시간 재고 관리 시스템', b'0', 1, 78),
	(310, '게시판의 조회수 업데이트', b'0', 2, 78),
	(311, '사용자 프로필 정보 수정', b'1', 3, 78),
	(312, '대량의 배치 처리 작업', b'0', 4, 78),
	(313, '각 주문별로 개별 트랜잭션을 실행하여 커밋한다', b'0', 1, 79),
	(314, '모든 주문을 한 번의 트랜잭션에서 처리하며 실패 시 전체 롤백한다', b'0', 2, 79),
	(315, '배치 크기를 설정하여 처리하며, 부분 커밋을 수행하여 성능을 최적화한다', b'1', 3, 79),
	(316, '전체 주문을 하나의 테이블에서 조회하고 한 번의 트랜잭션으로 처리한다', b'0', 4, 79),
	(317, '모든 트랜잭션의 격리 수준을 READ COMMITTED로 변경', b'0', 1, 80),
	(318, '트랜잭션에서 테이블 접근 순서를 동일하게 설정', b'1', 2, 80),
	(319, '모든 업데이트를 하나의 트랜잭션으로 통합', b'0', 3, 80),
	(320, '각각의 업데이트를 개별 트랜잭션으로 분리', b'0', 4, 80),
	(321, 'NULL은 \'아직 정의되지 않은 값\' 또는 \'알 수 없는 값\'을 의미한다', b'0', 1, 81),
	(322, 'NULL과 숫자 0은 동일한 의미로 취급된다', b'1', 2, 81),
	(323, 'NULL과 NULL을 비교한 결과는 알 수 없음(UNKNOWN)이다', b'0', 3, 81),
	(324, 'NULL이 포함된 산술 연산의 결과는 NULL이다', b'0', 4, 81),
	(325, 'cnt1 = cnt2 = cnt3', b'0', 1, 82),
	(326, 'cnt1 >= cnt2 >= cnt3', b'1', 2, 82),
	(327, 'cnt1 > cnt2 > cnt3', b'0', 3, 82),
	(328, 'cnt1 = cnt2 > cnt3', b'0', 4, 82),
	(329, 'commission_pct가 모두 NULL인 경우', b'0', 1, 83),
	(330, 'commission_pct가 모두 0인 경우', b'0', 2, 83),
	(331, 'commission_pct가 NULL과 0이 모두 없는 경우', b'0', 3, 83),
	(332, 'commission_pct가 NULL과 0이 모두 있는 경우', b'1', 4, 83),
	(333, 'NVL(d.department_name, \'미배치\') as dept_name, AVG(NVL(salary, 0)) as avg_salary', b'0', 1, 84),
	(334, 'COALESCE(d.department_name, \'미배치\'), COALESCE(AVG(salary), 0)', b'0', 2, 84),
	(335, 'NVL(d.department_name, \'미배치\'), NVL(AVG(NVL(salary, 0)), 0)', b'1', 3, 84),
	(336, 'NVL(department_name, \'미배치\'), AVG(salary)', b'0', 4, 84),
	(337, 'Method 1이 가장 효율적이다', b'1', 1, 85),
	(338, 'Method 2가 가장 효율적이다', b'0', 2, 85),
	(339, 'Method 3이 가장 효율적이다', b'0', 3, 85),
	(340, 'Method 4가 가장 효율적이다', b'0', 4, 85),
	(341, 'NVL(exp1, exp2)는 exp1이 NULL이 아닐 때 exp2를 반환한다', b'0', 1, 86),
	(342, 'COALESCE는 입력된 표현식들 중 첫 번째 NULL값을 반환한다', b'0', 2, 86),
	(343, 'NULLIF(exp1, exp2)는 exp1과 exp2가 같으면 NULL을 반환한다', b'1', 3, 86),
	(344, 'NVL2(exp1, exp2, exp3)는 exp1이 NULL이면 exp2를, NULL이 아니면 exp3를 반환한다', b'0', 4, 86),
	(345, 'avg_salary1 = avg_salary2', b'0', 1, 87),
	(346, 'avg_salary1 < avg_salary2', b'1', 2, 87),
	(347, 'avg_salary1 > avg_salary2', b'0', 3, 87),
	(348, 'avg_salary1과 avg_salary2의 대소 관계는 NULL의 개수에 따라 달라진다', b'0', 4, 87),
	(349, 'Method 1', b'0', 1, 88),
	(350, 'Method 2', b'1', 2, 88),
	(351, 'Method 3', b'0', 3, 88),
	(352, '모든 방식이 동일한 결과를 produces', b'0', 4, 88),
	(353, 'CHECK 제약조건에 NULL 허용하고 애플리케이션에서 처리', b'0', 1, 89),
	(354, 'DEFAULT \'PENDING\' 설정', b'0', 2, 89),
	(355, 'TRIGGER로 NULL 입력 시 자동 변환', b'0', 3, 89),
	(356, 'NOT NULL 제약조건과 DEFAULT \'PENDING\' 설정', b'1', 4, 89),
	(357, 'RIGHT JOIN 사용하여 고객 정보 기준으로 조인', b'0', 1, 90),
	(358, 'COALESCE 사용하여 NULL 처리', b'0', 2, 90),
	(359, 'WITH절을 활용하여 복잡한 계산을 분리하여 처리', b'1', 3, 90),
	(360, 'HAVING을 사용하여 NULL이 포함되지 않도록 필터링', b'0', 4, 90),
	(361, '본질 식별자는 업무에서 자연적으로 발생하는 속성을 식별자로 사용한다', b'0', 1, 91),
	(362, '인조 식별자는 시스템에서 임의로 생성한 식별자를 사용한다', b'0', 2, 91),
	(363, '본질 식별자는 업무적 의미를 가지고 있어 변경될 수 있다', b'0', 3, 91),
	(364, '인조 식별자는 반드시 숫자 형태로만 지정해야 한다', b'1', 4, 91),
	(365, '주민등록번호를 기본키로 사용한다 (본질 식별자)', b'0', 1, 92),
	(366, '고객번호를 기본키로 사용하고 주민등록번호는 유니크 제약조건을 설정한다 (인조 식별자)', b'1', 2, 92),
	(367, '이메일주소를 기본키로 사용한다 (본질 식별자)', b'0', 3, 92),
	(368, '휴대폰번호를 기본키로 사용한다 (본질 식별자)', b'0', 4, 92),
	(369, 'Design 1: 주문일자와 일련번호로 구성된 자연키가 업무적 의미를 잘 표현한다', b'0', 1, 93),
	(370, 'Design 2: 단순한 키 구조로 인해 참조 테이블 설계가 용이하다', b'1', 2, 93),
	(371, 'Design 1: 복합키를 사용하므로 데이터 정합성이 향상된다', b'0', 3, 93),
	(372, '두 설계 모두 동일한 성능을 보장한다', b'0', 4, 93),
	(373, '본질 식별자 사용: board_id와 post_no를 기본키로 사용', b'0', 1, 94),
	(374, '인조 식별자 사용: post_id를 기본키로 사용하고 parent_post_id로 계층 표현', b'1', 2, 94),
	(375, '복합 식별자 사용: board_id, post_no, ref_no를 기본키로 사용', b'0', 3, 94),
	(376, '자연키 사용: post_date와 post_seq를 기본키로 사용', b'0', 4, 94),
	(377, '본질 식별자는 항상 인조 식별자보다 나은 선택이다', b'0', 1, 95),
	(378, '시스템 확장성을 고려할 때는 인조 식별자가 유리하다', b'1', 2, 95),
	(379, '테이블 간 관계가 많을수록 본질 식별자가 유리하다', b'0', 3, 95),
	(380, '데이터 양이 많을수록 복합 식별자를 사용해야 한다', b'0', 4, 95),
	(381, '물리적으로 작은 크기를 가질 수 있다', b'0', 1, 96),
	(382, '업무적 의미를 가지고 있어 직관적이다', b'1', 2, 96),
	(383, '참조 관계가 단순해진다', b'0', 3, 96),
	(384, '키 값의 변경 가능성이 없다', b'0', 4, 96),
	(385, 'emp_no를 기본키로 설정 (본질 식별자)', b'0', 1, 97),
	(386, 'emp_id를 기본키로 설정 (인조 식별자)', b'1', 2, 97),
	(387, '(emp_no, dept_code)를 복합키로 설정', b'0', 3, 97),
	(388, '(join_date, emp_no)를 복합키로 설정', b'0', 4, 97),
	(389, '온라인 쇼핑몰의 주문 테이블', b'0', 1, 98),
	(390, '은행의 계좌 테이블', b'1', 2, 98),
	(391, '병원의 환자 진료기록 테이블', b'0', 3, 98),
	(392, '학교의 성적 테이블', b'0', 4, 98),
	(393, '복합키 사용: emp_no와 change_date를 기본키로 설정', b'0', 1, 99),
	(394, '인조 식별자 사용: history_id를 기본키로 설정', b'1', 2, 99),
	(395, '부분 키 사용: emp_no와 seq_no를 기본키로 설정', b'0', 3, 99),
	(396, '날짜 기반 키 사용: change_date와 emp_no를 기본키로 설정', b'0', 4, 99),
	(397, '복합키 사용: contract_year와 contract_no를 기본키로 설정', b'0', 1, 100),
	(398, '인조 식별자 사용: contract_id를 기본키로 설정하고, contract_no는 UNIQUE로 관리', b'1', 2, 100),
	(399, '자연키 사용: contract_no를 기본키로 설정', b'0', 3, 100),
	(400, '문서번호 사용: contract_no와 doc_no를 기본키로 설정', b'0', 4, 100),
	(401, '데이터를 2차원 테이블 형태로 표현한다', b'0', 1, 101),
	(402, '테이블 간의 관계는 반드시 1:1 관계만 가능하다', b'1', 2, 101),
	(403, 'SQL을 통해 데이터를 조작할 수 있다', b'0', 3, 101),
	(404, '기본키(Primary Key)를 통해 각 행을 구분할 수 있다', b'0', 4, 101),
	(405, '개체 무결성은 외래키가 참조하는 값이 부모 테이블에 존재해야 함을 의미한다', b'0', 1, 102),
	(406, '참조 무결성은 기본키가 NULL 값을 가질 수 있음을 의미한다', b'0', 2, 102),
	(407, '도메인 무결성은 컬럼의 값이 정의된 도메인에 속한 값이어야 함을 의미한다', b'1', 3, 102),
	(408, '관계 무결성은 모든 테이블이 최소 하나 이상의 관계를 가져야 함을 의미한다', b'0', 4, 102),
	(409, '개체 무결성 위배', b'0', 1, 103),
	(410, '참조 무결성 위배', b'1', 2, 103),
	(411, '도메인 무결성 위배', b'0', 3, 103),
	(412, '컬럼 무결성 위배', b'0', 4, 103),
	(413, '후보키(Candidate Key)는 테이블에서 반드시 하나만 존재해야 한다', b'0', 1, 104),
	(414, '기본키(Primary Key)는 여러 개의 컬럼으로 구성될 수 없다', b'0', 2, 104),
	(415, '대체키(Alternate Key)는 후보키 중 기본키로 선택되지 않은 키를 의미한다', b'1', 3, 104),
	(416, '외래키(Foreign Key)는 참조하는 테이블의 기본키와 동일한 이름이어야 한다', b'0', 4, 104),
	(417, '배송지 테이블을 생성하지만 회원 삭제 시 관련 데이터가 삭제되지 않는다', b'0', 1, 105),
	(418, '배송지 테이블에서 회원 삭제 시 ON DELETE CASCADE 설정을 포함하고, 기본 배송지 제한을 UNIQUE로 설정한다', b'1', 2, 105),
	(419, '기본 배송지를 CHECK 제약조건으로 관리하여 기본 배송지가 항상 한 개만 유지되도록 한다', b'0', 3, 105),
	(420, '배송지 정보를 JSON 형태로 저장하여 데이터 무결성을 유지한다', b'0', 4, 105),
	(421, '테이블의 각 행(Row)은 유일해야 한다', b'0', 1, 106),
	(422, '테이블의 각 컬럼(Column)은 원자값을 가져야 한다', b'0', 2, 106),
	(423, '테이블의 행과 컬럼의 순서는 데이터의 의미에 영향을 준다', b'1', 3, 106),
	(424, '모든 테이블은 최소한 하나 이상의 컬럼을 가져야 한다', b'0', 4, 106),
	(425, '릴레이션의 카디널리티(Cardinality)는 컬럼의 수를 의미한다', b'0', 1, 107),
	(426, '릴레이션의 차수(Degree)는 행의 수를 의미한다', b'0', 2, 107),
	(427, '릴레이션의 속성(Attribute)은 같은 이름을 가질 수 있다', b'0', 3, 107),
	(428, '릴레이션의 튜플(Tuple)은 중복될 수 없다', b'1', 4, 107),
	(429, '기본키를 복합키(product_id, product_name)로 설정한다', b'0', 1, 108),
	(430, 'CHECK 제약조건(price, stock >= 0)과 기본키(product_id)를 설정한다', b'1', 2, 108),
	(431, '기본키 설정과 함께 UNIQUE(product_name, category_id)를 추가한다', b'0', 3, 108),
	(432, '기본키(product_id)와 외래키(category_id)를 설정하고 CHECK(price > 0)를 추가한다', b'0', 4, 108),
	(433, '트리거를 사용하여 포인트 합계를 검증한다', b'0', 1, 109),
	(434, '애플리케이션 로직에서 포인트를 검증한다', b'0', 2, 109),
	(435, '테이블 제약조건을 추가하여 포인트 합계를 검증한다', b'0', 3, 109),
	(436, '저장 프로시저에서 포인트 합계를 검증하고 트랜잭션을 관리한다', b'1', 4, 109),
	(437, '상품-카테고리 관계를 1:N으로 설정한다', b'0', 1, 110),
	(438, '카테고리 계층을 지원하는 테이블과 M:N 관계를 표현하는 테이블을 설정한다', b'1', 2, 110),
	(439, '카테고리 정보를 JSON 컬럼으로 저장하여 관계를 관리한다', b'0', 3, 110),
	(440, '상품 노출 정보를 product_display 테이블로 분리하여 관리한다', b'0', 4, 110),
	(441, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'1', 1, 111),
	(442, 'SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 2, 111),
	(443, 'FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 3, 111),
	(444, 'SELECT → WHERE → GROUP BY → HAVING → FROM → ORDER BY', b'0', 4, 111),
	(445, '모든 부서의 직원 수를 조회한다', b'0', 1, 112),
	(446, '급여가 5000 이상인 직원이 3명 이상인 부서와 직원 수를 조회한다', b'1', 2, 112),
	(447, '급여가 5000 이상이고 직원이 3명인 부서를 조회한다', b'0', 3, 112),
	(448, '부서별 평균 급여가 5000 이상인 부서를 조회한다', b'0', 4, 112),
	(449, 'EMPLOYEES 테이블에 중복된 DEPARTMENT_ID가 없는 경우', b'0', 1, 113),
	(450, 'DEPARTMENT_ID가 NULL인 데이터가 있는 경우', b'1', 2, 113),
	(451, 'DEPARTMENT_ID가 모두 다른 경우', b'0', 3, 113),
	(452, 'EMPLOYEES 테이블이 비어있는 경우', b'0', 4, 113),
	(453, 'GROUP BY 절이 SELECT 절보다 먼저 실행된다', b'0', 1, 114),
	(454, 'WHERE 절에서 집계 함수를 사용할 수 없다', b'1', 2, 114),
	(455, 'GROUP BY 절에 없는 컬럼을 SELECT 절에서 사용할 수 없다', b'0', 3, 114),
	(456, 'ORDER BY 절이 없어서 결과의 순서가 보장되지 않는다', b'0', 4, 114),
	(457, 'HAVING COUNT(*) > 0을 추가하면 결과가 변경된다', b'0', 1, 115),
	(458, 'WHERE SALARY IS NOT NULL을 추가하면 결과가 변경된다', b'0', 2, 115),
	(459, 'AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID)를 사용하면 결과가 변경된다', b'0', 3, 115),
	(460, 'ROLLUP을 사용하면 총계 행이 추가되어 결과가 달라진다', b'1', 4, 115),
	(461, 'SELECT employee_id AS emp_no FROM employees', b'0', 1, 116),
	(462, 'SELECT salary * 12 annual_salary FROM employees', b'0', 2, 116),
	(463, 'SELECT department_id dept FROM employees', b'0', 3, 116),
	(464, 'SELECT employee_name AS "직원 이름" AS name FROM employees', b'1', 4, 116),
	(465, '각 부서의 전체 직원 수와 직무 수를 조회', b'0', 1, 117),
	(466, '급여가 3000 이상인 직원의 부서별 통계', b'0', 2, 117),
	(467, '평균 급여가 5000 초과인 부서의 직원 수와 직무 수', b'1', 3, 117),
	(468, '부서별 직무 수가 가장 많은 순서대로 조회', b'0', 4, 117),
	(469, 'COUNT(1)과 COUNT(*)는 동일한 결과를 반환한다', b'0', 1, 118),
	(470, 'COUNT(column1)는 NULL을 제외한 값만 카운트한다', b'0', 2, 118),
	(471, 'COUNT(DISTINCT column1)는 중복을 제거한 고유한 값만 카운트한다', b'1', 3, 118),
	(472, 'COUNT(NVL(column1, 0))는 NULL을 포함하여 카운트한다', b'0', 4, 118),
	(473, 'INNER JOIN을 사용하여 직원이 있는 부서만 포함', b'0', 1, 119),
	(474, 'LEFT OUTER JOIN을 사용하여 모든 부서를 포함하고, NULL 처리', b'1', 2, 119),
	(475, 'RIGHT OUTER JOIN을 사용하여 모든 부서를 포함하고, NULL 처리', b'0', 3, 119),
	(476, 'HAVING COUNT(*) > 0을 추가하여 직원이 있는 부서만 조회', b'0', 4, 119),
	(477, 'Query 1이 항상 가장 빠르다', b'0', 1, 120),
	(478, 'Query 2와 Query 3은 동일한 실행 계획을 생성한다', b'0', 2, 120),
	(479, 'Query 1은 서브쿼리로 인해 항상 가장 느리다', b'0', 3, 120),
	(480, '성능은 데이터의 분포도와 인덱스 구성에 따라 달라진다', b'1', 4, 120),
	(481, 'ROUND(123.456, 2)의 결과는 123.46이다', b'0', 1, 121),
	(482, 'TRUNC(123.456, 2)의 결과는 123.45이다', b'1', 2, 121),
	(483, 'CEIL(123.456)의 결과는 124이다', b'0', 3, 121),
	(484, 'MOD(10, 3)의 결과는 3이다', b'1', 4, 121),
	(485, 'COMMISSION_PCT가 NULL이면 SALARY를 반환한다', b'1', 1, 122),
	(486, 'COMMISSION_PCT가 NULL이면 0을 반환한다', b'0', 2, 122),
	(487, 'COMMISSION_PCT가 NULL이 아니면 SALARY를 반환한다', b'0', 3, 122),
	(488, 'COMMISSION_PCT가 NULL이 아니면 SALARY * COMMISSION_PCT를 반환한다', b'0', 4, 122),
	(489, 'ADD_MONTHS(SYSDATE, 3)', b'0', 1, 123),
	(490, 'SYSDATE + 90', b'1', 2, 123),
	(491, 'LAST_DAY(SYSDATE)', b'0', 3, 123),
	(492, 'TRUNC(SYSDATE, \'MONTH\')', b'0', 4, 123),
	(493, '부서별로 모든 직원의 이름을 쉼표로 구분하여 나열한다', b'0', 1, 124),
	(494, '부서별로 가장 높은 급여를 받는 직원의 이름을 출력한다', b'0', 2, 124),
	(495, '부서별로 직원의 이름을 급여 순으로 정렬하여 쉼표로 구분해 나열한다', b'1', 3, 124),
	(496, '부서별로 직원의 이름을 알파벳 순으로 정렬하여 출력한다', b'0', 4, 124),
	(497, 'DECODE는 등호(=) 비교만 가능하지만, CASE는 다양한 비교 연산자 사용이 가능하다', b'1', 1, 125),
	(498, 'DECODE는 다중 조건을 처리할 수 없지만, CASE는 가능하다', b'0', 2, 125),
	(499, 'DECODE는 ELSE 처리가 불가능하지만, CASE는 가능하다', b'0', 3, 125),
	(500, 'DECODE는 Oracle에서만 사용 가능하지만, CASE는 모든 DBMS에서 사용할 수 없다', b'0', 4, 125),
	(501, 'SUBSTR(\'ORACLE SQL\', 1, 6)의 결과는 \'ORACLE\'이다', b'0', 1, 126),
	(502, 'LPAD(\'SQL\', 5, \'*\')의 결과는 \'**SQL\'이다', b'0', 2, 126),
	(503, 'REPLACE(\'HELLO WORLD\', \'L\', \'*\')의 결과는 \'HE**O WORLD\'이다', b'0', 3, 126),
	(504, 'INSTR(\'ORACLE SQL\', \'SQL\')의 결과는 1이다', b'1', 4, 126),
	(505, '부서별 전체 직원 수를 조회한다', b'0', 1, 127),
	(506, '부서별 성별 비율을 계산한다', b'0', 2, 127),
	(507, '부서별 전체 직원 수와 성별 인원을 조회한다', b'1', 3, 127),
	(508, '성별로 부서별 직원 수를 조회한다', b'0', 4, 127),
	(509, 'REPLACE(REPLACE(phone_number, \'-\', \'\'), \')\', \'\')', b'0', 1, 128),
	(510, 'REGEXP_REPLACE(phone_number, \'[^0-9]\', \'\')', b'0', 2, 128),
	(511, 'TRANSLATE(phone_number, \'-) (\', \'   \')', b'0', 3, 128),
	(512, 'CASE WHEN INSTR(phone_number, \'-\') > 0 THEN REPLACE(phone_number, \'-\', \'\') ELSE phone_number END', b'1', 4, 128),
	(513, 'MONTHS_BETWEEN을 사용하여 정확한 월 수를 계산하고, 년도와 개월을 구분하여 출력한다', b'1', 1, 129),
	(514, 'SYSDATE - HIRE_DATE를 365로 나누어 근속연수를 구한다', b'0', 2, 129),
	(515, 'TO_CHAR(SYSDATE, \'YYYY\') - TO_CHAR(HIRE_DATE, \'YYYY\')로 근속연수를 계산한다', b'0', 3, 129),
	(516, 'FLOOR 함수로 연수만 계산하고 개월 수는 무시한다', b'0', 4, 129),
	(517, 'ROUND(AVG(NVL(commission_pct, 0)), 2)', b'0', 1, 130),
	(518, 'ROUND(NVL(AVG(commission_pct), 0), 2)', b'1', 2, 130),
	(519, 'COALESCE(ROUND(AVG(commission_pct), 2), 0)', b'0', 3, 130),
	(520, 'ROUND(AVG(COALESCE(commission_pct, 0)), 2)', b'0', 4, 130),
	(521, 'BETWEEN A AND B는 A와 B를 포함한 범위를 검색한다', b'0', 1, 131),
	(522, 'IN (list)는 list의 값 중 어느 하나와 일치하면 참이다', b'0', 2, 131),
	(523, 'LIKE \'_A%\'는 두 번째 문자가 \'A\'인 모든 문자열과 일치한다', b'0', 3, 131),
	(524, 'IS NULL은 NULL값을 찾을 때 \'=\' 연산자와 동일한 결과를 반환한다', b'1', 4, 131),
	(525, '급여가 5000 미만이거나 6000 초과인 직원을 조회한다', b'0', 1, 132),
	(526, '커미션이 없는 직원을 조회한다', b'0', 2, 132),
	(527, '부서번호가 10, 20, 30인 직원을 조회한다', b'0', 3, 132),
	(528, '2020년 이후 입사하고, 급여가 5000~6000 사이며, 커미션이 있고, 부서번호가 10,20,30이 아닌 직원을 조회한다', b'1', 4, 132),
	(529, 'department_id가 20이고 salary가 5000 미만인 직원이 있는 경우', b'1', 1, 133),
	(530, 'job_id가 \'SA_REP\'이고 salary가 5000 이상인 직원이 있는 경우', b'0', 2, 133),
	(531, 'department_id가 20이고 salary가 5000 이상인 직원이 있는 경우', b'0', 3, 133),
	(532, 'job_id가 \'SA_REP\'이고 salary가 5000 미만인 직원이 있는 경우', b'0', 4, 133),
	(533, 'LIKE 연산자를 숫자형 컬럼에 사용하면 암시적 형변환이 발생할 수 있다', b'1', 1, 134),
	(534, 'NVL 함수는 WHERE절에서 사용할 수 없다', b'0', 2, 134),
	(535, 'BETWEEN 연산자는 날짜형에 사용할 수 없다', b'0', 3, 134),
	(536, 'commission_pct가 NULL이면 전체 결과가 NULL이 된다', b'0', 4, 134),
	(537, 'LIKE 연산자에서 와일드카드(%)를 문자열 앞에 사용하면 인덱스를 효율적으로 사용할 수 없다', b'0', 1, 135),
	(538, 'IN 절 안의 서브쿼리는 실행 시점마다 결과가 달라질 수 있어 성능에 영향을 줄 수 있다', b'0', 2, 135),
	(539, 'NULL 값이 많은 컬럼은 IS NULL 조건보다 IS NOT NULL 조건이 인덱스를 더 효율적으로 사용한다', b'0', 3, 135),
	(540, 'OR 조건은 AND 조건으로 변환하여 사용하면 항상 더 나은 성능을 보장한다', b'1', 4, 135),
	(541, 'WHERE salary >= ANY (SELECT salary FROM employees)', b'0', 1, 136),
	(542, 'WHERE hire_date LIKE \'2023%\'', b'0', 2, 136),
	(543, 'WHERE salary BETWEEN NULL AND 5000', b'1', 3, 136),
	(544, 'WHERE job_id IN (\'IT_PROG\', \'SA_REP\')', b'0', 4, 136),
	(545, 'SELECT employee_name FROM employees WHERE NVL(commission_pct, 0) != 0;', b'0', 1, 137),
	(546, 'SELECT employee_name FROM employees WHERE commission_pct IS NOT NULL;', b'1', 2, 137),
	(547, 'SELECT employee_name FROM employees WHERE COALESCE(commission_pct, 0) > 0;', b'0', 3, 137),
	(548, 'SELECT employee_name FROM employees WHERE commission_pct > 0;', b'0', 4, 137),
	(549, 'SUBSTR(email, 1, 3) = \'ABC\'', b'0', 1, 138),
	(550, 'salary * 12 >= 60000', b'0', 2, 138),
	(551, 'hire_date = TO_DATE(\'2023-01-01\', \'YYYY-MM-DD\')', b'1', 3, 138),
	(552, 'NVL(department_id, 0) = 50', b'0', 4, 138),
	(553, 'WHERE EXTRACT(YEAR FROM hire_date) = 2023 AND salary >= 5000 AND department_id IN (10, 20, 30) AND email LIKE \'A%\'', b'0', 1, 139),
	(554, 'WHERE hire_date BETWEEN \'2023-01-01\' AND \'2023-12-31\' AND salary >= 5000 AND department_id IN (10, 20, 30) AND email LIKE \'A%\'', b'1', 2, 139),
	(555, 'WHERE email LIKE \'A%\' AND department_id IN (10, 20, 30) AND hire_date >= \'2023-01-01\' AND hire_date < \'2024-01-01\' AND salary >= 5000', b'0', 3, 139),
	(556, 'WHERE department_id IN (10, 20, 30) AND hire_date BETWEEN \'2023-01-01\' AND \'2023-12-31\' AND salary >= 5000 AND SUBSTR(email, 1, 1) = \'A\'', b'0', 4, 139),
	(557, '각 부서별 최고 급여를 받는 직원 중 커미션이 있는 직원을 조회하며, 서브쿼리가 한 번만 실행된다', b'1', 1, 140),
	(558, '각 부서별 최고 급여를 받는 직원을 조회하며, 서브쿼리가 주 쿼리의 각 행마다 실행된다', b'0', 2, 140),
	(559, '전체 직원 중 최고 급여를 받는 직원을 조회하며, 인덱스를 효율적으로 사용할 수 없다', b'0', 3, 140),
	(560, '부서와 급여가 동일한 직원을 조회하며, 중첩 루프 조인이 발생한다', b'0', 4, 140),
	(561, 'GROUP BY 절에 사용된 컬럼은 SELECT 절에서 사용할 수 있다', b'0', 1, 141),
	(562, 'HAVING 절은 GROUP BY 절 없이 단독으로 사용할 수 있다', b'1', 2, 141),
	(563, 'GROUP BY 절에는 별칭(Alias)을 사용할 수 없다', b'0', 3, 141),
	(564, 'HAVING 절은 그룹화된 결과에 대한 조건을 지정한다', b'0', 4, 141),
	(565, '모든 부서와 직무별 급여 통계를 조회한다', b'0', 1, 142),
	(566, '급여가 5000 이상인 직원이 2명 이상인 부서의 통계를 조회한다', b'0', 2, 142),
	(567, '급여가 5000 이상이며, 같은 부서와 직무를 가진 직원이 2명 이상인 그룹의 통계를 조회한다', b'1', 3, 142),
	(568, '부서별로 최대 급여가 5000 이상이고 최소 급여가 2000 이상인 통계를 조회한다', b'0', 4, 142),
	(569, 'department_id가 NULL인 직원이 있는 경우', b'0', 1, 143),
	(570, 'salary가 NULL인 직원이 있는 경우', b'0', 2, 143),
	(571, '평균 급여가 5000 미만인 부서가 있는 경우', b'0', 3, 143),
	(572, '두 쿼리는 항상 에러가 발생한다', b'1', 4, 143),
	(573, 'GROUP BY로 부서별 그룹화 후, HAVING 절에서 조건을 체크한다', b'0', 1, 144),
	(574, 'HAVING 절에서 NULL 처리를 한다', b'0', 2, 144),
	(575, 'WHERE 절에서 NULL을 먼저 제외하고, GROUP BY 후 HAVING에서 조건을 체크한다', b'1', 3, 144),
	(576, 'HAVING 절에서 NULL을 먼저 필터링한다', b'0', 4, 144),
	(577, 'COUNT 함수로 각 급여 구간의 개수를 계산한다', b'0', 1, 145),
	(578, 'SUM 함수와 CASE를 사용하여 구간별 집계를 한다', b'1', 2, 145),
	(579, 'ROLLUP을 사용하여 급여 범위를 만든다', b'0', 3, 145),
	(580, 'HAVING 절을 사용해 특정 급여 구간을 필터링한다', b'0', 4, 145),
	(581, 'EXTRACT(YEAR FROM hire_date)', b'0', 1, 146),
	(582, 'CASE WHEN salary > 5000 THEN \'HIGH\' ELSE \'LOW\' END', b'0', 2, 146),
	(583, 'NVL(department_id, 0)', b'0', 3, 146),
	(584, 'salary + commission_pct', b'1', 4, 146),
	(585, 'employee_name은 GROUP BY 절에 포함되어야 한다', b'1', 1, 147),
	(586, 'MAX(salary)는 GROUP BY 절에 포함되어야 한다', b'0', 2, 147),
	(587, 'first_hired라는 별칭은 사용할 수 없다', b'0', 3, 147),
	(588, 'department_id와 job_id는 SELECT 절에서 사용할 수 없다', b'0', 4, 147),
	(589, 'TO_CHAR(hire_date, \'YYYY-MM\')로 그룹화하여 월별 데이터를 집계한다', b'1', 1, 148),
	(590, 'EXTRACT(MONTH FROM hire_date)를 사용하여 월별 데이터를 집계한다', b'0', 2, 148),
	(591, 'ROLLUP을 사용해 부서별, 날짜별 그룹을 만든다', b'0', 3, 148),
	(592, 'HAVING 절에서 특정 연도에 대한 필터링을 수행한다', b'0', 4, 148),
	(593, 'HAVING 절에서 전체 매출의 10%를 넘는지 확인한다', b'1', 1, 149),
	(594, 'WHERE 절에서 amount >= 1000인 데이터만 필터링한다', b'0', 2, 149),
	(595, '서브쿼리를 사용해 전체 매출의 10% 이상을 찾는다', b'0', 3, 149),
	(596, 'HAVING 절에서 COUNT(*)가 1000 이상인 경우만 필터링한다', b'0', 4, 149),
	(597, 'GROUP BY 절에 인덱스가 생성된 컬럼을 사용한다', b'0', 1, 150),
	(598, 'GROUP BY 전에 WHERE 절로 데이터를 최대한 필터링한다', b'0', 2, 150),
	(599, 'GROUP BY 대신 DISTINCT를 사용하여 중복을 제거한다', b'1', 3, 150),
	(600, 'GROUP BY 결과를 임시 테이블에 저장하여 재사용한다', b'0', 4, 150),
	(601, 'ORDER BY 절은 SQL문의 가장 마지막에 위치한다', b'0', 1, 151),
	(602, 'ORDER BY 절에서 열 번호를 사용하여 정렬할 수 있다', b'0', 2, 151),
	(603, '오름차순 정렬의 경우 ASC를 생략할 수 있다', b'0', 3, 151),
	(604, 'GROUP BY 절에 사용한 컬럼만 ORDER BY 절에서 사용할 수 있다', b'1', 4, 151),
	(605, 'department_id를 기준으로 오름차순 정렬한다', b'0', 1, 152),
	(606, '평균 급여를 기준으로 내림차순 정렬한다', b'0', 2, 152),
	(607, '직원 수를 기준으로 내림차순, 같은 경우 평균 급여 오름차순으로 정렬한다', b'1', 3, 152),
	(608, 'department_id를 기준으로 내림차순, 같은 경우 직원 수 오름차순으로 정렬한다', b'0', 4, 152),
	(609, 'salary가 NULL인 직원이 없는 경우', b'0', 1, 153),
	(610, 'department_id가 NULL인 직원이 있는 경우', b'0', 2, 153),
	(611, 'salary가 NULL인 직원이 있는 경우', b'1', 3, 153),
	(612, 'first_name이 NULL인 직원이 있는 경우', b'0', 4, 153),
	(613, 'ORDER BY d.department_name, j.job_title, e.salary DESC, e.hire_date;', b'0', 1, 154),
	(614, 'ORDER BY d.department_name NULLS LAST, j.job_title NULLS LAST, e.salary DESC NULLS LAST, e.hire_date ASC;', b'1', 2, 154),
	(615, 'ORDER BY 3, 4, 5 DESC, 6;', b'0', 3, 154),
	(616, 'ORDER BY CASE WHEN d.department_name IS NULL THEN 1 ELSE 0 END, d.department_name, CASE WHEN j.job_title IS NULL THEN 1 ELSE 0 END, j.job_title, e.salary DESC, e.hire_date;', b'0', 4, 154),
	(617, 'RANK()를 사용하여 부서별 급여 순위를 매기고 상위 3위까지만 조회', b'1', 1, 155),
	(618, 'ROW_NUMBER()를 사용하여 부서별 급여 순위를 매기고 상위 3위까지만 조회', b'0', 2, 155),
	(619, 'DENSE_RANK()를 사용하여 부서별 급여 순위를 매기고 상위 3위까지만 조회', b'0', 3, 155),
	(620, 'WHERE rank <= 3을 사용하여 순위를 필터링한다', b'0', 4, 155),
	(621, 'ORDER BY salary DESC NULLS FIRST', b'1', 1, 156),
	(622, 'ORDER BY salary NULLS LAST', b'0', 2, 156),
	(623, 'ORDER BY NVL(salary, 0)', b'0', 3, 156),
	(624, 'ORDER BY salary IS NULL, salary', b'0', 4, 156),
	(625, '(department_id, job_id, hire_date, salary)', b'1', 1, 157),
	(626, '(job_id, hire_date, salary)', b'0', 2, 157),
	(627, '(department_id) + (job_id, hire_date, salary)', b'0', 3, 157),
	(628, '(hire_date, job_id, salary)', b'0', 4, 157),
	(629, 'hire_date에 인덱스가 있는 경우', b'0', 1, 158),
	(630, 'employee_id에 인덱스가 있는 경우', b'1', 2, 158),
	(631, 'salary에 인덱스가 있는 경우', b'0', 3, 158),
	(632, '어떤 인덱스가 있어도 실행 계획은 같다', b'0', 4, 158),
	(633, 'RANK()를 사용하여 상위 3개 부서를 구하고, 나머지는 "Others"로 그룹화', b'1', 1, 159),
	(634, 'HAVING RANK() OVER (ORDER BY SUM(salary) DESC) <= 3을 사용하여 상위 3개 부서를 조회', b'0', 2, 159),
	(635, 'ROWNUM을 사용하여 상위 3개 부서를 조회', b'0', 3, 159),
	(636, 'CASE WHEN ROWNUM <= 3 THEN department_name ELSE "Others" END를 사용하여 정렬', b'0', 4, 159),
	(637, '불필요한 컬럼은 SELECT 목록에서 제외한다', b'0', 1, 160),
	(638, '가능한 모든 정렬 컬럼에 대해 인덱스를 생성한다', b'1', 2, 160),
	(639, 'ORDER BY 대신 인라인 뷰의 ROWNUM을 활용한다', b'0', 3, 160),
	(640, 'WHERE 절로 데이터를 최대한 필터링한 후 정렬한다', b'0', 4, 160),
	(641, 'EQUI JOIN은 \'=\' 연산자를 사용하여 같은 값을 가진 컬럼을 연결한다.', b'0', 1, 161),
	(642, 'NATURAL JOIN은 동일한 이름의 컬럼을 자동으로 조인해주는 기능이다.', b'0', 2, 161),
	(643, 'CROSS JOIN은 조인 조건이 없는 모든 데이터의 조합을 출력한다.', b'0', 3, 161),
	(644, 'OUTER JOIN은 조인 조건에서 NULL 값을 가진 데이터는 절대 출력할 수 없다.', b'1', 4, 161),
	(645, '부서가 없는 사원의 수를 조회한다.', b'1', 1, 162),
	(646, '사원이 없는 부서의 수를 조회한다.', b'0', 2, 162),
	(647, '모든 사원의 수를 조회한다.', b'0', 3, 162),
	(648, '모든 부서의 수를 조회한다.', b'0', 4, 162),
	(649, 'SELECT * FROM TABLE1 T1 INNER JOIN TABLE2 T2 ON T1.COL1 = T2.COL1 INNER JOIN TABLE3 T3 ON T2.COL2 = T3.COL2;', b'1', 1, 163),
	(650, 'SELECT * FROM TABLE1 T1 LEFT JOIN TABLE2 T2 ON T1.COL1 = T2.COL1 LEFT JOIN TABLE3 T3 ON T2.COL2 = T3.COL2;', b'0', 2, 163),
	(651, 'SELECT * FROM TABLE1 T1 RIGHT JOIN TABLE2 T2 ON T1.COL1 = T2.COL1 RIGHT JOIN TABLE3 T3 ON T2.COL2 = T3.COL2;', b'0', 3, 163),
	(652, 'SELECT * FROM TABLE1 T1 FULL OUTER JOIN TABLE2 T2 ON T1.COL1 = T2.COL1 FULL OUTER JOIN TABLE3 T3 ON T2.COL2 = T3.COL2;', b'0', 4, 163),
	(653, 'EMP 테이블의 모든 DEPTNO가 DEPT 테이블에 존재하는 경우', b'0', 1, 164),
	(654, 'DEPT 테이블의 모든 부서에 사원이 배정된 경우', b'0', 2, 164),
	(655, 'EMP 테이블의 DEPTNO가 NULL인 데이터가 있는 경우', b'1', 3, 164),
	(656, 'DEPT 테이블의 DEPTNO가 NULL인 데이터가 있는 경우', b'0', 4, 164),
	(657, 'CARTESIAN PRODUCT가 발생할 수 있다', b'0', 1, 165),
	(658, 'NULL 값을 가진 데이터가 누락될 수 있다', b'1', 2, 165),
	(659, '조인 컬럼의 인덱스를 사용할 수 없다', b'0', 3, 165),
	(660, '조인 조건과 일반 조건의 순서가 잘못되었다', b'0', 4, 165),
	(661, '동일한 테이블을 두 번 이상 조인하는 것이다', b'0', 1, 166),
	(662, '한 테이블 내에서 두 컬럼이 연관관계가 있을 때 사용한다', b'0', 2, 166),
	(663, '반드시 서브쿼리와 함께 사용해야 한다', b'1', 3, 166),
	(664, '계층 구조를 표현할 때 주로 사용된다', b'0', 4, 166),
	(665, 'Query 1과 Query 2', b'1', 1, 167),
	(666, 'Query 3과 Query 4', b'0', 2, 167),
	(667, 'Query 2와 Query 3', b'0', 3, 167),
	(668, 'Query 1과 Query 4', b'0', 4, 167),
	(669, 'SELECT o.order_id, c.customer_name, o.amount FROM orders o LEFT JOIN customers c ON o.customer_id = c.customer_id ORDER BY o.amount DESC;', b'0', 1, 168),
	(670, 'SELECT o.order_id, c.customer_name, o.amount FROM orders o RIGHT JOIN customers c ON o.customer_id = c.customer_id ORDER BY o.amount DESC;', b'0', 2, 168),
	(671, 'SELECT o.order_id, c.customer_name, o.amount FROM orders o INNER JOIN customers c ON o.customer_id = c.customer_id ORDER BY o.amount DESC;', b'1', 3, 168),
	(672, 'SELECT o.order_id, c.customer_name, o.amount FROM orders o FULL OUTER JOIN customers c ON o.customer_id = c.customer_id ORDER BY o.amount DESC;', b'0', 4, 168),
	(673, 'SELECT COALESCE(d.department_name, \'No Department\') as dept_name, COUNT(e.employee_id) as emp_count FROM departments d FULL OUTER JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name ORDER BY dept_name;', b'0', 1, 169),
	(674, 'SELECT d.department_name, COUNT(e.employee_id) as emp_count FROM departments d LEFT OUTER JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name ORDER BY d.department_name NULLS LAST;', b'0', 2, 169),
	(675, 'SELECT NVL(d.department_name, \'No Department\') as dept_name, COUNT(e.employee_id) as emp_count FROM departments d FULL OUTER JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name ORDER BY CASE WHEN d.department_name IS NULL THEN \'No Department\' ELSE d.department_name END;', b'1', 3, 169),
	(676, 'SELECT COALESCE(d.department_name, \'No Department\') as dept_name, COUNT(*) as emp_count FROM employees e RIGHT OUTER JOIN departments d ON e.department_id = d.department_id GROUP BY d.department_name ORDER BY dept_name;', b'0', 4, 169),
	(677, 'INNER JOIN 대신 EXISTS를 사용한다', b'0', 1, 170),
	(678, '조인 조건에 인덱스를 생성한다', b'0', 2, 170),
	(679, 'WHERE 절의 조건을 ON 절로 이동한다', b'1', 3, 170),
	(680, '불필요한 외부 조인을 내부 조인으로 변경한다', b'0', 4, 170),
	(681, 'INNER JOIN은 양쪽 테이블에서 매칭되는 데이터만 조회한다.', b'0', 1, 171),
	(682, 'LEFT OUTER JOIN은 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 매칭되는 데이터를 조회한다.', b'0', 2, 171),
	(683, 'CROSS JOIN은 ON 절을 필수적으로 사용해야 한다.', b'1', 3, 171),
	(684, 'FULL OUTER JOIN은 양쪽 테이블의 모든 데이터를 조회한다.', b'0', 4, 171),
	(685, 'department_id가 NULL인 직원이 있는 경우', b'1', 1, 172),
	(686, 'location_id가 1700이 아닌 부서가 있는 경우', b'0', 2, 172),
	(687, '부서가 없는 직원이 있는 경우', b'0', 3, 172),
	(688, '직원이 없는 부서가 있는 경우', b'0', 4, 172),
	(689, '2개의 행이 조회된다', b'0', 1, 173),
	(690, '3개의 행이 조회된다', b'0', 2, 173),
	(691, '4개의 행이 조회된다', b'1', 3, 173),
	(692, '5개의 행이 조회된다', b'0', 4, 173),
	(693, 'SELECT d.department_name, COUNT(e.employee_id) as emp_count, AVG(e.salary) as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name;', b'0', 1, 174),
	(694, 'SELECT d.department_name, COUNT(e.employee_id) as emp_count, NVL(AVG(e.salary), 0) as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_id, d.department_name;', b'1', 2, 174),
	(695, 'SELECT d.department_name, COUNT(*) as emp_count, AVG(NVL(e.salary, 0)) as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_name;', b'0', 3, 174),
	(696, 'SELECT d.department_name, COUNT(1) as emp_count, COALESCE(AVG(e.salary), 0) as avg_salary FROM employees e RIGHT JOIN departments d ON e.department_id = d.department_id GROUP BY d.department_name;', b'0', 4, 174),
	(697, 'WHERE 절의 조건을 먼저 적용하여 조인 대상 데이터를 줄인다', b'0', 1, 175),
	(698, 'LEFT JOIN 대신 INNER JOIN을 사용하여 성능을 개선한다', b'1', 2, 175),
	(699, '조인 순서를 조정하여 더 작은 결과셋을 먼저 조인한다', b'0', 3, 175),
	(700, '모든 조인 컬럼에 인덱스가 있는지 확인한다', b'0', 4, 175),
	(701, '동일한 이름을 가진 모든 컬럼을 조인 조건으로 사용한다', b'1', 1, 176),
	(702, 'ON 절을 사용하여 조인 조건을 명시해야 한다', b'0', 2, 176),
	(703, '조인하는 테이블 간에 같은 이름의 컬럼이 없어도 사용할 수 있다', b'0', 3, 176),
	(704, '결과에 조인 컬럼이 중복되어 나타난다', b'0', 4, 176),
	(705, 'Query 1과 Query 2', b'0', 1, 177),
	(706, 'Query 3과 Query 4', b'0', 2, 177),
	(707, 'Query 2와 Query 3', b'1', 3, 177),
	(708, 'Query 1과 Query 4', b'0', 4, 177),
	(709, 'INNER JOIN만 사용', b'1', 1, 178),
	(710, 'LEFT OUTER JOIN만 사용', b'0', 2, 178),
	(711, 'INNER JOIN과 LEFT OUTER JOIN 혼용', b'0', 3, 178),
	(712, 'CROSS JOIN 사용', b'0', 4, 178),
	(713, 'SELECT d.department_name, NVL(AVG(e.salary), (SELECT AVG(salary) FROM employees)) as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_id, d.department_name;', b'0', 1, 179),
	(714, 'SELECT d.department_name, CASE WHEN COUNT(e.employee_id) = 0 THEN (SELECT AVG(salary) FROM employees) ELSE AVG(e.salary) END as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_id, d.department_name;', b'1', 2, 179),
	(715, 'SELECT d.department_name, COALESCE(AVG(e.salary), 0) as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_id, d.department_name;', b'0', 3, 179),
	(716, 'SELECT d.department_name, AVG(NVL(e.salary, (SELECT AVG(salary) FROM employees))) as avg_salary FROM departments d LEFT JOIN employees e ON d.department_id = e.department_id GROUP BY d.department_id, d.department_name;', b'0', 4, 179),
	(717, '계층 구조 데이터 조회', b'0', 1, 180),
	(718, '모든 가능한 조합 생성', b'1', 2, 180),
	(719, '누락된 데이터 검색', b'0', 3, 180),
	(720, '집계 데이터 생성', b'0', 4, 180),
	(721, '단일 행 서브쿼리는 실행 결과가 1건 이하인 서브쿼리이다', b'0', 1, 181),
	(722, '다중 행 서브쿼리는 IN, ANY, ALL 등의 연산자와 함께 사용할 수 있다', b'0', 2, 181),
	(723, '스칼라 서브쿼리는 SELECT절에서 사용되며 반드시 다중 행을 반환해야 한다', b'1', 3, 181),
	(724, '상호연관 서브쿼리는 메인쿼리의 컬럼을 서브쿼리에서 참조하는 형태이다', b'0', 4, 181),
	(725, '전체 직원의 평균 급여보다 높은 급여를 받는 직원을 조회한다', b'0', 1, 182),
	(726, '각 부서별 평균 급여보다 높은 급여를 받는 직원을 조회한다', b'1', 2, 182),
	(727, '부서가 없는 직원 중 평균 급여보다 높은 급여를 받는 직원을 조회한다', b'0', 3, 182),
	(728, '모든 부서의 평균 급여보다 높은 급여를 받는 직원을 조회한다', b'0', 4, 182),
	(729, 'employees 테이블에 salary가 NULL인 데이터가 있는 경우', b'0', 1, 183),
	(730, 'departments 테이블에 직원이 없는 부서가 있는 경우', b'0', 2, 183),
	(731, 'employees 테이블에 department_id가 NULL인 데이터가 있는 경우', b'1', 3, 183),
	(732, 'departments 테이블의 department_id가 중복되는 경우', b'0', 4, 183),
	(733, '스칼라 서브쿼리는 SELECT절에서 사용할 수 없다', b'0', 1, 184),
	(734, '서브쿼리가 NULL을 반환하면 전체 결과가 출력되지 않는다', b'0', 2, 184),
	(735, '각 행마다 서브쿼리가 실행되어 성능이 저하될 수 있다', b'1', 3, 184),
	(736, '두 개의 스칼라 서브쿼리는 동시에 사용할 수 없다', b'0', 4, 184),
	(737, '서브쿼리를 조인으로 변환하여 사용한다', b'0', 1, 185),
	(738, 'WITH절을 사용하여 서브쿼리 결과를 재사용한다', b'0', 2, 185),
	(739, '모든 서브쿼리는 뷰로 생성하여 사용한다', b'1', 3, 185),
	(740, '불필요한 중첩 단계를 줄여 서브쿼리를 단순화한다', b'0', 4, 185),
	(741, 'FROM절에서 사용되는 서브쿼리이다', b'0', 1, 186),
	(742, 'ORDER BY절을 사용할 수 있다', b'0', 2, 186),
	(743, '반드시 별칭(Alias)을 지정해야 한다', b'0', 3, 186),
	(744, '메인쿼리의 컬럼을 참조할 수 없다', b'1', 4, 186),
	(745, '전체 직원 중 급여가 가장 높은 2명을 조회한다', b'0', 1, 187),
	(746, '각 부서별로 급여가 가장 높은 직원을 조회한다', b'0', 2, 187),
	(747, '각 부서별로 급여가 높은 순서대로 2명의 직원을 조회한다', b'1', 3, 187),
	(748, '급여가 평균보다 높은 모든 직원을 조회한다', b'0', 4, 187),
	(749, 'EXISTS를 사용하여 변환', b'0', 1, 188),
	(750, '조인으로 변환', b'0', 2, 188),
	(751, 'WITH절을 사용하여 변환', b'0', 3, 188),
	(752, '현재 방식 유지', b'1', 4, 188),
	(753, 'LEFT JOIN을 사용하여 부서가 없는 직원 포함 및 부서별 평균 급여 비교', b'1', 1, 189),
	(754, 'JOIN을 사용하여 부서별 평균 급여보다 높은 직원 조회', b'0', 2, 189),
	(755, 'WITH절을 활용하여 부서별 평균 급여를 미리 계산 후 비교', b'0', 3, 189),
	(756, '부서별 평균 급여보다 높은 직원만 필터링 (부서 없는 직원 제외)', b'0', 4, 189),
	(757, '모든 서브쿼리를 조인으로 변환', b'0', 1, 190),
	(758, 'WITH절을 사용하여 결과 캐시', b'1', 2, 190),
	(759, '뷰 생성하여 재사용', b'0', 3, 190),
	(760, '복합 인덱스 생성', b'0', 4, 190),
	(761, 'UNION은 두 집합의 합집합을 반환하고 중복을 제거한다', b'0', 1, 191),
	(762, 'INTERSECT는 두 집합의 교집합을 반환한다', b'0', 2, 191),
	(763, 'UNION ALL은 두 집합의 합집합을 반환하고 중복을 허용한다', b'0', 3, 191),
	(764, 'MINUS는 첫 번째 집합과 두 번째 집합의 교집합을 반환한다', b'1', 4, 191),
	(765, '부서번호가 10인 직원과 급여가 5000 이상인 직원을 모두 조회하며 중복은 제거된다', b'1', 1, 192),
	(766, '부서번호가 10이고 급여가 5000 이상인 직원만 조회된다', b'0', 2, 192),
	(767, '부서번호가 10인 직원만 조회된다', b'0', 3, 192),
	(768, 'ORDER BY 절은 에러를 발생시킨다', b'0', 4, 192),
	(769, 'employees 테이블의 department_id가 모두 NULL인 경우', b'0', 1, 193),
	(770, 'departments 테이블의 모든 부서에 직원이 있는 경우', b'0', 2, 193),
	(771, 'employees 테이블의 department_id가 모두 departments 테이블에 존재하는 경우', b'0', 3, 193),
	(772, '두 쿼리는 항상 같은 결과를 반환한다', b'1', 4, 193),
	(773, '두 기간의 매출을 별도로 집계한 후, 동일한 월만 조인하여 차이를 계산한다', b'1', 1, 194),
	(774, 'INTERSECT를 사용하여 공통된 월만 조회한 후 차이를 계산한다', b'0', 2, 194),
	(775, 'CASE 문을 활용하여 동일한 쿼리 내에서 매출 비교를 수행한다', b'0', 3, 194),
	(776, 'UNION ALL을 사용하여 두 기간을 별도로 조회하고 매출 차이를 계산한다', b'0', 4, 194),
	(777, '집합 연산자로 연결되는 각 SELECT문의 컬럼 수가 동일해야 한다', b'0', 1, 195),
	(778, '집합 연산자로 연결되는 각 SELECT문의 컬럼 데이터 타입이 일치해야 한다', b'0', 2, 195),
	(779, 'ORDER BY절은 마지막 SELECT문에만 사용할 수 있다', b'0', 3, 195),
	(780, '각 SELECT문의 별칭(Alias)이 모두 동일해야 한다', b'1', 4, 195),
	(781, 'UNION ALL은 ORDER BY를 사용할 수 없다', b'0', 1, 196),
	(782, 'UNION은 중복을 제거하지만, UNION ALL은 중복을 허용한다', b'1', 2, 196),
	(783, 'UNION ALL은 데이터 타입이 다른 컬럼도 연결할 수 있다', b'0', 3, 196),
	(784, 'UNION은 NULL 값을 포함할 수 없다', b'0', 4, 196),
	(785, 'Query 1과 Query 2는 동일한 결과를 반환한다', b'1', 1, 197),
	(786, 'Query 3과 Query 4는 동일한 결과를 반환한다', b'0', 2, 197),
	(787, 'Query 2와 Query 3은 동일한 결과를 반환한다', b'0', 3, 197),
	(788, 'Query 1과 Query 4는 동일한 결과를 반환한다', b'0', 4, 197),
	(789, '2개의 행이 조회된다', b'1', 1, 198),
	(790, '3개의 행이 조회된다', b'0', 2, 198),
	(791, '1개의 행이 조회된다', b'0', 3, 198),
	(792, '0개의 행이 조회된다', b'0', 4, 198),
	(793, '부서별로 따로 집계 후 INNER JOIN으로 연결', b'0', 1, 199),
	(794, 'HAVING 절과 CASE 문을 활용하여 단일 테이블 조회로 최적화', b'1', 2, 199),
	(795, 'WITH절을 사용하여 고객 데이터를 필터링 후 조회', b'0', 3, 199),
	(796, 'INTERSECT를 사용하여 2023년과 2024년 모두 주문한 고객을 찾는다', b'0', 4, 199),
	(797, 'UNION 대신 UNION ALL 사용을 고려한다', b'1', 1, 200),
	(798, '양쪽 쿼리에 WHERE 조건을 추가한다', b'0', 2, 200),
	(799, 'ORDER BY를 제거한다', b'0', 3, 200),
	(800, '뷰로 생성하여 사용한다', b'0', 4, 200),
	(801, 'COUNT(*)는 NULL 값을 포함한 모든 행의 수를 계산한다', b'0', 1, 201),
	(802, 'SUM 함수는 NULL 값을 제외하고 합계를 계산한다', b'0', 2, 201),
	(803, 'AVG 함수는 NULL 값을 0으로 처리하여 평균을 계산한다', b'1', 3, 201),
	(804, 'MAX/MIN 함수는 날짜 데이터 타입에도 사용 가능하다', b'0', 4, 201),
	(805, '모든 부서의 급여 통계를 조회한다', b'0', 1, 202),
	(806, '커미션이 있는 부서의 급여 통계를 조회한다', b'0', 2, 202),
	(807, '직원이 5명 이상인 부서의 급여 통계를 조회한다', b'1', 3, 202),
	(808, '평균 급여가 5000 이상인 부서의 통계를 조회한다', b'0', 4, 202),
	(809, 'employee_id 컬럼에 NULL이 있는 경우', b'1', 1, 203),
	(810, 'department_id 컬럼에 NULL이 있는 경우', b'0', 2, 203),
	(811, 'employee_id가 중복되는 경우', b'0', 3, 203),
	(812, 'department_id가 중복되는 경우', b'0', 4, 203),
	(813, '부서별, 직무별 소계와 총계를 모두 계산한다', b'1', 1, 204),
	(814, '부서별 소계만 계산한다', b'0', 2, 204),
	(815, '직무별 소계만 계산한다', b'0', 3, 204),
	(816, '부서와 직무의 조합별 집계만 계산한다', b'0', 4, 204),
	(817, 'AVG(salary), SUM(salary), MAX(salary) - MIN(salary) 사용', b'0', 1, 205),
	(818, 'ROUND(AVG(NVL(salary,0)),2) 사용, 급여 NULL을 0 처리', b'0', 2, 205),
	(819, 'ROUND(AVG(salary),2) 사용, 커미션 NULL 제외', b'0', 3, 205),
	(820, 'ROUND(AVG(NVL(salary,0)),2) 사용, 급여 및 최대/최소 NVL 적용', b'1', 4, 205),
	(821, 'ROLLUP은 지정된 컬럼의 계층적 집계만 생성한다', b'1', 1, 206),
	(822, 'CUBE는 GROUP BY 절에서만 사용할 수 있다', b'0', 2, 206),
	(823, 'ROLLUP은 NULL 값을 포함할 수 없다', b'0', 3, 206),
	(824, 'CUBE는 단일 컬럼에 대해서만 사용할 수 있다', b'0', 4, 206),
	(825, 'COUNT(DISTINCT salary) 사용', b'0', 1, 207),
	(826, 'COUNT(*)와 DISTINCT 서브쿼리 사용', b'0', 2, 207),
	(827, 'COUNT(1)와 GROUP BY 사용', b'0', 3, 207),
	(828, 'COUNT(*)와 WHERE salary IS NOT NULL 사용', b'1', 4, 207),
	(829, 'LISTAGG(employee_name, ", ") WITHIN GROUP (ORDER BY employee_name)', b'0', 1, 208),
	(830, 'LISTAGG(employee_name, ", " ON OVERFLOW TRUNCATE)', b'0', 2, 208),
	(831, 'LISTAGG(SUBSTR(employee_name,1,10), ", ") WITHIN GROUP (ORDER BY employee_name)', b'0', 3, 208),
	(832, 'LISTAGG(employee_name, ", " ON OVERFLOW TRUNCATE "...") WITHIN GROUP (ORDER BY employee_name)', b'1', 4, 208),
	(833, 'AVG(salary * NVL(commission_pct, 0)) 사용', b'0', 1, 209),
	(834, 'AVG(salary * commission_pct) 사용', b'1', 2, 209),
	(835, 'AVG(NVL(salary * commission_pct, 0)) 사용', b'0', 3, 209),
	(836, 'AVG(NVL(salary,0) * NVL(commission_pct,0)) 사용', b'0', 4, 209),
	(837, '모든 부서에 직원이 한 명씩만 있는 경우', b'0', 1, 210),
	(838, '모든 직원의 급여가 동일한 경우', b'0', 2, 210),
	(839, '부서가 하나만 있는 경우', b'0', 3, 210),
	(840, '위의 모든 경우', b'1', 4, 210),
	(841, 'ROW_NUMBER()는 동일한 값에 대해 고유한 순위를 부여한다', b'0', 1, 211),
	(842, 'RANK()는 동일한 값에 대해 같은 순위를 부여하고 다음 순위는 건너뛴다', b'0', 2, 211),
	(843, 'DENSE_RANK()는 동일한 값에 대해 같은 순위를 부여하고 다음 순위는 건너뛰지 않는다', b'0', 3, 211),
	(844, 'PARTITION BY는 GROUP BY와 동일하게 그룹 단위 집계를 수행한다', b'1', 4, 211),
	(845, '부서별 급여 합계를 계산한다', b'0', 1, 212),
	(846, '전체 직원의 급여 누적 합계를 계산한다', b'0', 2, 212),
	(847, '부서 내에서 현재 행까지의 급여 누적 합계를 계산한다', b'1', 3, 212),
	(848, '부서별로 가장 높은 급여를 계산한다', b'0', 4, 212),
	(849, '모든 부서의 급여가 동일한 경우', b'0', 1, 213),
	(850, '부서가 하나만 있는 경우', b'0', 2, 213),
	(851, '급여가 같은 직원이 있는 경우', b'1', 3, 213),
	(852, '부서별로 가장 높은 급여가 모두 다른 경우', b'0', 4, 213),
	(853, 'RANK()를 사용하여 급여 순위를 매긴다', b'0', 1, 214),
	(854, 'ROW_NUMBER()를 사용하여 급여 순위를 매긴다', b'0', 2, 214),
	(855, 'DENSE_RANK()를 사용하여 급여 순위를 매긴다', b'1', 3, 214),
	(856, 'COUNT()를 사용하여 순위를 매긴다', b'0', 4, 214),
	(857, 'LAG와 LEAD 없이 SUM()을 활용하여 계산한다', b'0', 1, 215),
	(858, 'LAG()를 사용하여 전일 매출과 비교하고, AVG()로 이동평균을 구한다', b'0', 2, 215),
	(859, 'LEAD()를 사용하여 다음 행과 비교하고, SUM()을 활용하여 누적 매출을 구한다', b'0', 3, 215),
	(860, 'LAG()와 이동 평균 윈도우 함수 사용, 누적합은 SUM()을 사용', b'1', 4, 215),
	(861, 'LAG는 이전 행만 참조할 수 있다', b'1', 1, 216),
	(862, 'LEAD는 다음 행만 참조할 수 있다', b'1', 2, 216),
	(863, 'LAG는 NULL 값을 처리할 수 없다', b'0', 3, 216),
	(864, 'LEAD는 PARTITION BY와 함께 사용할 수 없다', b'0', 4, 216),
	(865, 'FIRST_VALUE()는 전체 데이터 중 첫 번째 값을 반환한다', b'0', 1, 217),
	(866, 'MIN()은 전체 데이터에서 최소값을 반환한다', b'0', 2, 217),
	(867, 'ROWS 범위를 지정하면 누적 최소값이 계산된다', b'1', 3, 217),
	(868, '모든 FIRST_VALUE()와 MIN() 함수는 동일한 결과를 반환한다', b'0', 4, 217),
	(869, 'AVG()를 사용하여 중앙값을 계산한다', b'0', 1, 218),
	(870, 'PERCENTILE_CONT(0.5)를 사용하여 중앙값을 계산한다', b'1', 2, 218),
	(871, 'MIN과 MAX를 평균 내서 중앙값을 계산한다', b'0', 3, 218),
	(872, 'MEDIAN() 함수를 사용하여 중앙값을 계산한다', b'0', 4, 218),
	(873, 'ROUND(salary/SUM(salary) OVER (PARTITION BY department_id) * 100, 2)를 사용한다', b'0', 1, 219),
	(874, 'RATIO_TO_REPORT()를 사용하여 비율을 계산한다', b'0', 2, 219),
	(875, 'RATIO_TO_REPORT()를 사용하여 부서별/전체 급여 비율을 구하고 ROUND()로 정리한다', b'1', 3, 219),
	(876, 'PCT_RANK()를 사용하여 급여 비율을 계산한다', b'0', 4, 219),
	(877, 'PARTITION BY는 윈도우 함수의 그룹을 결정한다', b'0', 1, 220),
	(878, 'ORDER BY는 순위를 부여하는 기준을 결정한다', b'0', 2, 220),
	(879, 'ROWS 절은 RANK() 함수의 결과에 영향을 미치지 않는다', b'1', 3, 220),
	(880, 'SELECT 절의 컬럼 순서는 윈도우 함수의 결과에 영향을 미친다', b'0', 4, 220),
	(881, 'ROWNUM은 Oracle에서 사용되는 의사 컬럼(Pseudo Column)이다', b'0', 1, 221),
	(882, 'TOP N 쿼리는 데이터를 정렬한 후 상위 N개의 행을 추출하는 것이다', b'0', 2, 221),
	(883, 'ROWNUM은 WHERE 절이 실행된 후에 부여된다', b'1', 3, 221),
	(884, 'ORDER BY는 항상 ROWNUM이 부여된 후에 실행된다', b'0', 4, 221),
	(885, 'SELECT employee_id, name, salary FROM employees WHERE ROWNUM <= 5 ORDER BY salary DESC;', b'0', 1, 222),
	(886, 'SELECT employee_id, name, salary FROM (SELECT employee_id, name, salary FROM employees ORDER BY salary DESC) WHERE ROWNUM <= 5;', b'1', 2, 222),
	(887, 'SELECT employee_id, name, salary FROM employees ORDER BY salary DESC WHERE ROWNUM <= 5;', b'0', 3, 222),
	(888, 'SELECT TOP 5 employee_id, name, salary FROM employees ORDER BY salary;', b'0', 4, 222),
	(889, 'SELECT e.employee_id, e.name, d.department_name, e.salary FROM employees e, departments d WHERE e.department_id = d.department_id AND ROWNUM <= 3 ORDER BY e.salary DESC, e.name;', b'0', 1, 223),
	(890, 'SELECT * FROM (SELECT e.employee_id, e.name, d.department_name, e.salary, RANK() OVER (PARTITION BY e.department_id ORDER BY e.salary DESC, e.name) as rn FROM employees e, departments d WHERE e.department_id = d.department_id) WHERE rn <= 3;', b'1', 2, 223),
	(891, 'SELECT DISTINCT e.employee_id, e.name, d.department_name, e.salary FROM employees e, departments d WHERE e.department_id = d.department_id AND ROWNUM <= 3 ORDER BY e.department_id, e.salary DESC;', b'0', 3, 223),
	(892, 'SELECT TOP 3 e.employee_id, e.name, d.department_name, e.salary FROM employees e, departments d WHERE e.department_id = d.department_id ORDER BY e.department_id, e.salary DESC;', b'0', 4, 223),
	(893, '상위 5명의 급여가 모두 다른 경우', b'0', 1, 224),
	(894, '급여가 같은 직원이 없는 경우', b'0', 2, 224),
	(895, '2위와 3위의 급여가 동일한 경우', b'1', 3, 224),
	(896, '전체 직원이 5명 이하인 경우', b'0', 4, 224),
	(897, 'NTILE(5) 함수를 사용하여 상위 20%의 직원 조회', b'0', 1, 225),
	(898, 'PERCENT_RANK()를 사용하여 상위 20% 필터링', b'0', 2, 225),
	(899, '서브쿼리를 이용한 20% 급여 기준 조회', b'0', 3, 225),
	(900, 'CUME_DIST()를 사용하여 상위 20% 필터링', b'1', 4, 225),
	(901, 'FETCH FIRST n ROWS ONLY는 상위 n개의 행을 조회한다', b'0', 1, 226),
	(902, 'OFFSET n ROWS는 처음 n개의 행을 건너뛴다', b'0', 2, 226),
	(903, 'WITH TIES 옵션은 마지막 행과 동일한 값을 가진 행도 포함한다', b'0', 3, 226),
	(904, 'FETCH 절은 반드시 ORDER BY 절과 함께 사용해야 한다', b'1', 4, 226),
	(905, 'Query 1과 Query 2', b'1', 1, 227),
	(906, 'Query 2와 Query 3', b'0', 2, 227),
	(907, 'Query 3과 Query 4', b'0', 3, 227),
	(908, 'Query 1과 Query 4', b'1', 4, 227),
	(909, 'SELECT * FROM employees WHERE ROWNUM BETWEEN 21 AND 30 ORDER BY salary DESC;', b'0', 1, 228),
	(910, 'SELECT * FROM (SELECT * FROM employees ORDER BY salary DESC) WHERE ROWNUM BETWEEN 21 AND 30;', b'0', 2, 228),
	(911, 'SELECT * FROM (SELECT a.*, ROWNUM as rnum FROM (SELECT * FROM employees ORDER BY salary DESC) a WHERE ROWNUM <= 30) WHERE rnum >= 21;', b'1', 3, 228),
	(912, 'SELECT * FROM employees ORDER BY salary DESC OFFSET 20 ROWS FETCH NEXT 10 ROWS ONLY;', b'1', 4, 228),
	(913, 'RANK()를 사용하여 부서별 급여 상위 3명을 조회', b'1', 1, 229),
	(914, 'ROW_NUMBER()를 사용하여 상위 3명 조회', b'0', 2, 229),
	(915, 'COUNT()를 사용하여 상위 3명 필터링', b'0', 3, 229),
	(916, '서브쿼리를 사용하여 상위 3명 조회', b'0', 4, 229),
	(917, '바인드 변수 사용으로 인한 성능 저하', b'0', 1, 230),
	(918, 'ORDER BY 절로 인한 정렬 비용 발생', b'1', 2, 230),
	(919, 'ROWNUM 사용으로 인한 페이징 처리 불가', b'0', 3, 230),
	(920, '대용량 데이터 처리 시 메모리 부족', b'0', 4, 230),
	(921, 'CONNECT BY PRIOR는 계층형 구조에서 상하 관계를 지정한다', b'0', 1, 231),
	(922, 'START WITH는 계층형 구조의 시작점을 지정한다', b'0', 2, 231),
	(923, 'LEVEL은 계층형 구조에서 현재 레벨을 반환하는 의사컬럼이다', b'0', 3, 231),
	(924, 'ORDER BY절은 계층형 구조와 무관하게 항상 전체 결과를 정렬한다', b'1', 4, 231),
	(925, '모든 직원을 급여 순으로 정렬하여 출력한다', b'0', 1, 232),
	(926, '직원의 상하 관계를 표현하되, 같은 레벨의 직원은 이름순으로 정렬한다', b'1', 2, 232),
	(927, '관리자가 없는 직원부터 시작하여 모든 부하 직원을 출력한다', b'0', 3, 232),
	(928, '말단 직원부터 최상위 관리자까지의 경로를 출력한다', b'0', 4, 232),
	(929, 'SELECT e.emp_name as employee, m.emp_name as manager FROM employee e, employee m WHERE e.emp_id = m.manager_id;', b'0', 1, 233),
	(930, 'SELECT e.emp_name as employee, m.emp_name as manager FROM employee e, employee m WHERE e.manager_id = m.emp_id(+);', b'1', 2, 233),
	(931, 'SELECT e.emp_name as employee, m.emp_name as manager FROM employee e, employee m WHERE e.emp_id(+) = m.manager_id;', b'0', 3, 233),
	(932, 'SELECT e.emp_name as employee, m.emp_name as manager FROM employee e CROSS JOIN employee m;', b'0', 4, 233),
	(933, '모든 직원의 경로를 최상위 루트까지 표시한다', b'0', 1, 234),
	(934, 'CEO부터 시작하여 3레벨까지의 조직도를 표시한다', b'1', 2, 234),
	(935, '말단 직원부터 CEO까지의 경로를 표시한다', b'0', 3, 234),
	(936, '직원별 하위 직원 수를 계산한다', b'0', 4, 234),
	(937, '계층형 쿼리에 NOCYCLE을 추가하여 순환 참조를 방지한다', b'0', 1, 235),
	(938, '서브쿼리 대신 인라인 뷰를 사용하여 부서 정보를 조회한다', b'0', 2, 235),
	(939, 'START WITH 절에 인덱스를 사용할 수 있는 조건을 추가한다', b'0', 3, 235),
	(940, 'CONNECT BY 절의 조건을 WHERE 절로 이동하여 처리한다', b'1', 4, 235),
	(941, 'CONNECT_BY_ROOT는 최상위 노드의 값만 반환한다', b'1', 1, 236),
	(942, 'SYS_CONNECT_BY_PATH는 구분자를 지정할 수 없다', b'0', 2, 236),
	(943, 'CONNECT_BY_ROOT는 계층 구조에서만 사용할 수 없다', b'0', 3, 236),
	(944, 'SYS_CONNECT_BY_PATH는 최대 경로 길이에 제한이 없다', b'0', 4, 236),
	(945, '관리자가 없는 직원이 있는 경우', b'0', 1, 237),
	(946, '순환 참조가 있는 경우', b'1', 2, 237),
	(947, '모든 직원이 정상적인 계층 구조를 가진 경우', b'0', 3, 237),
	(948, '말단 직원만 있는 경우', b'0', 4, 237),
	(949, '셀프 조인을 사용하여 관리자-부하직원 관계를 설정하고, GROUP BY와 COUNT를 사용하여 부하직원 수를 계산한다', b'1', 1, 238),
	(950, '계층형 쿼리를 사용하여 모든 부하직원을 계산한다', b'0', 2, 238),
	(951, '부서 테이블과 조인하여 부서별 직원 수를 구한다', b'0', 3, 238),
	(952, '전체 직원 중 직급이 낮은 직원만 선택하여 계산한다', b'0', 4, 238),
	(953, 'HTML 태그 없이 계층 구조만 표현한다', b'0', 1, 239),
	(954, 'ORDER SIBLINGS BY 없이 전체 정렬한다', b'0', 2, 239),
	(955, 'HTML 태그를 사용하여 조직도를 계층 구조로 출력한다', b'1', 3, 239),
	(956, '계층 구조 대신 단순 리스트로 출력한다', b'0', 4, 239),
	(957, '테이블 조인을 인라인 뷰 안으로 이동한다', b'0', 1, 240),
	(958, 'START WITH 절을 제거하고 WHERE 절로 대체한다', b'0', 2, 240),
	(959, 'CONNECT BY 절에 인덱스를 추가한다', b'0', 3, 240),
	(960, '계층형 쿼리를 먼저 수행한 후 부서 정보를 조인한다', b'1', 4, 240),
	(961, 'PIVOT은 행을 열로 변환하는 기능을 수행한다', b'0', 1, 241),
	(962, 'UNPIVOT은 열을 행으로 변환하는 기능을 수행한다', b'0', 2, 241),
	(963, 'PIVOT 시에는 집계함수를 반드시 사용해야 한다', b'0', 3, 241),
	(964, 'UNPIVOT 시에는 집계함수를 반드시 사용해야 한다', b'1', 4, 241),
	(965, 'SELECT * FROM sales_data PIVOT (SUM(SALES) FOR QUARTER IN (\'Q1\', \'Q2\', \'Q3\', \'Q4\')) ORDER BY YEAR;', b'1', 1, 242),
	(966, 'SELECT * FROM sales_data PIVOT (SALES FOR QUARTER IN (\'Q1\', \'Q2\', \'Q3\', \'Q4\'));', b'0', 2, 242),
	(967, 'SELECT * FROM sales_data PIVOT (SUM(QUARTER) FOR SALES IN (\'Q1\', \'Q2\', \'Q3\', \'Q4\'));', b'0', 3, 242),
	(968, 'SELECT * FROM sales_data PIVOT (COUNT(SALES) FOR QUARTER IN (\'Q1\', \'Q2\', \'Q3\', \'Q4\'));', b'0', 4, 242),
	(969, 'SELECT * FROM sales_data UNPIVOT (SALES FOR QUARTER IN (Q1_SALES, Q2_SALES, Q3_SALES, Q4_SALES));', b'0', 1, 243),
	(970, 'SELECT * FROM sales_data UNPIVOT ((Q1_SALES, Q2_SALES, Q3_SALES, Q4_SALES) FOR QUARTER IN (SALES));', b'0', 2, 243),
	(971, 'SELECT * FROM sales_data UNPIVOT (SALES FOR QUARTER IN (Q1_SALES AS \'Q1\', Q2_SALES AS \'Q2\', Q3_SALES AS \'Q3\', Q4_SALES AS \'Q4\'));', b'1', 3, 243),
	(972, 'SELECT * FROM sales_data UNPIVOT (SUM(SALES) FOR QUARTER IN (Q1_SALES, Q2_SALES, Q3_SALES, Q4_SALES));', b'0', 4, 243),
	(973, 'SELECT * FROM emp_salary PIVOT (SUM(SALARY) FOR EMP_TYPE IN (\'정규직\' AS 정규직_급여, \'계약직\' AS 계약직_급여));', b'1', 1, 244),
	(974, 'SELECT * FROM emp_salary PIVOT (AVG(SALARY) FOR EMP_TYPE IN (\'정규직\', \'계약직\'));', b'0', 2, 244),
	(975, 'SELECT * FROM emp_salary PIVOT (SUM(SALARY) FOR EMP_TYPE IN (\'정규직_급여\', \'계약직_급여\'));', b'0', 3, 244),
	(976, 'SELECT * FROM emp_salary PIVOT (MAX(SALARY) FOR (EMP_TYPE) IN (\'정규직\' AS "정규직_급여", \'계약직\' AS "계약직_급여"));', b'0', 4, 244),
	(977, 'PIVOT은 NULL 값을 자동으로 0으로 변환한다', b'0', 1, 245),
	(978, 'UNPIVOT은 결과를 정렬할 수 없다', b'0', 2, 245),
	(979, 'WHERE 절은 PIVOT/UNPIVOT 전에 적용되어야 한다', b'1', 3, 245),
	(980, 'IN 절에 지정되지 않은 값은 모두 무시된다', b'0', 4, 245),
	(981, 'SUM', b'0', 1, 246),
	(982, 'COUNT', b'0', 2, 246),
	(983, 'MEDIAN', b'0', 3, 246),
	(984, 'MODE', b'1', 4, 246),
	(985, 'SALARY 값이 NULL인 경우', b'1', 1, 247),
	(986, 'JOB 값이 중복되는 경우', b'0', 2, 247),
	(987, 'DEPT 값이 NULL인 경우', b'0', 3, 247),
	(988, 'SALARY 값이 모두 동일한 경우', b'0', 4, 247),
	(989, 'SELECT * FROM (SELECT dept_name, NVL(grade, \'미지정\') as grade, salary FROM emp_salary) PIVOT (TO_CHAR(AVG(salary), \'999,999\') FOR grade IN (\'사원\', \'대리\', \'과장\', \'미지정\'));', b'0', 1, 248),
	(990, 'SELECT * FROM (SELECT dept_name, NVL(grade, \'미지정\') as grade, salary FROM emp_salary) PIVOT (AVG(salary) FOR grade IN (\'사원\', \'대리\', \'과장\', \'미지정\'));', b'0', 2, 248),
	(991, 'SELECT * FROM (SELECT dept_name, NVL(grade, \'미지정\') as grade, TO_CHAR(salary, \'999,999\') as salary FROM emp_salary) PIVOT (AVG(salary) FOR grade IN (\'사원\', \'대리\', \'과장\', \'미지정\'));', b'0', 3, 248),
	(992, 'SELECT dept_name, TO_CHAR(AVG(DECODE(grade, \'사원\', salary)) ,\'999,999\') as "사원", TO_CHAR(AVG(DECODE(grade, \'대리\', salary)) ,\'999,999\') as "대리", TO_CHAR(AVG(DECODE(grade, \'과장\', salary)) ,\'999,999\') as "과장", TO_CHAR(AVG(DECODE(grade, NULL, salary)) ,\'999,999\') as "미지정" FROM emp_salary GROUP BY dept_name;', b'1', 4, 248),
	(993, 'XML을 사용한 동적 쿼리 생성', b'1', 1, 249),
	(994, 'UNION ALL을 사용한 결과 합치기', b'0', 2, 249),
	(995, 'CASE 문을 사용한 조건부 집계', b'0', 3, 249),
	(996, 'WITH절을 사용한 임시 테이블 생성', b'0', 4, 249),
	(997, 'PIVOT 전 WHERE 절로 데이터를 필터링한다', b'1', 1, 250),
	(998, 'UNPIVOT 시 NULL 포함 여부를 명시적으로 지정한다', b'0', 2, 250),
	(999, '모든 집계는 PIVOT 외부에서 처리한다', b'0', 3, 250),
	(1000, '가능한 많은 컬럼을 한 번에 변환한다', b'0', 4, 250),
	(1001, '\'^\'는 문자열의 시작을 의미한다', b'0', 1, 251),
	(1002, '\'$\'는 문자열의 끝을 의미한다', b'0', 2, 251),
	(1003, '\'.\'는 정확히 한 글자만을 의미한다', b'1', 3, 251),
	(1004, '\'*\'는 앞의 문자가 0번 이상 나타남을 의미한다', b'0', 4, 251),
	(1005, '모든 전화번호를 검색한다', b'0', 1, 252),
	(1006, '010 또는 011로 시작하는 휴대폰 번호만 검색한다', b'0', 2, 252),
	(1007, '중간 번호가 4자리이고 마지막 번호가 4자리인 번호를 검색한다', b'0', 3, 252),
	(1008, '010 또는 011로 시작하고, 중간과 끝이 각각 4자리 숫자인 전화번호를 검색한다', b'1', 4, 252),
	(1009, '\'^[a-zA-Z0-9]+@[a-zA-Z0-9]+$\'', b'0', 1, 253),
	(1010, '\'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$\'', b'1', 2, 253),
	(1011, '\'^[0-9]+@[a-zA-Z]+.[a-zA-Z]+$\'', b'0', 3, 253),
	(1012, '\'^.+@.+..+$\'', b'0', 4, 253),
	(1013, '\'AB-1234\'', b'0', 1, 254),
	(1014, '\'CD-5678R\'', b'0', 2, 254),
	(1015, '\'EF-9012B\'', b'0', 3, 254),
	(1016, '\'GH-345G\'', b'1', 4, 254),
	(1017, '\'^d{6}-[1-4]d{6}$\'', b'0', 1, 255),
	(1018, '\'^([0-9]{2})(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])-[1-4][0-9]{6}$\'', b'1', 2, 255),
	(1019, '\'^d{2}(0|1)d(0|1|2|3)d-[1-4]d{6}$\'', b'0', 3, 255),
	(1020, '\'^[0-9]{6}-[0-9]{7}$\'', b'0', 4, 255),
	(1021, '\'?\' 는 앞의 문자가 0번 또는 1번 나타남을 의미한다', b'0', 1, 256),
	(1022, '\'+\' 는 앞의 문자가 1번 이상 나타남을 의미한다', b'0', 2, 256),
	(1023, '\'{n}\' 는 앞의 문자가 정확히 n번 나타남을 의미한다', b'0', 3, 256),
	(1024, '\'*?\' 는 가능한 많은 문자와 매칭됨을 의미한다', b'1', 4, 256),
	(1025, '모든 숫자를 하이픈으로 대체한다', b'0', 1, 257),
	(1026, '11자리 숫자를 3-4-4 형식으로 변환한다', b'1', 2, 257),
	(1027, '전화번호에서 하이픈을 제거한다', b'0', 3, 257),
	(1028, '연속된 숫자를 그룹화한다', b'0', 4, 257),
	(1029, '\'^[a-zA-Z]+.(txt|doc|docx|pdf)$\'', b'0', 1, 258),
	(1030, '\'^.*.[a-z]+$\'', b'0', 2, 258),
	(1031, '\'^w+.(txt|doc.?|pdf)$\'', b'1', 3, 258),
	(1032, '\'^[^.]+.[a-z]{3,4}$\'', b'0', 4, 258),
	(1033, '\'^https?://w{3}?.[a-zA-Z0-9-]+.[a-zA-Z]{2,6}$\'', b'0', 1, 259),
	(1034, '\'^(http|https)://[a-zA-Z0-9-.]+.[a-zA-Z]{2,6}$\'', b'0', 2, 259),
	(1035, '\'^https?://(www.)?[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+[a-zA-Z]{2,6}$\'', b'0', 3, 259),
	(1036, '\'^https?://(www.)?[a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)*.[a-zA-Z]{2,6}$\'', b'1', 4, 259),
	(1037, '정규 표현식의 시작과 끝을 명시한다', b'0', 1, 260),
	(1038, '가능한 한 구체적인 패턴을 사용한다', b'0', 2, 260),
	(1039, '복잡한 패턴은 여러 개의 REGEXP_LIKE로 분리한다', b'1', 3, 260),
	(1040, '인덱스를 활용할 수 있는 일반 조건을 먼저 적용한다', b'0', 4, 260),
	(1041, 'INSERT 문은 테이블에 새로운 데이터를 입력하는 명령어이다', b'0', 1, 261),
	(1042, 'UPDATE 문은 테이블의 기존 데이터를 수정하는 명령어이다', b'0', 2, 261),
	(1043, 'DELETE 문은 테이블의 데이터를 삭제하는 명령어이다', b'0', 3, 261),
	(1044, 'DROP 문은 테이블의 모든 데이터를 삭제하는 DML이다', b'1', 4, 261),
	(1045, 'INSERT INTO EMPLOYEES VALUES (1001, \'John\', \'Smith\', \'2024-01-01\');', b'0', 1, 262),
	(1046, 'INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME, HIRE_DATE, SALARY) VALUES (1001, \'John\', \'Smith\', TO_DATE(\'2024-01-01\', \'YYYY-MM-DD\'), 5000);', b'1', 2, 262),
	(1047, 'INSERT INTO EMPLOYEES (EMPLOYEE_ID, FIRST_NAME, LAST_NAME) VALUES (1001, \'John\', \'Smith\', 5000);', b'0', 3, 262),
	(1048, 'INSERT VALUES (1001, \'John\', \'Smith\', \'2024-01-01\', 5000) INTO EMPLOYEES;', b'0', 4, 262),
	(1049, '모든 직원의 급여를 부서별 평균 급여로 변경한다', b'0', 1, 263),
	(1050, '급여가 3000 미만인 직원의 급여를 전체 평균 급여로 변경한다', b'0', 2, 263),
	(1051, '급여가 3000 미만인 직원의 급여를 해당 부서의 평균 급여로 변경한다', b'1', 3, 263),
	(1052, '부서별 평균 급여가 3000 미만인 직원의 급여를 변경한다', b'0', 4, 263),
	(1053, 'Query 1', b'1', 1, 264),
	(1054, 'Query 2', b'0', 2, 264),
	(1055, 'Query 3', b'0', 3, 264),
	(1056, 'Query 4', b'0', 4, 264),
	(1057, 'TRUNCATE를 사용하여 DELETE 작업의 성능을 개선한다', b'0', 1, 265),
	(1058, 'INSERT 작업 전에 COMMIT을 실행하여 데이터 정합성을 보장한다', b'0', 2, 265),
	(1059, '대용량 데이터 처리 시 적절한 크기로 분할하여 처리한다', b'1', 3, 265),
	(1060, 'UPDATE 문을 실행하기 전에 테이블을 백업한다', b'0', 4, 265),
	(1061, '조건에 따라 INSERT 또는 UPDATE를 수행한다', b'0', 1, 266),
	(1062, 'WHEN NOT MATCHED THEN 절은 INSERT 작업을 수행한다', b'0', 2, 266),
	(1063, '한 번의 구문으로 여러 DML 작업을 수행할 수 있다', b'0', 3, 266),
	(1064, 'DELETE 작업은 수행할 수 없다', b'1', 4, 266),
	(1065, '모든 데이터를 target_table에 입력한다', b'0', 1, 267),
	(1066, '기존 데이터는 모두 갱신하고 없는 데이터는 입력한다', b'0', 2, 267),
	(1067, '값이 다른 데이터만 갱신하고 없는 데이터는 입력한다', b'1', 3, 267),
	(1068, 'source_table의 모든 데이터로 target_table을 대체한다', b'0', 4, 267),
	(1069, 'INSERT /*+ APPEND */ INTO sales_summary SELECT year, month, SUM(amount) FROM sales_transactions GROUP BY year, month;', b'1', 1, 268),
	(1070, 'INSERT ALL INTO sales_summary VALUES (year, month, amount) SELECT year, month, SUM(amount) FROM sales_transactions GROUP BY year, month;', b'0', 2, 268),
	(1071, 'INSERT FIRST WHEN 1=1 THEN INTO sales_summary VALUES (year, month, amount) SELECT year, month, SUM(amount) FROM sales_transactions GROUP BY year, month;', b'0', 3, 268),
	(1072, 'CREATE TABLE sales_summary AS SELECT year, month, SUM(amount) as amount FROM sales_transactions GROUP BY year, month;', b'0', 4, 268),
	(1073, 'BEGIN UPDATE orders SET status = \'APPROVED\' WHERE order_id = :ord_id; UPDATE inventory SET quantity = quantity - :qty WHERE product_id = :prod_id; INSERT INTO point_history (customer_id, point) VALUES (:cust_id, :point); COMMIT; EXCEPTION WHEN OTHERS THEN ROLLBACK; END;', b'1', 1, 269),
	(1074, 'UPDATE orders SET status = \'APPROVED\' WHERE order_id = :ord_id; COMMIT; UPDATE inventory SET quantity = quantity - :qty WHERE product_id = :prod_id; COMMIT; INSERT INTO point_history (customer_id, point) VALUES (:cust_id, :point); COMMIT;', b'0', 2, 269),
	(1075, 'MERGE INTO orders o USING dual ON (o.order_id = :ord_id) WHEN MATCHED THEN UPDATE SET status = \'APPROVED\'; MERGE INTO inventory i USING dual ON (i.product_id = :prod_id) WHEN MATCHED THEN UPDATE SET quantity = quantity - :qty;', b'0', 3, 269),
	(1076, 'BEGIN SAVEPOINT s1; UPDATE orders SET status = \'APPROVED\' WHERE order_id = :ord_id; SAVEPOINT s2; UPDATE inventory SET quantity = quantity - :qty WHERE product_id = :prod_id; INSERT INTO point_history (customer_id, point) VALUES (:cust_id, :point); COMMIT; END;', b'0', 4, 269),
	(1077, 'FOR UPDATE 절 사용', b'0', 1, 270),
	(1078, 'NOWAIT 옵션 추가', b'0', 2, 270),
	(1079, 'SELECT FOR UPDATE 먼저 수행', b'1', 3, 270),
	(1080, '낙관적 락(Optimistic Lock) 사용', b'0', 4, 270),
	(1081, 'COMMIT은 트랜잭션의 변경사항을 데이터베이스에 영구적으로 반영한다', b'0', 1, 271),
	(1082, 'ROLLBACK은 트랜잭션의 변경사항을 취소하고 이전 상태로 되돌린다', b'0', 2, 271),
	(1083, 'SAVEPOINT는 트랜잭션 내에 중간 저장점을 지정한다', b'0', 3, 271),
	(1084, 'COMMIT 후에도 ROLLBACK을 수행하면 이전 상태로 되돌릴 수 있다', b'1', 4, 271),
	(1085, 'A001, A002, A003 계좌의 모든 변경사항이 취소된다', b'0', 1, 272),
	(1086, 'A001 계좌의 변경사항만 데이터베이스에 반영된다', b'1', 2, 272),
	(1087, 'A001, A002 계좌의 변경사항이 데이터베이스에 반영된다', b'0', 3, 272),
	(1088, 'A001, A002, A003 계좌의 모든 변경사항이 데이터베이스에 반영된다', b'0', 4, 272),
	(1089, '더티 리드(Dirty Read) 발생 가능, COMMIT 후 SELECT 실행', b'1', 1, 273),
	(1090, '반복 불가능한 읽기(Non-repeatable Read) 발생 가능, 트랜잭션 격리 수준 상향', b'0', 2, 273),
	(1091, '팬텀 리드(Phantom Read) 발생 가능, 테이블 잠금(LOCK TABLE) 사용', b'0', 3, 273),
	(1092, '교착상태(Deadlock) 발생 가능, NOWAIT 옵션 사용', b'0', 4, 273),
	(1093, 'order_id = 1인 주문이 amount = 1000으로 저장된다', b'1', 1, 274),
	(1094, 'order_id = 1인 주문이 amount = 2000으로 저장된다', b'0', 2, 274),
	(1095, 'order_id = 1인 주문이 amount = 3000으로 저장된다', b'0', 3, 274),
	(1096, 'order_id = 1인 주문이 삭제된다', b'0', 4, 274),
	(1097, 'SAVEPOINT를 활용하여 부분 완료를 허용한다', b'0', 1, 275),
	(1098, '각 단계를 개별 트랜잭션으로 실행하여 부분 성공을 허용한다', b'0', 2, 275),
	(1099, 'ROLLBACK 대신 UNDO 로그를 활용하여 오류를 복구한다', b'0', 3, 275),
	(1100, '모든 작업을 하나의 트랜잭션으로 묶고 실패 시 전체 ROLLBACK 한다', b'1', 4, 275),
	(1101, 'Atomicity(원자성)는 트랜잭션이 모두 실행되거나 전혀 실행되지 않아야 함을 의미한다', b'0', 1, 276),
	(1102, 'Consistency(일관성)는 트랜잭션 실행 전과 후의 데이터베이스 상태가 일관되어야 함을 의미한다', b'0', 2, 276),
	(1103, 'Isolation(고립성)은 모든 트랜잭션이 순차적으로만 실행되어야 함을 의미한다', b'1', 3, 276),
	(1104, 'Durability(지속성)는 성공적으로 완료된 트랜잭션의 결과는 영구적이어야 함을 의미한다', b'0', 4, 276),
	(1105, 'sp2 이후의 변경사항만 취소된다', b'0', 1, 277),
	(1106, 'sp1 이후의 변경사항만 취소된다', b'0', 2, 277),
	(1107, '가장 최근 변경사항만 취소된다', b'0', 3, 277),
	(1108, '모든 변경사항이 취소된다', b'1', 4, 277),
	(1109, '배치 단위로 처리하고 각 배치마다 COMMIT을 수행한다', b'1', 1, 278),
	(1110, 'SAVEPOINT를 각 배치마다 설정하여 개별 롤백 가능하도록 한다', b'0', 2, 278),
	(1111, '전체 데이터를 한 번에 처리하고 마지막에 COMMIT한다', b'0', 3, 278),
	(1112, 'LOOP 내에서 모든 변경사항을 ROLLBACK 후 진행한다', b'0', 4, 278),
	(1113, 'SELECT FOR UPDATE 사용으로 충분하다', b'1', 1, 279),
	(1114, '트랜잭션 격리 수준을 SERIALIZABLE로 상향한다', b'0', 2, 279),
	(1115, 'NOWAIT 옵션을 추가한다', b'0', 3, 279),
	(1116, '모든 SELECT문에 FOR UPDATE를 추가한다', b'0', 4, 279),
	(1117, 'READ UNCOMMITTED: Time 1과 Time 3의 결과가 같다', b'0', 1, 280),
	(1118, 'READ COMMITTED: Time 1과 Time 3의 결과가 다를 수 있다', b'1', 2, 280),
	(1119, 'REPEATABLE READ: Time 2의 UPDATE가 실패한다', b'0', 3, 280),
	(1120, 'SERIALIZABLE: Time 1과 Time 3의 결과가 반드시 다르다', b'0', 4, 280),
	(1121, 'CREATE 문은 새로운 데이터베이스 객체를 생성한다', b'0', 1, 281),
	(1122, 'ALTER 문은 기존 데이터베이스 객체의 구조를 변경한다', b'0', 2, 281),
	(1123, 'DROP 문으로 삭제된 데이터는 ROLLBACK으로 복구할 수 있다', b'1', 3, 281),
	(1124, 'TRUNCATE 문은 테이블의 모든 데이터를 삭제한다', b'0', 4, 281),
	(1125, 'CREATE TABLE employees (emp_id NUMBER PRIMARY KEY, name VARCHAR2(100) NOT NULL, hire_date DATE DEFAULT SYSDATE);', b'0', 1, 282),
	(1126, 'CREATE TABLE departments (dept_id NUMBER, dept_name VARCHAR2(100), PRIMARY KEY (dept_id, dept_name));', b'0', 2, 282),
	(1127, 'CREATE TABLE salaries (emp_id NUMBER, salary NUMBER CHECK (salary >= 0), effective_date DATE DEFAULT SYSDATE, FOREIGN KEY emp_id REFERENCES employees);', b'1', 3, 282),
	(1128, 'CREATE TABLE locations (loc_id NUMBER PRIMARY KEY, city VARCHAR2(100), country VARCHAR2(100) DEFAULT \'Korea\');', b'0', 4, 282),
	(1129, 'ALTER TABLE products ADD (description VARCHAR2(1000));', b'0', 1, 283),
	(1130, 'ALTER TABLE products MODIFY (price NUMBER NOT NULL);', b'1', 2, 283),
	(1131, 'ALTER TABLE products DROP COLUMN product_name;', b'0', 3, 283),
	(1132, 'ALTER TABLE products ADD CONSTRAINT price_check CHECK (price > 0);', b'0', 4, 283),
	(1133, 'CREATE TABLE orders (order_id NUMBER DEFAULT order_seq.NEXTVAL, order_status VARCHAR2(20) CHECK (order_status IN (\'접수\', \'처리중\', \'완료\')), order_date DATE DEFAULT SYSDATE, PRIMARY KEY (order_id));', b'0', 1, 284),
	(1134, 'CREATE TABLE orders (order_id NUMBER PRIMARY KEY, order_status VARCHAR2(20), order_date DATE, CONSTRAINT status_check CHECK (order_status IN (\'접수\', \'처리중\', \'완료\'))) AS SELECT order_seq.NEXTVAL, \'접수\', SYSDATE FROM DUAL;', b'0', 2, 284),
	(1135, 'CREATE TABLE orders (order_id NUMBER DEFAULT order_seq.NEXTVAL PRIMARY KEY, order_status VARCHAR2(20) CHECK (order_status IN (\'접수\', \'처리중\', \'완료\')), order_date DATE DEFAULT SYSDATE); CREATE TRIGGER trg_orders_history BEFORE DELETE ON orders FOR EACH ROW BEGIN INSERT INTO orders_history VALUES (:OLD.order_id, :OLD.order_status, :OLD.order_date, SYSDATE); END;', b'1', 3, 284),
	(1136, 'CREATE SEQUENCE order_seq; CREATE TABLE orders (order_id NUMBER, order_status VARCHAR2(20), order_date DATE, CONSTRAINT pk_order PRIMARY KEY (order_id), CONSTRAINT chk_status CHECK (order_status IN (\'접수\', \'처리중\', \'완료\')));', b'0', 4, 284),
	(1137, 'NOT NULL 제약조건을 NULL로 변경', b'0', 1, 285),
	(1138, 'VARCHAR2 컬럼의 크기를 증가', b'0', 2, 285),
	(1139, 'NUMBER 컬럼의 정밀도(precision) 감소', b'0', 3, 285),
	(1140, '복합 기본키(Composite Primary Key)를 단일 컬럼 기본키로 변경', b'1', 4, 285),
	(1141, '기존 테이블의 구조와 데이터를 복사할 수 있다', b'0', 1, 286),
	(1142, '제약조건은 NOT NULL만 복사된다', b'0', 2, 286),
	(1143, 'ORDER BY 절을 사용하여 정렬된 결과를 저장할 수 있다', b'1', 3, 286),
	(1144, 'WHERE 절을 사용하여 일부 데이터만 선택할 수 있다', b'0', 4, 286),
	(1145, '1 → 2 → 3 → 4', b'0', 1, 287),
	(1146, '2 → 1 → 4 → 3', b'1', 2, 287),
	(1147, '4 → 2 → 1 → 3', b'0', 3, 287),
	(1148, '2 → 4 → 3 → 1', b'0', 4, 287),
	(1149, 'TRUNCATE는 로그를 생성하지 않는다', b'0', 1, 288),
	(1150, 'DELETE는 ROLLBACK이 가능하다', b'1', 2, 288),
	(1151, 'TRUNCATE는 WHERE 절을 사용할 수 있다', b'0', 3, 288),
	(1152, 'DELETE는 자동 COMMIT이 발생한다', b'0', 4, 288),
	(1153, 'CREATE TABLE sales (sales_date DATE, amount NUMBER) PARTITION BY RANGE (sales_date) (PARTITION p_2022 VALUES LESS THAN (\'2023-01-01\'), PARTITION p_2023 VALUES LESS THAN (\'2024-01-01\'), PARTITION p_max VALUES LESS THAN (MAXVALUE));', b'0', 1, 289),
	(1154, 'CREATE TABLE sales (sales_date DATE, amount NUMBER) PARTITION BY LIST (EXTRACT(YEAR FROM sales_date)) (PARTITION p_2022 VALUES (2022), PARTITION p_2023 VALUES (2023), PARTITION p_2024 VALUES (2024));', b'0', 2, 289),
	(1155, 'CREATE TABLE sales (sales_date DATE, amount NUMBER) PARTITION BY HASH (sales_date) PARTITIONS 4;', b'0', 3, 289),
	(1156, 'CREATE TABLE sales (sales_date DATE, amount NUMBER) PARTITION BY RANGE (sales_date) INTERVAL(NUMTOYMINTERVAL(1, \'YEAR\')) (PARTITION p_first VALUES LESS THAN (\'2023-01-01\'));', b'1', 4, 289),
	(1157, '대용량 테이블의 컬럼 추가는 업무 외 시간에 수행한다', b'0', 1, 290),
	(1158, '제약조건은 데이터 로딩 후에 생성한다', b'0', 2, 290),
	(1159, '파티션 테이블은 항상 더 나은 성능을 제공한다', b'1', 3, 290),
	(1160, '인덱스는 데이터 로딩 전에 삭제하고 로딩 후에 재생성한다', b'0', 4, 290),
	(1161, 'GRANT는 사용자에게 권한을 부여하는 명령어이다', b'0', 1, 291),
	(1162, 'REVOKE는 사용자의 권한을 회수하는 명령어이다', b'0', 2, 291),
	(1163, 'CREATE USER는 DCL에 속하는 명령어이다', b'1', 3, 291),
	(1164, 'WITH GRANT OPTION은 다른 사용자에게 권한을 부여할 수 있는 권한을 준다', b'0', 4, 291),
	(1165, 'GRANT SELECT ON employees TO user1;', b'0', 1, 292),
	(1166, 'GRANT INSERT, UPDATE ON departments TO user1 WITH GRANT OPTION;', b'0', 2, 292),
	(1167, 'GRANT ALL PRIVILEGES ON *.* TO user1;', b'0', 3, 292),
	(1168, 'GRANT SELECT ON employees WHERE department_id = 10 TO user1;', b'1', 4, 292),
	(1169, 'SELECT 권한이 없다', b'0', 1, 293),
	(1170, 'SELECT 권한이 있다', b'1', 2, 293),
	(1171, 'WITH GRANT OPTION 권한이 있다', b'0', 3, 293),
	(1172, 'SELECT 권한과 WITH GRANT OPTION 권한이 모두 있다', b'0', 4, 293),
	(1173, '각 사용자별로 필요한 권한을 개별적으로 부여한다', b'0', 1, 294),
	(1174, 'ROLE을 생성하여 공통 권한을 부여하고 사용자들에게 ROLE을 부여한다', b'1', 2, 294),
	(1175, 'PUBLIC으로 모든 권한을 부여한다', b'0', 3, 294),
	(1176, '관리자 계정의 비밀번호를 공유한다', b'0', 4, 294),
	(1177, 'ROLE에 부여된 권한은 ROLE이 부여된 사용자가 즉시 사용할 수 있다', b'1', 1, 295),
	(1178, 'CASCADE 옵션으로 권한을 취소하면 연관된 모든 권한이 취소된다', b'0', 2, 295),
	(1179, 'PUBLIC으로 부여된 권한은 모든 사용자가 사용할 수 있다', b'0', 3, 295),
	(1180, 'ROLE은 다른 ROLE에 포함될 수 있다', b'0', 4, 295),
	(1181, 'DBA는 데이터베이스의 모든 권한을 가진 관리자이다', b'0', 1, 296),
	(1182, 'RESOURCE는 테이블 등 객체를 생성할 수 있는 권한을 가진다', b'0', 2, 296),
	(1183, 'CONNECT는 데이터베이스에 접속할 수 있는 권한을 가진다', b'0', 3, 296),
	(1184, 'PUBLIC은 특정 사용자에게만 부여되는 권한이다', b'1', 4, 296),
	(1185, 'user1은 employees 테이블에 대한 모든 권한을 가진다', b'0', 1, 297),
	(1186, 'departments 테이블에 대한 권한이 충분하지 않다', b'0', 2, 297),
	(1187, 'ROLE 생성이 권한 부여보다 늦게 수행되었다', b'1', 3, 297),
	(1188, 'ALTER TABLE 권한이 중복 부여된다', b'0', 4, 297),
	(1189, 'GRANT CREATE TABLE, ALTER TABLE TO dev_team; GRANT SELECT, UPDATE TO qa_team; GRANT SELECT TO ops_team;', b'0', 1, 298),
	(1190, 'CREATE ROLE role_dev; GRANT CREATE TABLE, ALTER TABLE TO role_dev; CREATE ROLE role_qa; GRANT SELECT, UPDATE TO role_qa; CREATE ROLE role_ops; GRANT SELECT TO role_ops;', b'1', 2, 298),
	(1191, 'GRANT ALL PRIVILEGES TO dev_team; GRANT SELECT, UPDATE TO qa_team; GRANT SELECT TO PUBLIC;', b'0', 3, 298),
	(1192, 'CREATE USER dev_team IDENTIFIED BY password; CREATE USER qa_team IDENTIFIED BY password; CREATE USER ops_team IDENTIFIED BY password;', b'0', 4, 298),
	(1193, 'REVOKE CREATE TABLE FROM user1;', b'0', 1, 299),
	(1194, 'REVOKE SELECT ON table1 FROM user1 CASCADE;', b'1', 2, 299),
	(1195, 'REVOKE SELECT ON table1 FROM user2, user3;', b'0', 3, 299),
	(1196, 'REVOKE ALL PRIVILEGES FROM user1;', b'0', 4, 299),
	(1197, '모든 사용자의 모든 작업을 로깅한다', b'0', 1, 300),
	(1198, 'ROLE 단위로 주요 작업만 로깅한다', b'1', 2, 300),
	(1199, 'DDL 문장만 로깅한다', b'0', 3, 300),
	(1200, '로깅을 하지 않고 정기적으로 권한을 검토한다', b'0', 4, 300),
	(1201, '개념적 모델링 → 논리적 모델링 → 물리적 모델링', b'1', 1, 301),
	(1202, '물리적 모델링 → 논리적 모델링 → 개념적 모델링', b'0', 2, 301),
	(1203, '논리적 모델링 → 개념적 모델링 → 물리적 모델링', b'0', 3, 301),
	(1204, '개념적 모델링 → 물리적 모델링 → 논리적 모델링', b'0', 4, 301),
	(1205, '데이터의 중복을 최소화하는 과정', b'0', 1, 302),
	(1206, '현실 세계의 복잡한 내용을 정해진 표기법에 의해 표현하는 과정', b'1', 2, 302),
	(1207, '데이터베이스의 성능을 향상시키는 과정', b'0', 3, 302),
	(1208, '데이터의 무결성을 보장하는 과정', b'0', 4, 302),
	(1209, '추상화 (Abstraction)', b'0', 1, 303),
	(1210, '단순화 (Simplification)', b'0', 2, 303),
	(1211, '명확화 (Clarification)', b'0', 3, 303),
	(1212, '복잡화 (Complication)', b'1', 4, 303),
	(1213, '엔터티 (Entity)', b'0', 1, 304),
	(1214, '속성 (Attribute)', b'0', 2, 304),
	(1215, '관계 (Relationship)', b'0', 3, 304),
	(1216, '인덱스 (Index)', b'1', 4, 304),
	(1217, '테이블, 컬럼, 키 등의 물리적 요소를 정의한다.', b'0', 1, 305),
	(1218, '업무 중심의 포괄적인 수준의 모델링을 제공한다.', b'1', 2, 305),
	(1219, 'DBMS 특성을 고려한 성능 최적화를 수행한다.', b'0', 3, 305),
	(1220, '정규화를 통해 데이터 중복을 제거한다.', b'0', 4, 305),
	(1221, '정규화', b'0', 1, 306),
	(1222, '엔터티 정의', b'0', 2, 306),
	(1223, '관계 정의', b'0', 3, 306),
	(1224, '인덱스 설계', b'1', 4, 306),
	(1225, '데이터 중복을 최소화하는 것', b'0', 1, 307),
	(1226, '데이터 모델이 모든 사용자에게 같은 의미로 이해되는 것', b'1', 2, 307),
	(1227, '데이터베이스의 성능을 향상시키는 것', b'0', 3, 307),
	(1228, '데이터의 보안을 강화하는 것', b'0', 4, 307),
	(1229, '업무 중심의 개념적인 모델을 만든다.', b'0', 1, 308),
	(1230, 'DBMS에 독립적인 모델을 생성한다.', b'0', 2, 308),
	(1231, '실제 데이터베이스 구현을 위한 스키마를 생성한다.', b'1', 3, 308),
	(1232, '정규화 과정을 주로 수행한다.', b'0', 4, 308),
	(1233, '데이터의 중복을 최소화하는 것', b'0', 1, 309),
	(1234, '데이터가 정확하고 유효한 상태를 유지하는 것', b'1', 2, 309),
	(1235, '데이터의 접근 속도를 향상시키는 것', b'0', 3, 309),
	(1236, '데이터의 보안을 강화하는 것', b'0', 4, 309),
	(1237, '파일 구조의 최적화', b'1', 1, 310),
	(1238, '데이터 품질 향상', b'0', 2, 310),
	(1239, '시스템 아키텍처의 최적화', b'0', 3, 310),
	(1240, '의사소통 도구', b'0', 4, 310),
	(1241, '데이터 구조를 쉽게 변경하고 확장할 수 있는 능력', b'1', 1, 311),
	(1242, '데이터베이스의 성능을 향상시키는 능력', b'0', 2, 311),
	(1243, '데이터의 중복을 최소화하는 능력', b'0', 3, 311),
	(1244, '데이터의 보안을 강화하는 능력', b'0', 4, 311),
	(1245, '테이블 정의서', b'0', 1, 312),
	(1246, 'ERD (Entity-Relationship Diagram)', b'1', 2, 312),
	(1247, '물리적 스키마', b'0', 3, 312),
	(1248, '인덱스 설계서', b'0', 4, 312),
	(1249, '동일한 데이터를 여러 번 저장하는 것', b'0', 1, 313),
	(1250, '이미 정의된 데이터 모델을 다른 영역에서도 사용할 수 있는 것', b'1', 2, 313),
	(1251, '데이터베이스를 주기적으로 백업하는 것', b'0', 3, 313),
	(1252, '데이터의 접근 속도를 향상시키는 것', b'0', 4, 313),
	(1253, '요구사항 수집 → 개념적 모델링 → 논리적 모델링 → 물리적 모델링', b'1', 1, 314),
	(1254, '물리적 모델링 → 논리적 모델링 → 개념적 모델링 → 요구사항 수집', b'0', 2, 314),
	(1255, '요구사항 수집 → 물리적 모델링 → 논리적 모델링 → 개념적 모델링', b'0', 3, 314),
	(1256, '개념적 모델링 → 물리적 모델링 → 논리적 모델링 → 요구사항 수집', b'0', 4, 314),
	(1257, '데이터베이스에 저장되는 테이블', b'0', 1, 315),
	(1258, '업무에서 관리해야 하는 데이터 단위', b'1', 2, 315),
	(1259, '두 개의 엔터티 사이의 연관성', b'0', 3, 315),
	(1260, '엔터티의 특성을 나타내는 항목', b'0', 4, 315),
	(1261, '식별자에 의해 식별 가능해야 한다', b'0', 1, 316),
	(1262, '업무에서 관리되어야 하는 정보이어야 한다', b'0', 2, 316),
	(1263, '반드시 물리적인 형태로 존재해야 한다', b'1', 3, 316),
	(1264, '속성을 포함해야 한다', b'0', 4, 316),
	(1265, '엔터티 타입은 테이블이고, 엔터티 인스턴스는 컬럼이다', b'0', 1, 317),
	(1266, '엔터티 타입은 클래스이고, 엔터티 인스턴스는 객체이다', b'1', 2, 317),
	(1267, '엔터티 타입은 데이터베이스이고, 엔터티 인스턴스는 테이블이다', b'0', 3, 317),
	(1268, '엔터티 타입은 인덱스이고, 엔터티 인스턴스는 키이다', b'0', 4, 317),
	(1269, '다른 엔터티의 존재에 의존적이다', b'1', 1, 318),
	(1270, '항상 독립적으로 존재할 수 있다', b'0', 2, 318),
	(1271, '식별자가 없다', b'0', 3, 318),
	(1272, '관계를 가질 수 없다', b'0', 4, 318),
	(1273, '업무에서 관리되는 정보인가?', b'0', 1, 319),
	(1274, '식별자가 있는가?', b'0', 2, 319),
	(1275, '속성을 포함하는가?', b'0', 3, 319),
	(1276, '테이블 이름이 명사인가?', b'1', 4, 319),
	(1277, '타원', b'0', 1, 320),
	(1278, '사각형', b'1', 2, 320),
	(1279, '마름모', b'0', 3, 320),
	(1280, '삼각형', b'0', 4, 320),
	(1281, '엔터티 셋', b'1', 1, 321),
	(1282, '속성 집합', b'0', 2, 321),
	(1283, '관계 집합', b'0', 3, 321),
	(1284, '키 집합', b'0', 4, 321),
	(1285, '영속적으로 존재하는 정보인가?', b'0', 1, 322),
	(1286, '업무 프로세스에서 사용되는 정보인가?', b'0', 2, 322),
	(1287, '데이터베이스에 저장할 만큼 중요한 정보인가?', b'0', 3, 322),
	(1288, '테이블의 컬럼 수가 10개 이상인가?', b'1', 4, 322),
	(1289, '물리적 엔터티는 테이블로 구현되고, 논리적 엔터티는 개념적 모델에서 사용된다', b'1', 1, 323),
	(1290, '물리적 엔터티는 속성을 가지지 않고, 논리적 엔터티는 속성을 가진다', b'0', 2, 323),
	(1291, '물리적 엔터티는 관계를 가질 수 없고, 논리적 엔터티는 관계를 가질 수 있다', b'0', 3, 323),
	(1292, '물리적 엔터티는 식별자가 없고, 논리적 엔터티는 식별자가 있다', b'0', 4, 323),
	(1293, '현업업무에서 사용하는 용어를 사용한다', b'0', 1, 324),
	(1294, '약어를 사용하지 않는다', b'0', 2, 324),
	(1295, '단수형을 사용한다', b'0', 3, 324),
	(1296, '반드시 영문으로 작성해야 한다', b'1', 4, 324),
	(1297, '유형에 따른 분류 (유형 엔터티, 개념 엔터티)', b'0', 1, 325),
	(1298, '발생 시점에 따른 분류 (기본 엔터티, 중심 엔터티, 행위 엔터티)', b'0', 2, 325),
	(1299, '스토리지 유형에 따른 분류 (파일 엔터티, 테이블 엔터티)', b'1', 3, 325),
	(1300, '독립성에 따른 분류 (독립 엔터티, 의존 엔터티)', b'0', 4, 325),
	(1301, '업무에서 기본적으로 관리해야 하는 단위', b'0', 1, 326),
	(1302, '두 개 이상의 엔터티로부터 발생되는 엔터티', b'1', 2, 326),
	(1303, '상위 엔터티의 속성을 상속받는 엔터티', b'0', 3, 326),
	(1304, '물리적으로 존재하지 않고 개념적으로만 존재하는 엔터티', b'0', 4, 326),
	(1305, '슈퍼타입은 서브타입의 공통 속성을 가지며, 서브타입은 고유한 속성을 추가로 가진다', b'1', 1, 327),
	(1306, '슈퍼타입은 서브타입의 모든 속성을 포함하며, 서브타입은 속성을 가질 수 없다', b'0', 2, 327),
	(1307, '슈퍼타입과 서브타입은 항상 1:1 관계를 가진다', b'0', 3, 327),
	(1308, '슈퍼타입은 물리적 엔터티이고, 서브타입은 논리적 엔터티이다', b'0', 4, 327),
	(1309, '생성 → 추가 → 수정 → 삭제', b'1', 1, 328),
	(1310, '추가 → 생성 → 삭제 → 수정', b'0', 2, 328),
	(1311, '수정 → 생성 → 추가 → 삭제', b'0', 3, 328),
	(1312, '생성 → 수정 → 삭제 → 추가', b'0', 4, 328),
	(1313, '엔터티 간의 관계를 나타내는 것', b'0', 1, 329),
	(1314, '엔터티를 구성하는 더 이상 분리되지 않는 최소의 데이터 단위', b'1', 2, 329),
	(1315, '데이터베이스의 테이블', b'0', 3, 329),
	(1316, '엔터티의 식별자', b'0', 4, 329),
	(1317, '다른 속성으로부터 계산되어 조회되는 속성', b'0', 1, 330),
	(1318, '엔터티를 식별하기 위해 사용되는 속성', b'0', 2, 330),
	(1319, '업무에서 기본적으로 도출되는 속성', b'1', 3, 330),
	(1320, '하나의 속성이 여러 개의 값을 가지는 속성', b'0', 4, 330),
	(1321, '하나의 의미로 사용되는 여러 개의 속성들의 집합', b'1', 1, 331),
	(1322, '여러 개의 값을 동시에 가질 수 있는 속성', b'0', 2, 331),
	(1323, '다른 속성으로부터 유도되어 계산되는 속성', b'0', 3, 331),
	(1324, 'null 값을 가질 수 있는 속성', b'0', 4, 331),
	(1325, '단일 값 속성은 null을 허용하고, 다중 값 속성은 null을 허용하지 않는다', b'0', 1, 332),
	(1326, '단일 값 속성은 하나의 값만 가질 수 있고, 다중 값 속성은 여러 개의 값을 가질 수 있다', b'1', 2, 332),
	(1327, '단일 값 속성은 숫자형 데이터만 가질 수 있고, 다중 값 속성은 문자형 데이터만 가질 수 있다', b'0', 3, 332),
	(1328, '단일 값 속성은 기본키로 사용될 수 있고, 다중 값 속성은 기본키로 사용될 수 없다', b'0', 4, 332),
	(1329, '고객의 이름', b'0', 1, 333),
	(1330, '직원의 입사일', b'0', 2, 333),
	(1331, '주문의 총액 (단가 * 수량)', b'1', 3, 333),
	(1332, '상품의 코드', b'0', 4, 333),
	(1333, '현업에서 사용하는 이름을 사용한다', b'0', 1, 334),
	(1334, '약어 사용을 피한다', b'0', 2, 334),
	(1335, '가능한 한 짧게 만든다', b'0', 3, 334),
	(1336, '반드시 영문으로 작성해야 한다', b'1', 4, 334),
	(1337, '아직 값이 정해지지 않은 상태를 나타낸다', b'0', 1, 335),
	(1338, '공백이나 0과는 다른 의미이다', b'0', 2, 335),
	(1339, '모든 속성은 null 값을 가질 수 있다', b'1', 3, 335),
	(1340, 'null 값은 데이터베이스 설계 시 고려해야 할 중요한 요소이다', b'0', 4, 335),
	(1341, '속성이 가질 수 있는 모든 가능한 값들의 집합', b'1', 1, 336),
	(1342, '속성의 물리적 저장 공간', b'0', 2, 336),
	(1343, '속성의 기본값', b'0', 3, 336),
	(1344, '속성의 제약조건', b'0', 4, 336),
	(1345, '속성의 특성 (문자형, 숫자형, 날짜형 등)', b'0', 1, 337),
	(1346, '속성값의 최대 길이', b'0', 2, 337),
	(1347, '속성의 이름', b'1', 3, 337),
	(1348, '속성값의 정밀도 (소수점 이하 자릿수)', b'0', 4, 337),
	(1349, '다른 속성을 대신하여 엔터티를 식별할 수 있는 속성', b'1', 1, 338),
	(1350, '여러 개의 값을 동시에 가질 수 있는 속성', b'0', 2, 338),
	(1351, '다른 속성으로부터 계산되어 조회되는 속성', b'0', 3, 338),
	(1352, '복합 속성을 구성하는 하위 속성', b'0', 4, 338),
	(1353, '서브타입 엔터티는 슈퍼타입 엔터티의 속성을 상속받지 않는다', b'0', 1, 339),
	(1354, '슈퍼타입 엔터티는 서브타입 엔터티의 모든 속성을 가진다', b'0', 2, 339),
	(1355, '서브타입 엔터티는 슈퍼타입 엔터티의 속성을 상속받고 추가적인 고유 속성을 가질 수 있다', b'1', 3, 339),
	(1356, '슈퍼타입 엔터티와 서브타입 엔터티는 항상 동일한 속성을 가진다', b'0', 4, 339),
	(1357, '다른 엔터티와의 관계에서 부모 엔터티의 주식별자를 자신의 주식별자로 이용하는 속성', b'1', 1, 340),
	(1358, '엔터티 내에서 각 인스턴스를 유일하게 구분할 수 있는 속성', b'0', 2, 340),
	(1359, '업무적으로 구분되는 단위로 이용되는 속성', b'0', 3, 340),
	(1360, '여러 개의 속성으로 구성된 식별자 속성', b'0', 4, 340),
	(1361, '데이터의 중복을 최소화한다', b'0', 1, 341),
	(1362, '데이터의 일관성을 유지한다', b'0', 2, 341),
	(1363, '항상 성능을 향상시킨다', b'1', 3, 341),
	(1364, '데이터의 무결성을 보장한다', b'0', 4, 341),
	(1365, '칼럼명', b'0', 1, 342),
	(1366, '데이터 타입', b'0', 2, 342),
	(1367, '길이', b'0', 3, 342),
	(1368, '엔터티와의 관계', b'1', 4, 342),
	(1369, '두 개의 테이블 간의 조인 연산', b'0', 1, 343),
	(1370, '데이터베이스 내의 테이블', b'1', 2, 343),
	(1371, '테이블 간의 논리적 연관성', b'0', 3, 343),
	(1372, '프라이머리 키와 포린 키의 연결', b'0', 4, 343),
	(1373, '두 테이블의 모든 데이터를 결합한다', b'0', 1, 344),
	(1374, '조인 조건을 만족하는 데이터만 결과에 포함한다', b'1', 2, 344),
	(1375, '왼쪽 테이블의 모든 데이터를 결과에 포함한다', b'0', 3, 344),
	(1376, '오른쪽 테이블의 모든 데이터를 결과에 포함한다', b'0', 4, 344),
	(1377, '오른쪽 테이블의 모든 행이 결과에 포함된다', b'0', 1, 345),
	(1378, '왼쪽 테이블의 모든 행이 결과에 포함된다', b'1', 2, 345),
	(1379, '두 테이블의 공통된 데이터만 결과에 포함된다', b'0', 3, 345),
	(1380, '조인 조건을 만족하지 않는 데이터는 모두 제외된다', b'0', 4, 345),
	(1381, '왼쪽 테이블의 데이터만 모두 포함한다', b'0', 1, 346),
	(1382, '오른쪽 테이블의 데이터만 모두 포함한다', b'0', 2, 346),
	(1383, '두 테이블의 모든 데이터를 포함하며, 매치되지 않는 행은 NULL로 채운다', b'1', 3, 346),
	(1384, '두 테이블의 공통된 데이터만 포함한다', b'0', 4, 346),
	(1385, '두 테이블의 공통된 열만 결합한다', b'0', 1, 347),
	(1386, '두 테이블의 모든 가능한 조합을 만든다 (카테시안 곱)', b'1', 2, 347),
	(1387, '조인 조건을 만족하는 행만 결합한다', b'0', 3, 347),
	(1388, '왼쪽 테이블의 모든 행을 기준으로 결합한다', b'0', 4, 347),
	(1389, '서로 다른 두 테이블을 조인하는 것', b'0', 1, 348),
	(1390, '같은 테이블을 자기 자신과 조인하는 것', b'1', 2, 348),
	(1391, '기본키와 외래키로 조인하는 것', b'0', 3, 348),
	(1392, '세 개 이상의 테이블을 조인하는 것', b'0', 4, 348),
	(1393, '동일한 이름을 가진 모든 열을 기준으로 자동으로 조인한다', b'1', 1, 349),
	(1394, '사용자가 지정한 열을 기준으로 조인한다', b'0', 2, 349),
	(1395, '항상 INNER JOIN과 동일한 결과를 반환한다', b'0', 3, 349),
	(1396, '두 테이블의 모든 열을 결합한다', b'0', 4, 349),
	(1397, '\'= 연산자를 사용하여 조인 조건을 지정하는 방식', b'0', 1, 350),
	(1398, '\'= 연산자가 아닌 다른 비교 연산자를 사용하여 조인 조건을 지정하는 방식', b'1', 2, 350),
	(1399, '조인 조건 없이 두 테이블을 결합하는 방식', b'0', 3, 350),
	(1400, '세 개 이상의 테이블을 조인하는 방식', b'0', 4, 350),
	(1401, '조인 속도를 향상시키기 위해', b'0', 1, 351),
	(1402, '데이터의 정확성을 높이기 위해', b'0', 2, 351),
	(1403, '조인 조건을 만족하지 않는 데이터도 결과에 포함시키기 위해', b'1', 3, 351),
	(1404, '데이터베이스의 용량을 줄이기 위해', b'0', 4, 351),
	(1405, 'INNER JOIN은 조건을 만족하는 행만 반환하고, OUTER JOIN은 조건을 만족하지 않는 행도 포함하여 반환할 수 있다', b'1', 1, 352),
	(1406, 'INNER JOIN은 두 테이블만 조인할 수 있고, OUTER JOIN은 세 개 이상의 테이블을 조인할 수 있다', b'0', 2, 352),
	(1407, '0', b'0', 3, 352),
	(1408, 'INNER JOIN은 성능이 좋고, OUTER JOIN은 성능이 나쁘다', b'0', 4, 352),
	(1409, '조인되는 테이블의 수', b'0', 1, 353),
	(1410, '조인 키의 데이터 타입', b'0', 2, 353),
	(1411, '조인되는 테이블의 크기와 인덱스 유무', b'1', 3, 353),
	(1412, '조인의 종류 (INNER, OUTER 등)', b'0', 4, 353),
	(1413, '두 테이블의 공통된 데이터를 찾기 위해', b'0', 1, 354),
	(1414, '첫 번째 테이블에는 있지만 두 번째 테이블에는 없는 데이터를 찾기 위해', b'1', 2, 354),
	(1415, '두 테이블의 모든 가능한 조합을 만들기 위해', b'0', 3, 354),
	(1416, '두 테이블의 모든 데이터를 결합하기 위해', b'0', 4, 354),
	(1417, '조인 조건을 만족하는 왼쪽 테이블의 데이터만 반환하며, 오른쪽 테이블의 열은 포함하지 않는다', b'1', 1, 355),
	(1418, '조인 조건을 만족하지 않는 데이터만 반환한다', b'0', 2, 355),
	(1419, '항상 INNER JOIN과 동일한 결과를 반환한다', b'0', 3, 355),
	(1420, '두 테이블의 모든 열을 결합한다', b'0', 4, 355),
	(1421, '0', b'0', 1, 356),
	(1422, 'EQUI JOIN은 조인 조건을 명시적으로 지정하고, NATURAL JOIN은 같은 이름의 열을 자동으로 조인한다', b'1', 2, 356),
	(1423, 'EQUI JOIN은 INNER JOIN에만 사용 가능하고, NATURAL JOIN은 OUTER JOIN에만 사용 가능하다', b'0', 3, 356),
	(1424, 'EQUI JOIN은 두 테이블만 조인 가능하고, NATURAL JOIN은 여러 테이블을 조인할 수 있다', b'0', 4, 356),
	(1425, '엔터티 내에서 인스턴스를 유일하게 구분할 수 있는 속성 또는 속성의 집합', b'1', 1, 357),
	(1426, '엔터티의 모든 속성의 집합', b'0', 2, 357),
	(1427, '엔터티 간의 관계를 나타내는 속성', b'0', 3, 357),
	(1428, '엔터티의 이름을 나타내는 속성', b'0', 4, 357),
	(1429, '엔터티를 유일하게 식별할 수 있는 속성들의 집합', b'1', 1, 358),
	(1430, '반드시 단일 속성으로 구성되어야 한다', b'0', 2, 358),
	(1431, '엔터티당 하나만 존재할 수 있다', b'0', 3, 358),
	(1432, '널(NULL) 값을 가질 수 있다', b'0', 4, 358),
	(1433, '유일성', b'0', 1, 359),
	(1434, '최소성', b'0', 2, 359),
	(1435, '불변성', b'0', 3, 359),
	(1436, '널(NULL) 허용', b'1', 4, 359),
	(1437, '기본키로 선택된 후보키', b'0', 1, 360),
	(1438, '기본키로 선택되지 않은 후보키', b'1', 2, 360),
	(1439, '다른 엔터티로부터 상속받은 식별자', b'0', 3, 360),
	(1440, '여러 개의 속성으로 구성된 복합 식별자', b'0', 4, 360),
	(1441, '두 개 이상의 속성으로 구성된 키', b'1', 1, 361),
	(1442, '단일 속성으로 구성된 키', b'0', 2, 361),
	(1443, '다른 엔터티로부터 상속받은 키', b'0', 3, 361),
	(1444, '인조적으로 만들어진 키', b'0', 4, 361),
	(1445, '다른 엔터티의 기본키를 참조하는 속성', b'0', 1, 362),
	(1446, '관계를 통해 다른 엔터티와 연결되는 속성', b'0', 2, 362),
	(1447, '항상 해당 엔터티의 기본키의 일부가 되어야 한다', b'1', 3, 362),
	(1448, '널(NULL) 값을 가질 수 있다', b'0', 4, 362),
	(1449, '업무적 의미를 가지는 식별자', b'0', 1, 363),
	(1450, '자연적으로 발생하는 식별자', b'0', 2, 363),
	(1451, '인위적으로 생성한 식별자', b'1', 3, 363),
	(1452, '여러 개의 속성으로 구성된 식별자', b'0', 4, 363),
	(1453, '유일성', b'0', 1, 364),
	(1454, '최소성', b'0', 2, 364),
	(1455, '불변성', b'0', 3, 364),
	(1456, '길이의 최대화', b'1', 4, 364),
	(1457, '인위적으로 만들어진 식별자', b'0', 1, 365),
	(1458, '업무적으로 의미 있는 식별자', b'1', 2, 365),
	(1459, '항상 단일 속성으로 구성된다', b'0', 3, 365),
	(1460, '변경될 가능성이 높은 식별자', b'0', 4, 365),
	(1461, '식별자 관계는 1:1 관계만 가능하고, 비식별자 관계는 1:N 관계만 가능하다', b'0', 1, 366),
	(1462, '식별자 관계는 부모 엔터티의 키가 자식 엔터티의 키의 일부가 되고, 비식별자 관계는 그렇지 않다', b'1', 2, 366),
	(1463, '식별자 관계는 필수적 관계이고, 비식별자 관계는 선택적 관계이다', b'0', 3, 366),
	(1464, '식별자 관계는 물리적 모델에서만 표현되고, 비식별자 관계는 논리적 모델에서만 표현된다', b'0', 4, 366),
	(1465, '유일성을 보장하기 어렵다', b'0', 1, 367),
	(1466, '인덱스 크기가 커질 수 있다', b'1', 2, 367),
	(1467, '널(NULL) 값을 허용한다', b'0', 3, 367),
	(1468, '업무적 의미를 가지지 않는다', b'0', 4, 367),
	(1469, '기존 식별자의 크기가 너무 큰 경우', b'0', 1, 368),
	(1470, '여러 개의 속성으로 구성된 식별자인 경우', b'0', 2, 368),
	(1471, '식별자가 업무적 의미를 가지는 경우', b'1', 3, 368),
	(1472, '식별자가 자주 변경되는 경우', b'0', 4, 368),
	(1473, '복합식별자', b'0', 1, 369),
	(1474, '단일식별자', b'1', 2, 369),
	(1475, '본질식별자', b'0', 3, 369),
	(1476, '인조식별자', b'0', 4, 369),
	(1477, '기본키는 중복된 값을 가질 수 없다', b'0', 1, 370),
	(1478, '외래키는 참조하는 테이블의 기본키에 없는 값을 가질 수 없다', b'1', 2, 370),
	(1479, '모든 속성은 원자값을 가져야 한다', b'0', 3, 370),
	(1480, '기본키는 널(NULL) 값을 가질 수 있다', b'0', 4, 370),
	(1481, '데이터베이스의 성능 향상', b'0', 1, 371),
	(1482, '데이터의 중복 제거와 일관성 확보', b'1', 2, 371),
	(1483, '데이터의 보안성 강화', b'0', 3, 371),
	(1484, '데이터베이스의 용량 증가', b'0', 4, 371),
	(1485, '부분적 함수 종속 제거', b'0', 1, 372),
	(1486, '이행적 함수 종속 제거', b'0', 2, 372),
	(1487, '모든 속성의 원자값화', b'1', 3, 372),
	(1488, '결정자이면서 후보키가 아닌 것 제거', b'0', 4, 372),
	(1489, '모든 비주요 속성이 주요 속성에 완전 함수적 종속', b'1', 1, 373),
	(1490, '이행적 함수 종속 제거', b'0', 2, 373),
	(1491, '모든 속성이 원자값을 가짐', b'0', 3, 373),
	(1492, '결정자이면서 후보키가 아닌 것 제거', b'0', 4, 373),
	(1493, '부분적 함수 종속 제거', b'0', 1, 374),
	(1494, '이행적 함수 종속 제거', b'1', 2, 374),
	(1495, '모든 속성의 원자값화', b'0', 3, 374),
	(1496, '결정자이면서 후보키가 아닌 것 제거', b'0', 4, 374),
	(1497, '모든 결정자가 후보키인 경우', b'1', 1, 375),
	(1498, '모든 속성이 원자값을 가지는 경우', b'0', 2, 375),
	(1499, '부분적 함수 종속이 없는 경우', b'0', 3, 375),
	(1500, '이행적 함수 종속이 없는 경우', b'0', 4, 375),
	(1501, 'X의 값에 따라 Y의 값이 유일하게 정해지는 관계', b'1', 1, 376),
	(1502, 'X와 Y가 서로 독립적인 관계', b'0', 2, 376),
	(1503, 'X와 Y가 1:N 관계를 가지는 경우', b'0', 3, 376),
	(1504, 'X와 Y가 복합키를 형성하는 경우', b'0', 4, 376),
	(1505, '데이터의 중복성 증가', b'0', 1, 377),
	(1506, '데이터의 일관성 저하', b'0', 2, 377),
	(1507, '조인 연산의 증가로 인한 성능 저하 가능성', b'1', 3, 377),
	(1508, '데이터베이스 용량의 증가', b'0', 4, 377),
	(1509, '부분적 함수 종속', b'0', 1, 378),
	(1510, '이행적 함수 종속', b'0', 2, 378),
	(1511, '다치 종속(Multi-valued Dependency)', b'1', 3, 378),
	(1512, '결합 종속(Join Dependency)', b'0', 4, 378),
	(1513, '다른 속성의 값을 유일하게 결정하는 속성', b'1', 1, 379),
	(1514, '기본키로 선정된 속성', b'0', 2, 379),
	(1515, '외래키로 사용되는 속성', b'0', 3, 379),
	(1516, '널(NULL) 값을 가질 수 없는 속성', b'0', 4, 379),
	(1517, '데이터의 일관성이 너무 낮을 때', b'0', 1, 380),
	(1518, '조인으로 인한 성능 저하가 심각할 때', b'1', 2, 380),
	(1519, '데이터의 중복이 너무 많을 때', b'0', 3, 380),
	(1520, '데이터베이스의 용량이 너무 작을 때', b'0', 4, 380),
	(1521, 'A→B이고 B→C일 때, A→C가 성립하는 경우', b'1', 1, 381),
	(1522, 'A와 B가 서로 독립적인 관계', b'0', 2, 381),
	(1523, 'A가 B를 결정하고 B가 A를 결정하는 경우', b'0', 3, 381),
	(1524, 'A와 B가 복합키를 형성하는 경우', b'0', 4, 381),
	(1525, '부분적 함수 종속 제거', b'0', 1, 382),
	(1526, '이행적 함수 종속 제거', b'0', 2, 382),
	(1527, '다치 종속 제거', b'0', 3, 382),
	(1528, '조인 종속성 제거', b'1', 4, 382),
	(1529, '데이터베이스의 성능을 향상시키기 위해', b'0', 1, 383),
	(1530, '속성 간의 종속 관계를 시각적으로 표현하기 위해', b'1', 2, 383),
	(1531, '데이터의 보안성을 강화하기 위해', b'0', 3, 383),
	(1532, '데이터베이스의 용량을 줄이기 위해', b'0', 4, 383),
	(1533, '종속성의 방향', b'0', 1, 384),
	(1534, '결정자의 개수', b'0', 2, 384),
	(1535, '복합키의 전체 또는 일부 사용 여부', b'1', 3, 384),
	(1536, '종속성의 강도', b'0', 4, 384),
	(1537, '엔터티의 인스턴스들 사이의 논리적인 연관성', b'1', 1, 385),
	(1538, '엔터티를 구성하는 속성의 집합', b'0', 2, 385),
	(1539, '데이터베이스의 테이블 구조', b'0', 3, 385),
	(1540, '엔터티의 식별자', b'0', 4, 385),
	(1541, '관계에 참여하는 엔터티의 수', b'1', 1, 386),
	(1542, '관계가 발생하는 빈도수', b'0', 2, 386),
	(1543, '관계를 식별하는 속성의 수', b'0', 3, 386),
	(1544, '관계에 참여하는 엔터티 인스턴스의 수', b'0', 4, 386),
	(1545, '양쪽 엔터티 모두 하나의 인스턴스가 서로 하나의 인스턴스와 관계를 맺는다', b'0', 1, 387),
	(1546, '한 쪽 엔터티의 하나의 인스턴스가 다른 쪽 엔터티의 여러 인스턴스와 관계를 맺을 수 있다', b'1', 2, 387),
	(1547, '양쪽 엔터티 모두 하나의 인스턴스가 서로 여러 개의 인스턴스와 관계를 맺을 수 있다', b'0', 3, 387),
	(1548, '관계가 성립하지 않는다', b'0', 4, 387),
	(1549, '두 엔터티 중 하나를 삭제한다', b'0', 1, 388),
	(1550, '관계를 1:1로 변경한다', b'0', 2, 388),
	(1551, '중간에 연결 엔터티를 추가한다', b'1', 3, 388),
	(1552, '속성을 추가하여 해결한다', b'0', 4, 388),
	(1553, '관계에 참여하는 엔터티의 수', b'0', 1, 389),
	(1554, '관계의 발생 빈도', b'0', 2, 389),
	(1555, '관계 참여의 필수 여부', b'1', 3, 389),
	(1556, '관계를 식별하는 속성의 수', b'0', 4, 389),
	(1557, '두 개 이상의 엔터티가 순환하며 관계를 맺는 것', b'0', 1, 390),
	(1558, '하나의 엔터티가 자기 자신과 관계를 맺는 것', b'1', 2, 390),
	(1559, '관계가 주기적으로 반복되는 것', b'0', 3, 390),
	(1560, '양방향으로 관계가 성립되는 것', b'0', 4, 390),
	(1561, '부모 엔터티의 기본키가 자식 엔터티의 기본키의 일부로 사용된다', b'1', 1, 391),
	(1562, '부모 엔터티와 자식 엔터티가 항상 1:1 관계를 가진다', b'0', 2, 391),
	(1563, '자식 엔터티의 기본키가 부모 엔터티의 기본키의 일부로 사용된다', b'0', 3, 391),
	(1564, '부모 엔터티와 자식 엔터티 사이에 독립적인 관계가 성립한다', b'0', 4, 391),
	(1565, '사각형', b'0', 1, 392),
	(1566, '마름모', b'1', 2, 392),
	(1567, '타원', b'0', 3, 392),
	(1568, '삼각형', b'0', 4, 392),
	(1569, '관계의 이름', b'0', 1, 393),
	(1570, '관계의 참여도', b'0', 2, 393),
	(1571, '관계의 필수 여부', b'0', 3, 393),
	(1572, '관계의 색상', b'1', 4, 393),
	(1573, '부모 엔터티의 기본키가 자식 엔터티의 기본키의 일부로 사용된다', b'0', 1, 394),
	(1574, '부모 엔터티의 기본키가 자식 엔터티의 일반 속성으로 사용된다', b'1', 2, 394),
	(1575, '자식 엔터티의 기본키가 부모 엔터티의 기본키의 일부로 사용된다', b'0', 3, 394),
	(1576, '부모 엔터티와 자식 엔터티 사이에 관계가 존재하지 않는다', b'0', 4, 394),
	(1577, '관계에 참여하는 엔터티의 수', b'0', 1, 395),
	(1578, '관계에 참여하는 각 엔터티의 인스턴스 수의 최대치', b'1', 2, 395),
	(1579, '관계를 식별하는 속성의 수', b'0', 3, 395),
	(1580, '관계가 발생하는 빈도수', b'0', 4, 395),
	(1581, '데이터의 중복을 최소화한다', b'0', 1, 396),
	(1582, '데이터의 일관성을 유지한다', b'0', 2, 396),
	(1583, '항상 조회 성능을 향상시킨다', b'1', 3, 396),
	(1584, '데이터의 무결성을 보장한다', b'0', 4, 396),
	(1585, '한 엔터티의 존재가 다른 엔터티의 존재에 의존하는 것', b'1', 1, 397),
	(1586, '관계에 참여하는 엔터티의 수', b'0', 2, 397),
	(1587, '관계를 식별하는 속성의 수', b'0', 3, 397),
	(1588, '관계가 발생하는 빈도수', b'0', 4, 397),
	(1589, '업무적 연관성을 정확히 파악해야 한다', b'0', 1, 398),
	(1590, '관계의 방향성을 고려해야 한다', b'0', 2, 398),
	(1591, '모든 관계는 반드시 M:N으로 설정해야 한다', b'1', 3, 398),
	(1592, '관계의 필수 여부를 명확히 해야 한다', b'0', 4, 398),
	(1593, '데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위', b'1', 1, 399),
	(1594, '데이터베이스 테이블 간의 관계', b'0', 2, 399),
	(1595, '데이터베이스의 물리적 저장 구조', b'0', 3, 399),
	(1596, '데이터베이스의 백업 작업', b'0', 4, 399),
	(1597, '원자성(Atomicity)', b'0', 1, 400),
	(1598, '일관성(Consistency)', b'0', 2, 400),
	(1599, '독립성(Isolation)', b'0', 3, 400),
	(1600, '확장성(Scalability)', b'1', 4, 400),
	(1601, '엔터티 간의 관계 정의', b'0', 1, 401),
	(1602, '속성의 정의', b'0', 2, 401),
	(1603, '제약조건의 설정', b'0', 3, 401),
	(1604, '테이블의 색상 지정', b'1', 4, 401),
	(1605, 'Read Uncommitted', b'0', 1, 402),
	(1606, 'Read Committed', b'0', 2, 402),
	(1607, 'Repeatable Read', b'0', 3, 402),
	(1608, 'Distributed Read', b'1', 4, 402),
	(1609, '인덱싱(Indexing)', b'0', 1, 403),
	(1610, '락킹(Locking)', b'1', 2, 403),
	(1611, '파티셔닝(Partitioning)', b'0', 3, 403),
	(1612, '샤딩(Sharding)', b'0', 4, 403),
	(1613, '데이터의 일관성 유지', b'0', 1, 404),
	(1614, '동시성 제어', b'0', 2, 404),
	(1615, '복구 가능성', b'0', 3, 404),
	(1616, '테이블의 물리적 위치', b'1', 4, 404),
	(1617, '외래 키 제약조건 설정', b'0', 1, 405),
	(1618, '테이블 간 관계 정의', b'0', 2, 405),
	(1619, '롤백(Rollback) 메커니즘 설계', b'1', 3, 405),
	(1620, '인덱스 생성', b'0', 4, 405),
	(1621, '모든 데이터를 하나의 테이블에 저장', b'0', 1, 406),
	(1622, '제약조건과 무결성 규칙 정의', b'1', 2, 406),
	(1623, '모든 트랜잭션의 격리 수준을 최대로 설정', b'0', 3, 406),
	(1624, '모든 속성을 널(NULL) 허용으로 설정', b'0', 4, 406),
	(1625, '정규화(Normalization)', b'0', 1, 407),
	(1626, '역정규화(Denormalization)', b'0', 2, 407),
	(1627, '동시성 제어(Concurrency Control)', b'1', 3, 407),
	(1628, '인덱싱(Indexing)', b'0', 4, 407),
	(1629, '모든 데이터를 메모리에 저장', b'0', 1, 408),
	(1630, '로깅(Logging) 메커니즘 구현', b'1', 2, 408),
	(1631, '모든 트랜잭션을 직렬화(Serialization)', b'0', 3, 408),
	(1632, '모든 테이블에 타임스탬프 추가', b'0', 4, 408),
	(1633, '락(Lock) 메커니즘 사용', b'0', 1, 409),
	(1634, '트랜잭션 격리 수준 설정', b'0', 2, 409),
	(1635, '낙관적 동시성 제어(Optimistic Concurrency Control) 구현', b'0', 3, 409),
	(1636, '모든 트랜잭션을 순차적으로 실행', b'1', 4, 409),
	(1637, '트랜잭션을 더 작은 단위로 분할', b'1', 1, 410),
	(1638, '트랜잭션의 타임아웃 시간을 늘림', b'0', 2, 410),
	(1639, '모든 데이터를 메모리에 로드', b'0', 3, 410),
	(1640, '트랜잭션의 격리 수준을 낮춤', b'0', 4, 410),
	(1641, '업무적 연관성을 정확히 파악해야 한다', b'0', 1, 411),
	(1642, '관계의 방향성을 고려해야 한다', b'0', 2, 411),
	(1643, '모든 관계는 반드시 M:N으로 설정해야 한다', b'1', 3, 411),
	(1644, '관계의 필수 여부를 명확히 해야 한다', b'0', 4, 411),
	(1645, '2단계 커밋(Two-Phase Commit) 프로토콜', b'1', 1, 412),
	(1646, '모든 데이터를 단일 서버에 저장', b'0', 2, 412),
	(1647, '트랜잭션 격리 수준을 항상 최대로 설정', b'0', 3, 412),
	(1648, '모든 트랜잭션을 비동기적으로 처리', b'0', 4, 412),
	(1649, '0', b'0', 1, 413),
	(1650, '빈 문자열(\'\')', b'0', 2, 413),
	(1651, '알 수 없는 값 또는 해당 없음', b'1', 3, 413),
	(1652, '잘못된 데이터', b'0', 4, 413),
	(1653, 'NULL + 5 의 결과는 5이다', b'0', 1, 414),
	(1654, 'NULL과 NULL은 같다', b'0', 2, 414),
	(1655, 'NULL과의 모든 비교 연산 결과는 FALSE이다', b'0', 3, 414),
	(1656, 'NULL과의 모든 비교 연산 결과는 UNKNOWN이다', b'1', 4, 414),
	(1657, 'SUM 함수는 NULL을 0으로 처리한다', b'0', 1, 415),
	(1658, 'COUNT(*) 함수는 NULL을 포함한 모든 행을 계산한다', b'1', 2, 415),
	(1659, 'AVG 함수는 NULL을 포함한 모든 행을 분모로 사용한다', b'0', 3, 415),
	(1660, 'MAX 함수는 NULL을 가장 큰 값으로 간주한다', b'0', 4, 415),
	(1661, '해당 열에 중복된 값을 허용하지 않는다', b'0', 1, 416),
	(1662, '해당 열에 NULL 값을 허용하지 않는다', b'1', 2, 416),
	(1663, '해당 열의 값이 반드시 0이어야 한다', b'0', 3, 416),
	(1664, '해당 열의 값이 반드시 고유해야 한다', b'0', 4, 416),
	(1665, 'ISNULL()', b'0', 1, 417),
	(1666, 'COALESCE()', b'1', 2, 417),
	(1667, 'NULLIF()', b'0', 3, 417),
	(1668, 'NVL()', b'0', 4, 417),
	(1669, 'TRUE', b'0', 1, 418),
	(1670, 'FALSE', b'0', 2, 418),
	(1671, 'UNKNOWN', b'0', 3, 418),
	(1672, 'MAYBE', b'1', 4, 418),
	(1673, 'NULL 값은 모두 제거된다', b'0', 1, 419),
	(1674, 'NULL 값은 하나의 고유한 값으로 취급된다', b'1', 2, 419),
	(1675, 'NULL 값은 오류를 발생시킨다', b'0', 3, 419),
	(1676, 'NULL 값은 가장 작은 값으로 정렬된다', b'0', 4, 419),
	(1677, 'NULL 값은 인덱스에 포함되지 않는다', b'0', 1, 420),
	(1678, 'NULL 값은 인덱스의 첫 번째 항목으로 저장된다', b'0', 2, 420),
	(1679, 'NULL 값은 인덱스의 마지막 항목으로 저장된다', b'0', 3, 420),
	(1680, 'NULL 값의 인덱스 처리는 DBMS에 따라 다를 수 있다', b'1', 4, 420),
	(1681, '= NULL', b'0', 1, 421),
	(1682, '== NULL', b'0', 2, 421),
	(1683, 'IS NULL', b'1', 3, 421),
	(1684, 'EQUALS NULL', b'0', 4, 421),
	(1685, 'NULL 값은 UNIQUE 제약조건을 위반한다', b'0', 1, 422),
	(1686, '하나의 NULL 값만 허용된다', b'0', 2, 422),
	(1687, 'NULL 값은 UNIQUE 제약조건과 관계없이 여러 개 허용될 수 있다', b'1', 3, 422),
	(1688, 'NULL 값은 UNIQUE 제약조건이 설정된 열에 입력할 수 없다', b'0', 4, 422),
	(1689, '복합 기본키의 일부 열에만 NULL 값이 허용된다', b'0', 1, 423),
	(1690, '복합 기본키의 모든 열에 NULL 값이 허용된다', b'0', 2, 423),
	(1691, '복합 기본키의 어떤 열에도 NULL 값이 허용되지 않는다', b'1', 3, 423),
	(1692, '복합 기본키의 첫 번째 열에만 NULL 값이 허용된다', b'0', 4, 423),
	(1693, 'NULL 값은 별도의 그룹으로 처리된다', b'1', 1, 424),
	(1694, 'NULL 값이 포함된 행은 그룹화에서 제외된다', b'0', 2, 424),
	(1695, 'NULL 값이 포함된 열은 GROUP BY를 사용할 수 없다', b'0', 3, 424),
	(1696, 'NULL 값은 가장 큰 값의 그룹에 포함된다', b'0', 4, 424),
	(1697, '외래 키는 항상 NULL 값을 허용한다', b'0', 1, 425),
	(1698, '외래 키는 절대 NULL 값을 허용하지 않는다', b'0', 2, 425),
	(1699, '외래 키의 NULL 허용 여부는 설계자가 지정할 수 있다', b'1', 3, 425),
	(1700, '외래 키가 NULL이면 참조 무결성이 위반된다', b'0', 4, 425),
	(1701, 'NULL 값은 모두 제거된다', b'0', 1, 426),
	(1702, 'NULL 값은 하나의 고유한 값으로 취급된다', b'1', 2, 426),
	(1703, 'NULL 값이 포함된 행은 UNION 결과에서 제외된다', b'0', 3, 426),
	(1704, 'NULL 값이 포함된 열은 UNION 연산을 수행할 수 없다', b'0', 4, 426),
	(1705, '인위적으로 만들어진 식별자', b'0', 1, 427),
	(1706, '업무적으로 의미 있는 데이터를 식별자로 사용하는 것', b'1', 2, 427),
	(1707, '항상 숫자로 구성된 식별자', b'0', 3, 427),
	(1708, '여러 개의 칼럼으로 구성된 식별자', b'0', 4, 427),
	(1709, '일반적으로 단순한 숫자로 구성된다', b'0', 1, 428),
	(1710, '업무적 의미를 가지고 있다', b'1', 2, 428),
	(1711, '자동으로 생성되는 경우가 많다', b'0', 3, 428),
	(1712, '변경될 가능성이 낮다', b'0', 4, 428),
	(1713, '항상 유일성이 보장된다', b'0', 1, 429),
	(1714, '업무적 의미를 파악하기 쉽다', b'1', 2, 429),
	(1715, '데이터 크기가 항상 일정하다', b'0', 3, 429),
	(1716, '인덱스 성능이 항상 우수하다', b'0', 4, 429),
	(1717, '데이터의 의미를 파악하기 어려울 수 있다', b'1', 1, 430),
	(1718, '유일성을 보장하기 어렵다', b'0', 2, 430),
	(1719, '인덱스 성능이 떨어진다', b'0', 3, 430),
	(1720, '데이터베이스 용량을 많이 차지한다', b'0', 4, 430),
	(1721, '식별자로 사용할 만한 본질적인 속성이 없을 때', b'1', 1, 431),
	(1722, '데이터의 업무적 의미가 매우 중요할 때', b'0', 2, 431),
	(1723, '데이터의 변경이 거의 없을 때', b'0', 3, 431),
	(1724, '테이블 간 관계가 거의 없을 때', b'0', 4, 431),
	(1725, '의미 있는 데이터의 변경 가능성', b'1', 1, 432),
	(1726, '식별자의 길이가 너무 짧아질 수 있다는 점', b'0', 2, 432),
	(1727, '자동 생성이 어렵다는 점', b'0', 3, 432),
	(1728, '다른 테이블과의 관계 설정이 어렵다는 점', b'0', 4, 432),
	(1729, '주민등록번호', b'0', 1, 433),
	(1730, '자동 증가하는 일련번호', b'1', 2, 433),
	(1731, '이메일 주소', b'0', 3, 433),
	(1732, '상품 코드', b'0', 4, 433),
	(1733, '데이터베이스 성능이 항상 향상된다', b'0', 1, 434),
	(1734, '데이터의 일관성이 무조건 보장된다', b'0', 2, 434),
	(1735, '업무적 의미와 시스템 효율성을 모두 고려할 수 있다', b'1', 3, 434),
	(1736, '데이터베이스 설계가 항상 단순해진다', b'0', 4, 434),
	(1737, '자동 증가(Auto Increment) 칼럼 사용', b'0', 1, 435),
	(1738, 'UUID(Universally Unique Identifier) 사용', b'0', 2, 435),
	(1739, '시퀀스(Sequence) 사용', b'0', 3, 435),
	(1740, '기본키의 모든 칼럼을 연결하여 사용', b'1', 4, 435),
	(1741, '업무적 의미를 쉽게 파악할 수 있다', b'0', 1, 436),
	(1742, '별도의 식별자 칼럼이 필요 없다', b'0', 2, 436),
	(1743, '항상 최고의 검색 성능을 보장한다', b'1', 3, 436),
	(1744, '데이터의 무결성을 직관적으로 확인할 수 있다', b'0', 4, 436),
	(1745, '항상 모델을 단순화한다', b'0', 1, 437),
	(1746, '테이블 간 관계 설정을 더 복잡하게 만든다', b'0', 2, 437),
	(1747, '물리적 모델과 논리적 모델의 차이를 줄일 수 있다', b'1', 3, 437),
	(1748, '정규화 과정을 완전히 생략할 수 있게 한다', b'0', 4, 437),
	(1749, '데이터의 특성', b'0', 1, 438),
	(1750, '시스템의 요구사항', b'0', 2, 438),
	(1751, '개발 팀의 선호도', b'1', 3, 438),
	(1752, '데이터베이스 관리 시스템의 종류', b'0', 4, 438),
	(1753, '항상 성능을 향상시킨다', b'0', 1, 439),
	(1754, '항상 성능을 저하시킨다', b'0', 2, 439),
	(1755, '일반적으로 단순한 구조로 인해 성능이 향상될 수 있다', b'1', 3, 439),
	(1756, '성능과는 전혀 관계가 없다', b'0', 4, 439),
	(1757, '항상 피해야 할 설계 방식이다', b'0', 1, 440),
	(1758, '데이터의 무결성을 해칠 수 있어 권장되지 않는다', b'0', 2, 440),
	(1759, '업무적 요구사항과 시스템 효율성을 모두 고려할 수 있는 방식이다', b'1', 3, 440),
	(1760, '데이터베이스 용량을 크게 증가시키므로 주의해야 한다', b'0', 4, 440),
	(1761, '테이블', b'0', 1, 441),
	(1762, '행(Row)', b'0', 2, 441),
	(1763, '열(Column)', b'0', 3, 441),
	(1764, '포인터(Pointer)', b'1', 4, 441),
	(1765, '데이터베이스 관리자와 사용자의 관계', b'0', 1, 442),
	(1766, '테이블 간의 논리적 연관성', b'1', 2, 442),
	(1767, '데이터베이스 서버와 클라이언트의 관계', b'0', 3, 442),
	(1768, '프로그래밍 언어와 SQL의 관계', b'0', 4, 442),
	(1769, '데이터의 중복을 최소화한다', b'0', 1, 443),
	(1770, 'SQL을 이용하여 데이터를 조작한다', b'0', 2, 443),
	(1771, '계층적 구조로 데이터를 저장한다', b'1', 3, 443),
	(1772, '테이블 간의 관계를 이용하여 데이터를 조회한다', b'0', 4, 443),
	(1773, '인스턴스', b'0', 1, 444),
	(1774, '릴레이션', b'1', 2, 444),
	(1775, '도메인', b'0', 3, 444),
	(1776, '카디널리티', b'0', 4, 444),
	(1777, '기본키(Primary Key)', b'0', 1, 445),
	(1778, '외래키(Foreign Key)', b'0', 2, 445),
	(1779, '슈퍼키(Super Key)', b'0', 3, 445),
	(1780, '복합키(Composite Key)', b'1', 4, 445),
	(1781, '개체 무결성', b'0', 1, 446),
	(1782, '참조 무결성', b'0', 2, 446),
	(1783, '도메인 무결성', b'0', 3, 446),
	(1784, '병행 무결성', b'1', 4, 446),
	(1785, '데이터 중복', b'0', 1, 447),
	(1786, '갱신 이상', b'0', 2, 447),
	(1787, '삭제 이상', b'0', 3, 447),
	(1788, '암호화 이상', b'1', 4, 447),
	(1789, '숫자 0', b'0', 1, 448),
	(1790, '빈 문자열(\'\')', b'0', 2, 448),
	(1791, '알 수 없거나 해당 없음', b'1', 3, 448),
	(1792, '시스템 오류', b'0', 4, 448),
	(1793, 'Oracle', b'0', 1, 449),
	(1794, 'MySQL', b'0', 2, 449),
	(1795, 'MongoDB', b'1', 3, 449),
	(1796, 'Microsoft SQL Server', b'0', 4, 449),
	(1797, 'RAID', b'0', 1, 450),
	(1798, 'ACID', b'1', 2, 450),
	(1799, 'BASE', b'0', 3, 450),
	(1800, 'CASE', b'0', 4, 450),
	(1801, '데이터의 일관성 유지', b'0', 1, 451),
	(1802, '복잡한 쿼리 처리 가능', b'0', 2, 451),
	(1803, '대용량 비정형 데이터 처리에 최적화', b'1', 3, 451),
	(1804, '데이터 중복 최소화', b'0', 4, 451),
	(1805, '데이터 저장 공간 확보', b'0', 1, 452),
	(1806, '데이터 접근 제어 및 복잡한 쿼리 단순화', b'1', 2, 452),
	(1807, '데이터 백업 및 복구', b'0', 3, 452),
	(1808, '데이터베이스 성능 최적화', b'0', 4, 452),
	(1809, '데이터베이스의 물리적 저장 구조', b'0', 1, 453),
	(1810, '데이터베이스의 논리적 구조와 제약조건의 정의', b'1', 2, 453),
	(1811, '데이터베이스의 백업 파일', b'0', 3, 453),
	(1812, '데이터베이스의 질의 처리 엔진', b'0', 4, 453),
	(1813, '인덱스(Index)', b'0', 1, 454),
	(1814, '트리거(Trigger)', b'0', 2, 454),
	(1815, '외래키(Foreign Key) 제약조건', b'1', 3, 454),
	(1816, '저장 프로시저(Stored Procedure)', b'0', 4, 454),
	(1817, 'SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY', b'1', 1, 455),
	(1818, 'FROM - SELECT - WHERE - GROUP BY - HAVING - ORDER BY', b'0', 2, 455),
	(1819, 'SELECT - WHERE - FROM - GROUP BY - HAVING - ORDER BY', b'0', 3, 455),
	(1820, 'FROM - WHERE - SELECT - GROUP BY - HAVING - ORDER BY', b'0', 4, 455),
	(1821, 'SELECT column_name AS alias_name', b'1', 1, 456),
	(1822, 'SELECT column_name IS alias_name', b'0', 2, 456),
	(1823, 'SELECT column_name = alias_name', b'0', 3, 456),
	(1824, 'SELECT alias_name FOR column_name', b'0', 4, 456),
	(1825, 'UNIQUE', b'0', 1, 457),
	(1826, 'DISTINCT', b'1', 2, 457),
	(1827, 'DIFFERENT', b'0', 3, 457),
	(1828, 'SINGLE', b'0', 4, 457),
	(1829, 'LIKE', b'0', 1, 458),
	(1830, 'IN', b'0', 2, 458),
	(1831, 'BETWEEN', b'0', 3, 458),
	(1832, 'HAVING', b'1', 4, 458),
	(1833, 'UNION', b'0', 1, 459),
	(1834, 'JOIN', b'1', 2, 459),
	(1835, 'COMBINE', b'0', 3, 459),
	(1836, 'MERGE', b'0', 4, 459),
	(1837, '특정 열을 기준으로 행을 그룹화한다', b'0', 1, 460),
	(1838, '집계 함수와 함께 자주 사용된다', b'0', 2, 460),
	(1839, 'WHERE 절 다음에 위치한다', b'0', 3, 460),
	(1840, 'ORDER BY 절 다음에 위치한다', b'1', 4, 460),
	(1841, 'SORT BY', b'0', 1, 461),
	(1842, 'ARRANGE BY', b'0', 2, 461),
	(1843, 'ORDER BY', b'1', 3, 461),
	(1844, 'SEQUENCE BY', b'0', 4, 461),
	(1845, '개별 행을 필터링한다', b'0', 1, 462),
	(1846, '그룹화된 결과에 조건을 적용한다', b'1', 2, 462),
	(1847, '결과를 정렬한다', b'0', 3, 462),
	(1848, '여러 테이블을 조인한다', b'0', 4, 462),
	(1849, 'SELECT 절', b'0', 1, 463),
	(1850, 'FROM 절', b'0', 2, 463),
	(1851, 'WHERE 절', b'0', 3, 463),
	(1852, 'ORDER BY 절', b'1', 4, 463),
	(1853, 'SUM', b'0', 1, 464),
	(1854, 'AVG', b'0', 2, 464),
	(1855, 'MEDIAN', b'1', 3, 464),
	(1856, 'COUNT', b'0', 4, 464),
	(1857, '%', b'0', 1, 465),
	(1858, '_', b'0', 2, 465),
	(1859, '*', b'1', 3, 465),
	(1860, '[]', b'0', 4, 465),
	(1861, 'FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY', b'1', 1, 466),
	(1862, 'SELECT - FROM - WHERE - GROUP BY - HAVING - ORDER BY', b'0', 2, 466),
	(1863, 'FROM - SELECT - WHERE - GROUP BY - HAVING - ORDER BY', b'0', 3, 466),
	(1864, 'WHERE - FROM - GROUP BY - HAVING - SELECT - ORDER BY', b'0', 4, 466),
	(1865, 'WHERE column_name = NULL', b'0', 1, 467),
	(1866, 'WHERE column_name IS NULL', b'1', 2, 467),
	(1867, 'WHERE column_name EQUALS NULL', b'0', 3, 467),
	(1868, 'WHERE column_name <- NULL', b'0', 4, 467),
	(1869, '두 개 이상의 SELECT 문 결과를 결합한다', b'0', 1, 468),
	(1870, '기본적으로 중복된 행을 제거한다', b'0', 2, 468),
	(1871, '결합되는 SELECT 문의 열 개수와 데이터 타입이 일치해야 한다', b'0', 3, 468),
	(1872, '결과를 자동으로 오름차순 정렬한다', b'1', 4, 468),
	(1873, 'SUBSTR', b'0', 1, 469),
	(1874, 'CONCAT', b'0', 2, 469),
	(1875, 'ROUND', b'1', 3, 469),
	(1876, 'UPPER', b'0', 4, 469),
	(1877, 'ISNULL', b'0', 1, 470),
	(1878, 'COALESCE', b'1', 2, 470),
	(1879, 'NULLIF', b'0', 3, 470),
	(1880, 'NVL', b'0', 4, 470),
	(1881, 'DATEDIFF', b'0', 1, 471),
	(1882, 'MONTHS_BETWEEN', b'1', 2, 471),
	(1883, 'DATE_SUB', b'0', 3, 471),
	(1884, 'INTERVAL', b'0', 4, 471),
	(1885, 'SUM', b'0', 1, 472),
	(1886, 'AVG', b'0', 2, 472),
	(1887, 'DECODE', b'1', 3, 472),
	(1888, 'COUNT', b'0', 4, 472),
	(1889, 'POSITION', b'0', 1, 473),
	(1890, 'LOCATE', b'0', 2, 473),
	(1891, 'INSTR', b'0', 3, 473),
	(1892, '위의 모든 것', b'1', 4, 473),
	(1893, 'ROUND', b'1', 1, 474),
	(1894, 'CEIL', b'0', 2, 474),
	(1895, 'FLOOR', b'0', 3, 474),
	(1896, 'TRUNC', b'0', 4, 474),
	(1897, 'NOW()', b'0', 1, 475),
	(1898, 'CURRENT_TIMESTAMP', b'0', 2, 475),
	(1899, 'SYSDATE', b'0', 3, 475),
	(1900, '위의 모든 것 (DBMS에 따라 다름)', b'1', 4, 475),
	(1901, 'IF', b'0', 1, 476),
	(1902, 'CASE', b'1', 2, 476),
	(1903, 'SWITCH', b'0', 3, 476),
	(1904, 'CONDITION', b'0', 4, 476),
	(1905, 'SIZE', b'0', 1, 477),
	(1906, 'LEN', b'0', 2, 477),
	(1907, 'LENGTH', b'0', 3, 477),
	(1908, 'b와 c 모두 (DBMS에 따라 다름)', b'1', 4, 477),
	(1909, 'GREATER', b'0', 1, 478),
	(1910, 'MAX', b'0', 2, 478),
	(1911, 'LARGEST', b'0', 3, 478),
	(1912, 'GREATEST', b'1', 4, 478),
	(1913, 'ABS', b'1', 1, 479),
	(1914, 'ABSOLUTE', b'0', 2, 479),
	(1915, 'POS', b'0', 3, 479),
	(1916, 'POSITIVE', b'0', 4, 479),
	(1917, 'EXTRACT', b'0', 1, 480),
	(1918, 'SUBSTRING', b'0', 2, 480),
	(1919, 'SUBSTR', b'0', 3, 480),
	(1920, 'b와 c 모두 (DBMS에 따라 다름)', b'1', 4, 480),
	(1921, 'DATE_ADD', b'0', 1, 481),
	(1922, 'ADD_MONTHS', b'0', 2, 481),
	(1923, 'DATEADD', b'0', 3, 481),
	(1924, '위의 모든 것 (DBMS에 따라 다름)', b'1', 4, 481),
	(1925, 'ROW_NUMBER', b'0', 1, 482),
	(1926, 'RANK', b'0', 2, 482),
	(1927, 'LEAD', b'0', 3, 482),
	(1928, 'ROUND', b'1', 4, 482),
	(1929, '결과를 정렬한다', b'0', 1, 483),
	(1930, '조건에 맞는 행을 선택한다', b'1', 2, 483),
	(1931, '열을 그룹화한다', b'0', 3, 483),
	(1932, '결과의 개수를 제한한다', b'0', 4, 483),
	(1933, '=', b'0', 1, 484),
	(1934, 'LIKE', b'0', 2, 484),
	(1935, 'HAVING', b'1', 3, 484),
	(1936, 'IN', b'0', 4, 484),
	(1937, 'AND', b'0', 1, 485),
	(1938, 'OR', b'0', 2, 485),
	(1939, 'NOT', b'0', 3, 485),
	(1940, 'XOR', b'1', 4, 485),
	(1941, 'WHERE column_name = NULL', b'0', 1, 486),
	(1942, 'WHERE column_name IS NULL', b'1', 2, 486),
	(1943, 'WHERE column_name == NULL', b'0', 3, 486),
	(1944, 'WHERE column_name EQUALS NULL', b'0', 4, 486),
	(1945, 'WITHIN', b'0', 1, 487),
	(1946, 'RANGE', b'0', 2, 487),
	(1947, 'BETWEEN', b'1', 3, 487),
	(1948, 'AMONG', b'0', 4, 487),
	(1949, 'LIKE', b'1', 1, 488),
	(1950, 'SIMILAR', b'0', 2, 488),
	(1951, 'MATCH', b'0', 3, 488),
	(1952, 'EQUALS', b'0', 4, 488),
	(1953, 'ANY', b'0', 1, 489),
	(1954, 'SOME', b'0', 2, 489),
	(1955, 'IN', b'1', 3, 489),
	(1956, 'MATCH', b'0', 4, 489),
	(1957, 'NOT column_name = value', b'0', 1, 490),
	(1958, 'column_name <> value', b'0', 2, 490),
	(1959, 'column_name != value', b'0', 3, 490),
	(1960, 'column_name ISNOT value', b'1', 4, 490),
	(1961, 'IN', b'0', 1, 491),
	(1962, 'ANY', b'0', 2, 491),
	(1963, 'ALL', b'0', 3, 491),
	(1964, '=', b'1', 4, 491),
	(1965, '날짜는 항상 문자열로 처리해야 한다', b'0', 1, 492),
	(1966, '날짜 형식이 데이터베이스 설정과 일치해야 한다', b'1', 2, 492),
	(1967, '날짜 비교는 불가능하다', b'0', 3, 492),
	(1968, '날짜는 항상 숫자로 변환해야 한다', b'0', 4, 492),
	(1969, 'LOWER() 또는 UPPER() 함수를 사용한다', b'1', 1, 493),
	(1970, 'CASE INSENSITIVE 키워드를 사용한다', b'0', 2, 493),
	(1971, 'IGNORE CASE 옵션을 추가한다', b'0', 3, 493),
	(1972, '대소문자 구분 없이 비교는 불가능하다', b'0', 4, 493),
	(1973, 'LIKE', b'0', 1, 494),
	(1974, 'REGEXP 또는 RLIKE', b'1', 2, 494),
	(1975, 'MATCH', b'0', 3, 494),
	(1976, 'SIMILAR TO', b'0', 4, 494),
	(1977, 'WHERE 절에서는 계산된 열에 대한 조건을 지정할 수 없다', b'0', 1, 495),
	(1978, '계산식을 그대로 WHERE 절에 사용한다', b'1', 2, 495),
	(1979, 'HAVING 절을 대신 사용해야 한다', b'0', 3, 495),
	(1980, '서브쿼리를 이용해 계산된 열을 먼저 생성해야 한다', b'0', 4, 495),
	(1981, 'OR와 AND는 함께 사용할 수 없다', b'0', 1, 496),
	(1982, 'AND가 OR보다 우선순위가 높다', b'0', 2, 496),
	(1983, 'OR가 AND보다 우선순위가 높다', b'0', 3, 496),
	(1984, '괄호를 사용하여 우선순위를 명확히 해야 한다', b'1', 4, 496),
	(1985, '데이터를 정렬한다', b'0', 1, 497),
	(1986, '데이터를 필터링한다', b'0', 2, 497),
	(1987, '데이터를 그룹화한다', b'1', 3, 497),
	(1988, '데이터를 조인한다', b'0', 4, 497),
	(1989, '개별 행을 필터링한다', b'0', 1, 498),
	(1990, '그룹화된 결과를 필터링한다', b'1', 2, 498),
	(1991, '결과를 정렬한다', b'0', 3, 498),
	(1992, '그룹을 생성한다', b'0', 4, 498),
	(1993, 'GROUP BY → HAVING', b'1', 1, 499),
	(1994, 'HAVING → GROUP BY', b'0', 2, 499),
	(1995, '동시에 실행된다', b'0', 3, 499),
	(1996, '쿼리에 따라 다르다', b'0', 4, 499),
	(1997, '테이블의 칼럼', b'0', 1, 500),
	(1998, '집계 함수', b'0', 2, 500),
	(1999, '표현식', b'0', 3, 500),
	(2000, '별칭(Alias)', b'1', 4, 500),
	(2001, '집계 함수', b'1', 1, 501),
	(2002, 'WHERE 절', b'0', 2, 501),
	(2003, 'ORDER BY 절', b'0', 3, 501),
	(2004, 'DISTINCT 키워드', b'0', 4, 501),
	(2005, '반드시 GROUP BY 절에 포함시켜야 한다', b'1', 1, 502),
	(2006, 'SELECT 문에서 제외해야 한다', b'0', 2, 502),
	(2007, 'HAVING 절에 포함시켜야 한다', b'0', 3, 502),
	(2008, 'WHERE 절에 조건을 추가해야 한다', b'0', 4, 502),
	(2009, '첫 번째 칼럼만으로 그룹화된다', b'0', 1, 503),
	(2010, '마지막 칼럼만으로 그룹화된다', b'0', 2, 503),
	(2011, '모든 칼럼의 조합으로 그룹화된다', b'1', 3, 503),
	(2012, '그룹화가 불가능하다', b'0', 4, 503),
	(2013, 'HAVING은 그룹화 이전, WHERE은 그룹화 이후에 적용된다', b'0', 1, 504),
	(2014, 'HAVING은 그룹화 결과, WHERE은 개별 행에 대해 조건을 적용한다', b'1', 2, 504),
	(2015, 'HAVING은 집계 함수를 사용할 수 없고, WHERE은 사용할 수 있다', b'0', 3, 504),
	(2016, 'HAVING은 SELECT 문에, WHERE은 INSERT 문에 사용된다', b'0', 4, 504),
	(2017, '무시된다', b'0', 1, 505),
	(2018, '오류가 발생한다', b'0', 2, 505),
	(2019, '별도의 그룹으로 처리된다', b'1', 3, 505),
	(2020, '가장 작은 값으로 취급된다', b'0', 4, 505),
	(2021, 'COUNT', b'0', 1, 506),
	(2022, 'SUM', b'0', 2, 506),
	(2023, 'SUBSTR', b'1', 3, 506),
	(2024, 'AVG', b'0', 4, 506),
	(2025, '불가능하다', b'0', 1, 507),
	(2026, '가능하지만 의미가 없다', b'0', 2, 507),
	(2027, '가능하며, 전체 집합을 하나의 그룹으로 취급한다', b'1', 3, 507),
	(2028, 'DBMS에 따라 다르다', b'0', 4, 507),
	(2029, '그룹화 결과를 정렬한다', b'0', 1, 508),
	(2030, '부분 합계를 생성한다', b'1', 2, 508),
	(2031, '중복된 그룹을 제거한다', b'0', 3, 508),
	(2032, '그룹화 결과를 필터링한다', b'0', 4, 508),
	(2033, '불가능하다', b'0', 1, 509),
	(2034, '가능하다', b'1', 2, 509),
	(2035, 'DBMS에 따라 다르다', b'0', 3, 509),
	(2036, 'GROUP BY 절에서만 가능하다', b'0', 4, 509),
	(2037, '인덱스 사용', b'0', 1, 510),
	(2038, '불필요한 칼럼 제거', b'0', 2, 510),
	(2039, 'GROUP BY 절 제거', b'1', 3, 510),
	(2040, '데이터 분할 처리', b'0', 4, 510),
	(2041, '데이터를 필터링한다', b'0', 1, 511),
	(2042, '데이터를 그룹화한다', b'0', 2, 511),
	(2043, '결과를 정렬한다', b'1', 3, 511),
	(2044, '데이터를 집계한다', b'0', 4, 511),
	(2045, '오름차순 (ASC)', b'1', 1, 512),
	(2046, '내림차순 (DESC)', b'0', 2, 512),
	(2047, '랜덤', b'0', 3, 512),
	(2048, '입력 순서', b'0', 4, 512),
	(2049, '무작위로 결정된다', b'0', 1, 513),
	(2050, 'ORDER BY 절에 나열된 순서대로', b'1', 2, 513),
	(2051, '알파벳 순서로', b'0', 3, 513),
	(2052, '테이블에 정의된 열 순서대로', b'0', 4, 513),
	(2053, '항상 첫 번째로 정렬된다', b'0', 1, 514),
	(2054, '항상 마지막으로 정렬된다', b'0', 2, 514),
	(2055, '오름차순에서는 처음, 내림차순에서는 마지막', b'0', 3, 514),
	(2056, 'DBMS에 따라 다르다', b'1', 4, 514),
	(2057, '불가능하다', b'0', 1, 515),
	(2058, '가능하다', b'1', 2, 515),
	(2059, 'SELECT 문에서 정의한 경우에만 가능하다', b'0', 3, 515),
	(2060, 'DBMS에 따라 다르다', b'0', 4, 515),
	(2061, '칼럼 이름', b'0', 1, 516),
	(2062, '표현식', b'0', 2, 516),
	(2063, '별칭', b'0', 3, 516),
	(2064, 'WHERE 절', b'1', 4, 516),
	(2065, '정렬 우선순위', b'0', 1, 517),
	(2066, 'SELECT 문의 칼럼 위치', b'1', 2, 517),
	(2067, '최대 정렬 개수', b'0', 3, 517),
	(2068, '의미 없음', b'0', 4, 517),
	(2069, 'ORDER BY UPPERCASE(column)', b'0', 1, 518),
	(2070, 'ORDER BY LOWER(column)', b'1', 2, 518),
	(2071, 'ORDER BY CASE_INSENSITIVE(column)', b'0', 3, 518),
	(2072, 'ORDER BY IGNORE CASE column', b'0', 4, 518),
	(2073, '항상 오류가 발생한다', b'0', 1, 519),
	(2074, '정렬 속도가 느려질 수 있다', b'1', 2, 519),
	(2075, '정렬 결과에 영향을 주지 않는다', b'0', 3, 519),
	(2076, '함수는 사용할 수 없다', b'0', 4, 519),
	(2077, '가장 먼저 실행된다', b'0', 1, 520),
	(2078, 'WHERE 절 다음에 실행된다', b'0', 2, 520),
	(2079, 'GROUP BY 절 다음에 실행된다', b'0', 3, 520),
	(2080, '가장 마지막에 실행된다', b'1', 4, 520),
	(2081, '불가능하다', b'0', 1, 521),
	(2082, '가능하다', b'1', 2, 521),
	(2083, 'DBMS에 따라 다르다', b'0', 3, 521),
	(2084, '오직 상관 서브쿼리만 가능하다', b'0', 4, 521),
	(2085, 'NULL 값을 제외하고 정렬한다', b'0', 1, 522),
	(2086, 'NULL 값의 정렬 위치를 지정한다', b'1', 2, 522),
	(2087, 'NULL 값을 가진 행만 정렬한다', b'0', 3, 522),
	(2088, 'NULL 값을 다른 값으로 변환한다', b'0', 4, 522),
	(2089, '항상 인덱스를 사용하기 때문에', b'0', 1, 523),
	(2090, '대용량 데이터를 정렬할 때 메모리 사용량이 증가할 수 있어서', b'1', 2, 523),
	(2091, '정렬은 항상 빠르기 때문에 성능 문제가 발생하지 않는다', b'0', 3, 523),
	(2092, 'ORDER BY 절은 병렬 처리를 지원하지 않아서', b'0', 4, 523),
	(2093, '조건부 정렬을 수행하기 위해', b'1', 1, 524),
	(2094, '정렬 방향을 동적으로 변경하기 위해', b'0', 2, 524),
	(2095, 'NULL 값을 처리하기 위해', b'0', 3, 524),
	(2096, '정렬 속도를 향상시키기 위해', b'0', 4, 524),
	(2097, '데이터를 정렬한다', b'0', 1, 525),
	(2098, '여러 테이블의 데이터를 결합한다', b'1', 2, 525),
	(2099, '데이터를 그룹화한다', b'0', 3, 525),
	(2100, '데이터를 필터링한다', b'0', 4, 525),
	(2101, '두 테이블의 모든 데이터를 반환한다', b'0', 1, 526),
	(2102, '조인 조건을 만족하는 데이터만 반환한다', b'1', 2, 526),
	(2103, '왼쪽 테이블의 모든 데이터를 반환한다', b'0', 3, 526),
	(2104, '오른쪽 테이블의 모든 데이터를 반환한다', b'0', 4, 526),
	(2105, '오른쪽 테이블의 모든 행', b'0', 1, 527),
	(2106, '왼쪽 테이블의 모든 행', b'1', 2, 527),
	(2107, '두 테이블의 공통된 데이터만', b'0', 3, 527),
	(2108, '조인 조건을 만족하지 않는 데이터만', b'0', 4, 527),
	(2109, '내부 조인과 동일한 결과를 반환한다', b'0', 1, 528),
	(2110, '왼쪽 테이블의 모든 행만 반환한다', b'0', 2, 528),
	(2111, '오른쪽 테이블의 모든 행만 반환한다', b'0', 3, 528),
	(2112, '양쪽 테이블의 모든 행을 반환하며, 매치되지 않는 행은 NULL로 채운다', b'1', 4, 528),
	(2113, '동일한 테이블을 두 번 이상 조인하는 것', b'1', 1, 529),
	(2114, '서로 다른 두 테이블을 조인하는 것', b'0', 2, 529),
	(2115, '조인 없이 단일 테이블을 조회하는 것', b'0', 3, 529),
	(2116, '세 개 이상의 테이블을 조인하는 것', b'0', 4, 529),
	(2117, 'WHERE A.id = B.id', b'0', 1, 530),
	(2118, 'ON A.price BETWEEN B.min_price AND B.max_price', b'1', 2, 530),
	(2119, 'USING (department_id)', b'0', 3, 530),
	(2120, 'NATURAL JOIN', b'0', 4, 530),
	(2121, '동일한 이름을 가진 모든 열을 기준으로 자동으로 조인한다', b'1', 1, 531),
	(2122, '조인 조건을 명시적으로 지정할 필요가 없다', b'0', 2, 531),
	(2123, '항상 내부 조인으로 동작한다', b'0', 3, 531),
	(2124, '조인 결과에 중복 열이 생길 수 있다', b'0', 4, 531),
	(2125, '두 테이블의 공통된 행만 반환한다', b'0', 1, 532),
	(2126, '첫 번째 테이블의 모든 행과 두 번째 테이블의 모든 행을 조합한다 (카테시안 곱)', b'1', 2, 532),
	(2127, '조인 조건을 만족하는 행만 반환한다', b'0', 3, 532),
	(2128, '항상 빈 결과 집합을 반환한다', b'0', 4, 532),
	(2129, '적절한 인덱스 사용', b'0', 1, 533),
	(2130, '가능한 한 많은 테이블을 조인', b'1', 2, 533),
	(2131, '조인 조건 최적화', b'0', 3, 533),
	(2132, '데이터 분산도가 좋은 열을 조인 키로 선택', b'0', 4, 533),
	(2133, '항상 FULL OUTER JOIN을 사용해야 한다', b'0', 1, 534),
	(2134, '조인 순서가 결과에 영향을 미칠 수 있다', b'1', 2, 534),
	(2135, '세 개 이상의 테이블은 조인할 수 없다', b'0', 3, 534),
	(2136, '반드시 서브쿼리를 사용해야 한다', b'0', 4, 534),
	(2137, '조인 칼럼의 이름이 다를 때 사용한다', b'0', 1, 535),
	(2138, '조인 칼럼의 이름이 같을 때 사용할 수 있다', b'1', 2, 535),
	(2139, '외부 조인에서만 사용할 수 있다', b'0', 3, 535),
	(2140, '세 개 이상의 테이블을 조인할 때만 사용한다', b'0', 4, 535),
	(2141, 'INNER JOIN', b'0', 1, 536),
	(2142, 'LEFT OUTER JOIN', b'0', 2, 536),
	(2143, 'CROSS JOIN', b'1', 3, 536),
	(2144, 'RIGHT OUTER JOIN', b'0', 4, 536),
	(2145, '두 테이블의 공통된 데이터를 찾는 것', b'0', 1, 537),
	(2146, '첫 번째 테이블에는 있지만 두 번째 테이블에는 없는 데이터를 찾는 것', b'1', 2, 537),
	(2147, '두 테이블의 모든 데이터를 결합하는 것', b'0', 3, 537),
	(2148, '두 테이블의 데이터를 무작위로 섞는 것', b'0', 4, 537),
	(2149, 'NULL 값은 항상 조인에서 제외된다', b'0', 1, 538),
	(2150, '내부 조인에서 NULL 값은 결과에 포함되지 않는다', b'0', 2, 538),
	(2151, '외부 조인에서 NULL 값은 항상 결과에 포함된다', b'0', 3, 538),
	(2152, 'NULL 값의 처리는 조인 유형과 조건에 따라 다르다', b'1', 4, 538),
	(2153, 'WHERE 절을 이용한 조인', b'0', 1, 539),
	(2154, 'FROM 절의 INNER JOIN, OUTER JOIN 등', b'1', 2, 539),
	(2155, 'CONNECT BY를 이용한 조인', b'0', 3, 539),
	(2156, 'MERGE 문을 이용한 조인', b'0', 4, 539),
	(2157, 'FROM table1, table2 WHERE table1.col = table2.col', b'0', 1, 540),
	(2158, 'FROM table1 INNER JOIN table2 ON table1.col = table2.col', b'1', 2, 540),
	(2159, 'FROM table1 JOIN table2 WHERE table1.col = table2.col', b'0', 3, 540),
	(2160, 'FROM table1 INNER table2 ON table1.col = table2.col', b'0', 4, 540),
	(2161, 'ON 절은 조인 조건을, WHERE 절은 필터 조건을 명시한다', b'1', 1, 541),
	(2162, 'ON 절은 내부 조인에만, WHERE 절은 외부 조인에만 사용한다', b'0', 2, 541),
	(2163, 'ON 절은 성능이 더 좋고, WHERE 절은 가독성이 더 좋다', b'0', 3, 541),
	(2164, 'ON 절과 WHERE 절은 완전히 동일한 기능을 한다', b'0', 4, 541),
	(2165, '동일한 이름을 가진 모든 열을 자동으로 조인한다', b'0', 1, 542),
	(2166, 'ON 절이나 USING 절을 사용할 필요가 없다', b'0', 2, 542),
	(2167, '항상 내부 조인으로 동작한다', b'0', 3, 542),
	(2168, '조인 결과에 중복 열이 포함된다', b'1', 4, 542),
	(2169, '조인 칼럼의 이름이 다를 때 사용한다', b'0', 1, 543),
	(2170, '조인 칼럼의 이름이 같을 때 사용할 수 있다', b'1', 2, 543),
	(2171, '외부 조인에서만 사용할 수 있다', b'0', 3, 543),
	(2172, '조인 결과에 지정된 칼럼이 두 번 나타난다', b'0', 4, 543),
	(2173, 'FROM table1, table2 WHERE table1.col = table2.col(+)', b'0', 1, 544),
	(2174, 'FROM table1 LEFT OUTER JOIN table2 ON table1.col = table2.col', b'1', 2, 544),
	(2175, 'FROM table1 LEFT JOIN table2 WHERE table1.col = table2.col', b'0', 3, 544),
	(2176, 'FROM table1 OUTER JOIN table2 ON table1.col = table2.col', b'0', 4, 544),
	(2177, 'INNER JOIN 만으로 구현한다', b'0', 1, 545),
	(2178, 'LEFT OUTER JOIN과 RIGHT OUTER JOIN의 UNION을 사용한다', b'1', 2, 545),
	(2179, 'CROSS JOIN을 사용한다', b'0', 3, 545),
	(2180, 'FULL OUTER JOIN은 대체 불가능하다', b'0', 4, 545),
	(2181, '두 테이블의 곱집합(Cartesian Product)을 반환한다', b'1', 1, 546),
	(2182, 'ON 절이 반드시 필요하다', b'0', 2, 546),
	(2183, '내부 조인의 다른 이름이다', b'0', 3, 546),
	(2184, '항상 빈 결과 집합을 반환한다', b'0', 4, 546),
	(2185, '동일한 테이블을 두 번 이상 조인하는 것', b'1', 1, 547),
	(2186, '서로 다른 두 테이블을 조인하는 것', b'0', 2, 547),
	(2187, '조인 없이 단일 테이블을 조회하는 것', b'0', 3, 547),
	(2188, '표준 SQL에서는 지원하지 않는 조인 방식이다', b'0', 4, 547),
	(2189, 'WHERE 절에서 != 연산자를 사용한다', b'0', 1, 548),
	(2190, 'ON 절에서 범위 조건 등을 사용한다', b'1', 2, 548),
	(2191, 'NATURAL JOIN을 사용한다', b'0', 3, 548),
	(2192, '표준 SQL에서는 비등가 조인을 지원하지 않는다', b'0', 4, 548),
	(2193, '가능하다', b'0', 1, 549),
	(2194, '불가능하다', b'1', 2, 549),
	(2195, 'DBMS에 따라 다르다', b'0', 3, 549),
	(2196, '내부 조인에서만 가능하다', b'0', 4, 549),
	(2197, 'INNER JOIN', b'0', 1, 550),
	(2198, 'LEFT OUTER JOIN', b'0', 2, 550),
	(2199, 'FULL OUTER JOIN', b'0', 3, 550),
	(2200, 'CONNECT BY', b'1', 4, 550),
	(2201, 'NATURAL JOIN은 모든 공통 열을 사용하고, USING은 특정 열만 지정할 수 있다', b'1', 1, 551),
	(2202, 'NATURAL JOIN은 내부 조인만 가능하고, USING은 외부 조인도 가능하다', b'0', 2, 551),
	(2203, 'NATURAL JOIN은 성능이 더 좋고, USING은 가독성이 더 좋다', b'0', 3, 551),
	(2204, '차이가 없으며 완전히 동일한 결과를 생성한다', b'0', 4, 551),
	(2205, '두 개의 테이블만 조인 가능하며, 그 이상은 서브쿼리를 사용해야 한다', b'0', 1, 552),
	(2206, 'FROM 절에 쉼표로 구분하여 모든 테이블을 나열한다', b'0', 2, 552),
	(2207, '여러 개의 JOIN 키워드를 연속해서 사용한다', b'1', 3, 552),
	(2208, 'MULTI JOIN 키워드를 사용한다', b'0', 4, 552),
	(2209, '두 개의 테이블을 연결하는 쿼리', b'0', 1, 553),
	(2210, '메인 쿼리 내에 포함된 또 다른 쿼리', b'1', 2, 553),
	(2211, '데이터를 그룹화하는 쿼리', b'0', 3, 553),
	(2212, '데이터를 정렬하는 쿼리', b'0', 4, 553),
	(2213, 'SELECT 절', b'0', 1, 554),
	(2214, 'FROM 절', b'0', 2, 554),
	(2215, 'WHERE 절', b'0', 3, 554),
	(2216, 'CREATE TABLE 문', b'1', 4, 554),
	(2217, 'IN', b'0', 1, 555),
	(2218, 'ANY', b'0', 2, 555),
	(2219, 'ALL', b'0', 3, 555),
	(2220, '=', b'1', 4, 555),
	(2221, 'IN', b'0', 1, 556),
	(2222, 'ANY', b'0', 2, 556),
	(2223, 'ALL', b'0', 3, 556),
	(2224, '=', b'1', 4, 556),
	(2225, '메인 쿼리의 칼럼을 참조하지 않는다', b'0', 1, 557),
	(2226, '메인 쿼리에서 실행된 후 결과를 반환한다', b'0', 2, 557),
	(2227, '메인 쿼리의 각 행마다 서브 쿼리가 실행된다', b'1', 3, 557),
	(2228, '항상 다중 행 결과를 반환한다', b'0', 4, 557),
	(2229, 'FROM 절에 사용된 서브 쿼리', b'1', 1, 558),
	(2230, 'WHERE 절에 사용된 서브 쿼리', b'0', 2, 558),
	(2231, 'SELECT 절에 사용된 서브 쿼리', b'0', 3, 558),
	(2232, 'HAVING 절에 사용된 서브 쿼리', b'0', 4, 558),
	(2233, '항상 다중 행을 반환한다', b'0', 1, 559),
	(2234, 'SELECT 절에서만 사용할 수 있다', b'0', 2, 559),
	(2235, '단일 값을 반환한다', b'1', 3, 559),
	(2236, '메인 쿼리의 칼럼을 참조할 수 없다', b'0', 4, 559),
	(2237, '가능한 한 상관 서브 쿼리 사용을 피한다', b'0', 1, 560),
	(2238, '서브 쿼리 대신 조인을 사용할 수 있는지 검토한다', b'0', 2, 560),
	(2239, '서브 쿼리에 인덱스를 활용한다', b'0', 3, 560),
	(2240, '모든 쿼리를 서브 쿼리로 변환한다', b'1', 4, 560),
	(2241, '서브 쿼리의 결과가 존재하는지 여부만 확인한다', b'1', 1, 561),
	(2242, '서브 쿼리의 모든 결과를 반환한다', b'0', 2, 561),
	(2243, '항상 다중 행을 반환한다', b'0', 3, 561),
	(2244, '메인 쿼리의 칼럼을 참조할 수 없다', b'0', 4, 561),
	(2245, '복잡한 쿼리를 작성할 수 있다', b'0', 1, 562),
	(2246, '쿼리의 가독성을 높일 수 있다', b'0', 2, 562),
	(2247, '항상 쿼리의 성능을 향상시킨다', b'1', 3, 562),
	(2248, '동적으로 조건을 생성할 수 있다', b'0', 4, 562),
	(2249, 'SELECT 절', b'0', 1, 563),
	(2250, 'WHERE 절', b'0', 2, 563),
	(2251, 'FROM 절', b'1', 3, 563),
	(2252, 'HAVING 절', b'0', 4, 563),
	(2253, '서브 쿼리 안에 또 다른 서브 쿼리가 포함되어 있다', b'1', 1, 564),
	(2254, 'FROM 절에서만 사용할 수 있다', b'0', 2, 564),
	(2255, '항상 단일 행을 반환한다', b'0', 3, 564),
	(2256, '메인 쿼리와 독립적으로 실행된다', b'0', 4, 564),
	(2257, '모든 서브 쿼리에서 사용 가능하다', b'0', 1, 565),
	(2258, 'TOP-N 쿼리와 함께 사용할 때만 가능하다', b'0', 2, 565),
	(2259, '인라인 뷰에서만 사용 가능하다', b'1', 3, 565),
	(2260, '서브 쿼리에서는 ORDER BY를 사용할 수 없다', b'0', 4, 565),
	(2261, '항상 서브 쿼리가 조인보다 성능이 좋다', b'0', 1, 566),
	(2262, '항상 조인이 서브 쿼리보다 성능이 좋다', b'0', 2, 566),
	(2263, '데이터의 특성과 쿼리의 목적에 따라 선택해야 한다', b'1', 3, 566),
	(2264, 'DBMS의 종류에 따라 무조건 하나를 선택해야 한다', b'0', 4, 566),
	(2265, 'UNION', b'0', 1, 567),
	(2266, 'INTERSECT', b'0', 2, 567),
	(2267, 'MINUS', b'0', 3, 567),
	(2268, 'JOIN', b'1', 4, 567),
	(2269, '두 쿼리 결과의 합집합을 반환하며, 중복을 제거한다', b'1', 1, 568),
	(2270, '두 쿼리 결과의 교집합을 반환한다', b'0', 2, 568),
	(2271, '첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 뺀 차집합을 반환한다', b'0', 3, 568),
	(2272, '두 쿼리 결과를 단순히 연결한다', b'0', 4, 568),
	(2273, '중복을 제거한다', b'0', 1, 569),
	(2274, '중복을 허용한다', b'1', 2, 569),
	(2275, '자동으로 결과를 정렬한다', b'0', 3, 569),
	(2276, '두 쿼리의 교집합만 반환한다', b'0', 4, 569),
	(2277, '두 쿼리 결과의 합집합을 반환한다', b'0', 1, 570),
	(2278, '두 쿼리 결과의 교집합을 반환한다', b'1', 2, 570),
	(2279, '첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 뺀 차집합을 반환한다', b'0', 3, 570),
	(2280, '두 쿼리 결과를 단순히 연결한다', b'0', 4, 570),
	(2281, 'SUBTRACT', b'0', 1, 571),
	(2282, 'EXCEPT', b'1', 2, 571),
	(2283, 'DIFFERENCE', b'0', 3, 571),
	(2284, 'SQL Server는 이와 동등한 연산자를 제공하지 않는다', b'0', 4, 571),
	(2285, '연산 대상이 되는 쿼리들의 SELECT 절의 칼럼 개수가 동일해야 한다', b'1', 1, 572),
	(2286, '연산 대상이 되는 쿼리들의 테이블이 같아야 한다', b'0', 2, 572),
	(2287, '집합 연산자는 항상 OUTER JOIN보다 성능이 좋다', b'0', 3, 572),
	(2288, '집합 연산자는 서브쿼리 내에서만 사용할 수 있다', b'0', 4, 572),
	(2289, '각 개별 쿼리에 ORDER BY를 사용해야 한다', b'0', 1, 573),
	(2290, '맨 마지막 쿼리에만 ORDER BY를 사용할 수 있다', b'1', 2, 573),
	(2291, '집합 연산자와 ORDER BY는 함께 사용할 수 없다', b'0', 3, 573),
	(2292, '모든 개별 쿼리에 동일한 ORDER BY를 사용해야 한다', b'0', 4, 573),
	(2293, 'UNION은 중복을 제거하고, UNION ALL은 중복을 허용한다', b'1', 1, 574),
	(2294, 'UNION은 자동 정렬을 하고, UNION ALL은 정렬하지 않는다', b'0', 2, 574),
	(2295, 'UNION은 교집합을 반환하고, UNION ALL은 합집합을 반환한다', b'0', 3, 574),
	(2296, 'UNION은 OUTER JOIN과 같고, UNION ALL은 INNER JOIN과 같다', b'0', 4, 574),
	(2297, 'UNION이 UNION ALL보다 항상 빠르다', b'0', 1, 575),
	(2298, 'INTERSECT가 UNION보다 항상 빠르다', b'0', 2, 575),
	(2299, 'UNION ALL이 UNION보다 일반적으로 빠르다', b'1', 3, 575),
	(2300, '모든 집합 연산자의 성능은 동일하다', b'0', 4, 575),
	(2301, '모든 칼럼의 데이터 타입이 완전히 동일해야 한다', b'0', 1, 576),
	(2302, '대응되는 칼럼의 데이터 타입이 반드시 같을 필요는 없지만 호환 가능해야 한다', b'1', 2, 576),
	(2303, '데이터 타입은 전혀 고려할 필요가 없다', b'0', 3, 576),
	(2304, '숫자형과 문자형만 사용할 수 있다', b'0', 4, 576),
	(2305, '두 쿼리 결과의 합집합을 반환한다', b'0', 1, 577),
	(2306, '두 쿼리 결과의 교집합을 반환한다', b'0', 2, 577),
	(2307, '첫 번째 쿼리 결과에서 두 번째 쿼리 결과를 뺀 차집합을 반환한다', b'1', 3, 577),
	(2308, '연산 순서가 바뀌어도 결과는 동일하다', b'0', 4, 577),
	(2309, '모든 개별 쿼리에 ALIAS를 지정해야 한다', b'0', 1, 578),
	(2310, '첫 번째 쿼리의 ALIAS만 사용된다', b'1', 2, 578),
	(2311, '마지막 쿼리의 ALIAS만 사용된다', b'0', 3, 578),
	(2312, '집합 연산자를 사용할 때는 ALIAS를 사용할 수 없다', b'0', 4, 578),
	(2313, '왼쪽에서 오른쪽으로 순차적으로 실행된다', b'1', 1, 579),
	(2314, '오른쪽에서 왼쪽으로 순차적으로 실행된다', b'0', 2, 579),
	(2315, 'UNION, INTERSECT, MINUS 순서로 실행된다', b'0', 3, 579),
	(2316, '괄호로 우선순위를 지정하지 않으면 에러가 발생한다', b'0', 4, 579),
	(2317, 'NULL 값은 모든 집합 연산에서 무시된다', b'0', 1, 580),
	(2318, 'NULL 값은 다른 NULL 값과 동일한 것으로 간주된다', b'0', 2, 580),
	(2319, 'NULL 값이 포함된 행은 집합 연산에서 제외된다', b'0', 3, 580),
	(2320, 'NULL 값 처리는 DBMS와 연산자에 따라 다를 수 있다', b'1', 4, 580),
	(2321, 'SUM', b'0', 1, 581),
	(2322, 'AVG', b'0', 2, 581),
	(2323, 'SUBSTR', b'1', 3, 581),
	(2324, 'COUNT', b'0', 4, 581),
	(2325, 'COUNT(*)는 NULL을 포함한 모든 행의 수를 계산한다', b'0', 1, 582),
	(2326, 'COUNT(column)은 해당 열의 NULL이 아닌 값의 수를 계산한다', b'0', 2, 582),
	(2327, 'COUNT(DISTINCT column)은 해당 열의 중복을 제거한 고유한 값의 수를 계산한다', b'0', 3, 582),
	(2328, 'COUNT()는 항상 NULL을 반환한다', b'1', 4, 582),
	(2329, 'AVG', b'0', 1, 583),
	(2330, 'SUM', b'0', 2, 583),
	(2331, 'COUNT(*)', b'1', 3, 583),
	(2332, 'MAX', b'0', 4, 583),
	(2333, 'SELECT 절에는 그룹 함수만 사용할 수 있다', b'0', 1, 584),
	(2334, 'GROUP BY 절에 지정된 열은 반드시 SELECT 절에 포함되어야 한다', b'0', 2, 584),
	(2335, 'GROUP BY 절에 지정되지 않은 열이라도 SELECT 절에 사용할 수 있다', b'1', 3, 584),
	(2336, 'GROUP BY 절에는 별칭(Alias)을 사용할 수 없다', b'0', 4, 584),
	(2337, '개별 행을 필터링한다', b'0', 1, 585),
	(2338, '그룹화된 결과에 조건을 적용한다', b'1', 2, 585),
	(2339, '결과를 정렬한다', b'0', 3, 585),
	(2340, '조인 조건을 지정한다', b'0', 4, 585),
	(2341, 'SUM(AVG(column))', b'0', 1, 586),
	(2342, 'AVG(COUNT(column))', b'0', 2, 586),
	(2343, 'MAX(MIN(column))', b'0', 3, 586),
	(2344, '그룹 함수는 중첩해서 사용할 수 없다', b'1', 4, 586),
	(2345, '데이터 정렬', b'0', 1, 587),
	(2346, '소계와 총계를 계산', b'1', 2, 587),
	(2347, '행과 열을 전환', b'0', 3, 587),
	(2348, '중복 제거', b'0', 4, 587),
	(2349, 'CUBE는 다차원 소계를 생성하고, ROLLUP은 계층적 소계를 생성한다', b'1', 1, 588),
	(2350, 'CUBE는 항상 ROLLUP보다 적은 결과를 생성한다', b'0', 2, 588),
	(2351, 'ROLLUP은 다차원 소계를 생성하고, CUBE는 계층적 소계를 생성한다', b'0', 3, 588),
	(2352, 'CUBE와 ROLLUP은 완전히 동일한 결과를 생성한다', b'0', 4, 588),
	(2353, '여러 개의 GROUP BY 쿼리를 UNION ALL로 수행한 결과와 동일한 결과 생성', b'1', 1, 589),
	(2354, '그룹화된 결과를 자동으로 정렬', b'0', 2, 589),
	(2355, 'NULL 값을 자동으로 제외', b'0', 3, 589),
	(2356, '그룹화 결과에 대한 필터링', b'0', 4, 589),
	(2357, 'SUM', b'0', 1, 590),
	(2358, 'AVG', b'0', 2, 590),
	(2359, 'COUNT', b'1', 3, 590),
	(2360, '모든 그룹 함수', b'0', 4, 590),
	(2361, '모든 그룹 함수는 NULL 값을 무시한다', b'0', 1, 591),
	(2362, 'SUM, AVG는 NULL 값을 0으로 처리한다', b'0', 2, 591),
	(2363, 'COUNT(*)는 NULL 값을 포함하여 계산한다', b'1', 3, 591),
	(2364, '모든 그룹 함수는 NULL 값을 포함하여 계산한다', b'0', 4, 591),
	(2365, '그룹별 최대값 계산', b'0', 1, 592),
	(2366, '그룹별 행 수 계산', b'0', 2, 592),
	(2367, '그룹별로 데이터를 연결하여 하나의 열로 표시', b'1', 3, 592),
	(2368, '그룹별 중복 제거', b'0', 4, 592),
	(2369, '오류가 발생한다', b'0', 1, 593),
	(2370, '전체 데이터에 대한 하나의 결과만 반환된다', b'1', 2, 593),
	(2371, '각 행에 대한 결과가 반환된다', b'0', 3, 593),
	(2372, '무작위로 선택된 행에 대한 결과가 반환된다', b'0', 4, 593),
	(2373, '적절한 인덱스 사용', b'0', 1, 594),
	(2374, '불필요한 열은 GROUP BY에서 제외', b'0', 2, 594),
	(2375, '가능한 한 많은 열을 GROUP BY에 포함', b'1', 3, 594),
	(2376, '필요한 경우 HAVING 대신 WHERE 절 사용', b'0', 4, 594),
	(2377, '함수명() OVER (PARTITION BY 열 ORDER BY 열)', b'1', 1, 595),
	(2378, '함수명() (PARTITION BY 열 ORDER BY 열) OVER', b'0', 2, 595),
	(2379, 'OVER (PARTITION BY 열 ORDER BY 열) 함수명()', b'0', 3, 595),
	(2380, '(PARTITION BY 열 ORDER BY 열) 함수명() OVER', b'0', 4, 595),
	(2381, 'RANK()', b'0', 1, 596),
	(2382, 'DENSE_RANK()', b'0', 2, 596),
	(2383, 'ROW_NUMBER()', b'0', 3, 596),
	(2384, 'CONCAT()', b'1', 4, 596),
	(2385, '결과를 정렬한다', b'0', 1, 597),
	(2386, '윈도우를 그룹화한다', b'1', 2, 597),
	(2387, '중복을 제거한다', b'0', 3, 597),
	(2388, '조인 조건을 지정한다', b'0', 4, 597),
	(2389, 'ROW_NUMBER()는 중복 값에 대해 다른 번호를 부여하고, RANK()는 같은 순위를 부여한다', b'1', 1, 598),
	(2390, 'ROW_NUMBER()는 같은 순위를 부여하고, RANK()는 중복 값에 대해 다른 번호를 부여한다', b'0', 2, 598),
	(2391, 'ROW_NUMBER()는 내림차순으로, RANK()는 오름차순으로 번호를 부여한다', b'0', 3, 598),
	(2392, '차이가 없으며 동일한 결과를 반환한다', b'0', 4, 598),
	(2393, '현재 행을 기준으로 이전 행의 값을 참조한다', b'0', 1, 599),
	(2394, '현재 행을 기준으로 다음 행의 값을 참조한다', b'1', 2, 599),
	(2395, '파티션 내의 첫 번째 값을 반환한다', b'0', 3, 599),
	(2396, '파티션 내의 마지막 값을 반환한다', b'0', 4, 599),
	(2397, 'ROWS', b'0', 1, 600),
	(2398, 'RANGE', b'0', 2, 600),
	(2399, 'COLUMNS', b'1', 3, 600),
	(2400, 'UNBOUNDED PRECEDING', b'0', 4, 600),
	(2401, '윈도우의 첫 번째 행 값을 반환한다', b'1', 1, 601),
	(2402, '윈도우의 마지막 행 값을 반환한다', b'0', 2, 601),
	(2403, '윈도우 내 모든 값의 평균을 계산한다', b'0', 3, 601),
	(2404, '윈도우 내 행의 수를 계산한다', b'0', 4, 601),
	(2405, '윈도우 함수는 중복을 제거하고, GROUP BY는 중복을 허용한다', b'0', 1, 602),
	(2406, '윈도우 함수는 행 수를 줄이지 않고 계산을 수행하며, GROUP BY는 행 수를 줄인다', b'1', 2, 602),
	(2407, '윈도우 함수는 정렬만 가능하고, GROUP BY는 집계만 가능하다', b'0', 3, 602),
	(2408, '윈도우 함수는 서브쿼리에서만 사용 가능하고, GROUP BY는 메인 쿼리에서만 사용 가능하다', b'0', 4, 602),
	(2409, '데이터를 지정된 수의 그룹으로 나눈다', b'1', 1, 603),
	(2410, 'n번째 행의 값을 반환한다', b'0', 2, 603),
	(2411, '현재 행에서 n번째 이전 행의 값을 반환한다', b'0', 3, 603),
	(2412, '윈도우 내의 행 수를 계산한다', b'0', 4, 603),
	(2413, 'SUM()', b'0', 1, 604),
	(2414, 'AVG()', b'0', 2, 604),
	(2415, 'COUNT()', b'0', 3, 604),
	(2416, 'SUBSTR()', b'1', 4, 604),
	(2417, '0 초과 1 이하', b'1', 1, 605),
	(2418, '0 이상 1 미만', b'0', 2, 605),
	(2419, '1 이상의 정수', b'0', 3, 605),
	(2420, '0 이하의 음수', b'0', 4, 605),
	(2421, 'ROWS는 물리적 행 기준, RANGE는 논리적 값 기준으로 행을 지정한다', b'1', 1, 606),
	(2422, 'ROWS는 숫자 데이터에만 사용 가능하고, RANGE는 문자 데이터에만 사용 가능하다', b'0', 2, 606),
	(2423, 'ROWS는 오름차순 정렬에만 사용 가능하고, RANGE는 내림차순 정렬에만 사용 가능하다', b'0', 3, 606),
	(2424, 'ROWS와 RANGE는 완전히 동일한 기능을 한다', b'0', 4, 606),
	(2425, '현재 행과 이전 행, 다음 행의 값을 한 번에 비교하기 위해', b'1', 1, 607),
	(2426, '윈도우의 크기를 동적으로 조절하기 위해', b'0', 2, 607),
	(2427, '집계 함수의 결과를 수정하기 위해', b'0', 3, 607),
	(2428, '중복된 행을 제거하기 위해', b'0', 4, 607),
	(2429, '적절한 인덱스 사용', b'0', 1, 608),
	(2430, 'PARTITION BY 절을 최대한 활용', b'0', 2, 608),
	(2431, '불필요한 ORDER BY 절 제거', b'0', 3, 608),
	(2432, '모든 쿼리에 윈도우 함수 적용', b'1', 4, 608),
	(2433, 'LIMIT 절 사용', b'0', 1, 609),
	(2434, 'TOP 절 사용', b'0', 2, 609),
	(2435, 'ROWNUM 사용', b'1', 3, 609),
	(2436, 'FIRST 절 사용', b'0', 4, 609),
	(2437, 'LIMIT 절 사용', b'0', 1, 610),
	(2438, 'TOP 절 사용', b'1', 2, 610),
	(2439, 'ROWNUM 사용', b'0', 3, 610),
	(2440, 'FIRST 절 사용', b'0', 4, 610),
	(2441, 'LIMIT 절 사용', b'1', 1, 611),
	(2442, 'TOP 절 사용', b'0', 2, 611),
	(2443, 'ROWNUM 사용', b'0', 3, 611),
	(2444, 'FIRST 절 사용', b'0', 4, 611),
	(2445, '베스트셀러 목록 추출', b'0', 1, 612),
	(2446, '성적 상위 학생 목록 추출', b'0', 2, 612),
	(2447, '모든 데이터의 평균 계산', b'1', 3, 612),
	(2448, '최근 등록된 게시물 목록 추출', b'0', 4, 612),
	(2449, 'ORDER BY 절과 함께 사용할 때 서브쿼리가 필요할 수 있다', b'1', 1, 613),
	(2450, 'ROWNUM은 항상 1부터 시작한다', b'0', 2, 613),
	(2451, 'ROWNUM은 자동으로 결과를 정렬한다', b'0', 3, 613),
	(2452, 'ROWNUM은 NULL 값을 무시한다', b'0', 4, 613),
	(2453, '적절한 인덱스 사용', b'0', 1, 614),
	(2454, '필요한 열만 선택', b'0', 2, 614),
	(2455, '가능한 많은 데이터 추출', b'1', 3, 614),
	(2456, 'WHERE 절을 이용한 사전 필터링', b'0', 4, 614),
	(2457, 'RANK() 함수 사용', b'0', 1, 615),
	(2458, 'DENSE_RANK() 함수 사용', b'0', 2, 615),
	(2459, 'ROW_NUMBER() 함수 사용', b'0', 3, 615),
	(2460, 'a와 b 모두 가능', b'1', 4, 615),
	(2461, 'OFFSET과 FETCH NEXT 사용 (SQL Server)', b'0', 1, 616),
	(2462, 'LIMIT과 OFFSET 사용 (MySQL)', b'0', 2, 616),
	(2463, 'ROWNUM과 서브쿼리 사용 (Oracle)', b'0', 3, 616),
	(2464, '모든 답변이 정확하다', b'1', 4, 616),
	(2465, '결과를 정렬한다', b'0', 1, 617),
	(2466, '동점인 경우 추가 행을 포함한다', b'1', 2, 617),
	(2467, '중복을 제거한다', b'0', 3, 617),
	(2468, 'NULL 값을 제외한다', b'0', 4, 617),
	(2469, 'ROW_NUMBER()', b'0', 1, 618),
	(2470, 'RANK()', b'0', 2, 618),
	(2471, 'NTILE()', b'0', 3, 618),
	(2472, 'CONCAT()', b'1', 4, 618),
	(2473, 'BETWEEN AND', b'0', 1, 619),
	(2474, 'LIMIT OFFSET', b'0', 2, 619),
	(2475, 'ROWS BETWEEN', b'0', 3, 619),
	(2476, 'FETCH FIRST ROWS ONLY', b'1', 4, 619),
	(2477, '항상 더 빠른 성능을 제공한다', b'0', 1, 620),
	(2478, '복잡한 순위 지정 로직을 간단히 구현할 수 있다', b'1', 2, 620),
	(2479, '데이터베이스 크기를 줄일 수 있다', b'0', 3, 620),
	(2480, '자동으로 인덱스를 생성한다', b'0', 4, 620),
	(2481, '선택하는 열의 개수', b'0', 1, 621),
	(2482, '테이블의 전체 행 수', b'0', 2, 621),
	(2483, 'ORDER BY 절의 존재 여부와 정렬 기준 열의 인덱스', b'1', 3, 621),
	(2484, 'SELECT 문의 길이', b'0', 4, 621),
	(2485, '결과의 백분율을 계산한다', b'0', 1, 622),
	(2486, '전체 결과 중 상위 N%를 반환한다', b'1', 2, 622),
	(2487, 'N번째 백분위수를 계산한다', b'0', 3, 622),
	(2488, 'NULL 값의 비율을 계산한다', b'0', 4, 622),
	(2489, 'HIERARCHY', b'0', 1, 623),
	(2490, 'CONNECT BY', b'1', 2, 623),
	(2491, 'TREE', b'0', 3, 623),
	(2492, 'LEVEL BY', b'0', 4, 623),
	(2493, '서로 다른 두 테이블을 조인하는 것', b'0', 1, 624),
	(2494, '같은 테이블을 자기 자신과 조인하는 것', b'1', 2, 624),
	(2495, '세 개 이상의 테이블을 조인하는 것', b'0', 3, 624),
	(2496, '조인 없이 단일 테이블을 조회하는 것', b'0', 4, 624),
	(2497, '현재 행이 루트 노드인지 확인한다', b'0', 1, 625),
	(2498, '현재 행이 리프 노드인지 확인한다', b'1', 2, 625),
	(2499, '현재 행의 레벨을 반환한다', b'0', 3, 625),
	(2500, '현재 행의 자식 노드 수를 반환한다', b'0', 4, 625),
	(2501, '직원과 관리자 관계 표현', b'0', 1, 626),
	(2502, '테이블의 행 개수 계산', b'1', 2, 626),
	(2503, '계층 구조 데이터 처리', b'0', 3, 626),
	(2504, '연속된 날짜 간의 비교', b'0', 4, 626),
	(2505, '현재 행의 루트 노드 값을 반환한다', b'1', 1, 627),
	(2506, '현재 행이 루트 노드인지 확인한다', b'0', 2, 627),
	(2507, '루트 노드까지의 경로를 반환한다', b'0', 3, 627),
	(2508, '루트 노드의 자식 노드 수를 반환한다', b'0', 4, 627),
	(2509, 'NOCYCLE', b'1', 1, 628),
	(2510, 'PREVENT CYCLE', b'0', 2, 628),
	(2511, 'CYCLE', b'0', 3, 628),
	(2512, 'AVOID CYCLE', b'0', 4, 628),
	(2513, '항상 OUTER JOIN을 사용해야 한다', b'0', 1, 629),
	(2514, '같은 테이블의 별칭을 다르게 지정해야 한다', b'1', 2, 629),
	(2515, 'GROUP BY 절을 반드시 사용해야 한다', b'0', 3, 629),
	(2516, 'WHERE 절을 사용할 수 없다', b'0', 4, 629),
	(2517, '계층 구조의 끝을 지정한다', b'0', 1, 630),
	(2518, '계층 구조의 시작점을 지정한다', b'1', 2, 630),
	(2519, '계층 간의 관계를 정의한다', b'0', 3, 630),
	(2520, '계층의 깊이를 제한한다', b'0', 4, 630),
	(2521, 'ORDER SIBLINGS BY', b'1', 1, 631),
	(2522, 'SORT HIERARCHY', b'0', 2, 631),
	(2523, 'ARRANGE TREE', b'0', 3, 631),
	(2524, 'SEQUENCE LEVELS', b'0', 4, 631),
	(2525, '셀프 조인은 단일 테이블만 사용하고, 계층형 질의는 여러 테이블을 사용한다', b'0', 1, 632),
	(2526, '셀프 조인은 순환 관계를 처리할 수 없고, 계층형 질의는 가능하다', b'0', 2, 632),
	(2527, '셀프 조인은 모든 DBMS에서 지원하지만, 계층형 질의는 일부 DBMS에서만 지원한다', b'1', 3, 632),
	(2528, '셀프 조인은 항상 계층형 질의보다 성능이 좋다', b'0', 4, 632),
	(2529, '현재 행이 사이클을 형성하는지 확인한다', b'1', 1, 633),
	(2530, '현재 행의 레벨을 반환한다', b'0', 2, 633),
	(2531, '현재 행이 리프 노드인지 확인한다', b'0', 3, 633),
	(2532, '현재 행의 자식 노드 수를 반환한다', b'0', 4, 633),
	(2533, '연속된 날짜 간의 값 비교', b'0', 1, 634),
	(2534, '조직도 구현', b'0', 2, 634),
	(2535, '테이블 백업', b'1', 3, 634),
	(2536, '동일 테이블 내 데이터 비교', b'0', 4, 634),
	(2537, '현재 행의 루트 노드 값을 반환한다', b'1', 1, 635),
	(2538, '현재 행이 루트 노드인지 확인한다', b'0', 2, 635),
	(2539, '루트 노드까지의 경로를 반환한다', b'0', 3, 635),
	(2540, '루트 노드의 자식 노드 수를 반환한다', b'0', 4, 635),
	(2541, '가능한 한 깊은 레벨까지 탐색하도록 설정', b'1', 1, 636),
	(2542, '적절한 인덱스 사용', b'0', 2, 636),
	(2543, 'CONNECT BY 절에 사용되는 열에 인덱스 생성', b'0', 3, 636),
	(2544, '불필요한 열은 SELECT 목록에서 제외', b'0', 4, 636),
	(2545, '데이터를 정렬한다', b'0', 1, 637),
	(2546, '행 데이터를 열 데이터로 변환한다', b'1', 2, 637),
	(2547, '데이터를 필터링한다', b'0', 3, 637),
	(2548, '데이터를 집계한다', b'0', 4, 637),
	(2549, '데이터를 정렬한다', b'0', 1, 638),
	(2550, '열 데이터를 행 데이터로 변환한다', b'1', 2, 638),
	(2551, '데이터를 필터링한다', b'0', 3, 638),
	(2552, '데이터를 집계한다', b'0', 4, 638),
	(2553, 'GROUP BY 절', b'0', 1, 639),
	(2554, '집계 함수', b'1', 2, 639),
	(2555, 'ORDER BY 절', b'0', 3, 639),
	(2556, 'HAVING 절', b'0', 4, 639),
	(2557, 'SUM', b'0', 1, 640),
	(2558, 'AVG', b'0', 2, 640),
	(2559, 'COUNT', b'0', 3, 640),
	(2560, 'RANK', b'1', 4, 640),
	(2561, 'NULL 값은 항상 무시된다', b'0', 1, 641),
	(2562, 'INCLUDE NULLS 옵션을 사용하면 NULL 값을 포함할 수 있다', b'1', 2, 641),
	(2563, 'NULL 값은 항상 결과에 포함된다', b'0', 3, 641),
	(2564, 'UNPIVOT은 NULL 값을 처리할 수 없다', b'0', 4, 641),
	(2565, '크로스탭 리포트 생성', b'0', 1, 642),
	(2566, '월별 매출 요약', b'0', 2, 642),
	(2567, '데이터 정규화', b'1', 3, 642),
	(2568, '범주별 데이터 집계', b'0', 4, 642),
	(2569, '피벗할 열을 지정한다', b'1', 1, 643),
	(2570, '집계 함수를 지정한다', b'0', 2, 643),
	(2571, '정렬 기준을 지정한다', b'0', 3, 643),
	(2572, '필터링 조건을 지정한다', b'0', 4, 643),
	(2573, '언피벗할 열을 지정한다', b'1', 1, 644),
	(2574, '필터링 조건을 지정한다', b'0', 2, 644),
	(2575, '집계 함수를 지정한다', b'0', 3, 644),
	(2576, '정렬 기준을 지정한다', b'0', 4, 644),
	(2577, 'PIVOT XML 사용', b'1', 1, 645),
	(2578, 'DYNAMIC PIVOT 절 사용', b'0', 2, 645),
	(2579, 'AUTO COLUMN 옵션 사용', b'0', 3, 645),
	(2580, 'PIVOT 절은 동적 열 생성을 지원하지 않는다', b'0', 4, 645),
	(2581, 'MULTI UNPIVOT 사용', b'0', 1, 646),
	(2582, '여러 UNPIVOT 절을 연결', b'0', 2, 646),
	(2583, '괄호로 열 이름을 그룹화', b'1', 3, 646),
	(2584, 'UNPIVOT 절은 여러 열의 동시 언피벗을 지원하지 않는다', b'0', 4, 646),
	(2585, '항상 모든 열을 피벗한다', b'0', 1, 647),
	(2586, '피벗하기 전에 데이터를 미리 집계한다', b'1', 2, 647),
	(2587, 'PIVOT 대신 CASE 문을 사용한다', b'0', 3, 647),
	(2588, '모든 데이터에 대해 FULL OUTER JOIN을 수행한다', b'0', 4, 647),
	(2589, 'UNPIVOT은 내부적으로 CROSS JOIN을 사용한다', b'0', 1, 648),
	(2590, 'UNPIVOT과 CROSS JOIN은 완전히 다른 연산이다', b'1', 2, 648),
	(2591, 'CROSS JOIN으로 UNPIVOT의 모든 기능을 구현할 수 있다', b'0', 3, 648),
	(2592, 'UNPIVOT은 CROSS JOIN의 최적화된 버전이다', b'0', 4, 648),
	(2593, 'UNPIVOT 절 사용', b'0', 1, 649),
	(2594, 'CASE 문과 집계 함수 조합 사용', b'1', 2, 649),
	(2595, 'FULL OUTER JOIN 사용', b'0', 3, 649),
	(2596, 'PIVOT 절은 모든 DBMS에서 지원한다', b'0', 4, 649),
	(2597, '항상 원본 데이터와 동일한 형태가 된다', b'0', 1, 650),
	(2598, '데이터의 행과 열 개수가 항상 증가한다', b'0', 2, 650),
	(2599, '데이터의 행과 열 개수가 항상 감소한다', b'0', 3, 650),
	(2600, '원본 데이터와 다른 형태가 될 수 있으며, 사용 방식에 따라 결과가 달라진다', b'1', 4, 650),
	(2601, '정확히 한 개의 문자와 일치', b'1', 1, 651),
	(2602, '0개 이상의 문자와 일치', b'0', 2, 651),
	(2603, '1개 이상의 문자와 일치', b'0', 3, 651),
	(2604, '숫자만 일치', b'0', 4, 651),
	(2605, '0에서 9까지의 숫자 중 하나', b'0', 1, 652),
	(2606, '0에서 9까지의 숫자가 한 번 이상 반복', b'1', 2, 652),
	(2607, '0에서 9까지의 숫자가 정확히 한 번', b'0', 3, 652),
	(2608, '0 또는 9만 허용', b'0', 4, 652),
	(2609, 'LIKE', b'0', 1, 653),
	(2610, 'REGEXP_LIKE', b'1', 2, 653),
	(2611, 'MATCH', b'0', 3, 653),
	(2612, 'SIMILAR TO', b'0', 4, 653),
	(2613, '문자열의 끝', b'0', 1, 654),
	(2614, '문자열의 시작', b'1', 2, 654),
	(2615, 'NOT 연산', b'0', 3, 654),
	(2616, '공백 문자', b'0', 4, 654),
	(2617, '[0-9]', b'1', 1, 655),
	(2618, '[a-z]', b'0', 2, 655),
	(2619, '[A-Z]', b'0', 3, 655),
	(2620, '[	\n\r]', b'0', 4, 655),
	(2621, '정확히 한 번 일치', b'0', 1, 656),
	(2622, '한 번 이상 일치', b'0', 2, 656),
	(2623, '0번 또는 1번 일치', b'1', 3, 656),
	(2624, '0번 이상 일치', b'0', 4, 656),
	(2625, '^[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$', b'1', 1, 657),
	(2626, '^[0-9]+$', b'0', 2, 657),
	(2627, '^[a-zA-Z]+$', b'0', 3, 657),
	(2628, '^\\d{3}-\\d{3,4}-\\d{4}$', b'0', 4, 657),
	(2629, '복잡한 문자열 패턴을 간단히 표현할 수 있다', b'0', 1, 658),
	(2630, 'LIKE 연산자보다 더 강력한 패턴 매칭이 가능하다', b'0', 2, 658),
	(2631, '데이터 검증을 효과적으로 수행할 수 있다', b'0', 3, 658),
	(2632, '항상 LIKE 연산자보다 빠른 성능을 제공한다', b'1', 4, 658),
	(2633, '0에서 9까지의 숫자', b'0', 1, 659),
	(2634, '0에서 9까지의 숫자가 아닌 문자', b'1', 2, 659),
	(2635, '0 또는 9', b'0', 3, 659),
	(2636, '숫자로 시작하는 문자열', b'0', 4, 659),
	(2637, '백스페이스', b'0', 1, 660),
	(2638, '단어 경계', b'1', 2, 660),
	(2639, '공백 문자', b'0', 3, 660),
	(2640, '줄 바꿈 문자', b'0', 4, 660),
	(2641, 'REPLACE', b'0', 1, 661),
	(2642, 'REGEXP_REPLACE', b'1', 2, 661),
	(2643, 'SUBSTITUTE', b'0', 3, 661),
	(2644, 'REGEXP_CHANGE', b'0', 4, 661),
	(2645, '\'a\' 또는 \'b\'가 한 번 이상 반복', b'0', 1, 662),
	(2646, '\'ab\'가 한 번 이상 반복', b'1', 2, 662),
	(2647, '\'a\'로 시작하고 \'b\'로 끝나는 문자열', b'0', 3, 662),
	(2648, '\'a\' 다음에 \'b\'가 오는 문자열', b'0', 4, 662),
	(2649, 'LIKE 연산자', b'0', 1, 663),
	(2650, 'REGEXP_LIKE 함수', b'0', 2, 663),
	(2651, 'SIMILAR TO 연산자', b'0', 3, 663),
	(2652, 'PATINDEX 함수', b'1', 4, 663),
	(2653, '가능한 한 구체적인 패턴 사용', b'0', 1, 664),
	(2654, '불필요한 백트래킹 최소화', b'0', 2, 664),
	(2655, '모든 문자열에 대해 항상 정규 표현식 사용', b'1', 3, 664),
	(2656, '정규 표현식 패턴 컴파일 및 재사용', b'0', 4, 664),
	(2657, 'INSERT', b'0', 1, 665),
	(2658, 'UPDATE', b'0', 2, 665),
	(2659, 'DELETE', b'0', 3, 665),
	(2660, 'CREATE', b'1', 4, 665),
	(2661, 'INSERT INTO 테이블명 SET 열1 = 값1, 열2 = 값2;', b'0', 1, 666),
	(2662, 'INSERT INTO 테이블명 SELECT 문;', b'1', 2, 666),
	(2663, 'INSERT 테이블명 (값1, 값2, 값3);', b'0', 3, 666),
	(2664, 'INSERT VALUES INTO 테이블명 (값1, 값2, 값3);', b'0', 4, 666),
	(2665, 'SET 절', b'0', 1, 667),
	(2666, 'WHERE 절', b'0', 2, 667),
	(2667, 'UPDATE 키워드 다음', b'0', 3, 667),
	(2668, 'ORDER BY 절', b'1', 4, 667),
	(2669, 'DELETE는 로그를 남기지 않고, TRUNCATE는 로그를 남긴다', b'0', 1, 668),
	(2670, 'DELETE는 특정 행을 삭제할 수 있고, TRUNCATE는 테이블의 모든 데이터를 삭제한다', b'0', 2, 668),
	(2671, 'DELETE는 DML이고, TRUNCATE는 DDL이다', b'1', 3, 668),
	(2672, 'DELETE는 롤백이 불가능하고, TRUNCATE는 롤백이 가능하다', b'0', 4, 668),
	(2673, '두 테이블을 완전히 병합하여 새로운 테이블을 생성', b'0', 1, 669),
	(2674, '조건에 따라 INSERT, UPDATE, DELETE를 한 번에 수행', b'1', 2, 669),
	(2675, '테이블의 구조를 변경', b'0', 3, 669),
	(2676, '여러 테이블의 데이터를 하나의 결과로 조회', b'0', 4, 669),
	(2677, 'INSERT ALL INTO 테이블명 VALUES (값1, 값2), (값3, 값4);', b'0', 1, 670),
	(2678, 'INSERT INTO 테이블명 VALUES (값1, 값2), (값3, 값4);', b'1', 2, 670),
	(2679, 'INSERT MULTIPLE INTO 테이블명 VALUES (값1, 값2), (값3, 값4);', b'0', 3, 670),
	(2680, '여러 개의 INSERT 문을 각각 실행해야 한다', b'0', 4, 670),
	(2681, 'UPDATE 테이블1 SET 열 = (SELECT 문);', b'0', 1, 671),
	(2682, 'UPDATE 테이블1 JOIN 테이블2 ON 조건 SET 열 = 테이블2.열;', b'0', 2, 671),
	(2683, 'UPDATE 테이블1, 테이블2 SET 테이블1.열 = 테이블2.열 WHERE 조건;', b'0', 3, 671),
	(2684, 'a, b, c 모두 가능 (DBMS에 따라 다를 수 있음)', b'1', 4, 671),
	(2685, 'SELECT @@ROWCOUNT;', b'0', 1, 672),
	(2686, 'SELECT ROW_COUNT();', b'0', 2, 672),
	(2687, 'SELECT DELETED_ROWS FROM INFORMATION_SCHEMA;', b'0', 3, 672),
	(2688, 'a와 b 모두 가능 (DBMS에 따라 다름)', b'1', 4, 672),
	(2689, '항상 오류가 발생한다', b'0', 1, 673),
	(2690, '지정한 값이 이미 존재하면 오류가 발생할 수 있다', b'1', 2, 673),
	(2691, '자동 증가 값이 재설정된다', b'0', 3, 673),
	(2692, '아무런 영향이 없다', b'0', 4, 673),
	(2693, '오류가 발생한다', b'0', 1, 674),
	(2694, '아무런 변경이 일어나지 않는다', b'0', 2, 674),
	(2695, '테이블의 모든 행이 업데이트된다', b'1', 3, 674),
	(2696, '첫 번째 행만 업데이트된다', b'0', 4, 674),
	(2697, '조건에 일치하는 데이터가 없을 때 INSERT를 수행', b'1', 1, 675),
	(2698, '조건에 일치하는 데이터가 있을 때 UPDATE를 수행', b'0', 2, 675),
	(2699, '조건에 일치하는 데이터가 있을 때 DELETE를 수행', b'0', 3, 675),
	(2700, '조건에 일치하지 않는 데이터를 무시', b'0', 4, 675),
	(2701, '인덱스를 활용한다', b'0', 1, 676),
	(2702, '가능한 한 많은 데이터를 한 번에 처리한다', b'0', 2, 676),
	(2703, 'WHERE 절을 최적화한다', b'0', 3, 676),
	(2704, '모든 DML 문을 트랜잭션으로 묶어 실행한다', b'1', 4, 676),
	(2705, '중복 키 발생 시 오류를 방지하고 대체 작업을 수행', b'1', 1, 677),
	(2706, '삽입 작업 중 발생한 모든 오류를 무시', b'0', 2, 677),
	(2707, '중복 데이터를 자동으로 삭제', b'0', 3, 677),
	(2708, '트랜잭션을 자동으로 롤백', b'0', 4, 677),
	(2709, '사용자가 명시적으로 트랜잭션을 시작하고 종료해야 한다', b'0', 1, 678),
	(2710, '각 DML 문이 자동으로 하나의 트랜잭션으로 처리된다', b'1', 2, 678),
	(2711, '트랜잭션을 사용하지 않는다', b'0', 3, 678),
	(2712, '여러 DML 문을 하나의 트랜잭션으로 자동 처리한다', b'0', 4, 678),
	(2713, 'COMMIT', b'0', 1, 679),
	(2714, 'ROLLBACK', b'0', 2, 679),
	(2715, 'SAVEPOINT', b'0', 3, 679),
	(2716, 'UPDATE', b'1', 4, 679),
	(2717, 'Availability', b'0', 1, 680),
	(2718, 'Atomicity', b'1', 2, 680),
	(2719, 'Authenticity', b'0', 3, 680),
	(2720, 'Accessibility', b'0', 4, 680),
	(2721, '트랜잭션의 변경사항을 취소한다', b'0', 1, 681),
	(2722, '트랜잭션의 변경사항을 영구적으로 반영한다', b'1', 2, 681),
	(2723, '트랜잭션을 시작한다', b'0', 3, 681),
	(2724, '트랜잭션의 특정 지점을 표시한다', b'0', 4, 681),
	(2725, '마지막 COMMIT 이후의 모든 변경사항이 취소된다', b'1', 1, 682),
	(2726, '데이터베이스의 모든 데이터가 삭제된다', b'0', 2, 682),
	(2727, '현재 세션의 모든 테이블이 삭제된다', b'0', 3, 682),
	(2728, '아무런 변화가 없다', b'0', 4, 682),
	(2729, '데이터베이스 백업 지점 생성', b'0', 1, 683),
	(2730, '트랜잭션 내의 중간 지점 표시', b'1', 2, 683),
	(2731, '데이터베이스 스키마 변경 지점 표시', b'0', 3, 683),
	(2732, '데이터베이스 복구 지점 자동 생성', b'0', 4, 683),
	(2733, 'DDL 문 실행', b'0', 1, 684),
	(2734, 'DCL 문 실행', b'0', 2, 684),
	(2735, '정상적인 프로그램 종료', b'0', 3, 684),
	(2736, 'SELECT 문 실행', b'1', 4, 684),
	(2737, 'READ UNCOMMITTED', b'1', 1, 685),
	(2738, 'READ COMMITTED', b'0', 2, 685),
	(2739, 'REPEATABLE READ', b'0', 3, 685),
	(2740, 'SERIALIZABLE', b'0', 4, 685),
	(2741, '트랜잭션의 모든 변경사항을 취소한다', b'0', 1, 686),
	(2742, '지정된 SAVEPOINT 이후의 변경사항만 취소한다', b'1', 2, 686),
	(2743, '데이터베이스 전체를 특정 시점으로 되돌린다', b'0', 3, 686),
	(2744, 'SAVEPOINT를 삭제한다', b'0', 4, 686),
	(2745, '트랜잭션의 부분적 실행 방지', b'0', 1, 687),
	(2746, '동시에 실행되는 트랜잭션 간의 상호 영향 방지', b'1', 2, 687),
	(2747, '시스템 장애 발생 시 데이터 보호', b'0', 3, 687),
	(2748, '데이터의 영구적 저장', b'0', 4, 687),
	(2749, 'INSERT', b'0', 1, 688),
	(2750, 'UPDATE', b'0', 2, 688),
	(2751, 'DELETE', b'0', 3, 688),
	(2752, 'BEGIN TRANSACTION', b'1', 4, 688),
	(2753, '데이터베이스 락(Lock) 유지 시간 증가', b'0', 1, 689),
	(2754, '다른 트랜잭션의 대기 시간 증가', b'0', 2, 689),
	(2755, '데이터의 일관성 향상', b'1', 3, 689),
	(2756, '롤백 시 많은 리소스 소모', b'0', 4, 689),
	(2757, 'TCP/IP', b'0', 1, 690),
	(2758, 'HTTP', b'0', 2, 690),
	(2759, 'Two-Phase Commit', b'1', 3, 690),
	(2760, 'FTP', b'0', 4, 690),
	(2761, 'Dirty Read', b'1', 1, 691),
	(2762, 'Non-Repeatable Read', b'0', 2, 691),
	(2763, 'Phantom Read', b'0', 3, 691),
	(2764, 'Lost Update', b'0', 4, 691),
	(2765, '트랜잭션의 순서를 일관성 있게 유지', b'0', 1, 692),
	(2766, '트랜잭션의 크기를 가능한 한 크게 유지', b'1', 2, 692),
	(2767, '적절한 인덱스 사용', b'0', 3, 692),
	(2768, '트랜잭션 타임아웃 설정', b'0', 4, 692),
	(2769, 'CREATE', b'0', 1, 693),
	(2770, 'ALTER', b'0', 2, 693),
	(2771, 'DROP', b'0', 3, 693),
	(2772, 'INSERT', b'1', 4, 693),
	(2773, 'CREATE TABLE table_name (column_name datatype PRIMARY KEY);', b'0', 1, 694),
	(2774, 'CREATE TABLE table_name (column_name datatype UNIQUE NOT NULL);', b'0', 2, 694),
	(2775, 'CREATE TABLE table_name (column_name datatype KEY);', b'0', 3, 694),
	(2776, 'a와 b 모두 가능', b'1', 4, 694),
	(2777, '새로운 열 추가', b'0', 1, 695),
	(2778, '기존 열의 데이터 타입 변경', b'0', 2, 695),
	(2779, '제약조건 추가', b'0', 3, 695),
	(2780, '테이블의 모든 데이터 삭제', b'1', 4, 695),
	(2781, 'CREATE INDEX index_name ON table_name (column_name);', b'0', 1, 696),
	(2782, 'ALTER TABLE table_name ADD INDEX index_name (column_name);', b'0', 2, 696),
	(2783, 'ADD INDEX index_name ON table_name (column_name);', b'0', 3, 696),
	(2784, 'a와 b 모두 가능 (DBMS에 따라 다름)', b'1', 4, 696),
	(2785, '테이블의 모든 데이터를 삭제한다', b'0', 1, 697),
	(2786, '롤백이 가능하다', b'1', 2, 697),
	(2787, '테이블 구조는 유지된다', b'0', 3, 697),
	(2788, 'DELETE 보다 일반적으로 빠르다', b'0', 4, 697),
	(2789, 'CREATE VIEW view_name AS SELECT 문;', b'1', 1, 698),
	(2790, 'ALTER TABLE table_name ADD VIEW view_name;', b'0', 2, 698),
	(2791, 'INSERT VIEW view_name SELECT 문;', b'0', 3, 698),
	(2792, 'MAKE VIEW view_name FROM SELECT 문;', b'0', 4, 698),
	(2793, 'PRIMARY KEY', b'0', 1, 699),
	(2794, 'FOREIGN KEY', b'0', 2, 699),
	(2795, 'INDEX', b'1', 3, 699),
	(2796, 'CHECK', b'0', 4, 699),
	(2797, 'CREATE TABLESPACE', b'1', 1, 700),
	(2798, 'ALTER TABLESPACE', b'0', 2, 700),
	(2799, 'MAKE TABLESPACE', b'0', 3, 700),
	(2800, 'ADD TABLESPACE', b'0', 4, 700),
	(2801, '테이블의 데이터만 삭제된다', b'0', 1, 701),
	(2802, '테이블의 구조만 삭제된다', b'0', 2, 701),
	(2803, '테이블의 데이터와 구조 모두 삭제된다', b'1', 3, 701),
	(2804, '테이블의 인덱스만 삭제된다', b'0', 4, 701),
	(2805, '테이블 간의 관계 정의', b'0', 1, 702),
	(2806, '유일한 숫자 값 자동 생성', b'1', 2, 702),
	(2807, '데이터 정렬', b'0', 3, 702),
	(2808, '데이터 암호화', b'0', 4, 702),
	(2809, '열 이름 변경', b'0', 1, 703),
	(2810, '열 삭제', b'0', 2, 703),
	(2811, '테이블 이름 변경', b'0', 3, 703),
	(2812, '테이블의 모든 행 복제', b'1', 4, 703),
	(2813, '데이터베이스 객체에 주석 추가', b'1', 1, 704),
	(2814, 'SQL 문 내에 주석 추가', b'0', 2, 704),
	(2815, '에러 메시지 커스터마이징', b'0', 3, 704),
	(2816, '데이터베이스 로그에 메시지 추가', b'0', 4, 704),
	(2817, '파티션 키 선택', b'1', 1, 705),
	(2818, '파티션 방식 (범위, 목록, 해시 등)', b'0', 2, 705),
	(2819, '파티션의 수', b'0', 3, 705),
	(2820, '파티션 테이블의 인덱스 생성 불가능', b'0', 4, 705),
	(2821, '자동 커밋(Auto Commit)', b'1', 1, 706),
	(2822, '자동 롤백(Auto Rollback)', b'0', 2, 706),
	(2823, '트랜잭션 시작', b'0', 3, 706),
	(2824, '데이터베이스 백업', b'0', 4, 706),
	(2825, 'SELECT', b'0', 1, 707),
	(2826, 'INSERT', b'0', 2, 707),
	(2827, 'GRANT', b'1', 3, 707),
	(2828, 'CREATE', b'0', 4, 707),
	(2829, 'GRANT SELECT ON table_name TO user_name;', b'1', 1, 708),
	(2830, 'GIVE SELECT ON table_name TO user_name;', b'0', 2, 708),
	(2831, 'ALLOW SELECT ON table_name FOR user_name;', b'0', 3, 708),
	(2832, 'PERMIT SELECT ON table_name TO user_name;', b'0', 4, 708),
	(2833, '사용자에게 권한을 부여한다', b'0', 1, 709),
	(2834, '사용자로부터 권한을 제거한다', b'1', 2, 709),
	(2835, '새로운 사용자를 생성한다', b'0', 3, 709),
	(2836, '데이터베이스 객체를 삭제한다', b'0', 4, 709),
	(2837, 'CREATE USER', b'0', 1, 710),
	(2838, 'CREATE TABLE', b'0', 2, 710),
	(2839, 'SELECT ANY TABLE', b'0', 3, 710),
	(2840, 'INSERT ON employees', b'1', 4, 710),
	(2841, '데이터베이스 백업', b'0', 1, 711),
	(2842, '권한들의 집합을 관리', b'1', 2, 711),
	(2843, '데이터 암호화', b'0', 3, 711),
	(2844, '쿼리 성능 최적화', b'0', 4, 711),
	(2845, '부여받은 권한을 다른 사용자에게 부여할 수 있는 권한', b'1', 1, 712),
	(2846, '모든 권한을 한 번에 부여하는 옵션', b'0', 2, 712),
	(2847, '권한 부여를 취소할 수 있는 옵션', b'0', 3, 712),
	(2848, '임시로 권한을 부여하는 옵션', b'0', 4, 712),
	(2849, '사용자 생성 및 삭제', b'0', 1, 713),
	(2850, '테이블스페이스 관리', b'0', 2, 713),
	(2851, '일반 사용자의 비밀번호 확인', b'1', 3, 713),
	(2852, '데이터베이스 백업 및 복구', b'0', 4, 713),
	(2853, 'SELECT', b'0', 1, 714),
	(2854, 'INSERT', b'0', 2, 714),
	(2855, 'TRUNCATE', b'0', 3, 714),
	(2856, 'COMMENT', b'1', 4, 714),
	(2857, '모든 사용자에게 자동으로 부여되는 역할', b'1', 1, 715),
	(2858, '데이터베이스 관리자만 가질 수 있는 역할', b'0', 2, 715),
	(2859, '특정 애플리케이션에서만 사용되는 역할', b'0', 3, 715),
	(2860, '일시적으로 부여되는 역할', b'0', 4, 715),
	(2861, '해당 사용자의 모든 권한을 취소한다', b'0', 1, 716),
	(2862, '해당 권한과 관련된 모든 객체를 삭제한다', b'0', 2, 716),
	(2863, '해당 사용자가 다른 사용자에게 부여한 권한도 연쇄적으로 취소한다', b'1', 3, 716),
	(2864, '데이터베이스의 모든 동일한 권한을 취소한다', b'0', 4, 716),
	(2865, 'Oracle', b'0', 1, 717),
	(2866, 'MySQL', b'0', 2, 717),
	(2867, 'SQL Server', b'1', 3, 717),
	(2868, '모든 DBMS에서 자동 커밋이 발생한다', b'0', 4, 717),
	(2869, '여러 개의 GRANT 문을 각각 실행한다', b'0', 1, 718),
	(2870, 'GRANT 문에 쉼표로 구분하여 여러 권한을 나열한다', b'1', 2, 718),
	(2871, 'GRANT ALL PRIVILEGES를 사용한다', b'0', 3, 718),
	(2872, 'b와 c 모두 가능하다', b'0', 4, 718),
	(2873, '모든 사용자에게 가능한 적은 권한을 부여한다', b'0', 1, 719),
	(2874, '사용자에게 필요한 최소한의 권한만 부여한다', b'1', 2, 719),
	(2875, '관리자 권한을 가진 사용자 수를 최소화한다', b'0', 3, 719),
	(2876, '데이터베이스의 객체 수를 최소화한다', b'0', 4, 719),
	(2877, 'REVOKE는 항상 모든 권한을 한 번에 제거한다', b'0', 1, 720),
	(2878, 'REVOKE 후에는 해당 사용자가 데이터베이스에 접속할 수 없다', b'0', 2, 720),
	(2879, '잘못된 REVOKE 실행 시 의도치 않게 다른 사용자의 권한도 제거될 수 있다', b'1', 3, 720),
	(2880, 'REVOKE는 시스템 권한에만 적용되고, 객체 권한에는 적용되지 않는다', b'0', 4, 720),
	(2881, '상품리뷰(리뷰번호, 상품번호, 회원번호, 별점, 내용, 작성일자)', b'0', 1, 721),
	(2882, '고객주문(주문일자, 배송지, 결제방법) → NOT NULL', b'0', 1, 722),
	(2883, '주문과 상품을 N:M 관계로 설계하고 취소 정보는 주문 테이블에 칼럼으로 추가', b'0', 1, 723),
	(2884, '회원번호', b'0', 1, 724),
	(2885, '진료예약 테이블의 진료과명', b'1', 1, 725),
	(2886, '고객과 주문의 관계', b'0', 1, 726),
	(2887, '직원(슈퍼타입) - 정규직/계약직/임시직(서브타입): 배타적 서브타입', b'0', 1, 727),
	(2888, '실시간 주문 상태 조회 시 여러 테이블을 조인하여 성능이 저하되는 경우', b'0', 1, 728),
	(2889, '(회원번호, 로그인일시)의 복합키', b'0', 1, 729),
	(2890, '패키지상품(상품코드, 상품명, 여행기간, 최소인원, 최대인원)', b'0', 1, 730),
	(2891, 'SELECT A.SALES_MONTH, A.TOTAL_AMOUNT FROM SALES_MONTHLY A, SALES_MONTHLY B WHERE A.SALES_MONTH > B.SALES_MONTH AND A.TOTAL_AMOUNT >= B.TOTAL_AMOUNT * 1.1', b'0', 1, 731),
	(2892, 'DEPT_NO  EMP_COUNT  TOTAL_SALARY  AVG_BONUS\n-------------------------------------------\n10       2          8000          500\n20       2          6800          0', b'1', 1, 732),
	(2893, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_NO = E.DEPT_NO)', b'0', 1, 733),
	(2894, 'UNION은 중복된 행을 제거하고, UNION ALL은 중복된 행을 포함한다', b'0', 1, 734),
	(2895, 'SELECT order_date, next_date FROM (SELECT order_date, LEAD(order_date) OVER (ORDER BY order_date) as next_date, LEAD(order_date) OVER (ORDER BY order_date) - order_date as diff FROM orders) WHERE diff > 3', b'0', 1, 735),
	(2896, 'SELECT * FROM EMPLOYEE E1 WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE E2 WHERE E2.DEPT_NO = E1.DEPT_NO)', b'0', 1, 736),
	(2897, 'SELECT PROD_ID, TRX_DATE, SUM(CASE WHEN TRX_TYPE = \'\'IN\'\' THEN QUANTITY WHEN TRX_TYPE = \'\'OUT\'\' THEN -QUANTITY END) OVER (PARTITION BY PROD_ID ORDER BY TRX_DATE) as STOCK_QTY FROM STOCK_HISTORY', b'0', 1, 737),
	(2898, 'INSERT ALL 명령을 사용하면 하나의 데이터 소스로 여러 테이블에 데이터를 입력할 수 있다', b'0', 1, 738),
	(2899, 'SELECT DEPT_ID, LPAD(\'\' \'\', 2*(LEVEL-1)) || DEPT_NAME as DEPT_NAME FROM DEPARTMENT START WITH PARENT_DEPT_ID IS NULL CONNECT BY PRIOR DEPT_ID = PARENT_DEPT_ID', b'0', 1, 739),
	(2900, 'ROLLBACK TO SAVEPOINT 구문을 실행하면 해당 SAVEPOINT 이후의 변경사항만 취소된다', b'0', 1, 740),
	(2901, 'RANK() OVER (ORDER BY SALARY DESC) AS RANK', b'0', 1, 741),
	(2902, 'SELECT ORDER_DATE, PRODUCT_ID, QUANTITY FROM SALES S1 WHERE QUANTITY = (SELECT MAX(QUANTITY) FROM SALES S2 WHERE S1.ORDER_DATE = S2.ORDER_DATE)', b'0', 1, 742),
	(2903, 'CREATE INDEX idx_emp_name ON employee(emp_name)', b'0', 1, 743),
	(2904, 'SELECT DEPT_NO, MAX(SALARY) - MIN(SALARY) AS SALARY_GAP FROM EMPLOYEE WHERE MAX(SALARY) - MIN(SALARY) >= 5000 GROUP BY DEPT_NO', b'0', 1, 744),
	(2905, 'MERGE INTO TARGET_TBL T USING SOURCE_TBL S ON (T.PROD_ID = S.PROD_ID) WHEN MATCHED THEN UPDATE SET T.STOCK_QTY = S.STOCK_QTY WHEN NOT MATCHED THEN INSERT (PROD_ID, PROD_NAME, STOCK_QTY) VALUES (S.PROD_ID, S.PROD_NAME, S.STOCK_QTY)', b'1', 1, 745),
	(2906, 'SELECT USER_ID FROM (SELECT USER_ID, SUCCESS_YN, COUNT(*) OVER (PARTITION BY USER_ID ORDER BY LOGIN_DT ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS FAIL_COUNT FROM LOGIN_HISTORY WHERE SUCCESS_YN = \'\'N\'\') WHERE FAIL_COUNT >= 3', b'0', 1, 746),
	(2907, 'SELECT DISTINCT p2.PROD_ID FROM PURCHASES p1 JOIN PURCHASES p2 ON p1.CUST_ID = p2.CUST_ID WHERE p1.PROD_ID = \'\'A001\'\' AND p2.PROD_ID != \'\'A001\'\'', b'0', 1, 747),
	(2908, 'WHERE salary * 12 = 60000', b'1', 1, 748),
	(2909, 'SELECT SALES_MONTH, AMOUNT, ROUND((AMOUNT - LAG(AMOUNT) OVER (ORDER BY SALES_MONTH)) / LAG(AMOUNT) OVER (ORDER BY SALES_MONTH) * 100, 2) AS GROWTH_RATE FROM SALES', b'0', 1, 749),
	(2910, 'CASCADE DELETE 옵션을 사용하면 부모 테이블의 데이터 삭제 시 자식 테이블의 관련 데이터도 자동으로 삭제된다', b'0', 1, 750),
	(2911, '(2023년 데이터 ∪ 2024년 데이터) ∩ 2022년 데이터', b'0', 1, 751),
	(2912, 'SELECT DEPT_NO, COUNT(*) FROM EMPLOYEE E WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_NO = E.DEPT_NO) GROUP BY DEPT_NO', b'0', 1, 752),
	(2913, 'SELECT p.POST_ID, p.TITLE, (SELECT COUNT(*) FROM BOARD WHERE PARENT_ID = p.POST_ID) AS reply_count FROM BOARD p WHERE p.PARENT_ID IS NULL', b'0', 1, 753),
	(2914, 'GROUP BY 절에 있는 컬럼은 SELECT 절에 그대로 사용할 수 있다', b'0', 1, 754),
	(2915, 'SELECT * FROM (SELECT DEPT_NO, SALARY_GRADE, COUNT(*) AS CNT FROM EMPLOYEE GROUP BY DEPT_NO, SALARY_GRADE) PIVOT(COUNT(*) FOR SALARY_GRADE IN (\'\'A\'\', \'\'B\'\', \'\'C\'\'))', b'1', 1, 755),
	(2916, 'SELECT REGION, PRODUCT, SUM(QUANTITY) FROM SALES GROUP BY ROLLUP(REGION, PRODUCT)', b'1', 1, 756),
	(2917, 'TRUNC(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)/12) AS YEARS', b'1', 1, 757),
	(2918, 'Atomicity는 트랜잭션의 모든 연산이 완전히 수행되거나 전혀 수행되지 않아야 함을 의미한다', b'0', 1, 758),
	(2919, 'WHERE 절에서 자주 사용되는 컬럼에 대해 인덱스를 생성한다', b'0', 1, 759),
	(2920, 'SELECT p2.PROD_ID, p2.PROD_NAME FROM PRODUCTS p2 WHERE p2.CATEGORY = (SELECT p1.CATEGORY FROM PURCHASES pu JOIN PRODUCTS p1 ON pu.PROD_ID = p1.PROD_ID WHERE pu.ORDER_DATE = (SELECT MAX(ORDER_DATE) FROM PURCHASES)) AND p2.PROD_ID NOT IN (SELECT PROD_ID FROM PURCHASES)', b'0', 1, 760),
	(2921, 'SELECT STUDENT_ID FROM ATTENDANCE WHERE STATUS = \'결석\' GROUP BY STUDENT_ID HAVING COUNT(*) >= 3', b'0', 1, 761),
	(2922, 'SELECT * FROM (SELECT DEPT_NO, POSITION, COUNT(*) AS CNT FROM EMPLOYEE GROUP BY DEPT_NO, POSITION) PIVOT(COUNT(*) FOR POSITION IN (\'사원\' AS 사원, \'대리\' AS 대리, \'과장\' AS 과장))', b'1', 1, 762),
	(2923, 'SELECT SALES_DATE, AMOUNT FROM (SELECT SALES_DATE, AMOUNT, AVG(AMOUNT) OVER (ORDER BY SALES_DATE ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING) AS AVG_AMOUNT FROM DAILY_SALES) WHERE AMOUNT >= AVG_AMOUNT * 1.2', b'0', 1, 763),
	(2924, 'SELECT DEPT_NO, SALARY_MONTH, MIN_SALARY FROM SALARY_HISTORY s1 WHERE MIN_SALARY > (SELECT MIN_SALARY FROM SALARY_HISTORY s2 WHERE s2.DEPT_NO = s1.DEPT_NO AND s2.SALARY_MONTH = s1.SALARY_MONTH - 1)', b'0', 1, 764),
	(2925, 'ROW_NUMBER() OVER (PARTITION BY DEPT_NO ORDER BY SALARY DESC) AS RNK', b'0', 1, 765),
	(2926, 'MONTHS_BETWEEN(SYSDATE, LAST_LOGIN_DATE) >= 1', b'0', 1, 766),
	(2927, 'SELECT TO_CHAR(PURCHASE_DATE, \'YYYY-MM\') AS MONTH, COUNT(DISTINCT CASE WHEN RN = 1 THEN CUST_ID END) AS FIRST_PURCHASE, COUNT(DISTINCT CASE WHEN RN = CNT THEN CUST_ID END) AS LAST_PURCHASE FROM (SELECT CUST_ID, PURCHASE_DATE, ROW_NUMBER() OVER (PARTITION BY CUST_ID ORDER BY PURCHASE_DATE) AS RN, COUNT(*) OVER (PARTITION BY CUST_ID) AS CNT FROM CUSTOMER_PURCHASE) GROUP BY TO_CHAR(PURCHASE_DATE, \'YYYY-MM\')', b'1', 1, 767),
	(2928, 'SELECT PROD_ID, SALES_MONTH, QUANTITY, AVG(QUANTITY) OVER (PARTITION BY PROD_ID ORDER BY SALES_MONTH ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) AS AVG_3M FROM SALES', b'1', 1, 768),
	(2929, 'SELECT SALES_DATE, AMOUNT FROM (SELECT SALES_DATE, AMOUNT, AVG(AMOUNT) OVER (ORDER BY SALES_DATE ROWS BETWEEN 7 PRECEDING AND 1 PRECEDING) AS AVG_AMOUNT FROM DAILY_SALES) WHERE AMOUNT >= AVG_AMOUNT * 1.2', b'0', 1, 769),
	(2930, 'WITH SALARY_TREND AS (SELECT DEPT_NO, YM, AVG_SALARY, CASE WHEN AVG_SALARY > LAG(AVG_SALARY) OVER (PARTITION BY DEPT_NO ORDER BY YM) THEN 1 ELSE 0 END AS IS_INCREASE FROM MONTHLY_SALARY) SELECT DISTINCT DEPT_NO, MIN(YM) OVER (PARTITION BY DEPT_NO, GRP) AS START_YM, MAX(YM) OVER (PARTITION BY DEPT_NO, GRP) AS END_YM FROM (SELECT DEPT_NO, YM, AVG_SALARY, IS_INCREASE, SUM(CASE WHEN IS_INCREASE = 0 THEN 1 ELSE 0 END) OVER (PARTITION BY DEPT_NO ORDER BY YM) AS GRP FROM SALARY_TREND) WHERE IS_INCREASE = 1 GROUP BY DEPT_NO, GRP HAVING COUNT(*) >= 3', b'0', 1, 770),
	(2931, '업무에서 관리해야 하는 정보는 엔터티로 도출한다.', b'0', 1, 771),
	(2932, '하나의 엔터티는 여러 개의 인스턴스를 가질 수 있다.', b'0', 1, 772),
	(2933, '제2정규화는 제1정규화보다 더 많은 테이블이 생성된다.', b'1', 1, 773),
	(2934, '업무에서 필요한 정보를 나타낸다.', b'0', 1, 774),
	(2935, '모든 관계는 양방향성을 가져야 한다.', b'0', 1, 775),
	(2936, '부모 엔터티의 주식별자가 자식 엔터티의 일반 속성으로 상속된다.', b'0', 1, 776),
	(2937, '서브타입은 슈퍼타입의 속성을 상속받는다.', b'0', 1, 777),
	(2938, '기본 엔터티', b'0', 1, 778),
	(2939, '엔터티 정의', b'0', 1, 779),
	(2940, '엔터티는 사각형으로 표현한다.', b'0', 1, 780),
	(2941, 'CREATE', b'0', 1, 781),
	(2942, 'LD', b'0', 1, 782),
	(2943, 'GROUP BY절 다음에는 SELECT절에 사용된 집계함수 이외의 모든 열이 포함되어야 한다.', b'0', 1, 783),
	(2944, '2행', b'1', 1, 784),
	(2945, 'NVL 함수는 NULL을 다른 값으로 대체한다.', b'0', 1, 785),
	(2946, 'SELECT EXTRACT(YEAR FROM SYSDATE) - LEVEL + 1 FROM DUAL CONNECT BY LEVEL <= 3', b'1', 1, 786),
	(2947, '3행', b'0', 1, 787),
	(2948, 'RANK 함수는 동일한 값에 대해 동일한 순위를 부여한다.', b'0', 1, 788),
	(2949, '두 개의 SELECT문의 결과를 합친다.', b'0', 1, 789),
	(2950, 'SELECT MAX(VALUE) FROM SCORE;', b'1', 1, 790),
	(2951, 'COMMIT', b'0', 1, 791),
	(2952, '3행', b'0', 1, 792),
	(2953, 'LEVEL', b'0', 1, 793),
	(2954, 'FOR절', b'0', 1, 794),
	(2955, 'SELECT * FROM EMPLOYEE WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE)', b'0', 1, 795),
	(2956, 'Atomicity', b'0', 1, 796),
	(2957, 'ADD_MONTHS(date, n): date에 n개월을 더한다', b'0', 1, 797),
	(2958, '참조 무결성을 위한 제약조건이다', b'0', 1, 798),
	(2959, 'ROW_NUMBER() OVER (ORDER BY VALUE DESC)', b'0', 1, 799),
	(2960, '2행', b'0', 1, 800),
	(2961, '서브쿼리를 먼저 실행하여 임시 테이블을 생성한다', b'0', 1, 801),
	(2962, 'NULL', b'0', 1, 802),
	(2963, '인덱스는 테이블과 독립적으로 존재한다', b'0', 1, 803),
	(2964, 'A', b'0', 1, 804),
	(2965, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'1', 1, 805),
	(2966, '1행', b'1', 1, 806),
	(2967, 'ORDER BY와 동일한 기능을 한다', b'0', 1, 807),
	(2968, '3.46, 3, 300', b'1', 1, 808),
	(2969, 'SELECT * FROM EMPLOYEE WHERE ROWNUM <= (COUNT(*) * 0.2)', b'0', 1, 809),
	(2970, 'INSERT, UPDATE, DELETE 문에 의해 자동으로 실행된다', b'0', 1, 810),
	(2971, 'BEFORE INSERT', b'0', 1, 811),
	(2972, '3행', b'0', 1, 812),
	(2973, '/*+ FIRST_ROWS */', b'0', 1, 813),
	(2974, 'SELECT * FROM EMPLOYEE WHERE SALARY = MAX(SALARY) GROUP BY DEPT_ID', b'0', 1, 814),
	(2975, 'TOP 절은 ORDER BY와 함께 사용할 수 있다', b'0', 1, 815),
	(2976, 'GROUP BY 절에 AVG(SAL)이 없어서', b'0', 1, 816),
	(2977, 'CONNECT_BY_ROOT', b'0', 1, 817),
	(2978, '*ppl*\n   *r*ng*\n   B*n*n*', b'1', 1, 818),
	(2979, 'INSERT와 UPDATE를 한 번에 처리할 수 있다', b'0', 1, 819),
	(2980, 'TDE(Transparent Data Encryption) 사용', b'0', 1, 820),
	(2981, '업무에서 필요로 하는 정보여야 한다.', b'0', 1, 821),
	(2982, 'IE 표기법으로 실선을 사용한다.', b'1', 1, 822),
	(2983, '기본속성', b'0', 1, 823),
	(2984, '업무에서 관리되는 집합을 정의한다.', b'0', 1, 824),
	(2985, '1차 정규화', b'0', 1, 825),
	(2986, '하나의 속성은 하나의 값만 가져야 한다.', b'0', 1, 826),
	(2987, '실선 표현', b'1', 1, 827),
	(2988, '반드시 속성을 포함해야 한다.', b'0', 1, 828),
	(2989, '배타적 관계는 서브타입 중 하나만 선택 가능하다.', b'0', 1, 829),
	(2990, '부분 함수적 종속성 제거', b'0', 1, 830),
	(2991, 'NULL과 숫자 연산의 결과는 NULL이다.', b'0', 1, 831),
	(2992, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'0', 1, 832),
	(2993, 'SQL', b'0', 1, 833),
	(2994, 'HAVING COUNT(*) > 5', b'0', 1, 834),
	(2995, 'COUNT(column)', b'0', 1, 835),
	(2996, 'COMMIT, ROLLBACK', b'0', 1, 836),
	(2997, 'Park', b'0', 1, 837),
	(2998, 'PRIMARY KEY', b'0', 1, 838),
	(2999, '두 개의 SELECT문의 결과를 합친다.', b'0', 1, 839),
	(3000, '123.5', b'1', 1, 840),
	(3001, '두 개의 서로 다른 테이블을 조인하는 것이다.', b'0', 1, 841),
	(3002, 'Atomicity (원자성)', b'0', 1, 842),
	(3003, 'ELSE를 생략하면 ELSE NULL이 적용된다.', b'0', 1, 843),
	(3004, 'SELECT DISTINCT', b'0', 1, 844),
	(3005, '한 번에 여러 행을 입력할 수 있다.', b'0', 1, 845),
	(3006, 'ROW_NUMBER()는 동일한 값에 대해 다른 순위를 부여한다.', b'0', 1, 846),
	(3007, 'CROSS JOIN', b'0', 1, 847),
	(3008, 'CREATE', b'0', 1, 848),
	(3009, 'NULL', b'1', 1, 849),
	(3010, '테이블의 행 수가 적을 때', b'0', 1, 850),
	(3011, '메인쿼리의 칼럼을 서브쿼리에서 사용할 수 있다.', b'0', 1, 851),
	(3012, '조건을 만족하는 경우 UPDATE를 수행한다.', b'0', 1, 852),
	(3013, 'ONE', b'0', 1, 853),
	(3014, 'LEVEL', b'0', 1, 854),
	(3015, '반복적으로 사용되는 SQL의 결과를 저장할 수 있다.', b'0', 1, 855),
	(3016, '테이블의 모든 데이터가 삭제된다.', b'0', 1, 856),
	(3017, '데이터 보안을 제공할 수 있다.', b'0', 1, 857),
	(3018, 'NULL값을 허용하지 않는다.', b'0', 1, 858),
	(3019, 'DELETE는 DML이고 TRUNCATE는 DDL이다.', b'0', 1, 859),
	(3020, 'READ UNCOMMITTED', b'0', 1, 860),
	(3021, '지정된 컬럼의 소계를 생성한다', b'0', 1, 861),
	(3022, 'WHERE절에서 윈도우 함수를 사용할 수 없다', b'1', 1, 862),
	(3023, '데이터 조회 성능이 향상될 수 있다', b'0', 1, 863),
	(3024, 'SELECT TO_CHAR(SALES_DATE, \'YYYY-MM\') as YM, SUM(AMOUNT) as AMOUNT, LAG(SUM(AMOUNT), 12) OVER (ORDER BY SALES_DATE) as LAST_YEAR FROM SALES GROUP BY TO_CHAR(SALES_DATE, \'YYYY-MM\') ORDER BY YM;', b'1', 1, 864),
	(3025, 'EXISTS는 서브쿼리의 결과가 있는지만 확인한다', b'0', 1, 865),
	(3026, '계층 구조 데이터 조회', b'0', 1, 866),
	(3027, '1번', b'0', 1, 867),
	(3028, '데이터베이스 객체들이 저장되는 논리적인 저장 공간이다', b'0', 1, 868),
	(3029, 'SQL 문을 실행하기 위한 절차를 나타낸다', b'0', 1, 869),
	(3030, 'salary * 12 = 60000', b'0', 1, 870),
	(3031, '업무에서 필요로 하는 정보여야 한다', b'0', 1, 871),
	(3032, '유일성', b'0', 1, 872),
	(3033, '관계명', b'0', 1, 873),
	(3034, '독립적으로 존재할 수 있는 엔터티 타입이다', b'0', 1, 874),
	(3035, '하나의 속성은 한 개의 값만을 가진다', b'0', 1, 875),
	(3036, '정규화는 데이터의 중복을 제거한다', b'0', 1, 876),
	(3037, '조회 성능이 중요한 경우', b'0', 1, 877),
	(3038, '서브타입은 슈퍼타입의 속성을 상속받는다', b'0', 1, 878),
	(3039, '업무에서 관리하는 집합을 찾는다', b'0', 1, 879),
	(3040, '자식 엔터티의 존재 여부가 부모 엔터티의 존재 여부에 의존적인 경우', b'0', 1, 880),
	(3041, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID HAVING AVG(SALARY) > AVG(SALARY);', b'0', 1, 881),
	(3042, 'FIRST_VALUE 함수는 파티션별 윈도우에서 첫 번째 값을 구한다', b'0', 1, 882),
	(3043, 'LD', b'0', 1, 883),
	(3044, 'NATURAL JOIN은 동일한 이름을 가진 모든 컬럼들에 대한 등가 조인이다', b'0', 1, 884),
	(3045, 'SELECT TO_CHAR(ORDER_DATE, \'\'MM\'\') as MONTH, SUM(AMOUNT) as TOTAL_AMOUNT FROM ORDERS WHERE TO_CHAR(ORDER_DATE, \'\'YYYY\'\') = \'\'2023\'\' GROUP BY TO_CHAR(ORDER_DATE, \'\'MM\'\');', b'0', 1, 885),
	(3046, 'NULL + 숫자 = NULL', b'0', 1, 886),
	(3047, '데이터와 테이블 구조를 모두 삭제한다', b'0', 1, 887),
	(3048, 'START WITH → CONNECT BY → WHERE → ORDER SIBLINGS BY', b'1', 1, 888),
	(3049, '전체 사원의 평균 급여를 조회한다', b'0', 1, 889),
	(3050, 'GROUP BY절에는 Alias를 사용할 수 없다', b'0', 1, 890),
	(3051, '조건을 비교해서 테이블에 해당 조건이 없으면 INSERT를 수행한다', b'0', 1, 891),
	(3052, 'SELECT EMPNO, ENAME, SAL, CASE WHEN SAL > AVG(SAL) THEN \'이상\' ELSE \'이하\' END AS SALARY_GRADE FROM EMP;', b'0', 1, 892),
	(3053, '행을 열로 전환하는 기능을 제공한다', b'0', 1, 893),
	(3054, 'Atomicity (원자성)', b'0', 1, 894),
	(3055, 'SELECT * FROM EMP WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO);', b'0', 1, 895),
	(3056, 'ROLLUP은 계층 구조로 소계를 생성한다', b'0', 1, 896),
	(3057, '인덱스는 데이터 검색 속도를 향상시킨다', b'0', 1, 897),
	(3058, 'TOP-DOWN 방식으로 사원 계층 구조를 조회한다', b'0', 1, 898),
	(3059, 'ROWS', b'0', 1, 899),
	(3060, 'INSERT, UPDATE, DELETE 문이 수행될 때 자동으로 실행된다', b'0', 1, 900),
	(3061, 'SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR, EXTRACT(MONTH FROM ORDER_DATE) AS MONTH, SUM(AMOUNT) OVER (ORDER BY ORDER_DATE) AS CUM_AMT FROM SALES;', b'0', 1, 901),
	(3062, 'EXISTS는 서브쿼리의 결과가 있는지 여부만 확인한다', b'0', 1, 902),
	(3063, '뷰는 물리적으로 데이터를 저장한다', b'0', 1, 903),
	(3064, 'SELECT * FROM EMP E WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO);', b'1', 1, 904),
	(3065, 'IF', b'0', 1, 905),
	(3066, 'READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE', b'1', 1, 906),
	(3067, 'INSERT', b'0', 1, 907),
	(3068, 'CASCADE', b'1', 1, 908),
	(3069, 'SELECT * FROM (SELECT EMPNO, ENAME, DEPTNO, SAL, ROW_NUMBER() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS RN FROM EMP) WHERE RN = 1;', b'1', 1, 909),
	(3070, '테이블 검색 속도를 향상시킨다', b'0', 1, 910),
	(3071, '전체 백업(Full Backup)은 데이터베이스 전체를 백업하는 방식이다', b'0', 1, 911),
	(3072, 'SELECT TO_CHAR(SALE_DATE, \'YYYY-MM\') AS SALE_MONTH, SUM(AMOUNT) AS TOTAL_AMOUNT, ROUND((SUM(AMOUNT) - LAG(SUM(AMOUNT)) OVER (ORDER BY TO_CHAR(SALE_DATE, \'YYYY-MM\'))) / LAG(SUM(AMOUNT)) OVER (ORDER BY TO_CHAR(SALE_DATE, \'YYYY-MM\')) * 100, 2) AS GROWTH_RATE FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2023 GROUP BY TO_CHAR(SALE_DATE, \'YYYY-MM\');', b'1', 1, 912),
	(3073, '테이블의 데이터를 물리적으로 분할하여 저장한다', b'0', 1, 913),
	(3074, 'SELECT', b'0', 1, 914),
	(3075, 'SELECT * FROM EMPLOYEE E WHERE HIRE_DATE = (SELECT MAX(HIRE_DATE) FROM EMPLOYEE WHERE DEPT_ID = E.DEPT_ID);', b'0', 1, 915),
	(3076, '공유 락(Shared Lock)은 읽기 작업 시 사용된다', b'0', 1, 916),
	(3077, 'SELECT STUDENT_ID, SCORE, NTILE(4) OVER (ORDER BY SCORE DESC) AS GRADE FROM SCORE;', b'0', 1, 917),
	(3078, 'B-tree 인덱스', b'0', 1, 918),
	(3079, 'ORDER BY 절 이후에 ROWNUM 조건을 사용할 수 있다', b'0', 1, 919),
	(3080, 'SQL문을 모듈화하여 재사용할 수 있다', b'0', 1, 920),
	(3081, '유형 엔터티와 개념 엔터티', b'0', 1, 921),
	(3082, '기본 엔터티', b'0', 1, 922),
	(3083, '관계명', b'0', 1, 923),
	(3084, '식별관계', b'1', 1, 924),
	(3085, '엔터티와 마찬가지로 반드시 물리적으로 존재하는 성질이어야 한다', b'1', 1, 925),
	(3086, 'OneToOne Type', b'0', 1, 926),
	(3087, '1:1 관계', b'0', 1, 927),
	(3088, '제1정규형은 모든 속성이 원자값을 가져야 한다', b'0', 1, 928),
	(3089, '대표성 여부에 따라 주식별자와 보조식별자로 분류', b'0', 1, 929),
	(3090, '데이터의 일관성과 정합성이 중요한 경우', b'1', 1, 930),
	(3091, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO HAVING AVG(SALARY) >= 3000;', b'0', 1, 931),
	(3092, 'CASE문은 SELECT, WHERE, ORDER BY 절에서 사용할 수 있다', b'0', 1, 932),
	(3093, '서브쿼리는 항상 메인쿼리보다 먼저 실행된다', b'0', 1, 933),
	(3094, 'QL', b'0', 1, 934),
	(3095, 'SELECT절에 사용하여 중복된 행을 제거할 수 있다', b'0', 1, 935),
	(3096, 'SELECT A.DT, NVL(B.AMOUNT, 0) AS DAILY_AMOUNT FROM (SELECT TO_DATE(\'2024-01-01\',\'YYYY-MM-DD\') + LEVEL - 1 AS DT FROM DUAL CONNECT BY LEVEL <= 31) A LEFT OUTER JOIN (SELECT ORDER_DATE, SUM(ORDER_AMOUNT) AS AMOUNT FROM ORDERS WHERE TO_CHAR(ORDER_DATE,\'YYYY-MM\') = \'2024-01\' GROUP BY ORDER_DATE) B ON A.DT = B.ORDER_DATE ORDER BY A.DT;', b'1', 1, 936),
	(3097, 'IS NULL 연산자로 NULL 값을 비교할 수 있다', b'0', 1, 937),
	(3098, 'CROSS JOIN은 두 테이블의 모든 행을 조합한 결과를 반환한다', b'1', 1, 938),
	(3099, 'SELECT * FROM EMPLOYEE WHERE HIRE_DATE IN (SELECT MAX(HIRE_DATE) FROM EMPLOYEE GROUP BY DEPT_NO);', b'0', 1, 939),
	(3100, 'GROUP BY절에 명시되지 않은 컬럼은 집계함수 없이 SELECT절에 사용할 수 없다', b'0', 1, 940),
	(3101, 'SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, CEIL(EXTRACT(MONTH FROM SALE_DATE)/3) AS QUARTER, SUM(AMOUNT) AS TOTAL_AMOUNT, ROUND((SUM(AMOUNT) - LAG(SUM(AMOUNT), 4) OVER (ORDER BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3))) / LAG(SUM(AMOUNT), 4) OVER (ORDER BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3)) * 100, 2) AS GROWTH_RATE FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3) ORDER BY 1, 2;', b'1', 1, 941),
	(3102, 'Atomicity(원자성)는 트랜잭션의 연산이 모두 반영되거나 전혀 반영되지 않아야 함을 의미한다', b'0', 1, 942),
	(3103, 'NATURAL JOIN은 조인 조건을 명시적으로 지정할 수 있다', b'0', 1, 943),
	(3104, 'TABLE_A와 TABLE_B가 동일한 데이터를 가질 때', b'0', 1, 944),
	(3105, '테이블의 기본키(Primary Key) 컬럼', b'0', 1, 945),
	(3106, '공유락(Shared Lock)은 읽기 작업을 할 때 사용된다', b'0', 1, 946),
	(3107, 'TOP-DOWN 방식으로 순방향 전개되며, CONNECT_BY_ISLEAF는 리프 노드일 때 0을 반환한다', b'0', 1, 947),
	(3108, '데이터 조회 성능이 향상될 수 있다', b'0', 1, 948),
	(3109, '블록 구조로 되어있어 각 기능별로 모듈화가 가능하다', b'0', 1, 949),
	(3110, '네트워크 트래픽을 감소시킬 수 있다', b'0', 1, 950),
	(3111, 'SELECT EMP_NO, EMP_NAME, DEPT_NO, HIRE_DATE, ROW_NUMBER() OVER (PARTITION BY DEPT_NO ORDER BY HIRE_DATE) AS SEQ FROM EMPLOYEE;', b'0', 1, 951),
	(3112, 'DROP TABLE은 테이블 구조까지 삭제하지만, TRUNCATE TABLE은 데이터만 삭제한다', b'0', 1, 952),
	(3113, '3', b'0', 1, 953),
	(3114, 'INSERT, UPDATE, DELETE 문이 실행될 때 자동으로 동작한다', b'0', 1, 954),
	(3115, 'SELECT LEVEL AS MONTH FROM DUAL CONNECT BY LEVEL <= 6 MINUS SELECT EXTRACT(MONTH FROM SALE_DATE) AS MONTH FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2024 AND EXTRACT(MONTH FROM SALE_DATE) <= 6;', b'0', 1, 955),
	(3116, 'GRANT', b'0', 1, 956),
	(3117, '데이터 접근을 제한하여 보안성을 높일 수 있다', b'0', 1, 957),
	(3118, 'COL1    RESULT\nA       1,2\nB       3,4', b'1', 1, 958),
	(3119, '조건에 따라 INSERT 또는 UPDATE를 수행할 수 있다', b'0', 1, 959),
	(3120, 'SELECT * FROM (SELECT DEPT_NO, PAY_MONTH, SALARY FROM SALARY_HISTORY) PIVOT (AVG(SALARY) FOR PAY_MONTH IN (\'202401\', \'202402\', \'202403\'));', b'1', 1, 960),
	(3121, '인덱스는 WHERE절의 검색 조건으로 사용되는 컬럼에 생성하는 것이 효율적이다', b'0', 1, 961),
	(3122, 'SELECT * FROM (SELECT ORDER_NO, MEMBER_ID, ORDER_DATE, AMOUNT, ROW_NUMBER() OVER (PARTITION BY MEMBER_ID ORDER BY ORDER_DATE DESC) AS RN FROM ORDERS) WHERE RN <= 3;', b'1', 1, 962),
	(3123, '인덱스 컬럼에 데이터 변경이 빈번한 경우', b'0', 1, 963),
	(3124, 'NOW 컬럼은 현재 시간, AFTER_2HOUR 컬럼은 2시간 후 시간이 출력된다', b'1', 1, 964),
	(3125, 'UNION은 중복된 행을 제거하고 정렬한다', b'0', 1, 965),
	(3126, 'SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, EXTRACT(MONTH FROM SALE_DATE) AS MONTH, SUM(AMOUNT) AS MONTHLY_AMOUNT, SUM(SUM(AMOUNT)) OVER (ORDER BY EXTRACT(MONTH FROM SALE_DATE)) AS CUM_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), EXTRACT(MONTH FROM SALE_DATE);', b'0', 1, 966),
	(3127, '데이터의 무결성', b'0', 1, 967),
	(3128, 'ADD_MONTHS(date, n)는 date에 n개월을 더한다', b'0', 1, 968),
	(3129, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT MIN(SALARY) FROM (SELECT SALARY FROM EMPLOYEE WHERE DEPT_NO = E.DEPT_NO ORDER BY SALARY DESC) WHERE ROWNUM = 1);', b'0', 1, 969),
	(3130, 'READ UNCOMMITTED는 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다', b'0', 1, 970),
	(3131, '업무에서 관리되어야 하는 데이터의 집합이다', b'0', 1, 971),
	(3132, '유일성 - 하나의 엔터티 내에서 모든 인스턴스를 구분할 수 있어야 한다', b'0', 1, 972),
	(3133, '1:1', b'0', 1, 973),
	(3134, '아직 값이 할당되지 않음', b'0', 1, 974),
	(3135, '업무에서 관리하는 정보를 찾는다', b'0', 1, 975),
	(3136, '삭제 이상', b'0', 1, 976),
	(3137, '조회 성능이 중요한 경우', b'0', 1, 977),
	(3138, '업무로부터 직접 파생된 속성', b'0', 1, 978),
	(3139, '데이터 검색의 효율성', b'0', 1, 979),
	(3140, '학생은 동아리에 가입할 수도 있다', b'0', 1, 980),
	(3141, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID HAVING AVG(SALARY) > AVG(SALARY)', b'0', 1, 981),
	(3142, 'IS NULL은 NULL값을 찾기 위한 연산자이다', b'0', 1, 982),
	(3143, 'LD', b'0', 1, 983),
	(3144, '두 테이블의 동일한 이름을 가진 모든 칼럼에 대해 조인을 수행한다', b'0', 1, 984),
	(3145, 'SELECT YEAR(SALE_DATE), MONTH(SALE_DATE), SUM(AMOUNT) FROM SALES GROUP BY YEAR(SALE_DATE), MONTH(SALE_DATE)', b'0', 1, 985),
	(3146, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'1', 1, 986),
	(3147, 'START WITH EMP_ID = 3 CONNECT BY MGR_ID = PRIOR EMP_ID', b'1', 1, 987),
	(3148, 'ROLLUP은 지정된 컬럼의 소계를 생성한다', b'0', 1, 988),
	(3149, 'GRANT, REVOKE', b'1', 1, 989),
	(3150, 'SELECT * FROM EMPLOYEE WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID)', b'0', 1, 990),
	(3151, 'ALTER TABLE EMPLOYEE MODIFY NAME VARCHAR2(20)', b'0', 1, 991),
	(3152, 'PARTITION BY 절은 선택적으로 사용할 수 있다', b'0', 1, 992),
	(3153, 'MONTH=02, AMOUNT=150, PREV_AMOUNT=100', b'1', 1, 993),
	(3154, 'SELECT NAME, SCORE, RANK() OVER (ORDER BY SCORE DESC) AS RANK, DENSE_RANK() OVER (ORDER BY SCORE DESC) AS DENSE_RANK FROM SCORE', b'1', 1, 994),
	(3155, 'GROUP BY절에는 SELECT 절에서 사용한 집계함수 이외의 모든 컬럼이 포함되어야 한다', b'0', 1, 995),
	(3156, 'UNION은 중복을 제거하고 모든 결과를 반환한다', b'0', 1, 996),
	(3157, '0.5', b'0', 1, 997),
	(3158, '단일 행 서브쿼리는 결과가 반드시 1건이어야 한다', b'0', 1, 998),
	(3159, 'SELECT DEPT_ID, COUNT(*) FROM EMPLOYEE GROUP BY DEPT_ID WHERE COUNT(*) >= 2', b'0', 1, 999),
	(3160, '원자성(Atomicity)', b'0', 1, 1000),
	(3161, 'SELECT * FROM ORDERS O1 WHERE ORDER_DATE = (SELECT MAX(ORDER_DATE) FROM ORDERS O2 WHERE O1.CUSTOMER_ID = O2.CUSTOMER_ID)', b'1', 1, 1001),
	(3162, '2, 2', b'0', 1, 1002),
	(3163, '2024-12-16 14:30:00', b'0', 1, 1003),
	(3164, 'INSERT와 UPDATE를 한 번에 처리할 수 있다', b'0', 1, 1004),
	(3165, 'A', b'1', 1, 1005),
	(3166, 'SYSDATE + 1은 현재 시간보다 하루 뒤를 의미한다', b'0', 1, 1006),
	(3167, 'SELECT * FROM (SELECT MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID)', b'0', 1, 1007),
	(3168, 'EXISTS는 서브쿼리의 결과가 있는지만 확인한다', b'0', 1, 1008),
	(3169, 'YEAR | Q1  | Q2  | Q3  | Q4\n2023 | 100 | 200 | 300 | 400', b'1', 1, 1009),
	(3170, '인덱스는 테이블에서 데이터를 빠르게 조회하기 위한 객체이다', b'0', 1, 1010),
	(3171, 'DEPT_ID  LEVEL  DEPT_NAME\n1        1      영업부\n2        2      국내영업팀\n3        2      해외영업팀', b'0', 1, 1011),
	(3172, 'SELECT 문의 결과에 순번을 부여한다', b'0', 1, 1012),
	(3173, '123.46, 123.00, 120.00', b'0', 1, 1013),
	(3174, 'SELECT COL1 FROM TABLE_A UNION SELECT COL1 FROM TABLE_B', b'0', 1, 1014),
	(3175, 'READ UNCOMMITTED', b'0', 1, 1015),
	(3176, 'ID 컬럼에 NULL이 입력되어 PRIMARY KEY 제약조건 위배', b'0', 1, 1016),
	(3177, 'Atomicity(원자성) - 트랜잭션은 모두 실행되거나 모두 취소되어야 한다', b'0', 1, 1017),
	(3178, 'DELETE는 데이터만 삭제하고 테이블 구조는 유지된다', b'0', 1, 1018),
	(3179, 'GROUP BY절에는 SELECT절에서 사용한 모든 컬럼이 포함되어야 한다', b'1', 1, 1019),
	(3180, '뷰는 실제 데이터를 가지고 있지 않다', b'0', 1, 1020),
	(3181, '업무에서 필요로 하는 정보여야 한다', b'0', 1, 1021),
	(3182, '데이터의 일관성을 확보할 수 있다', b'0', 1, 1022),
	(3183, '테이블명은 단수형을 권장한다', b'0', 1, 1023),
	(3184, '슈퍼타입의 공통 속성을 서브타입이 상속받는다', b'0', 1, 1024),
	(3185, '유일성: 하나의 엔터티 내에서 인스턴스를 유일하게 구분한다', b'0', 1, 1025),
	(3186, '외부식별자', b'0', 1, 1026),
	(3187, '관계명', b'0', 1, 1027),
	(3188, '데이터의 일관성이 매우 중요한 경우', b'1', 1, 1028),
	(3189, '하나의 속성은 한 개의 값만을 가질 수 있다', b'0', 1, 1029),
	(3190, '식별관계', b'0', 1, 1030),
	(3191, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO HAVING AVG(SALARY) > AVG(SALARY)', b'0', 1, 1031),
	(3192, 'T', b'0', 1, 1032),
	(3193, 'GROUP BY절에서 그룹화된 컬럼은 SELECT절에서 그대로 사용할 수 있다', b'0', 1, 1033),
	(3194, 'RANK 함수는 동일한 값에 대해 동일한 순위를 부여한다', b'0', 1, 1034),
	(3195, 'START WITH MGR_ID IS NULL CONNECT BY EMP_ID = PRIOR MGR_ID', b'0', 1, 1035),
	(3196, 'DELETE는 데이터만 삭제하며 ROLLBACK이 가능하다', b'0', 1, 1036),
	(3197, '뷰는 실제 데이터를 저장하지 않는다', b'0', 1, 1037),
	(3198, 'LD', b'0', 1, 1038),
	(3199, 'ID 컬럼에 기본키가 없어서 발생하는 오류', b'0', 1, 1039),
	(3200, '조건에 따라 INSERT와 UPDATE를 한 번에 처리할 수 있다', b'0', 1, 1040),
	(3201, 'SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID)', b'0', 1, 1041),
	(3202, '0, 0, NULL', b'0', 1, 1042),
	(3203, '참조 무결성을 위한 제약조건이다', b'0', 1, 1043),
	(3204, 'SAL 내림차순, HIREDATE 내림차순', b'0', 1, 1044),
	(3205, '서브쿼리의 결과가 존재하는지 여부를 확인한다', b'0', 1, 1045),
	(3206, 'UNION은 중복을 제거하고, UNION ALL은 중복을 포함한다', b'1', 1, 1046),
	(3207, 'SELECT * FROM EMPLOYEE WHERE ROWNUM <= 3 ORDER BY SALARY DESC', b'0', 1, 1047),
	(3208, '반복적으로 사용되는 SQL문을 임시로 저장한다', b'0', 1, 1048),
	(3209, 'CASE JOB WHEN \'MANAGER\' THEN 1000 WHEN \'SALESMAN\' THEN 800 WHEN \'CLERK\' THEN 600 ELSE 0 END', b'1', 1, 1049),
	(3210, '테이블의 전체 행 중 15% 정도를 검색하는 경우', b'1', 1, 1050),
	(3211, 'CONNECT_BY_ISLEAF = 0', b'0', 1, 1051),
	(3212, 'SELECT DEPT_ID, AVG(SALARY) - (SELECT AVG(SALARY) FROM EMPLOYEE) FROM EMPLOYEE', b'0', 1, 1052),
	(3213, '7', b'0', 1, 1053),
	(3214, 'READ UNCOMMITTED → READ COMMITTED → REPEATABLE READ → SERIALIZABLE', b'1', 1, 1054),
	(3215, 'SELECT COL1 FROM TABLE_A WHERE COL1 = 1 UNION SELECT COL1 FROM TABLE_B WHERE COL1 = 2', b'0', 1, 1055),
	(3216, '123.4', b'1', 1, 1056),
	(3217, 'WITH GRANT OPTION을 통해 권한을 다른 사용자에게 부여할 수 있는 권한을 줄 수 있다', b'0', 1, 1057),
	(3218, 'NVL 함수는 첫 번째 인자가 NULL이면 두 번째 인자를 반환한다', b'0', 1, 1058),
	(3219, 'DEPT_ID | SUM(AMOUNT)\n10      | 3000\n20      | 4000', b'0', 1, 1059),
	(3220, 'Atomicity(원자성) - 트랜잭션은 모두 실행되거나 모두 취소되어야 한다', b'0', 1, 1060),
	(3221, 'SELECT ADD_MONTHS(ORDER_DATE, 2)\nFROM ORDERS', b'0', 1, 1061),
	(3222, 'OVER 절은 필수적으로 포함되어야 한다', b'0', 1, 1062),
	(3223, '메인쿼리와 서브쿼리는 연산자로 연결된다', b'0', 1, 1063),
	(3224, '인덱스는 WHERE절의 검색 조건으로 사용되는 컬럼에 생성하는 것이 효율적이다', b'0', 1, 1064),
	(3225, '\'**SQL\', \'SQL**\'', b'1', 1, 1065),
	(3226, 'CREATE, ALTER', b'0', 1, 1066),
	(3227, '4', b'0', 1, 1067),
	(3228, 'PRIMARY KEY 제약조건은 테이블당 여러 개 설정할 수 있다', b'1', 1, 1068),
	(3229, 'INSERT, UPDATE, DELETE 문이 수행될 때 자동으로 실행된다', b'0', 1, 1069),
	(3230, 'ORAC*L*E SQ*L*', b'1', 1, 1070),
	(3231, '엔터티는 업무적으로 관리가 필요한 정보여야 한다', b'0', 1, 1071),
	(3232, '유일성: 하나의 엔터티에서 인스턴스를 유일하게 구분할 수 있어야 한다', b'0', 1, 1072),
	(3233, '반드시 존재해야 하는 필수관계는 선으로 표시한다', b'0', 1, 1073),
	(3234, '삽입이상: 새로운 과목을 추가할 때 반드시 학생정보가 필요하다', b'0', 1, 1074),
	(3235, '반드시 속성을 가져야 한다', b'0', 1, 1075),
	(3236, '1:1 관계', b'0', 1, 1076),
	(3237, '데이터의 중복이 증가한다', b'0', 1, 1077),
	(3238, '엔터티명', b'0', 1, 1078),
	(3239, '특성에 따른 분류: 기본속성, 설계속성, 파생속성', b'0', 1, 1079),
	(3240, '데이터 양', b'0', 1, 1080),
	(3241, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO HAVING AVG(SALARY) > AVG(SALARY)', b'0', 1, 1081),
	(3242, '동일한 값에 대해서는 동일한 순위를 부여한다', b'0', 1, 1082),
	(3243, 'SQL', b'1', 1, 1083),
	(3244, '두 테이블의 곱집합을 반환한다', b'1', 1, 1084),
	(3245, 'SELECT YEAR(ORDER_DATE), MONTH(ORDER_DATE), SUM(ORDER_AMOUNT) FROM ORDERS GROUP BY ORDER_DATE', b'0', 1, 1085),
	(3246, 'NULL과의 산술연산은 ERROR를 발생시킨다', b'0', 1, 1086),
	(3247, 'WHERE 절을 생략하면 테이블의 모든 행이 삭제된다', b'0', 1, 1087),
	(3248, 'START WITH → CONNECT BY → WHERE → ORDER SIBLINGS BY', b'1', 1, 1088),
	(3249, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE WHERE SALARY >= 3000 GROUP BY DEPT_NO', b'0', 1, 1089),
	(3250, 'GROUP BY 절에서 Alias를 사용할 수 없다', b'1', 1, 1090),
	(3251, 'ALTER TABLE EMPLOYEE ADD DEPT_NO NUMBER(5) NOT NULL', b'0', 1, 1091),
	(3252, 'DISTINCT와 집계함수는 함께 사용할 수 없다', b'1', 1, 1092),
	(3253, 'FIRST_VALUE 함수는 파티션별 첫 번째 값을 구한다', b'0', 1, 1093),
	(3254, 'SELECT empno, sal, deptno FROM EMPLOYEES WHERE sal > (SELECT AVG(sal) FROM EMPLOYEES)', b'0', 1, 1094),
	(3255, 'Atomicity(원자성): 트랜잭션은 모두 실행되거나 모두 실행되지 않아야 한다', b'0', 1, 1095),
	(3256, 'COMMIT, ROLLBACK', b'0', 1, 1096),
	(3257, 'SQL##', b'0', 1, 1097),
	(3258, '인덱스는 테이블에 대한 조회 성능을 향상시킬 수 있다', b'0', 1, 1098),
	(3259, 'SELECT TO_CHAR(ORDER_DATE, \'\'MM\'\'), SUM(ORDER_AMOUNT) FROM ORDERS WHERE TO_CHAR(ORDER_DATE, \'\'YYYY\'\') = \'\'2023\'\' GROUP BY TO_CHAR(ORDER_DATE, \'\'MM\'\')', b'0', 1, 1099),
	(3260, '뷰는 물리적으로 데이터를 저장하지 않는다', b'0', 1, 1100),
	(3261, 'LEVEL', b'0', 1, 1101),
	(3262, '123.46, 123.00, 120.00', b'0', 1, 1102),
	(3263, 'SELECT SUBJECT, MAX(SCORE), NAME FROM SCORES GROUP BY SUBJECT', b'0', 1, 1103),
	(3264, 'COUNT(*) 함수는 NULL 값을 포함하여 모든 행의 수를 계산한다', b'0', 1, 1104),
	(3265, 'SELECT * FROM EMPLOYEES E1 WHERE HIRE_DATE = (SELECT MAX(HIRE_DATE) FROM EMPLOYEES E2 WHERE E1.DEPT_NO = E2.DEPT_NO)', b'1', 1, 1105),
	(3266, '2023/12/16 14:30:00  2023-12-16 SATURDAY  2023.12.16', b'1', 1, 1106),
	(3267, 'GROUP BY 절에서는 SELECT 절에 사용된 컬럼을 모두 포함해야 한다', b'0', 1, 1107),
	(3268, 'SELECT * FROM EMPLOYEES WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES)', b'0', 1, 1108),
	(3269, 'UNION은 중복된 행을 제거하지만, UNION ALL은 중복된 행을 포함한다', b'0', 1, 1109),
	(3270, '기본키(Primary Key) 컬럼', b'0', 1, 1110),
	(3271, 'DEPT 테이블의 모든 부서에 직원이 존재할 때', b'1', 1, 1111),
	(3272, 'SAME', b'1', 1, 1112),
	(3273, 'ROWS는 물리적인 행의 수를 기준으로 행 집합을 지정한다', b'0', 1, 1113),
	(3274, 'SELECT EMP_NO, COUNT(*) AS ABSENT_DAYS FROM ATTENDANCE GROUP BY EMP_NO', b'0', 1, 1114),
	(3275, '조건에 따라 INSERT, UPDATE, DELETE를 한 번에 처리할 수 있다', b'0', 1, 1115),
	(3276, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) OVER (ORDER BY SALE_DATE) AS CUM_SUM FROM SALES', b'0', 1, 1116),
	(3277, 'GROUP BY 절과 함께 사용할 수 없다', b'0', 1, 1117),
	(3278, 'SELECT * FROM (SELECT EMP_NO, DEPT_NO, SALARY, NAME, ROW_NUMBER() OVER (PARTITION BY DEPT_NO ORDER BY SALARY DESC) AS RN FROM EMPLOYEES) WHERE RN <= 2', b'1', 1, 1118),
	(3279, '1', b'0', 1, 1119),
	(3280, 'READ UNCOMMITTED는 가장 낮은 격리 수준이다', b'0', 1, 1120),
	(3281, '업무에서 필요한 정보이어야 한다', b'0', 1, 1121),
	(3282, '유일성 - 하나의 엔터티에서 인스턴스를 유일하게 구분할 수 있어야 한다', b'0', 1, 1122),
	(3283, '기본 엔터티', b'0', 1, 1123),
	(3284, '관계명', b'0', 1, 1124),
	(3285, '삽입 이상', b'0', 1, 1125),
	(3286, '반드시 부모 테이블의 기본키가 자식 테이블의 기본키가 되어야 한다', b'0', 1, 1126),
	(3287, '데이터의 중복을 제거한다', b'0', 1, 1127),
	(3288, '기본 속성', b'0', 1, 1128),
	(3289, '서브타입은 슈퍼타입의 속성을 상속받는다', b'0', 1, 1129),
	(3290, '속성이 가질 수 있는 값의 범위를 의미한다', b'0', 1, 1130),
	(3291, 'GROUP BY절에 사용된 컬럼은 SELECT절에도 동일하게 사용되어야 한다', b'0', 1, 1131),
	(3292, '5', b'0', 1, 1132),
	(3293, 'NVL(A,B): A가 NULL이면 B를 반환한다', b'0', 1, 1133),
	(3294, 'lo', b'0', 1, 1134),
	(3295, 'SELECT TO_CHAR(JOIN_DATE, \'MM\'), SUM(AMOUNT)\nFROM SALES\nWHERE JOIN_DATE LIKE \'2023%\'\nGROUP BY JOIN_DATE;', b'0', 1, 1135),
	(3296, '3행', b'1', 1, 1136),
	(3297, 'LEVEL', b'0', 1, 1137),
	(3298, 'ROLLUP은 지정된 컬럼의 소계를 생성한다', b'0', 1, 1138),
	(3299, 'SELECT문의 가장 마지막에 위치한다', b'0', 1, 1139),
	(3300, 'SELECT EMP_ID, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS RANK\nFROM EMP;', b'0', 1, 1140),
	(3301, 'SELECT DEPT_ID, MAX(SALARY)\nFROM EMP\nGROUP BY DEPT_ID;', b'0', 1, 1141),
	(3302, '조건을 만족하는 경우 UPDATE를 수행한다', b'0', 1, 1142),
	(3303, 'PREV_AMOUNT 열이 이전 달의 판매액을 보여준다', b'1', 1, 1143),
	(3304, 'Atomicity(원자성): 트랜잭션은 모두 실행되거나 전혀 실행되지 않아야 한다', b'0', 1, 1144),
	(3305, 'SELECT EMP_ID, MANAGER_ID, EMP_NAME\nFROM ORGANIZATION\nSTART WITH MANAGER_ID IS NULL\nCONNECT BY PRIOR EMP_ID = MANAGER_ID;', b'1', 1, 1145),
	(3306, 'GRANT', b'0', 1, 1146),
	(3307, '123.46, 123.0, 120', b'0', 1, 1147),
	(3308, 'SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 1, 1148),
	(3309, 'UNION은 중복을 제거하고, UNION ALL은 중복을 허용한다', b'0', 1, 1149),
	(3310, '테이블 생성 시 기본키에 대한 인덱스는 자동으로 생성된다', b'0', 1, 1150),
	(3311, 'SELECT *\nFROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC)\nWHERE ROWNUM <= 3;', b'0', 1, 1151),
	(3312, 'NULL과 숫자를 더하면 결과는 NULL이다', b'0', 1, 1152),
	(3313, 'ORACLE***\', \'***ORACLE\', \'ORACLE\'', b'1', 1, 1153),
	(3314, '4행(개별 그룹별 소계만)', b'0', 1, 1154),
	(3315, '동일 쿼리 내에서 반복적으로 사용할 수 있다', b'0', 1, 1155),
	(3316, '3, 6, 5', b'1', 1, 1156),
	(3317, 'WHERE 절에서 사용할 수 있다', b'1', 1, 1157),
	(3318, 'SELECT DECODE(STATUS, 1, \'신규\', 2, \'진행\', 3, \'완료\', \'기타\') FROM PRODUCT;', b'0', 1, 1158),
	(3319, 'FROM 절에서 사용되는 서브쿼리이다', b'0', 1, 1159),
	(3320, '2', b'0', 1, 1160),
	(3321, 'SELECT DEPT_ID, AVG(SALARY)\nFROM EMP\nGROUP BY DEPT_ID\nHAVING AVG(SALARY) > AVG(SALARY);', b'0', 1, 1161),
	(3322, 'SELECT *\nFROM SALES\nPIVOT(SUM(AMOUNT) FOR QUARTER IN (\'Q1\', \'Q2\'));', b'0', 1, 1162),
	(3323, 'READ UNCOMMITTED는 가장 낮은 격리 수준이다', b'0', 1, 1163),
	(3324, 'LEVEL  CONNECT_BY_ISLEAF\n------------------------\n1      0\n2      0\n3      1', b'1', 1, 1164),
	(3325, 'SELECT DEPT_ID, SUM(SALARY + BONUS)\nFROM EMPLOYEE\nGROUP BY DEPT_ID;', b'0', 1, 1165),
	(3326, '참조하는 테이블의 컬럼은 UNIQUE나 PRIMARY KEY 제약조건이 있어야 한다', b'0', 1, 1166),
	(3327, '대량의 INSERT 시 인덱스를 삭제했다가 다시 생성한다', b'0', 1, 1167),
	(3328, 'SELECT MIN(NUM), MAX(NUM)\nFROM NUMBERS N1\nWHERE NOT EXISTS (\n    SELECT 1 FROM NUMBERS N2\n    WHERE N2.NUM = N1.NUM + 1\n);', b'0', 1, 1168),
	(3329, 'WITH CHECK OPTION을 사용하면 뷰의 조건에 위배되는 DML을 막을 수 있다', b'0', 1, 1169),
	(3330, '2024-01-02, 2024-03-01, 2', b'1', 1, 1170),
	(3331, '업무에서 필요로 하는 정보여야 한다', b'0', 1, 1171),
	(3332, '하나의 속성은 여러 개의 값을 가질 수 있다', b'0', 1, 1172),
	(3333, '하나의 고객은 여러 개의 주문을 할 수 있다', b'0', 1, 1173),
	(3334, '기본 속성', b'0', 1, 1174),
	(3335, '업무에서 자주 이용되는 속성으로 지정한다', b'0', 1, 1175),
	(3336, '데이터의 중복을 제거하여 일관성을 확보한다', b'0', 1, 1176),
	(3337, '데이터 볼륨', b'0', 1, 1177),
	(3338, '식별관계에서는 부모 테이블의 기본키가 자식 테이블의 일반 컬럼으로 전이된다', b'0', 1, 1178),
	(3339, '속성이 가질 수 있는 값의 범위를 의미한다', b'0', 1, 1179),
	(3340, '조회 성능이 중요한 경우', b'0', 1, 1180),
	(3341, 'SELECT DEPT_ID, MAX(SALARY)\nFROM EMPLOYEE\nGROUP BY DEPT_ID;', b'0', 1, 1181),
	(3342, 'GROUP BY 절에 컬럼 별칭(Alias)을 사용할 수 있다', b'0', 1, 1182),
	(3343, 'QL', b'0', 1, 1183),
	(3344, '2행이 조회된다', b'0', 1, 1184),
	(3345, 'ORDER BY 절에서 사용할 수 있다', b'0', 1, 1185),
	(3346, 'TRUE', b'0', 1, 1186),
	(3347, 'INSERT와 UPDATE를 한 번에 처리할 수 있다', b'0', 1, 1187),
	(3348, '1, 2, 3', b'1', 1, 1188),
	(3349, 'UNION ALL은 중복을 제거한다', b'0', 1, 1189),
	(3350, 'SELECT STUDENT_ID, MIN(ABSENT_DATE), MAX(ABSENT_DATE)\nFROM ATTENDANCE\nGROUP BY STUDENT_ID;', b'0', 1, 1190),
	(3351, '오류가 발생한다', b'1', 1, 1191),
	(3352, '재귀적 쿼리를 작성할 수 있다', b'0', 1, 1192),
	(3353, 'SQL Developer ****', b'1', 1, 1193),
	(3354, 'ORDER BY 고객번호, 주문금액, 주문일자', b'0', 1, 1194),
	(3355, '인덱스 컬럼이 WHERE 절에서 \'=\' 연산자로 비교될 때', b'0', 1, 1195),
	(3356, 'INSERT INTO TEST(ID, NAME) VALUES (1, \'AAA\');', b'0', 1, 1196),
	(3357, 'NOW 컬럼과 AFTER_1HOUR 컬럼의 차이는 정확히 1시간이다', b'1', 1, 1197),
	(3358, 'SELECT DISTINCT COL1, COL2 FROM TABLE1;', b'0', 1, 1198),
	(3359, 'SELECT *\nFROM EMP E1\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM EMP E2\n    WHERE E2.DEPT_ID = E1.DEPT_ID\n    AND E2.SALARY > E1.SALARY\n);', b'0', 1, 1199),
	(3360, '데이터베이스의 물리적인 저장 구조이다', b'0', 1, 1200),
	(3361, 'SELECT LEVEL, NAME\nFROM EMPLOYEE\nSTART WITH MANAGER_ID IS NULL\nCONNECT BY PRIOR EMP_ID = MANAGER_ID;', b'1', 1, 1201),
	(3362, 'NEXTVAL을 사용하면 다음 순번을 가져올 수 있다', b'0', 1, 1202),
	(3363, '5, 2', b'0', 1, 1203),
	(3364, '10: 김사원,이사원 / 20: 박사원,최사원 / 30: 정사원', b'1', 1, 1204),
	(3365, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'1', 1, 1205),
	(3366, '두 결과는 동일하다', b'1', 1, 1206),
	(3367, 'SELECT * FROM TRANSACTIONS\nWHERE ROWNUM <= 3\nORDER BY TRANS_DATE DESC;', b'0', 1, 1207),
	(3368, 'NULL + 숫자는 NULL이다', b'0', 1, 1208),
	(3369, 'GRANT', b'0', 1, 1209),
	(3370, '123.46, 123.0, 120.0', b'0', 1, 1210),
	(3371, 'SELECT *\nFROM SALES\nPIVOT (\n    SUM(AMOUNT)\n    FOR YEAR IN (2023, 2024)\n)\nORDER BY DEPT;', b'0', 1, 1211),
	(3372, '인덱스는 테이블과 독립적으로 존재한다', b'0', 1, 1212),
	(3373, '계층형 구조를 들여쓰기 없이 표시한다', b'0', 1, 1213),
	(3374, 'NOLOGGING 옵션 사용하기', b'0', 1, 1214),
	(3375, 'SELECT SALE_DATE, AMOUNT,\n       SUM(AMOUNT) OVER (ORDER BY SALE_DATE)\nFROM SALES;', b'1', 1, 1215),
	(3376, '실제 데이터를 저장하지 않는다', b'0', 1, 1216),
	(3377, '첫 번째 INSERT만 성공한다', b'0', 1, 1217),
	(3378, 'ROLLUP은 계층적 집계를 생성하고, CUBE는 모든 가능한 조합의 집계를 생성한다', b'1', 1, 1218),
	(3379, 'SELECT * FROM EMP E\nWHERE SALARY > (SELECT AVG(SALARY)\n                FROM EMP\n                WHERE DEPT_ID = E.DEPT_ID);', b'1', 1, 1219),
	(3380, 'A', b'1', 1, 1220),
	(3381, '추상화 - 현실세계를 일정한 형식에 맞추어 표현한다', b'0', 1, 1221),
	(3382, '두 엔터티간의 관계명을 서술한다', b'0', 1, 1222),
	(3383, '유일성 - 하나의 엔터티 내에서 인스턴스를 유일하게 구분할 수 있어야 한다', b'0', 1, 1223),
	(3384, '발생시점에 따른 분류 - 기본/중심/행위 엔터티', b'0', 1, 1224),
	(3385, '기본 속성', b'0', 1, 1225),
	(3386, '삽입 이상', b'0', 1, 1226),
	(3387, '존재적 종속관계를 표현한다', b'0', 1, 1227),
	(3388, '조회 성능이 중요한 경우', b'0', 1, 1228),
	(3389, '강한 연관관계를 표현하고자 할 때', b'0', 1, 1229),
	(3390, '새로운 관계엔터티를 생성한다', b'1', 1, 1230),
	(3391, 'SELECT DEPT_ID, MAX(SALARY), NAME FROM EMPLOYEE GROUP BY DEPT_ID;', b'0', 1, 1231),
	(3392, 'ROLLUP은 계층 구조로 소계를 계산하고, CUBE는 모든 가능한 조합의 소계를 계산한다', b'1', 1, 1232),
	(3393, 'AADDCC, AADDEE', b'1', 1, 1233),
	(3394, 'SELECT D.DEPT_NAME, E.EMP_NAME FROM DEPT D, EMP E WHERE D.DEPT_ID = E.DEPT_ID(+);', b'0', 1, 1234),
	(3395, 'WHERE 절을 생략하면 테이블의 모든 행이 삭제된다', b'0', 1, 1235),
	(3396, 'NUM  PREV_NUM  NEXT_NUM\n1    0         2\n2    1         3\n3    2         0', b'1', 1, 1236),
	(3397, 'LIKE', b'0', 1, 1237),
	(3398, 'SYSDATE는 현재 날짜와 시간을 반환한다', b'0', 1, 1238),
	(3399, 'SELECT * FROM EMPLOYEE WHERE SALARY > AVG(SALARY) GROUP BY DEPT_ID;', b'0', 1, 1239),
	(3400, 'NULL과의 산술 연산 결과는 NULL이다', b'0', 1, 1240),
	(3401, 'LEVEL  ISLEAF\n1      1\n2      1\n3      1', b'0', 1, 1241),
	(3402, '동일 쿼리 내에서 반복적으로 사용할 수 있다', b'0', 1, 1242),
	(3403, 'TARGET_TBL의 모든 데이터를 삭제할 때', b'0', 1, 1243),
	(3404, '조회 조건으로 자주 사용되는 컬럼', b'0', 1, 1244),
	(3405, '두 INSERT문 모두 성공한다', b'0', 1, 1245),
	(3406, 'Atomicity는 트랜잭션이 모두 실행되거나 전혀 실행되지 않아야 한다', b'0', 1, 1246),
	(3407, '123.45, \'123.45\', \'2024-01-01\'', b'0', 1, 1247),
	(3408, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) OVER (ORDER BY SALE_DATE) FROM SALES;', b'1', 1, 1248),
	(3409, 'CREATE', b'0', 1, 1249),
	(3410, 'NVL(A,B)은 A가 NULL이면 B를 반환한다', b'0', 1, 1250),
	(3411, 'SELECT EMP_ID, DEPT_ID, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS RANK FROM EMPLOYEE;', b'0', 1, 1251),
	(3412, '서브쿼리가 반환하는 결과의 존재 여부를 확인한다', b'0', 1, 1252),
	(3413, '1, 4, 3, 3.6', b'1', 1, 1253),
	(3414, 'GROUP BY절에 있는 컬럼이 SELECT절에 반드시 포함되어야 한다', b'1', 1, 1254),
	(3415, 'DELETE FROM DUPLICATE_DATA WHERE ROWID NOT IN (SELECT MIN(ROWID) FROM DUPLICATE_DATA GROUP BY ID, NAME, VALUE);', b'1', 1, 1255),
	(3416, 'INNER JOIN은 양쪽 테이블에 모두 존재하는 데이터만 조회한다', b'0', 1, 1256),
	(3417, '현재 날짜의 연, 월, 일이 문자형으로 출력된다', b'0', 1, 1257),
	(3418, '단일 행 서브쿼리는 하나의 행만 반환한다', b'0', 1, 1258),
	(3419, 'Q1    Q2\n2500  4500', b'1', 1, 1259),
	(3420, 'READ UNCOMMITTED', b'0', 1, 1260),
	(3421, 'SELECT MONTH, AMOUNT, ROUND((AMOUNT - LAG(AMOUNT) OVER (ORDER BY MONTH)) / LAG(AMOUNT) OVER (ORDER BY MONTH) * 100, 2) AS RATE FROM SALES;', b'1', 1, 1261),
	(3422, '데이터베이스의 물리적인 저장 구조이다', b'0', 1, 1262),
	(3423, 'LEVEL  EMP_NAME\n1      김사장\n2      이부장\n2      박부장\n3      최대리', b'0', 1, 1263),
	(3424, 'MEMBER 테이블의 모든 데이터를 삭제할 때', b'0', 1, 1264),
	(3425, '기본키에는 자동으로 인덱스가 생성된다', b'0', 1, 1265),
	(3426, 'SELECT * FROM (SELECT * FROM EMP ORDER BY HIRE_DATE DESC) WHERE ROWNUM <= 3;', b'0', 1, 1266),
	(3427, '5, 9, 0', b'1', 1, 1267),
	(3428, 'COMMIT 이후에는 ROLLBACK이 불가능하다', b'0', 1, 1268),
	(3429, 'SELECT DEPT_ID, POSITION, AVG(SALARY) OVER (PARTITION BY DEPT_ID, POSITION) FROM EMP;', b'0', 1, 1269),
	(3430, '절차적 프로그래밍이 가능하다', b'0', 1, 1270),
	(3431, '유형 엔터티와 개념 엔터티', b'0', 1, 1271),
	(3432, '기본 엔터티', b'0', 1, 1272),
	(3433, '관계명', b'0', 1, 1273),
	(3434, '유일성 - 하나의 엔터티에서 인스턴스를 유일하게 구분', b'0', 1, 1274),
	(3435, '삽입 이상', b'0', 1, 1275),
	(3436, '관계는 엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 행위로서 서로에게 연관성이 부여된 상태', b'0', 1, 1276),
	(3437, '하나의 속성이 취할 수 있는 동일한 유형의 값들의 집합', b'0', 1, 1277),
	(3438, '한 학생은 여러 개의 수강내역을 가질 수 있다', b'0', 1, 1278),
	(3439, '부모 테이블의 기본키가 자식 테이블의 기본키로 전이되지 않는다', b'0', 1, 1279),
	(3440, '슈퍼타입/서브타입 모델링은 공통의 부분을 슈퍼타입으로 모델링하여 여러 엔터티에서 반복되는 속성을 제거할 수 있다', b'0', 1, 1280),
	(3441, 'WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'0', 1, 1281),
	(3442, '5000, 5, 3', b'1', 1, 1282),
	(3443, 'NVL(expr1, expr2): expr1이 NULL이면 expr2를 반환', b'0', 1, 1283),
	(3444, 'SELECT DISTINCT DEPTNO FROM EMP;', b'0', 1, 1284),
	(3445, 'ROWS는 물리적인 단위로 행 집합을 지정', b'0', 1, 1285),
	(3446, 'TableA INNER JOIN TableB', b'0', 1, 1286),
	(3447, 'Atomicity(원자성): 트랜잭션은 모두 실행되거나 모두 실행되지 않아야 함', b'0', 1, 1287),
	(3448, 'LEVEL', b'0', 1, 1288),
	(3449, '2023, 300, 700', b'1', 1, 1289),
	(3450, '인덱스는 테이블 검색 속도를 향상시키기 위한 자료구조이다', b'0', 1, 1290),
	(3451, '스칼라 서브쿼리는 메인쿼리의 칼럼처럼 사용 가능하다', b'0', 1, 1291),
	(3452, 'B, 2, 1, 75, 150', b'1', 1, 1292),
	(3453, 'SELECT * FROM EMP A WHERE SAL = (SELECT MAX(SAL) FROM EMP B WHERE A.DEPTNO = B.DEPTNO);', b'0', 1, 1293),
	(3454, 'ID | VALUE\n1  | X\n2  | B\n3  | C', b'1', 1, 1294),
	(3455, 'FIRST_VALUE 함수는 파티션별 윈도우에서 가장 먼저 나온 값을 구한다', b'0', 1, 1295),
	(3456, '3, 3, 3', b'0', 1, 1296),
	(3457, 'INSERT INTO TEST_TABLE VALUES (1, \'Kim\', 20);', b'0', 1, 1297),
	(3458, 'READ UNCOMMITTED는 가장 낮은 격리수준이다', b'0', 1, 1298),
	(3459, 'INNER JOIN', b'0', 1, 1299),
	(3460, '루트 노드부터 시작하여 하위 방향으로 전개된다', b'0', 1, 1300),
	(3461, 'GROUP BY 절에서는 Alias를 사용할 수 있다', b'0', 1, 1301),
	(3462, 'MONTH | TOTAL\n00    | 400\n01    | 100\n02    | 200\n03    | 300', b'1', 1, 1302),
	(3463, 'UNION은 중복된 행을 제거하지만, UNION ALL은 중복된 행을 모두 포함한다', b'0', 1, 1303),
	(3464, 'PRIMARY KEY 제약조건은 테이블당 여러 개 설정할 수 있다', b'1', 1, 1304),
	(3465, '격검', b'1', 1, 1305),
	(3466, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE);', b'0', 1, 1306),
	(3467, 'Commit은 변경사항을 데이터베이스에 영구적으로 반영한다', b'0', 1, 1307),
	(3468, '들여쓰기 없이 모든 EMPNO가 같은 위치에 출력된다', b'0', 1, 1308),
	(3469, 'WHERE 절에서 컬럼에 함수를 적용한 경우', b'1', 1, 1309),
	(3470, 'SELECT * FROM EMPLOYEE E WHERE SAL = (SELECT MAX(SAL) FROM EMPLOYEE WHERE DEPTNO = E.DEPTNO);', b'0', 1, 1310),
	(3471, 'COMMIT, ROLLBACK', b'0', 1, 1311),
	(3472, 'YEAR | MONTH | AMOUNT | RESULT\n2023 | 01    | 100    | 100\n2023 | 02    | 200    | 300\n2023 | 03    | 300    | 500', b'1', 1, 1312),
	(3473, '컬럼 추가는 ADD COLUMN 구문을 사용한다', b'0', 1, 1313),
	(3474, 'ABC123', b'1', 1, 1314),
	(3475, 'Dirty Read', b'0', 1, 1315),
	(3476, 'CREATE TABLE DEPT (\n    DEPTNO NUMBER(4),\n    DNAME VARCHAR2(14),\n    LOC VARCHAR2(13),\n    CONSTRAINT DEPT_PK PRIMARY KEY (DEPTNO)\n);', b'0', 1, 1316),
	(3477, 'SYSDATE는 현재 날짜와 시간을 반환한다', b'0', 1, 1317),
	(3478, 'SELECT EMPNO, DEPTNO, SAL,\n       RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS RNK\nFROM EMP;', b'0', 1, 1318),
	(3479, 'Oracle에서는 ROWNUM을 사용하여 구현할 수 있다', b'0', 1, 1319),
	(3480, '공유 락(Shared Lock)은 읽기 작업 시 사용된다', b'0', 1, 1320),
	(3904, '리뷰댓글(댓글번호, 리뷰번호, 회원번호, 내용, 작성일자, 수정일자)', b'0', 2, 721),
	(3905, '상품가격(변경일자, 변경금액, 상태) → CHECK (상태 IN (\'적용\', \'보류\', \'취소\'))', b'0', 2, 722),
	(3906, '주문상세와 주문취소이력을 별도 엔터티로 분리하여 설계', b'1', 2, 723),
	(3907, '(회원번호, 배송지명)', b'0', 2, 724),
	(3908, '환자 테이블의 누적진료횟수', b'0', 2, 725),
	(3909, '주문과 주문상품의 관계', b'0', 2, 726),
	(3910, '결제수단(슈퍼타입) - 신용카드/계좌이체/포인트(서브타입): 선택적 서브타입', b'0', 2, 727),
	(3911, '상품의 리뷰 수와 평균 평점을 자주 조회하는 경우', b'0', 2, 728),
	(3912, '별도의 로그인이력번호를 생성', b'1', 2, 729),
	(3913, '패키지출발일(상품코드, 출발일자, 예약가능인원, 확정여부)', b'0', 2, 730),
	(3914, 'SELECT SALES_MONTH, TOTAL_AMOUNT FROM SALES_MONTHLY A WHERE TOTAL_AMOUNT >= (SELECT TOTAL_AMOUNT * 1.1 FROM SALES_MONTHLY B WHERE TO_NUMBER(B.SALES_MONTH) = TO_NUMBER(A.SALES_MONTH) - 1)', b'0', 2, 731),
	(3915, 'DEPT_NO  EMP_COUNT  TOTAL_SALARY  AVG_BONUS\n-------------------------------------------\n10       2          8000          500\n30       1          4500          700', b'0', 2, 732),
	(3916, 'SELECT * FROM EMPLOYEE E, (SELECT DEPT_NO, AVG(SALARY) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_NO) D WHERE E.DEPT_NO = D.DEPT_NO AND E.SALARY > D.AVG_SAL', b'1', 2, 733),
	(3917, 'UNION을 사용할 때 SELECT절의 칼럼 개수와 데이터 타입이 일치해야 한다', b'0', 2, 734),
	(3918, 'SELECT order_date FROM orders a WHERE NOT EXISTS (SELECT 1 FROM orders b WHERE b.order_date BETWEEN a.order_date AND a.order_date + 3)', b'0', 2, 735),
	(3919, 'SELECT * FROM EMPLOYEE E WHERE (DEPT_NO, SALARY) IN (SELECT DEPT_NO, MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO)', b'0', 2, 736),
	(3920, 'SELECT PROD_ID, TRX_DATE, SUM(DECODE(TRX_TYPE, \'\'IN\'\', QUANTITY, \'\'OUT\'\', -QUANTITY, 0)) OVER (PARTITION BY PROD_ID ORDER BY TRX_DATE RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as STOCK_QTY FROM STOCK_HISTORY', b'0', 2, 737),
	(3921, 'INSERT SELECT 구문을 사용하면 SELECT 문의 결과를 테이블에 입력할 수 있다', b'0', 2, 738),
	(3922, 'START WITH DEPT_ID IN (2,3) CONNECT BY PRIOR PARENT_DEPT_ID = DEPT_ID', b'1', 2, 739),
	(3923, 'DDL 문장을 실행하면 이전까지의 트랜잭션이 자동으로 COMMIT된다', b'0', 2, 740),
	(3924, 'RANK() OVER (PARTITION BY DEPT_NO ORDER BY SALARY DESC) AS RANK', b'1', 2, 741),
	(3925, 'SELECT ORDER_DATE, PRODUCT_ID, QUANTITY FROM (SELECT ORDER_DATE, PRODUCT_ID, QUANTITY, RANK() OVER (PARTITION BY ORDER_DATE ORDER BY QUANTITY DESC) AS RNK FROM SALES) WHERE RNK = 1', b'1', 2, 742),
	(3926, 'ALTER TABLE employee ADD (address VARCHAR2(100))', b'0', 2, 743),
	(3927, 'SELECT DEPT_NO, MAX(SALARY) - MIN(SALARY) AS SALARY_GAP FROM EMPLOYEE GROUP BY DEPT_NO HAVING MAX(SALARY) - MIN(SALARY) >= 5000', b'1', 2, 744),
	(3928, 'MERGE TARGET_TBL T USING SOURCE_TBL S ON T.PROD_ID = S.PROD_ID WHEN MATCHED THEN UPDATE SET STOCK_QTY = S.STOCK_QTY WHEN NOT MATCHED THEN INSERT VALUES (S.PROD_ID, S.PROD_NAME, S.STOCK_QTY)', b'0', 2, 745),
	(3929, 'SELECT USER_ID FROM LOGIN_HISTORY WHERE SUCCESS_YN = \'\'N\'\' GROUP BY USER_ID HAVING COUNT(*) >= 3', b'0', 2, 746),
	(3930, 'SELECT PROD_ID FROM PURCHASES WHERE CUST_ID IN (SELECT CUST_ID FROM PURCHASES WHERE PROD_ID = \'\'A001\'\') AND PROD_ID != \'\'A001\'\'', b'0', 2, 747),
	(3931, 'WHERE hire_date >= TO_DATE(\'2024-01-01\', \'YYYY-MM-DD\')', b'0', 2, 748),
	(3932, 'SELECT s1.SALES_MONTH, s1.AMOUNT, ROUND((s1.AMOUNT - s2.AMOUNT) / s2.AMOUNT * 100, 2) AS GROWTH_RATE FROM SALES s1, SALES s2 WHERE s1.SALES_MONTH = s2.SALES_MONTH + 1', b'0', 2, 749),
	(3933, '참조하는 테이블(자식)과 참조되는 테이블(부모)의 데이터 타입이 반드시 동일해야 한다', b'1', 2, 750),
	(3934, '2023년 데이터 ∪ (2024년 데이터 ∩ 2022년 데이터)', b'1', 2, 751),
	(3935, 'WITH AVG_SAL AS (SELECT DEPT_NO, AVG(SALARY) AS AVG_SALARY FROM EMPLOYEE GROUP BY DEPT_NO) SELECT E.DEPT_NO, COUNT(*) FROM EMPLOYEE E JOIN AVG_SAL A ON E.DEPT_NO = A.DEPT_NO WHERE E.SALARY > A.AVG_SALARY GROUP BY E.DEPT_NO', b'1', 2, 752),
	(3936, 'SELECT p.POST_ID, p.TITLE, COUNT(r.POST_ID) AS reply_count FROM BOARD p LEFT JOIN BOARD r ON p.POST_ID = r.PARENT_ID WHERE p.PARENT_ID IS NULL GROUP BY p.POST_ID, p.TITLE', b'0', 2, 753),
	(3937, 'GROUP BY 절에 없는 컬럼이라도 집계함수로 감싸면 SELECT 절에 사용할 수 있다', b'0', 2, 754),
	(3938, 'SELECT DEPT_NO, COUNT(CASE WHEN SALARY_GRADE = \'\'A\'\' THEN 1 END) AS A_CNT, COUNT(CASE WHEN SALARY_GRADE = \'\'B\'\' THEN 1 END) AS B_CNT, COUNT(CASE WHEN SALARY_GRADE = \'\'C\'\' THEN 1 END) AS C_CNT FROM EMPLOYEE GROUP BY DEPT_NO', b'0', 2, 755),
	(3939, 'SELECT REGION, PRODUCT, SUM(QUANTITY) FROM SALES GROUP BY REGION, ROLLUP(PRODUCT)', b'0', 2, 756),
	(3940, 'EXTRACT(YEAR FROM SYSDATE) - EXTRACT(YEAR FROM HIRE_DATE) AS YEARS', b'0', 2, 757),
	(3941, 'Consistency는 트랜잭션 수행 후에도 데이터베이스가 일관된 상태를 유지해야 함을 의미한다', b'0', 2, 758),
	(3942, '카디널리티(Cardinality)가 높은 컬럼에 인덱스를 생성하는 것이 효율적이다', b'0', 2, 759),
	(3943, 'SELECT p2.PROD_ID, p2.PROD_NAME FROM PRODUCTS p2 WHERE p2.CATEGORY IN (SELECT CATEGORY FROM PRODUCTS WHERE PROD_ID IN (SELECT PROD_ID FROM PURCHASES WHERE ORDER_DATE = (SELECT MAX(ORDER_DATE) FROM PURCHASES)))', b'0', 2, 760),
	(3944, 'SELECT DISTINCT a1.STUDENT_ID FROM ATTENDANCE a1 WHERE EXISTS (SELECT 1 FROM ATTENDANCE a2 WHERE a1.STUDENT_ID = a2.STUDENT_ID AND a2.STATUS = \'결석\' GROUP BY a2.ATT_DATE, a2.STUDENT_ID HAVING COUNT(*) >= 3)', b'0', 2, 761),
	(3945, 'SELECT DEPT_NO, COUNT(CASE WHEN POSITION = \'사원\' THEN 1 END) AS 사원, COUNT(CASE WHEN POSITION = \'대리\' THEN 1 END) AS 대리, COUNT(CASE WHEN POSITION = \'과장\' THEN 1 END) AS 과장 FROM EMPLOYEE GROUP BY DEPT_NO', b'0', 2, 762),
	(3946, 'SELECT s1.SALES_DATE, s1.AMOUNT FROM DAILY_SALES s1 WHERE s1.AMOUNT >= (SELECT AVG(s2.AMOUNT) * 1.2 FROM DAILY_SALES s2 WHERE s2.SALES_DATE BETWEEN s1.SALES_DATE - 7 AND s1.SALES_DATE - 1)', b'0', 2, 763),
	(3947, 'SELECT DEPT_NO, SALARY_MONTH, MIN_SALARY FROM (SELECT DEPT_NO, SALARY_MONTH, MIN_SALARY, LAG(MIN_SALARY) OVER (PARTITION BY DEPT_NO ORDER BY SALARY_MONTH) AS PREV_MIN FROM SALARY_HISTORY) WHERE MIN_SALARY > PREV_MIN', b'1', 2, 764),
	(3948, 'RANK() OVER (PARTITION BY DEPT_NO ORDER BY SALARY DESC) AS RNK', b'1', 2, 765),
	(3949, 'LAST_LOGIN_DATE <= SYSDATE - 30', b'0', 2, 766),
	(3950, 'SELECT TO_CHAR(PURCHASE_DATE, \'YYYY-MM\') AS MONTH, COUNT(CASE WHEN PURCHASE_DATE = MIN_DATE THEN 1 END) AS FIRST_PURCHASE, COUNT(CASE WHEN PURCHASE_DATE = MAX_DATE THEN 1 END) AS LAST_PURCHASE FROM CUSTOMER_PURCHASE cp JOIN (SELECT CUST_ID, MIN(PURCHASE_DATE) AS MIN_DATE, MAX(PURCHASE_DATE) AS MAX_DATE FROM CUSTOMER_PURCHASE GROUP BY CUST_ID) m ON cp.CUST_ID = m.CUST_ID GROUP BY TO_CHAR(PURCHASE_DATE, \'YYYY-MM\')', b'0', 2, 767),
	(3951, 'SELECT PROD_ID, SALES_MONTH, QUANTITY, (LAG(QUANTITY, 1) OVER (ORDER BY SALES_MONTH) + LAG(QUANTITY, 2) OVER (ORDER BY SALES_MONTH) + LAG(QUANTITY, 3) OVER (ORDER BY SALES_MONTH)) / 3 AS AVG_3M FROM SALES', b'0', 2, 768),
	(3952, 'SELECT s1.SALES_DATE, s1.AMOUNT FROM DAILY_SALES s1 WHERE s1.AMOUNT >= (SELECT AVG(s2.AMOUNT) * 1.2 FROM DAILY_SALES s2 WHERE s2.SALES_DATE BETWEEN s1.SALES_DATE - 7 AND s1.SALES_DATE - 1)', b'1', 2, 769),
	(3953, 'SELECT DEPT_NO, YM FROM (SELECT DEPT_NO, YM, AVG_SALARY, COUNT(*) OVER (PARTITION BY DEPT_NO ORDER BY YM ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS CNT, MIN(AVG_SALARY) OVER (PARTITION BY DEPT_NO ORDER BY YM ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS MIN_SAL, MAX(AVG_SALARY) OVER (PARTITION BY DEPT_NO ORDER BY YM ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS MAX_SAL FROM MONTHLY_SALARY) WHERE CNT = 3 AND MIN_SAL < MAX_SAL', b'0', 2, 770),
	(3954, '시스템이 목표하는 정보의 집합을 엔터티로 도출한다.', b'0', 2, 771),
	(3955, '인스턴스는 엔터티에 속하는 개별적인 객체들이다.', b'0', 2, 772),
	(3956, '제1정규화는 복합 속성을 분해하는 것이다.', b'0', 2, 773),
	(3957, '하나의 속성은 하나의 값만 가진다.', b'0', 2, 774),
	(3958, '관계의 참여도는 항상 1:1이어야 한다.', b'0', 2, 775),
	(3959, '자식 엔터티의 주식별자는 부모 엔터티와 무관하게 결정된다.', b'0', 2, 776),
	(3960, '하나의 슈퍼타입은 여러 개의 서브타입을 가질 수 있다.', b'0', 2, 777),
	(3961, '중심 엔터티', b'0', 2, 778),
	(3962, '정규화', b'0', 2, 779),
	(3963, '관계는 마름모로 표현한다.', b'0', 2, 780),
	(3964, 'ALTER', b'0', 2, 781),
	(3965, '자격', b'1', 2, 782),
	(3966, 'WHERE절은 GROUP BY절 앞에 위치해야 한다.', b'0', 2, 783),
	(3967, '3행', b'0', 2, 784),
	(3968, 'NULLIF 함수는 두 개의 값이 같으면 NULL을 반환한다.', b'0', 2, 785),
	(3969, 'SELECT TO_CHAR(SYSDATE, \'YYYY\') - ROWNUM FROM DUAL', b'0', 2, 786),
	(3970, '4행', b'1', 2, 787),
	(3971, 'ROW_NUMBER 함수는 동일한 값이라도 고유한 순위를 부여한다.', b'0', 2, 788),
	(3972, '중복된 행은 한 번만 표시된다.', b'0', 2, 789),
	(3973, 'SELECT MAX(NVL(VALUE,0)) FROM SCORE;', b'0', 2, 790),
	(3974, 'CREATE', b'0', 2, 791),
	(3975, '4행', b'0', 2, 792),
	(3976, 'CONNECT_BY_ISLEAF', b'0', 2, 793),
	(3977, 'IN절', b'0', 2, 794),
	(3978, 'SELECT * FROM EMPLOYEE WHERE DEPT_ID IN (SELECT DEPT_ID FROM EMPLOYEE WHERE SALARY >= 4000)', b'0', 2, 795),
	(3979, 'Consistency', b'0', 2, 796),
	(3980, 'MONTHS_BETWEEN(date1, date2): 두 날짜 간의 월 수 차이를 구한다', b'0', 2, 797),
	(3981, 'NULL 값을 허용한다', b'0', 2, 798),
	(3982, 'RANK() OVER (ORDER BY VALUE DESC)', b'1', 2, 799),
	(3983, '3행', b'0', 2, 800),
	(3984, '동일 블록에서 반복적으로 사용할 수 있다', b'0', 2, 801),
	(3985, '80', b'1', 2, 802),
	(3986, 'PRIMARY KEY 제약조건을 정의하면 자동으로 인덱스가 생성된다', b'0', 2, 803),
	(3987, 'B', b'1', 2, 804),
	(3988, 'SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 2, 805),
	(3989, '2행', b'0', 2, 806),
	(3990, '전체 데이터를 파티션으로 나누는 역할을 한다', b'1', 2, 807),
	(3991, '3.46, 3, 345', b'0', 2, 808),
	(3992, 'SELECT * FROM (SELECT * FROM EMPLOYEE WHERE ROWNUM <= (SELECT COUNT(*) * 0.2 FROM EMPLOYEE))', b'1', 2, 809),
	(3993, '테이블과 별도로 데이터베이스에 저장된다', b'0', 2, 810),
	(3994, 'AFTER DELETE', b'0', 2, 811),
	(3995, '4행', b'0', 2, 812),
	(3996, '/*+ FULL */', b'0', 2, 813),
	(3997, 'SELECT * FROM EMPLOYEE WHERE (DEPT_ID, SALARY) IN (SELECT DEPT_ID, MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID)', b'1', 2, 814),
	(3998, 'ROWNUM은 WHERE 절에서만 사용할 수 있다', b'1', 2, 815),
	(3999, 'WHERE 절에 집계함수를 사용할 수 없어서', b'1', 2, 816),
	(4000, 'SYS_CONNECT_BY_PATH', b'0', 2, 817),
	(4001, 'Apple\n   Orange\n   Banana', b'0', 2, 818),
	(4002, 'ON 절에서 조인 조건을 지정한다', b'0', 2, 819),
	(4003, 'ENCRYPT 키워드 사용', b'0', 2, 820),
	(4004, '식별이 가능한 이름이 있어야 한다.', b'0', 2, 821),
	(4005, '관계 차수는 1:1 관계가 된다.', b'0', 2, 822),
	(4006, '설계속성', b'0', 2, 823),
	(4007, '명사구로 정의되어야 한다.', b'0', 2, 824),
	(4008, '2차 정규화', b'0', 2, 825),
	(4009, '업무상 관리하고자 하는 개념이어야 한다.', b'0', 2, 826),
	(4010, '점선 표현', b'0', 2, 827),
	(4011, '다른 엔터티와 최소 한 개 이상의 관계를 맺어야 한다.', b'1', 2, 828),
	(4012, '포괄적 관계는 서브타입 중 여러 개 선택이 가능하다.', b'0', 2, 829),
	(4013, '이행 함수적 종속성 제거', b'1', 2, 830),
	(4014, 'NULL과 비교연산의 결과는 FALSE이다.', b'1', 2, 831),
	(4015, 'SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY', b'1', 2, 832),
	(4016, 'Pro', b'1', 2, 833),
	(4017, 'HAVING dept_id = 10', b'1', 2, 834),
	(4018, 'COUNT(*)', b'1', 2, 835),
	(4019, 'GRANT, REVOKE', b'1', 2, 836),
	(4020, 'NULL', b'1', 2, 837),
	(4021, 'FOREIGN KEY', b'0', 2, 838),
	(4022, '중복된 행은 한 번만 출력된다.', b'0', 2, 839),
	(4023, '123.4', b'0', 2, 840),
	(4024, '하나의 테이블을 두 번 이상 사용하여 조인하는 것이다.', b'1', 2, 841),
	(4025, 'Consistency (일관성)', b'0', 2, 842),
	(4026, 'END 뒤에 반드시 별칭을 지정해야 한다.', b'1', 2, 843),
	(4027, 'FROM', b'0', 2, 844),
	(4028, 'VALUES 대신 서브쿼리를 사용할 수 있다.', b'0', 2, 845),
	(4029, 'RANK()는 동일한 값에 대해 동일한 순위를 부여한다.', b'0', 2, 846),
	(4030, 'NATURAL JOIN', b'0', 2, 847),
	(4031, 'ALTER', b'0', 2, 848),
	(4032, 'Empty', b'0', 2, 849),
	(4033, 'INSERT가 빈번한 테이블', b'0', 2, 850),
	(4034, '서브쿼리의 SELECT 절에는 반드시 하나의 칼럼만 지정해야 한다.', b'1', 2, 851),
	(4035, '조건을 만족하지 않는 경우 INSERT를 수행한다.', b'0', 2, 852),
	(4036, 'TWO', b'0', 2, 853),
	(4037, 'CONNECT_BY_ROOT', b'0', 2, 854),
	(4038, '성능 향상을 위해 사용된다.', b'0', 2, 855),
	(4039, '삭제된 데이터가 복구된다.', b'1', 2, 856),
	(4040, '복잡한 SQL문을 단순화할 수 있다.', b'0', 2, 857),
	(4041, '중복된 값을 허용하지 않는다.', b'0', 2, 858),
	(4042, 'DELETE는 로그를 남기고 TRUNCATE는 로그를 남기지 않는다.', b'0', 2, 859),
	(4043, 'READ COMMITTED', b'0', 2, 860),
	(4044, 'GROUP BY와 함께 사용된다', b'0', 2, 861),
	(4045, 'ORDER BY 방향이 다르면 안 된다', b'0', 2, 862),
	(4046, '데이터 관리가 용이하다', b'0', 2, 863),
	(4047, 'SELECT TO_CHAR(SALES_DATE, \'YYYY-MM\') as YM, SUM(AMOUNT) as AMOUNT, LEAD(SUM(AMOUNT), 12) OVER (ORDER BY SALES_DATE) as LAST_YEAR FROM SALES GROUP BY TO_CHAR(SALES_DATE, \'YYYY-MM\') ORDER BY YM;', b'0', 2, 864),
	(4048, 'IN은 서브쿼리의 모든 결과를 비교한다', b'0', 2, 865),
	(4049, '연속된 숫자 생성', b'0', 2, 866),
	(4050, '2번', b'1', 2, 867),
	(4051, '하나의 테이블은 하나의 테이블 스페이스에만 저장될 수 있다', b'0', 2, 868),
	(4052, '인덱스의 사용 여부를 확인할 수 있다', b'0', 2, 869),
	(4053, 'SUBSTR(emp_name, 1, 3) = \'Kim\'', b'0', 2, 870),
	(4054, '식별자에 의해 식별이 가능해야 한다', b'0', 2, 871),
	(4055, '최소성', b'0', 2, 872),
	(4056, '관계차수', b'1', 2, 873),
	(4057, '기본키를 가지고 있지 않은 엔터티 타입이다', b'0', 2, 874),
	(4058, '하나의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다', b'0', 2, 875),
	(4059, '정규화는 항상 조회 성능을 향상시킨다', b'0', 2, 876),
	(4060, '데이터의 일관성이 중요한 경우', b'1', 2, 877),
	(4061, '하나의 슈퍼타입은 여러 개의 서브타입을 가질 수 있다', b'0', 2, 878),
	(4062, '업무 프로세스에서 발생하는 이벤트를 찾는다', b'0', 2, 879),
	(4063, '자식 엔터티의 인스턴스가 생성될 때 부모 엔터티의 인스턴스가 반드시 존재해야 하는 경우', b'0', 2, 880),
	(4064, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID HAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE);', b'1', 2, 881),
	(4065, 'LAG 함수는 이전 행의 값을 가져온다', b'0', 2, 882),
	(4066, '자격', b'1', 2, 883),
	(4067, 'USING 절에는 조인에 사용될 컬럼명만 지정할 수 있다', b'0', 2, 884),
	(4068, 'SELECT EXTRACT(MONTH FROM ORDER_DATE) as MONTH, SUM(AMOUNT) as TOTAL_AMOUNT FROM ORDERS WHERE EXTRACT(YEAR FROM ORDER_DATE) = 2023 GROUP BY MONTH;', b'0', 2, 885),
	(4069, 'NULL과의 비교연산은 FALSE를 반환한다', b'0', 2, 886),
	(4070, 'WHERE 절을 사용할 수 없다', b'0', 2, 887),
	(4071, 'WHERE → START WITH → CONNECT BY → ORDER SIBLINGS BY', b'0', 2, 888),
	(4072, '부서별 평균 급여가 3000 이상인 부서를 조회한다', b'0', 2, 889),
	(4073, 'GROUP BY절에 사용된 컬럼이 SELECT절에 모두 나타날 필요는 없다', b'0', 2, 890),
	(4074, '조건을 비교해서 테이블에 해당 조건이 있으면 UPDATE를 수행한다', b'0', 2, 891),
	(4075, 'SELECT EMPNO, ENAME, SAL, CASE WHEN SAL > (SELECT AVG(SAL) FROM EMP) THEN \'이상\' ELSE \'이하\' END AS SALARY_GRADE FROM EMP;', b'1', 2, 892),
	(4076, 'GROUP BY절과 함께 사용할 수 있다', b'0', 2, 893),
	(4077, 'Consistency (일관성)', b'0', 2, 894),
	(4078, 'SELECT E.* FROM EMP E JOIN (SELECT DEPTNO, MAX(SAL) AS MAX_SAL FROM EMP GROUP BY DEPTNO) M ON E.DEPTNO = M.DEPTNO AND E.SAL = M.MAX_SAL;', b'1', 2, 895),
	(4079, 'CUBE는 모든 가능한 조합의 소계를 생성한다', b'0', 2, 896),
	(4080, '인덱스는 디스크 공간을 추가로 사용한다', b'0', 2, 897),
	(4081, 'BOTTOM-UP 방식으로 사원 계층 구조를 조회한다', b'0', 2, 898),
	(4082, 'RANGE', b'0', 2, 899),
	(4083, '트리거 내에서 COMMIT, ROLLBACK을 실행할 수 있다', b'0', 2, 900),
	(4084, 'SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR, EXTRACT(MONTH FROM ORDER_DATE) AS MONTH, SUM(AMOUNT) OVER (PARTITION BY EXTRACT(YEAR FROM ORDER_DATE) ORDER BY EXTRACT(MONTH FROM ORDER_DATE)) AS CUM_AMT FROM SALES;', b'1', 2, 901),
	(4085, 'IN은 서브쿼리의 결과를 모두 수행한다', b'0', 2, 902),
	(4086, '뷰를 통해서는 데이터를 수정할 수 없다', b'0', 2, 903),
	(4087, 'SELECT * FROM EMP E WHERE SAL > AVG(SAL) GROUP BY DEPTNO;', b'0', 2, 904),
	(4088, 'CASE', b'1', 2, 905),
	(4089, 'READ COMMITTED → READ UNCOMMITTED → REPEATABLE READ → SERIALIZABLE', b'0', 2, 906),
	(4090, 'UPDATE', b'0', 2, 907),
	(4091, 'SET NULL', b'0', 2, 908),
	(4092, 'SELECT * FROM (SELECT EMPNO, ENAME, DEPTNO, SAL, RANK() OVER (ORDER BY SAL DESC) AS RN FROM EMP) WHERE RN = 1;', b'0', 2, 909),
	(4093, '시스템 부하를 줄여준다', b'0', 2, 910),
	(4094, '차등 백업(Differential Backup)은 마지막 전체 백업 이후 변경된 데이터를 백업한다', b'0', 2, 911),
	(4095, 'SELECT EXTRACT(MONTH FROM SALE_DATE) AS MONTH, SUM(AMOUNT) AS TOTAL_AMOUNT, (SUM(AMOUNT) / LAG(SUM(AMOUNT)) OVER (ORDER BY EXTRACT(MONTH FROM SALE_DATE)) - 1) * 100 AS GROWTH_RATE FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2023 GROUP BY EXTRACT(MONTH FROM SALE_DATE);', b'0', 2, 912),
	(4096, '데이터 조회 성능을 향상시킬 수 있다', b'0', 2, 913),
	(4097, 'EXECUTE', b'0', 2, 914),
	(4098, 'SELECT * FROM EMPLOYEE WHERE (DEPT_ID, HIRE_DATE) IN (SELECT DEPT_ID, MAX(HIRE_DATE) FROM EMPLOYEE GROUP BY DEPT_ID);', b'0', 2, 915),
	(4099, '배타적 락(Exclusive Lock)은 쓰기 작업 시 사용된다', b'0', 2, 916),
	(4100, 'SELECT STUDENT_ID, SCORE, WIDTH_BUCKET(SCORE, 0, 100, 4) AS GRADE FROM SCORE;', b'1', 2, 917),
	(4101, '비트맵 인덱스', b'0', 2, 918),
	(4102, 'ROWNUM은 조회되는 행의 순서대로 번호를 부여한다', b'0', 2, 919),
	(4103, '네트워크 트래픽을 감소시킬 수 있다', b'0', 2, 920),
	(4104, '기본 엔터티와 중심 엔터티', b'1', 2, 921),
	(4105, '행위 엔터티', b'1', 2, 922),
	(4106, '관계차수', b'0', 2, 923),
	(4107, '비식별관계', b'0', 2, 924),
	(4108, '하나의 값만 가질 수 있다', b'0', 2, 925),
	(4109, 'Plus Type', b'1', 2, 926),
	(4110, '1:M 관계', b'0', 2, 927),
	(4111, '제2정규형은 부분함수 종속을 제거한다', b'0', 2, 928),
	(4112, '스스로 생성되었는지 여부에 따라 내부식별자와 외부식별자로 분류', b'0', 2, 929),
	(4113, '조회 성능이 중요한 경우', b'0', 2, 930),
	(4114, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE WHERE AVG(SALARY) >= 3000 GROUP BY DEPT_NO;', b'1', 2, 931),
	(4115, 'ELSE를 생략하면 자동으로 NULL이 지정된다', b'0', 2, 932),
	(4116, '다중행 서브쿼리는 비교 연산자(>, <, =)와 함께 사용할 수 있다', b'0', 2, 933),
	(4117, 'L전', b'1', 2, 934),
	(4118, 'COUNT 함수와 함께 사용할 수 있다', b'0', 2, 935),
	(4119, 'SELECT ORDER_DATE, NVL(SUM(ORDER_AMOUNT), 0) FROM ORDERS WHERE TO_CHAR(ORDER_DATE,\'YYYY-MM\') = \'2024-01\' GROUP BY ORDER_DATE;', b'0', 2, 936),
	(4120, 'NULL + 100 의 결과는 NULL이다', b'0', 2, 937),
	(4121, 'NATURAL JOIN은 조인 조건을 명시해야 한다', b'0', 2, 938),
	(4122, 'SELECT * FROM EMPLOYEE E WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEE F WHERE F.DEPT_NO = E.DEPT_NO AND F.HIRE_DATE > E.HIRE_DATE);', b'0', 2, 939),
	(4123, 'WHERE절에는 집계함수를 사용할 수 없다', b'0', 2, 940),
	(4124, 'SELECT YEAR, QUARTER, TOTAL_AMOUNT, (TOTAL_AMOUNT - PREV_AMOUNT) / PREV_AMOUNT * 100 AS GROWTH_RATE FROM (SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, CEIL(EXTRACT(MONTH FROM SALE_DATE)/3) AS QUARTER, SUM(AMOUNT) AS TOTAL_AMOUNT, LAG(SUM(AMOUNT)) OVER (ORDER BY SALE_DATE) AS PREV_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3));', b'0', 2, 941),
	(4125, 'Consistency(일관성)는 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환해야 함을 의미한다', b'0', 2, 942),
	(4126, 'USING절을 사용할 때는 테이블 별칭을 사용할 수 없다', b'1', 2, 943),
	(4127, 'TABLE_A와 TABLE_B가 중복되는 데이터가 없을 때', b'1', 2, 944),
	(4128, 'JOIN절에서 자주 사용되는 컬럼', b'0', 2, 945),
	(4129, '배타적락(Exclusive Lock)은 쓰기 작업을 할 때 사용된다', b'0', 2, 946),
	(4130, 'BOTTOM-UP 방식으로 역방향 전개되며, CONNECT_BY_ISLEAF는 리프 노드일 때 1을 반환한다', b'0', 2, 947),
	(4131, '데이터 백업과 복구가 용이하다', b'0', 2, 948),
	(4132, '변수, 상수 등을 선언하여 SQL문장 간 값을 공유할 수 있다', b'0', 2, 949),
	(4133, '응용 프로그램의 성능을 향상시킬 수 있다', b'0', 2, 950),
	(4134, 'SELECT EMP_NO, EMP_NAME, DEPT_NO, HIRE_DATE, RANK() OVER (PARTITION BY DEPT_NO ORDER BY HIRE_DATE) AS SEQ FROM EMPLOYEE;', b'0', 2, 951),
	(4135, 'DROP TABLE은 롤백이 가능하지만, TRUNCATE TABLE은 롤백이 불가능하다', b'1', 2, 952),
	(4136, '4', b'0', 2, 953),
	(4137, 'BEFORE, AFTER 옵션으로 실행 시점을 지정할 수 있다', b'0', 2, 954),
	(4138, 'SELECT A.MONTH FROM (SELECT LEVEL AS MONTH FROM DUAL CONNECT BY LEVEL <= 6) A WHERE NOT EXISTS (SELECT 1 FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2024 AND EXTRACT(MONTH FROM SALE_DATE) = A.MONTH);', b'0', 2, 955),
	(4139, 'REVOKE', b'0', 2, 956),
	(4140, '복잡한 SQL문을 단순화할 수 있다', b'0', 2, 957),
	(4141, 'COL1    RESULT\nA       2,1\nB       4,3', b'0', 2, 958),
	(4142, 'WHEN NOT MATCHED 절에서 DELETE를 수행할 수 있다', b'1', 2, 959),
	(4143, 'SELECT * FROM SALARY_HISTORY PIVOT (AVG(SALARY) FOR DEPT_NO IN (SELECT DISTINCT DEPT_NO FROM SALARY_HISTORY));', b'0', 2, 960),
	(4144, 'ORDER BY절은 인덱스를 활용하여 성능을 향상시킬 수 있다', b'0', 2, 961),
	(4145, 'SELECT * FROM (SELECT ORDER_NO, MEMBER_ID, ORDER_DATE, AMOUNT, COUNT(*) OVER (PARTITION BY MEMBER_ID ORDER BY ORDER_DATE DESC) AS CNT FROM ORDERS) WHERE CNT <= 3;', b'0', 2, 962),
	(4146, '인덱스 컬럼에 NULL 값이 많은 경우', b'0', 2, 963),
	(4147, 'NOW 컬럼은 현재 날짜만, AFTER_2HOUR 컬럼은 2시간 후 날짜만 출력된다', b'0', 2, 964),
	(4148, 'UNION ALL은 중복된 행을 포함하며 정렬하지 않는다', b'0', 2, 965),
	(4149, 'SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, EXTRACT(MONTH FROM SALE_DATE) AS MONTH, SUM(AMOUNT) AS MONTHLY_AMOUNT, SUM(AMOUNT) OVER (ORDER BY EXTRACT(YEAR FROM SALE_DATE), EXTRACT(MONTH FROM SALE_DATE)) AS CUM_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), EXTRACT(MONTH FROM SALE_DATE);', b'1', 2, 966),
	(4150, '데이터의 확장성', b'0', 2, 967),
	(4151, 'MONTHS_BETWEEN(date1, date2)는 두 날짜 간의 월 수 차이를 반환한다', b'0', 2, 968),
	(4152, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEE WHERE DEPT_NO = E.DEPT_NO);', b'0', 2, 969),
	(4153, 'READ COMMITTED는 다른 트랜잭션이 커밋한 데이터만 읽을 수 있다', b'0', 2, 970),
	(4154, '영속적으로 존재하는 정보의 집합이다', b'0', 2, 971),
	(4155, '최소성 - 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다', b'0', 2, 972),
	(4156, '1:M', b'1', 2, 973),
	(4157, '값이 입력되었으나 삭제됨', b'0', 2, 974),
	(4158, '영속적으로 존재하는 데이터를 찾는다', b'0', 2, 975),
	(4159, '삽입 이상', b'0', 2, 976),
	(4160, '데이터의 일관성이 매우 중요한 경우', b'1', 2, 977),
	(4161, '타 엔터티와의 관계로부터 생성된 속성', b'0', 2, 978),
	(4162, '데이터의 볼륨', b'0', 2, 979),
	(4163, '직원은 반드시 하나의 부서에 속해야 한다', b'1', 2, 980),
	(4164, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID HAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE)', b'1', 2, 981),
	(4165, 'NULL + 숫자 = NULL이다', b'0', 2, 982),
	(4166, '자격', b'1', 2, 983),
	(4167, 'USING절이나 ON절을 사용할 수 없다', b'0', 2, 984),
	(4168, 'SELECT EXTRACT(YEAR FROM SALE_DATE), EXTRACT(MONTH FROM SALE_DATE), SUM(AMOUNT) FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), EXTRACT(MONTH FROM SALE_DATE) ORDER BY 1, 2', b'1', 2, 985),
	(4169, 'SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 2, 986),
	(4170, 'START WITH EMP_ID = 3 CONNECT BY PRIOR MGR_ID = EMP_ID', b'0', 2, 987),
	(4171, 'CUBE는 ROLLUP보다 더 많은 소계를 생성한다', b'0', 2, 988),
	(4172, 'INSERT, DELETE', b'0', 2, 989),
	(4173, 'SELECT * FROM EMPLOYEE A WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE B WHERE A.DEPT_ID = B.DEPT_ID)', b'0', 2, 990),
	(4174, 'ALTER TABLE EMPLOYEE MODIFY (NAME VARCHAR2(20) NOT NULL)', b'1', 2, 991),
	(4175, 'ORDER BY 절을 사용하면 파티션 내 순서를 정의할 수 있다', b'0', 2, 992),
	(4176, 'MONTH=02, AMOUNT=150, PREV_AMOUNT=0', b'0', 2, 993),
	(4177, 'SELECT NAME, SCORE, RANK() OVER (ORDER BY NAME) AS RANK, DENSE_RANK() OVER (ORDER BY NAME) AS DENSE_RANK FROM SCORE', b'0', 2, 994),
	(4178, 'GROUP BY절에는 Alias를 사용할 수 없다', b'1', 2, 995),
	(4179, 'INTERSECT는 두 집합의 교집합을 반환한다', b'0', 2, 996),
	(4180, '1.5', b'1', 2, 997),
	(4181, '다중 행 서브쿼리는 IN, ANY, ALL 등의 연산자를 사용한다', b'0', 2, 998),
	(4182, 'SELECT DEPT_ID, COUNT(*) FROM EMPLOYEE HAVING COUNT(*) >= 2', b'0', 2, 999),
	(4183, '일관성(Consistency)', b'0', 2, 1000),
	(4184, 'SELECT * FROM ORDERS WHERE ORDER_DATE IN (SELECT MAX(ORDER_DATE) FROM ORDERS GROUP BY CUSTOMER_ID)', b'0', 2, 1001),
	(4185, '2, 4', b'0', 2, 1002),
	(4186, '2024/12/16 14:30:00', b'1', 2, 1003),
	(4187, 'MATCHED와 NOT MATCHED 조건을 모두 사용해야 한다', b'1', 2, 1004),
	(4188, 'B', b'0', 2, 1005),
	(4189, 'MONTHS_BETWEEN 함수는 두 날짜 간의 월 수 차이를 반환한다', b'0', 2, 1006),
	(4190, 'SELECT * FROM EMPLOYEE E, (SELECT DEPT_ID, MAX(SALARY) AS MAX_SAL FROM EMPLOYEE GROUP BY DEPT_ID) M WHERE E.DEPT_ID = M.DEPT_ID AND E.SALARY = M.MAX_SAL', b'1', 2, 1007),
	(4191, 'IN은 서브쿼리의 모든 결과를 비교한다', b'0', 2, 1008),
	(4192, 'QUARTER | AMOUNT\nQ1      | 100\nQ2      | 200\nQ3      | 300\nQ4      | 400', b'0', 2, 1009),
	(4193, '인덱스가 많을수록 조회 성능이 향상된다', b'1', 2, 1010),
	(4194, 'DEPT_ID  LEVEL  DEPT_NAME\n4        1      서울영업소\n5        1      부산영업소\n2        2      국내영업팀\n1        3      영업부', b'0', 2, 1011),
	(4195, 'WHERE 절에서 ROWNUM = 1은 사용할 수 있다', b'0', 2, 1012),
	(4196, '123.46, 123, 120', b'1', 2, 1013),
	(4197, 'SELECT COL1 FROM TABLE_A WHERE COL1 = 1 UNION SELECT COL1 FROM TABLE_B WHERE COL1 = 2', b'0', 2, 1014),
	(4198, 'READ COMMITTED', b'0', 2, 1015),
	(4199, 'REG_DATE 컬럼이 누락되어 NOT NULL 제약조건 위배', b'0', 2, 1016),
	(4200, 'Consistency(일관성) - 트랜잭션 실행 후에도 데이터베이스가 일관된 상태를 유지해야 한다', b'0', 2, 1017),
	(4201, 'TRUNCATE는 데이터만 삭제되며 자동으로 COMMIT된다', b'0', 2, 1018),
	(4202, 'GROUP BY절에는 Alias를 사용할 수 있다', b'0', 2, 1019),
	(4203, '뷰를 통해 기본 테이블의 데이터를 수정할 수 있다', b'0', 2, 1020),
	(4204, '식별자에 의해 식별이 가능해야 한다', b'0', 2, 1021),
	(4205, '데이터의 중복을 최소화한다', b'0', 2, 1022),
	(4206, '테이블명은 업무적으로 의미있는 이름을 부여한다', b'0', 2, 1023),
	(4207, '한 엔터티는 하나의 서브타입에만 속할 수 있다', b'0', 2, 1024),
	(4208, '최소성: 식별자를 구성하는 속성의 수가 최소가 되어야 한다', b'0', 2, 1025),
	(4209, '복합식별자', b'1', 2, 1026),
	(4210, '관계차수', b'0', 2, 1027),
	(4211, '조인으로 인한 성능 저하가 심각한 경우', b'0', 2, 1028),
	(4212, '속성은 반드시 물리적으로 관찰 가능해야 한다', b'1', 2, 1029),
	(4213, '비식별관계', b'1', 2, 1030),
	(4214, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO HAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE)', b'1', 2, 1031),
	(4215, 'F', b'0', 2, 1032),
	(4216, '집계함수와 함께 사용하여 그룹별 집계를 구할 수 있다', b'0', 2, 1033),
	(4217, 'DENSE_RANK 함수는 동일한 순위를 하나의 건수로 계산한다', b'0', 2, 1034),
	(4218, 'START WITH MGR_ID IS NULL CONNECT BY PRIOR EMP_ID = MGR_ID', b'1', 2, 1035),
	(4219, 'TRUNCATE는 데이터와 할당된 공간을 모두 삭제한다', b'0', 2, 1036),
	(4220, '뷰를 통해 데이터를 수정할 수 있다', b'0', 2, 1037),
	(4221, '자격', b'0', 2, 1038),
	(4222, 'NAME 컬럼이 NOT NULL 제약조건을 위배', b'1', 2, 1039),
	(4223, 'WHEN MATCHED THEN 절은 필수적으로 포함되어야 한다', b'1', 2, 1040),
	(4224, 'SELECT * FROM EMPLOYEE A WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE B WHERE A.DEPT_ID = B.DEPT_ID)', b'0', 2, 1041),
	(4225, 'NULL, 0, 0', b'0', 2, 1042),
	(4226, '부모 테이블의 PRIMARY KEY나 UNIQUE로 지정된 컬럼만 참조할 수 있다', b'0', 2, 1043),
	(4227, 'SAL 오름차순, HIREDATE 내림차순', b'0', 2, 1044),
	(4228, '메인쿼리와 서브쿼리 간의 조인 조건이 필요하다', b'0', 2, 1045),
	(4229, 'UNION은 자동으로 정렬되고, UNION ALL은 정렬되지 않는다', b'0', 2, 1046),
	(4230, 'SELECT * FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM <= 3', b'1', 2, 1047),
	(4231, '성능 향상을 위해 사용될 수 있다', b'0', 2, 1048),
	(4232, 'CASE WHEN JOB = \'MANAGER\' THEN 1000 WHEN JOB = \'SALESMAN\' THEN 800 WHEN JOB = \'CLERK\' THEN 600 WHEN JOB IS NULL THEN 0 END', b'0', 2, 1049),
	(4233, 'PRIMARY KEY로 지정된 열을 검색하는 경우', b'0', 2, 1050),
	(4234, 'CONNECT_BY_ISLEAF = 1', b'1', 2, 1051),
	(4235, 'SELECT DEPT_ID, AVG(SALARY) - AVG(AVG(SALARY)) FROM EMPLOYEE GROUP BY DEPT_ID', b'0', 2, 1052),
	(4236, '8', b'0', 2, 1053),
	(4237, 'READ UNCOMMITTED → REPEATABLE READ → READ COMMITTED → SERIALIZABLE', b'0', 2, 1054),
	(4238, 'SELECT COL1 FROM TABLE_A WHERE COL1 <= 2 UNION SELECT COL1 FROM TABLE_B WHERE COL1 >= 4', b'0', 2, 1055),
	(4239, '123, 123.4', b'0', 2, 1056),
	(4240, 'REVOKE 명령어로 권한을 회수할 수 있다', b'0', 2, 1057),
	(4241, 'COALESCE 함수는 첫 번째로 NULL이 아닌 인자를 반환한다', b'0', 2, 1058),
	(4242, 'DEPT_ID | SUM(AMOUNT)\n20      | 4000', b'1', 2, 1059),
	(4243, 'Consistency(일관성) - 트랜잭션 실행 후에도 데이터베이스가 일관된 상태를 유지해야 한다', b'0', 2, 1060),
	(4244, 'SELECT LAST_DAY(ORDER_DATE)\nFROM ORDERS', b'0', 2, 1061),
	(4245, 'PARTITION BY를 사용하여 그룹별로 집계할 수 있다', b'0', 2, 1062),
	(4246, '서브쿼리는 괄호로 묶어야 한다', b'0', 2, 1063),
	(4247, 'INSERT, UPDATE, DELETE가 빈번한 테이블의 컬럼에도 인덱스 생성이 권장된다', b'1', 2, 1064),
	(4248, '\'*SQL*\', \'*SQL*\'', b'0', 2, 1065),
	(4249, 'INSERT, DELETE', b'0', 2, 1066),
	(4250, '5', b'0', 2, 1067),
	(4251, 'FOREIGN KEY는 참조하는 테이블의 PRIMARY KEY나 UNIQUE 컬럼을 참조할 수 있다', b'0', 2, 1068),
	(4252, 'BEFORE나 AFTER를 지정하여 실행 시점을 정할 수 있다', b'0', 2, 1069),
	(4253, 'ORACLE SQL', b'0', 2, 1070),
	(4254, '엔터티는 다른 엔터티와 최소 한 개 이상의 관계를 가져야 한다', b'0', 2, 1071),
	(4255, '최소성: 식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다', b'0', 2, 1072),
	(4256, '선택적으로 존재하는 관계는 점선으로 표시한다', b'0', 2, 1073),
	(4257, '삭제이상: 학생이 수강을 취소하면 과목정보도 함께 삭제된다', b'0', 2, 1074),
	(4258, '다른 엔터티와 최소 한 개 이상의 관계를 가져야 한다', b'1', 2, 1075),
	(4259, '1:N 관계', b'0', 2, 1076),
	(4260, '조회 시 조인으로 인한 성능 저하가 발생할 수 있다', b'1', 2, 1077),
	(4261, '속성의 수', b'0', 2, 1078),
	(4262, '엔터티 구성방식에 따른 분류: PK속성, FK속성, 일반속성', b'0', 2, 1079),
	(4263, '조회의 비중', b'0', 2, 1080),
	(4264, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO HAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE)', b'1', 2, 1081),
	(4265, '동일한 순위가 존재하면 다음 순위는 해당 개수만큼 건너뛴다', b'0', 2, 1082),
	(4266, 'SQL전', b'0', 2, 1083),
	(4267, 'WHERE 절에서 조인 조건을 지정해야 한다', b'0', 2, 1084),
	(4268, 'SELECT YEAR(ORDER_DATE), MONTH(ORDER_DATE), SUM(ORDER_AMOUNT) FROM ORDERS', b'0', 2, 1085),
	(4269, 'NULL과의 비교연산은 FALSE를 반환한다', b'0', 2, 1086),
	(4270, 'DELETE문은 로그를 남기지 않는다', b'1', 2, 1087),
	(4271, 'CONNECT BY → START WITH → WHERE → ORDER SIBLINGS BY', b'0', 2, 1088),
	(4272, 'WITH TEMP AS (SELECT DEPT_NO, AVG(SALARY) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_NO) SELECT DEPT_NO, AVG_SAL FROM TEMP WHERE AVG_SAL >= 3000', b'1', 2, 1089),
	(4273, 'GROUP BY 절에는 SELECT 절에서 사용한 집계함수 이외의 모든 컬럼이 포함되어야 한다', b'0', 2, 1090),
	(4274, 'ALTER TABLE EMPLOYEE MODIFY NAME VARCHAR2(20)', b'1', 2, 1091),
	(4275, 'GROUP BY 절의 컬럼이 부족하다', b'0', 2, 1092),
	(4276, 'LAG 함수는 이전 행의 값을 참조한다', b'0', 2, 1093),
	(4277, 'SELECT empno, sal, deptno FROM EMPLOYEES E1 WHERE sal > (SELECT AVG(sal) FROM EMPLOYEES E2 WHERE E1.deptno = E2.deptno)', b'1', 2, 1094),
	(4278, 'Consistency(일관성): 트랜잭션 실행 후에도 데이터베이스는 일관된 상태를 유지해야 한다', b'0', 2, 1095),
	(4279, 'GRANT, REVOKE', b'0', 2, 1096),
	(4280, '##SQL', b'1', 2, 1097),
	(4281, 'INSERT, UPDATE, DELETE 시 인덱스도 함께 수정되어야 한다', b'0', 2, 1098),
	(4282, 'SELECT EXTRACT(MONTH FROM ORDER_DATE), SUM(ORDER_AMOUNT) FROM ORDERS WHERE EXTRACT(YEAR FROM ORDER_DATE) = 2023 GROUP BY EXTRACT(MONTH FROM ORDER_DATE)', b'1', 2, 1099),
	(4283, '뷰를 통해 데이터의 보안성을 향상시킬 수 있다', b'0', 2, 1100),
	(4284, 'CONNECT_BY_ROOT', b'0', 2, 1101),
	(4285, '123.46, 123, 120', b'1', 2, 1102),
	(4286, 'SELECT s1.SUBJECT, s1.NAME, s1.SCORE FROM SCORES s1 WHERE s1.SCORE = (SELECT MAX(SCORE) FROM SCORES s2 WHERE s1.SUBJECT = s2.SUBJECT)', b'1', 2, 1103),
	(4287, 'COUNT(column) 함수는 해당 컬럼의 NULL이 아닌 값의 수를 계산한다', b'0', 2, 1104),
	(4288, 'SELECT DEPT_NO, MAX(HIRE_DATE), NAME FROM EMPLOYEES GROUP BY DEPT_NO', b'0', 2, 1105),
	(4289, '23/12/16 14:30:00    23-12-16 SATURDAY    23.12.16', b'0', 2, 1106),
	(4290, '집계 함수는 WHERE 절에서 사용할 수 없다', b'0', 2, 1107),
	(4291, 'SELECT * FROM EMPLOYEES E1 WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES E2 WHERE E1.DEPT_NO = E2.DEPT_NO)', b'1', 2, 1108),
	(4292, 'UNION은 자동으로 정렬을 수행하지만, UNION ALL은 정렬을 수행하지 않는다', b'1', 2, 1109),
	(4293, 'WHERE 절에서 자주 사용되는 컬럼', b'0', 2, 1110),
	(4294, 'EMP 테이블의 모든 직원이 부서를 가지고 있을 때', b'0', 2, 1111),
	(4295, 'DIFFERENT', b'0', 2, 1112),
	(4296, 'RANGE는 논리적인 값의 범위를 기준으로 행 집합을 지정한다', b'0', 2, 1113),
	(4297, 'SELECT EMP_NO, ABSENT_DATE - LAG(ABSENT_DATE) OVER (PARTITION BY EMP_NO ORDER BY ABSENT_DATE) AS DIFF FROM ATTENDANCE', b'0', 2, 1114),
	(4298, 'WHEN NOT MATCHED THEN 절은 필수적으로 포함되어야 한다', b'1', 2, 1115),
	(4299, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) OVER (ORDER BY SALE_DATE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS CUM_SUM FROM SALES', b'1', 2, 1116),
	(4300, '집계함수는 반드시 하나만 사용해야 한다', b'1', 2, 1117),
	(4301, 'SELECT * FROM EMPLOYEES E1 WHERE 2 > (SELECT COUNT(DISTINCT SALARY) FROM EMPLOYEES E2 WHERE E2.DEPT_NO = E1.DEPT_NO AND E2.SALARY > E1.SALARY)', b'0', 2, 1118),
	(4302, '1, 2, 3, 4', b'0', 2, 1119),
	(4303, 'SERIALIZABLE은 가장 높은 격리 수준이다', b'0', 2, 1120),
	(4304, '식별이 가능해야 한다', b'0', 2, 1121),
	(4305, '최소성 - 주식별자를 구성하는 속성의 수는 최소가 되어야 한다', b'0', 2, 1122),
	(4306, '행위 엔터티', b'1', 2, 1123),
	(4307, '관계차수', b'0', 2, 1124),
	(4308, '삭제 이상', b'0', 2, 1125),
	(4309, '부모 테이블의 기본키가 자식 테이블의 일반 속성으로 전이되는 관계이다', b'1', 2, 1126),
	(4310, '항상 조회 성능이 향상된다', b'1', 2, 1127),
	(4311, '설계 속성', b'0', 2, 1128),
	(4312, '하나의 슈퍼타입은 여러 개의 서브타입을 가질 수 있다', b'0', 2, 1129),
	(4313, '데이터 표준화를 위한 기준이 된다', b'0', 2, 1130),
	(4314, '집계함수와 함께 사용된다', b'0', 2, 1131),
	(4315, '4', b'0', 2, 1132),
	(4316, 'COALESCE(A,B,C): A,B,C 중 첫 번째로 NULL이 아닌 값을 반환한다', b'0', 2, 1133),
	(4317, 'op', b'0', 2, 1134),
	(4318, 'SELECT EXTRACT(MONTH FROM JOIN_DATE), SUM(AMOUNT)\nFROM SALES\nWHERE EXTRACT(YEAR FROM JOIN_DATE) = 2023\nGROUP BY EXTRACT(MONTH FROM JOIN_DATE)\nORDER BY 1;', b'1', 2, 1135),
	(4319, '4행', b'0', 2, 1136),
	(4320, 'CONNECT_BY_ROOT', b'0', 2, 1137),
	(4321, 'CUBE는 모든 가능한 조합의 소계를 생성한다', b'0', 2, 1138),
	(4322, '별칭(Alias)을 사용할 수 있다', b'0', 2, 1139),
	(4323, 'SELECT EMP_ID, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) AS RANK\nFROM EMP;', b'0', 2, 1140),
	(4324, 'SELECT *\nFROM EMP E1\nWHERE SALARY = (SELECT MAX(SALARY)\n                FROM EMP E2\n                WHERE E1.DEPT_ID = E2.DEPT_ID);', b'1', 2, 1141),
	(4325, '조건을 만족하지 않는 경우 INSERT를 수행한다', b'0', 2, 1142),
	(4326, 'PREV_AMOUNT 열이 다음 달의 판매액을 보여준다', b'0', 2, 1143),
	(4327, 'Consistency(일관성): 트랜잭션 실행 후에도 데이터베이스가 일관된 상태를 유지해야 한다', b'0', 2, 1144),
	(4328, 'SELECT EMP_ID, MANAGER_ID, EMP_NAME\nFROM ORGANIZATION\nSTART WITH MANAGER_ID IS NULL\nCONNECT BY EMP_ID = PRIOR MANAGER_ID;', b'0', 2, 1145),
	(4329, 'REVOKE', b'0', 2, 1146),
	(4330, '123.46, 123, 120', b'1', 2, 1147),
	(4331, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'1', 2, 1148),
	(4332, 'UNION은 자동으로 정렬되고, UNION ALL은 정렬되지 않는다', b'0', 2, 1149),
	(4333, '인덱스가 있으면 DELETE 연산의 성능이 항상 향상된다', b'1', 2, 1150),
	(4334, 'SELECT *\nFROM EMPLOYEE\nWHERE ROWNUM <= 3\nORDER BY SALARY DESC;', b'1', 2, 1151),
	(4335, 'NULL과 NULL은 서로 같다', b'1', 2, 1152),
	(4336, '***ORACLE\', \'ORACLE***\', \'***ORACLE***\'', b'0', 2, 1153),
	(4337, '5행(개별 그룹별 소계 + 전체 합계)', b'0', 2, 1154),
	(4338, '복잡한 쿼리를 단순화할 수 있다', b'0', 2, 1155),
	(4339, '3, 5, 5', b'0', 2, 1156),
	(4340, 'ORDER BY 절에서 사용할 수 있다', b'0', 2, 1157),
	(4341, 'SELECT DECODE(STATUS, NULL, \'미정\', STATUS) FROM PRODUCT;', b'0', 2, 1158),
	(4342, '별칭을 반드시 사용해야 한다', b'0', 2, 1159),
	(4343, '3', b'1', 2, 1160),
	(4344, 'SELECT DEPT_ID, AVG(SALARY)\nFROM EMP\nGROUP BY DEPT_ID\nHAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMP);', b'1', 2, 1161),
	(4345, 'SELECT *\nFROM SALES\nPIVOT(SUM(AMOUNT), COUNT(*) FOR QUARTER IN (\'Q1\', \'Q2\'));', b'1', 2, 1162),
	(4346, 'SERIALIZABLE은 가장 높은 격리 수준이다', b'0', 2, 1163),
	(4347, 'LEVEL  CONNECT_BY_ISLEAF\n------------------------\n1      0\n2      0\n3      0', b'0', 2, 1164),
	(4348, 'SELECT DEPT_ID, SUM(SALARY + NVL(BONUS, 0))\nFROM EMPLOYEE\nGROUP BY DEPT_ID;', b'1', 2, 1165),
	(4349, '외래키가 참조하는 값이 삭제될 때 CASCADE 옵션을 사용할 수 있다', b'0', 2, 1166),
	(4350, 'COMMIT 주기를 짧게 하여 자주 수행한다', b'1', 2, 1167),
	(4351, 'SELECT N1.NUM\nFROM NUMBERS N1, NUMBERS N2\nWHERE N1.NUM + 1 = N2.NUM\nGROUP BY N1.NUM;', b'0', 2, 1168),
	(4352, '복합 뷰는 DML 작업이 불가능하다', b'0', 2, 1169),
	(4353, '2024-01-02, 2024-02-01, 1', b'0', 2, 1170),
	(4354, '식별자로 구분이 가능해야 한다', b'0', 2, 1171),
	(4355, '기본키를 구성하는 속성은 널(NULL) 값을 가질 수 있다', b'0', 2, 1172),
	(4356, '하나의 주문은 반드시 하나의 고객에 속한다', b'0', 2, 1173),
	(4357, '설계 속성', b'1', 2, 1174),
	(4358, '값이 변하지 않는 속성을 지정한다', b'0', 2, 1175),
	(4359, '데이터 모델의 독립성을 향상시킨다', b'0', 2, 1176),
	(4360, '조인 성능', b'0', 2, 1177),
	(4361, '비식별관계는 항상 조인 성능을 저하시킨다', b'0', 2, 1178),
	(4362, '데이터 표준화의 기준이 된다', b'0', 2, 1179),
	(4363, '데이터의 일관성이 중요한 경우', b'1', 2, 1180),
	(4364, 'SELECT *\nFROM EMPLOYEE\nWHERE SALARY IN (SELECT MAX(SALARY) FROM EMPLOYEE\n                 GROUP BY DEPT_ID);', b'0', 2, 1181),
	(4365, 'GROUP BY 절에는 SELECT 목록에 있는 모든 컬럼이 포함되어야 한다', b'1', 2, 1182),
	(4366, 'SQ', b'1', 2, 1183),
	(4367, '3행이 조회된다', b'1', 2, 1184),
	(4368, 'GROUP BY 절에서 사용할 수 있다', b'1', 2, 1185),
	(4369, 'IS NULL', b'1', 2, 1186),
	(4370, 'WHEN NOT MATCHED THEN DELETE를 사용할 수 있다', b'1', 2, 1187),
	(4371, '1, 1, 1', b'0', 2, 1188),
	(4372, 'INTERSECT는 두 집합의 차집합을 반환한다', b'0', 2, 1189),
	(4373, 'SELECT STUDENT_ID, ABSENT_DATE,\n       LEAD(ABSENT_DATE) OVER (ORDER BY ABSENT_DATE) NEXT_DATE\nFROM ATTENDANCE;', b'0', 2, 1190),
	(4374, 'NULL이 포함된 행은 업데이트되지 않는다', b'0', 2, 1191),
	(4375, '한 번의 쿼리에서 여러 번 참조할 수 있다', b'0', 2, 1192),
	(4376, 'SQL Developer 2024', b'0', 2, 1193),
	(4377, 'ORDER BY 고객번호 ASC, 주문금액 ASC, 주문일자 DESC', b'0', 2, 1194),
	(4378, '인덱스 컬럼이 IS NULL 조건으로 검색될 때', b'0', 2, 1195),
	(4379, 'INSERT INTO TEST VALUES (2, NULL, NULL);', b'1', 2, 1196),
	(4380, 'NOW 컬럼과 AFTER_1HOUR 컬럼의 차이는 정확히 24시간이다', b'0', 2, 1197),
	(4381, 'SELECT COUNT(DISTINCT COL1) FROM TABLE1;', b'0', 2, 1198),
	(4382, 'SELECT *\nFROM EMP E1\nWHERE SALARY = (\n    SELECT MAX(SALARY)\n    FROM EMP E2\n    WHERE E2.DEPT_ID = E1.DEPT_ID\n);', b'0', 2, 1199),
	(4383, '하나의 테이블은 여러 테이블스페이스에 저장될 수 있다', b'1', 2, 1200),
	(4384, 'SELECT LEVEL, NAME\nFROM EMPLOYEE\nSTART WITH EMP_ID = 1\nCONNECT BY PRIOR MANAGER_ID = EMP_ID;', b'0', 2, 1201),
	(4385, 'CURRVAL은 현재 세션에서 마지막으로 생성된 값을 반환한다', b'0', 2, 1202),
	(4386, 'NULL, NULL', b'1', 2, 1203),
	(4387, '김사원,이사원,박사원,최사원,정사원', b'0', 2, 1204),
	(4388, 'SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 2, 1205),
	(4389, '첫 번째 표현식은 오류가 발생한다', b'0', 2, 1206),
	(4390, 'SELECT * FROM (\n    SELECT * FROM TRANSACTIONS\n    ORDER BY TRANS_DATE DESC\n)\nWHERE ROWNUM <= 3;', b'1', 2, 1207),
	(4391, 'NULL과 NULL의 비교는 FALSE를 반환한다', b'1', 2, 1208),
	(4392, 'REVOKE', b'0', 2, 1209),
	(4393, '123.46, 123, 120', b'1', 2, 1210),
	(4394, 'SELECT *\nFROM SALES\nPIVOT (\n    SUM(AMOUNT)\n    FOR DEPT IN (\'A\', \'B\')\n)\nORDER BY YEAR;', b'1', 2, 1211),
	(4395, '인덱스는 항상 정렬된 상태를 유지한다', b'0', 2, 1212),
	(4396, '계층형 구조를 들여쓰기하여 표시한다', b'1', 2, 1213),
	(4397, '데이터 로딩 전 인덱스 삭제하기', b'0', 2, 1214),
	(4398, 'SELECT SALE_DATE, AMOUNT,\n       SUM(AMOUNT) OVER (PARTITION BY SALE_DATE)\nFROM SALES;', b'0', 2, 1215),
	(4399, 'WITH CHECK OPTION으로 데이터 무결성을 보장할 수 있다', b'0', 2, 1216),
	(4400, '두 번째 INSERT까지 성공한다', b'1', 2, 1217),
	(4401, 'CUBE는 계층적 집계를 생성하고, ROLLUP은 모든 가능한 조합의 집계를 생성한다', b'0', 2, 1218),
	(4402, 'SELECT * FROM EMP\nWHERE SALARY > (SELECT AVG(SALARY)\n                FROM EMP\n                GROUP BY DEPT_ID);', b'0', 2, 1219),
	(4403, 'B', b'0', 2, 1220),
	(4404, '단순화 - 복잡한 현실세계를 약속된 규약에 의해 표현한다', b'0', 2, 1221),
	(4405, '각 엔터티간의 관계차수를 파악한다', b'0', 2, 1222),
	(4406, '최소성 - 주식별자를 구성하는 속성의 수는 최소가 되어야 한다', b'0', 2, 1223),
	(4407, '유무형에 따른 분류 - 유형/개념/사건 엔터티', b'0', 2, 1224),
	(4408, '설계 속성', b'0', 2, 1225),
	(4409, '삭제 이상', b'0', 2, 1226),
	(4410, '엔터티 간의 논리적인 연관성을 표현한다', b'0', 2, 1227),
	(4411, '입력, 수정, 삭제의 성능이 중요한 경우', b'1', 2, 1228),
	(4412, '상속받은 주식별자 속성을 자식 엔터티의 주식별자로 사용할 때', b'0', 2, 1229),
	(4413, '슈퍼타입-서브타입 관계로 변환한다', b'0', 2, 1230),
	(4414, 'SELECT * FROM EMPLOYEE E1 WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE E2 WHERE E1.DEPT_ID = E2.DEPT_ID);', b'0', 2, 1231),
	(4415, 'ROLLUP은 가로 방향으로 소계를 계산하고, CUBE는 세로 방향으로 소계를 계산한다', b'0', 2, 1232),
	(4416, 'AADDCC, AADDCC', b'0', 2, 1233),
	(4417, 'SELECT D.DEPT_NAME, E.EMP_NAME FROM DEPT D LEFT OUTER JOIN EMP E ON D.DEPT_ID = E.DEPT_ID;', b'1', 2, 1234),
	(4418, '데이터만 삭제되고 테이블 구조는 유지된다', b'0', 2, 1235),
	(4419, 'NUM  PREV_NUM  NEXT_NUM\n1    NULL      2\n2    1         3\n3    2         NULL', b'0', 2, 1236),
	(4420, 'IN', b'0', 2, 1237),
	(4421, 'ADD_MONTHS는 월을 더하거나 뺄 수 있다', b'0', 2, 1238),
	(4422, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_ID = E.DEPT_ID);', b'1', 2, 1239),
	(4423, 'NULL과 NULL은 같다고 판단한다', b'1', 2, 1240),
	(4424, 'LEVEL  ISLEAF\n1      0\n2      1\n3      1', b'0', 2, 1241),
	(4425, '복잡한 쿼리를 단순화할 수 있다', b'0', 2, 1242),
	(4426, 'SOURCE_TBL의 데이터가 존재하면 UPDATE하고, 없으면 INSERT할 때', b'1', 2, 1243),
	(4427, '외래키로 지정된 컬럼', b'0', 2, 1244),
	(4428, '첫 번째 INSERT문만 성공한다', b'1', 2, 1245),
	(4429, 'Consistency는 트랜잭션 실행 후에도 데이터베이스가 일관된 상태여야 한다', b'0', 2, 1246),
	(4430, '오류 발생', b'1', 2, 1247),
	(4431, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) OVER () FROM SALES;', b'0', 2, 1248),
	(4432, 'DROP', b'0', 2, 1249),
	(4433, 'COALESCE는 첫 번째 NULL이 아닌 값을 반환한다', b'1', 2, 1250),
	(4434, 'SELECT EMP_ID, DEPT_ID, SALARY, RANK() OVER (PARTITION BY DEPT_ID ORDER BY SALARY DESC) AS RANK FROM EMPLOYEE;', b'1', 2, 1251),
	(4435, '서브쿼리의 결과가 여러 행이어도 상관없다', b'0', 2, 1252),
	(4436, '1, 3, 3, 3.6', b'0', 2, 1253),
	(4437, 'WHERE절 다음에 위치한다', b'0', 2, 1254),
	(4438, 'DELETE FROM DUPLICATE_DATA A WHERE EXISTS (SELECT 1 FROM DUPLICATE_DATA B WHERE A.ID = B.ID AND A.ROWID > B.ROWID);', b'0', 2, 1255),
	(4439, 'NATURAL JOIN은 동일한 이름의 컬럼을 자동으로 조인한다', b'0', 2, 1256),
	(4440, '현재 날짜의 연, 월, 일이 숫자형으로 출력된다', b'1', 2, 1257),
	(4441, '다중 행 서브쿼리는 여러 개의 행을 반환할 수 있다', b'0', 2, 1258),
	(4442, '\'Q1\'  \'Q2\'\n2500  4500', b'0', 2, 1259),
	(4443, 'READ COMMITTED', b'0', 2, 1260),
	(4444, 'SELECT MONTH, AMOUNT, ROUND((AMOUNT - PREV_AMOUNT) / PREV_AMOUNT * 100, 2) AS RATE FROM (SELECT MONTH, AMOUNT, LAG(AMOUNT) OVER (ORDER BY MONTH) AS PREV_AMOUNT FROM SALES);', b'0', 2, 1261),
	(4445, '하나의 테이블은 여러 테이블스페이스에 분산 저장될 수 있다', b'1', 2, 1262),
	(4446, 'LEVEL  EMP_NAME\n1      김사장\n2          이부장\n2          박부장\n3              최대리', b'1', 2, 1263),
	(4447, 'POINT_UPDATE 테이블의 데이터로 MEMBER 테이블의 POINT를 갱신하고, 없는 회원은 추가할 때', b'1', 2, 1264),
	(4448, '데이터의 수정이 빈번한 컬럼에 인덱스를 생성하는 것이 좋다', b'1', 2, 1265),
	(4449, 'SELECT * FROM (SELECT * FROM EMP WHERE ROWNUM <= 3 ORDER BY HIRE_DATE DESC);', b'0', 2, 1266),
	(4450, '5, 9, NULL', b'0', 2, 1267),
	(4451, 'DDL 문장을 실행하면 자동으로 COMMIT된다', b'0', 2, 1268),
	(4452, 'SELECT DEPT_ID, POSITION, AVG(SALARY) FROM EMP GROUP BY ROLLUP(DEPT_ID, POSITION);', b'0', 2, 1269),
	(4453, '오라클 전용 언어이다', b'0', 2, 1270),
	(4454, '기본 엔터티와 중심 엔터티', b'0', 2, 1271),
	(4455, '행위 엔터티', b'1', 2, 1272),
	(4456, '관계차수', b'0', 2, 1273),
	(4457, '최소성 - 식별자를 구성하는 속성의 수가 유일성을 만족하는 최소가 되어야 함', b'0', 2, 1274),
	(4458, '삭제 이상', b'0', 2, 1275),
	(4459, '관계는 엔터티와 엔터티 간 연관성을 표현하기 위해 반드시 동사나 동사구를 사용해야 함', b'1', 2, 1276),
	(4460, '데이터 모델에서 정의되는 기준으로서 해당 속성에 대한 데이터 타입과 크기를 지정', b'0', 2, 1277),
	(4461, '하나의 과목은 하나의 수강내역에만 연결된다', b'1', 2, 1278),
	(4462, 'ERD에서 점선으로 표현된다', b'0', 2, 1279),
	(4463, '서브타입은 슈퍼타입의 특성을 상속받는다', b'0', 2, 1280),
	(4464, 'SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 2, 1281),
	(4465, '5000, 5, 4', b'0', 2, 1282),
	(4466, 'COALESCE(expr1, expr2, ...): NULL이 아닌 최초의 인자 값을 반환', b'0', 2, 1283),
	(4467, 'SELECT DEPTNO FROM EMP GROUP BY DEPTNO;', b'0', 2, 1284),
	(4468, 'RANGE는 논리적인 단위로 행 집합을 지정', b'0', 2, 1285),
	(4469, 'TableA LEFT OUTER JOIN TableB', b'0', 2, 1286),
	(4470, 'Consistency(일관성): 트랜잭션 실행 후에도 데이터베이스는 일관된 상태를 유지', b'0', 2, 1287),
	(4471, 'CONNECT_BY_ROOT', b'0', 2, 1288),
	(4472, '2023, 300, NULL', b'0', 2, 1289),
	(4473, '인덱스는 원하는 데이터를 빨리 찾을 수 있지만 UPDATE, INSERT, DELETE 시 성능이 저하될 수 있다', b'0', 2, 1290),
	(4474, '인라인 뷰는 FROM 절에서 사용되는 서브쿼리이다', b'0', 2, 1291),
	(4475, 'B, 2, 1, NULL, 150', b'0', 2, 1292),
	(4476, 'SELECT * FROM EMP A WHERE NOT EXISTS (SELECT 1 FROM EMP B WHERE A.DEPTNO = B.DEPTNO AND B.SAL > A.SAL);', b'0', 2, 1293),
	(4477, 'ID | VALUE\n1  | A\n2  | B\n3  | C', b'0', 2, 1294),
	(4478, 'LAG 함수는 이전 행의 값을 가져온다', b'0', 2, 1295),
	(4479, '3, 2, 2', b'1', 2, 1296),
	(4480, 'INSERT INTO TEST_TABLE (ID, NAME) VALUES (2, \'Lee\');', b'0', 2, 1297),
	(4481, 'REPEATABLE READ는 같은 데이터를 여러 번 읽어도 동일한 결과를 보장한다', b'0', 2, 1298),
	(4482, 'LEFT OUTER JOIN', b'0', 2, 1299),
	(4483, 'LEVEL은 최상위 레벨이 1이다', b'0', 2, 1300),
	(4484, 'GROUP BY 절에는 SELECT 목록에 있는 모든 열이 포함되어야 한다', b'0', 2, 1301),
	(4485, 'MONTH | TOTAL\n01    | 100\n02    | 200\n03    | 300\nNULL  | 400', b'0', 2, 1302),
	(4486, 'UNION이 자동으로 정렬되지만, UNION ALL은 자동으로 정렬되지 않는다', b'1', 2, 1303),
	(4487, 'FOREIGN KEY 제약조건은 참조하는 테이블에 존재하는 값만 입력할 수 있다', b'0', 2, 1304),
	(4488, '자격', b'0', 2, 1305),
	(4489, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE F WHERE E.DEPT_ID = F.DEPT_ID);', b'1', 2, 1306),
	(4490, 'Rollback은 변경사항을 취소하고 이전 상태로 되돌린다', b'0', 2, 1307),
	(4491, '계층 구조에 따라 EMPNO가 들여쓰기되어 출력된다', b'1', 2, 1308),
	(4492, 'NULL 값을 검색하는 경우', b'0', 2, 1309),
	(4493, 'SELECT * FROM EMPLOYEE E WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMPLOYEE GROUP BY DEPTNO);', b'0', 2, 1310),
	(4494, 'CREATE, ALTER, DROP', b'0', 2, 1311),
	(4495, 'YEAR | MONTH | AMOUNT | RESULT\n2023 | 01    | 100    | 100\n2023 | 02    | 200    | 300\n2023 | 03    | 300    | 600', b'0', 2, 1312),
	(4496, '컬럼 삭제는 DROP COLUMN 구문을 사용한다', b'0', 2, 1313),
	(4497, '123ABC, ABC123', b'0', 2, 1314),
	(4498, 'Non-Repeatable Read', b'0', 2, 1315),
	(4499, 'CREATE TABLE EMP (\n    EMPNO NUMBER(4),\n    ENAME VARCHAR2(10),\n    DEPTNO NUMBER(4),\n    PRIMARY KEY (EMPNO, DEPTNO)\n);', b'0', 2, 1316),
	(4500, 'MONTHS_BETWEEN은 두 날짜 간의 개월 수를 반환한다', b'0', 2, 1317),
	(4501, 'SELECT EMPNO, DEPTNO, SAL,\n       ROW_NUMBER() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS RNK\nFROM EMP;', b'0', 2, 1318),
	(4502, 'SQL Server에서는 TOP 절을 사용하여 구현할 수 있다', b'0', 2, 1319),
	(4503, '배타적 락(Exclusive Lock)은 쓰기 작업 시 사용된다', b'0', 2, 1320),
	(4927, '리뷰이미지(이미지번호, 리뷰번호, 이미지URL, 등록일자)', b'0', 3, 721),
	(4928, '회원포인트(포인트, 만료일자) → CHECK (포인트 >= 0)', b'0', 3, 722),
	(4929, '주문상세 테이블에 취소 관련 칼럼을 추가하여 설계', b'0', 3, 723),
	(4930, '(회원번호, 우편번호, 상세주소)', b'0', 3, 724),
	(4931, '진료과 테이블의 과장의사번호', b'0', 3, 725),
	(4932, '고객과 배송지의 관계', b'1', 3, 726),
	(4933, '보험상품(슈퍼타입) - 생명보험/손해보험/연금보험(서브타입): 배타적 서브타입', b'0', 3, 727),
	(4934, '회원의 등급을 계산하기 위해 최근 6개월간의 주문 실적을 집계하는 경우', b'0', 3, 728),
	(4935, '(회원번호, 세션ID)의 복합키', b'0', 3, 729),
	(4936, '예약(예약번호, 상품코드, 출발일자, 회원번호, 인원수, 총금액)', b'0', 3, 730),
	(4937, 'SELECT SALES_MONTH, TOTAL_AMOUNT FROM (SELECT SALES_MONTH, TOTAL_AMOUNT, LAG(TOTAL_AMOUNT) OVER (ORDER BY SALES_MONTH) AS PREV_AMOUNT FROM SALES_MONTHLY) WHERE TOTAL_AMOUNT >= PREV_AMOUNT * 1.1', b'1', 3, 731),
	(4938, 'DEPT_NO  EMP_COUNT  TOTAL_SALARY  AVG_BONUS\n-------------------------------------------\n30       1          4500          700\n10       2          8000          500\n20       2          6800          0', b'0', 3, 732),
	(4939, 'SELECT * FROM EMPLOYEE WHERE SALARY > AVG(SALARY) GROUP BY DEPT_NO', b'0', 3, 733),
	(4940, 'ORDER BY절은 마지막 SELECT문에만 사용할 수 있다', b'0', 3, 734),
	(4941, 'SELECT order_date, next_order_date FROM (SELECT order_date, LEAD(order_date) OVER (ORDER BY order_date) as next_order_date, LEAD(order_date) OVER (ORDER BY order_date) - order_date as date_diff FROM orders) WHERE date_diff >= 3', b'1', 3, 735),
	(4942, 'SELECT E.* FROM EMPLOYEE E, (SELECT DEPT_NO, MAX(SALARY) AS MAX_SAL FROM EMPLOYEE GROUP BY DEPT_NO) M WHERE E.DEPT_NO = M.DEPT_NO AND E.SALARY = M.MAX_SAL', b'1', 3, 736),
	(4943, 'WITH DATES AS (SELECT DISTINCT PROD_ID, TO_DATE(\'2023-01-01\',\'YYYY-MM-DD\') + LEVEL - 1 as TRX_DATE FROM STOCK_HISTORY CONNECT BY LEVEL <= 5) SELECT D.PROD_ID, D.TRX_DATE, SUM(CASE WHEN H.TRX_TYPE = \'IN\' THEN H.QUANTITY WHEN H.TRX_TYPE = \'OUT\' THEN -H.QUANTITY END) OVER (PARTITION BY D.PROD_ID ORDER BY D.TRX_DATE) as STOCK_QTY FROM DATES D LEFT JOIN STOCK_HISTORY H ON D.PROD_ID = H.PROD_ID AND D.TRX_DATE = H.TRX_DATE', b'1', 3, 737),
	(4944, 'INSERT 시 VALUES 절에 서브쿼리를 사용할 수 있다', b'0', 3, 738),
	(4945, 'SELECT DEPT_ID, DEPT_NAME, SYS_CONNECT_BY_PATH(DEPT_NAME, \'\'/\'\') as DEPT_PATH FROM DEPARTMENT START WITH PARENT_DEPT_ID IS NULL CONNECT BY PRIOR DEPT_ID = PARENT_DEPT_ID', b'0', 3, 739),
	(4946, 'READ COMMITTED 격리수준에서는 다른 트랜잭션이 COMMIT한 데이터를 읽을 수 있다', b'0', 3, 740),
	(4947, 'ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS RANK', b'0', 3, 741),
	(4948, 'SELECT ORDER_DATE, PRODUCT_ID, MAX(QUANTITY) FROM SALES GROUP BY ORDER_DATE, PRODUCT_ID', b'0', 3, 742),
	(4949, 'UPDATE employee SET salary = salary * 1.1', b'1', 3, 743),
	(4950, 'SELECT DEPT_NO, MAX(SALARY), MIN(SALARY), MAX(SALARY) - MIN(SALARY) AS SALARY_GAP FROM EMPLOYEE GROUP BY DEPT_NO WHERE SALARY_GAP >= 5000', b'0', 3, 744),
	(4951, 'MERGE INTO TARGET_TBL USING SOURCE_TBL ON (PROD_ID = PROD_ID) WHEN MATCHED THEN UPDATE SET STOCK_QTY = SOURCE_TBL.STOCK_QTY WHEN NOT MATCHED THEN INSERT VALUES (SOURCE_TBL.PROD_ID, SOURCE_TBL.PROD_NAME, SOURCE_TBL.STOCK_QTY)', b'0', 3, 745),
	(4952, 'SELECT DISTINCT L1.USER_ID FROM LOGIN_HISTORY L1, LOGIN_HISTORY L2, LOGIN_HISTORY L3 WHERE L1.USER_ID = L2.USER_ID AND L2.USER_ID = L3.USER_ID AND L1.SUCCESS_YN = \'\'N\'\' AND L2.SUCCESS_YN = \'\'N\'\' AND L3.SUCCESS_YN = \'\'N\'\' AND L2.LOGIN_DT > L1.LOGIN_DT AND L3.LOGIN_DT > L2.LOGIN_DT', b'1', 3, 746),
	(4953, 'SELECT DISTINCT PROD_ID FROM PURCHASES p2 WHERE PROD_ID != \'\'A001\'\' AND EXISTS (SELECT 1 FROM PURCHASES p1 WHERE p1.CUST_ID = p2.CUST_ID AND p1.PROD_ID = \'\'A001\'\')', b'1', 3, 747),
	(4954, 'WHERE UPPER(emp_name) = \'SMITH\'', b'0', 3, 748),
	(4955, 'SELECT SALES_MONTH, AMOUNT, CASE WHEN LAG(AMOUNT) OVER (ORDER BY SALES_MONTH) = 0 THEN 0 ELSE ROUND((AMOUNT / LAG(AMOUNT) OVER (ORDER BY SALES_MONTH) - 1) * 100, 2) END AS GROWTH_RATE FROM SALES', b'1', 3, 749),
	(4956, '한 테이블에 여러 개의 FOREIGN KEY를 정의할 수 있다', b'0', 3, 750),
	(4957, '2023년, 2024년, 2022년 데이터의 교집합', b'0', 3, 751),
	(4958, 'SELECT DEPT_NO, SUM(CASE WHEN SALARY > AVG_SAL THEN 1 ELSE 0 END) AS CNT FROM (SELECT DEPT_NO, SALARY, AVG(SALARY) OVER (PARTITION BY DEPT_NO) AS AVG_SAL FROM EMPLOYEE) GROUP BY DEPT_NO', b'0', 3, 752),
	(4959, 'SELECT POST_ID, TITLE, COUNT(*) OVER (PARTITION BY PARENT_ID) AS reply_count FROM BOARD WHERE PARENT_ID IS NULL', b'0', 3, 753),
	(4960, 'WHERE 절에는 집계함수를 사용할 수 없다', b'0', 3, 754),
	(4961, 'SELECT DEPT_NO, SALARY_GRADE, COUNT(*) FROM EMPLOYEE GROUP BY DEPT_NO, SALARY_GRADE', b'0', 3, 755),
	(4962, 'SELECT REGION, PRODUCT, SUM(QUANTITY) FROM SALES GROUP BY PRODUCT, ROLLUP(REGION)', b'0', 3, 756),
	(4963, 'ROUND((SYSDATE - HIRE_DATE)/365) AS YEARS', b'0', 3, 757),
	(4964, 'Isolation은 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리해야 함을 의미한다', b'0', 3, 758),
	(4965, '조인 조건으로 자주 사용되는 컬럼에는 인덱스 생성을 피해야 한다', b'1', 3, 759),
	(4966, 'WITH LAST_PURCHASE AS (SELECT pu.PROD_ID, p.CATEGORY FROM PURCHASES pu JOIN PRODUCTS p ON pu.PROD_ID = p.PROD_ID WHERE pu.ORDER_DATE = (SELECT MAX(ORDER_DATE) FROM PURCHASES)) SELECT p.PROD_ID, p.PROD_NAME FROM PRODUCTS p, LAST_PURCHASE lp WHERE p.CATEGORY = lp.CATEGORY AND p.PROD_ID != lp.PROD_ID', b'1', 3, 760),
	(4967, 'WITH CONS_ABS AS (SELECT STUDENT_ID, ATT_DATE, STATUS, COUNT(CASE WHEN STATUS = \'결석\' THEN 1 END) OVER (PARTITION BY STUDENT_ID ORDER BY ATT_DATE ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS ABS_CNT FROM ATTENDANCE) SELECT DISTINCT STUDENT_ID FROM CONS_ABS WHERE ABS_CNT >= 3', b'1', 3, 761),
	(4968, 'SELECT DEPT_NO, POSITION, COUNT(*) FROM EMPLOYEE GROUP BY DEPT_NO, POSITION', b'0', 3, 762),
	(4969, 'WITH WEEKLY_AVG AS (SELECT SALES_DATE, AMOUNT, AVG(AMOUNT) OVER (ORDER BY SALES_DATE RANGE BETWEEN INTERVAL \'7\' DAY PRECEDING AND INTERVAL \'1\' DAY PRECEDING) AS AVG_AMOUNT FROM DAILY_SALES) SELECT SALES_DATE, AMOUNT FROM WEEKLY_AVG WHERE AMOUNT >= AVG_AMOUNT * 1.2', b'0', 3, 763),
	(4970, 's1.DEPT_NO = s2.DEPT_NO AND s1.SALARY_MONTH = s2.SALARY_MONTH + 1 WHERE s1.MIN_SALARY > s2.MIN_SALARY', b'0', 3, 764),
	(4971, 'DENSE_RANK() OVER (PARTITION BY DEPT_NO ORDER BY SALARY DESC) AS RNK', b'0', 3, 765),
	(4972, 'ADD_MONTHS(LAST_LOGIN_DATE, 1) <= SYSDATE', b'0', 3, 766),
	(4973, 'SELECT TO_CHAR(PURCHASE_DATE, \'YYYY-MM\') AS MONTH, SUM(CASE WHEN FIRST_FLAG = 1 THEN 1 ELSE 0 END) AS FIRST_PURCHASE, SUM(CASE WHEN LAST_FLAG = 1 THEN 1 ELSE 0 END) AS LAST_PURCHASE FROM (SELECT *, ROW_NUMBER() OVER (PARTITION BY CUST_ID ORDER BY PURCHASE_DATE) AS FIRST_FLAG, ROW_NUMBER() OVER (PARTITION BY CUST_ID ORDER BY PURCHASE_DATE DESC) AS LAST_FLAG FROM CUSTOMER_PURCHASE) GROUP BY TO_CHAR(PURCHASE_DATE, \'YYYY-MM\')', b'0', 3, 767),
	(4974, 'SELECT s1.PROD_ID, s1.SALES_MONTH, s1.QUANTITY, (SELECT AVG(QUANTITY) FROM SALES s2 WHERE s2.PROD_ID = s1.PROD_ID AND s2.SALES_MONTH < s1.SALES_MONTH AND s2.SALES_MONTH >= s1.SALES_MONTH - 3) AS AVG_3M FROM SALES s1', b'0', 3, 768),
	(4975, 'WITH WEEKLY_AVG AS (SELECT SALES_DATE, AMOUNT, AVG(AMOUNT) OVER (ORDER BY SALES_DATE RANGE BETWEEN INTERVAL \'7\' DAY PRECEDING AND INTERVAL \'1\' DAY PRECEDING) AS AVG_AMOUNT FROM DAILY_SALES) SELECT SALES_DATE, AMOUNT FROM WEEKLY_AVG WHERE AMOUNT >= AVG_AMOUNT * 1.2', b'0', 3, 769),
	(4976, 'SELECT DISTINCT m1.DEPT_NO, m1.YM AS START_YM, m3.YM AS END_YM FROM MONTHLY_SALARY m1 JOIN MONTHLY_SALARY m2 ON m1.DEPT_NO = m2.DEPT_NO AND m2.YM = m1.YM + 1 JOIN MONTHLY_SALARY m3 ON m2.DEPT_NO = m3.DEPT_NO AND m3.YM = m2.YM + 1 WHERE m1.AVG_SALARY < m2.AVG_SALARY AND m2.AVG_SALARY < m3.AVG_SALARY', b'1', 3, 770),
	(4977, '업무 프로세스에서 관리되는 데이터를 엔터티로 도출한다.', b'0', 3, 771),
	(4978, '엔터티는 인스턴스의 특성을 설명할 수 있는 속성을 포함한다.', b'0', 3, 772),
	(4979, '정규화가 진행될수록 데이터의 중복은 증가한다.', b'0', 3, 773),
	(4980, '주식별자는 반드시 단일 속성이어야 한다.', b'1', 3, 774),
	(4981, '관계는 엔터티 간의 업무적 연관성을 표현한다.', b'1', 3, 775),
	(4982, '부모 엔터티의 주식별자가 자식 엔터티의 주식별자로 상속된다.', b'1', 3, 776),
	(4983, '서브타입은 반드시 슈퍼타입의 모든 속성을 포함해야 한다.', b'1', 3, 777),
	(4984, '행위 엔터티', b'1', 3, 778),
	(4985, '관계 정의', b'0', 3, 779),
	(4986, '속성은 타원형으로 표현한다.', b'0', 3, 780),
	(4987, 'UPDATE', b'1', 3, 781),
	(4988, '격검', b'0', 3, 782),
	(4989, 'GROUP BY절에서는 Alias 명을 사용할 수 있다.', b'1', 3, 783),
	(4990, '4행', b'0', 3, 784),
	(4991, 'COALESCE 함수는 NULL이 아닌 첫 번째 값을 반환한다.', b'0', 3, 785),
	(4992, 'SELECT YEAR(SYSDATE) - COUNT(*) FROM DUAL', b'0', 3, 786),
	(4993, '5행', b'0', 3, 787),
	(4994, 'NTILE 함수는 전체 데이터를 N등분한다.', b'0', 3, 788),
	(4995, 'ORDER BY는 마지막 SELECT문에만 사용할 수 있다.', b'0', 3, 789),
	(4996, 'SELECT MAX(COALESCE(VALUE,0)) FROM SCORE;', b'0', 3, 790),
	(4997, 'GRANT', b'1', 3, 791),
	(4998, '5행', b'0', 3, 792),
	(4999, 'CONNECT_BY_ROOT', b'0', 3, 793),
	(5000, 'WHERE절', b'1', 3, 794),
	(5001, 'SELECT * FROM EMPLOYEE WHERE EXISTS (SELECT * FROM EMPLOYEE WHERE SALARY = NULL)', b'1', 3, 795),
	(5002, 'Integrity', b'1', 3, 796),
	(5003, 'LAST_DAY(date): date가 속한 월의 마지막 날짜를 반환한다', b'0', 3, 797),
	(5004, '참조되는 테이블의 기본키나 고유키를 참조한다', b'0', 3, 798),
	(5005, 'DENSE_RANK() OVER (ORDER BY VALUE DESC)', b'0', 3, 799),
	(5006, '4행', b'0', 3, 800),
	(5007, '성능 향상을 위해 사용된다', b'0', 3, 801),
	(5008, '65', b'0', 3, 802),
	(5009, '인덱스가 있으면 항상 성능이 향상된다', b'1', 3, 803),
	(5010, 'C', b'0', 3, 804),
	(5011, 'FROM → WHERE → SELECT → GROUP BY → HAVING → ORDER BY', b'0', 3, 805),
	(5012, '3행', b'0', 3, 806),
	(5013, '반드시 사용해야 한다', b'0', 3, 807),
	(5014, '3.45, 3, 300', b'0', 3, 808),
	(5015, 'SELECT TOP 20 PERCENT * FROM EMPLOYEE', b'0', 3, 809),
	(5016, 'COMMIT, ROLLBACK을 사용할 수 있다', b'1', 3, 810),
	(5017, 'INSTEAD OF UPDATE', b'0', 3, 811),
	(5018, '5행', b'1', 3, 812),
	(5019, '/*+ OLD_PLAN_GENERATOR */', b'1', 3, 813),
	(5020, 'SELECT * FROM EMPLOYEE WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE)', b'0', 3, 814),
	(5021, 'TOP 절은 WITH TIES 옵션을 사용할 수 있다', b'0', 3, 815),
	(5022, 'SELECT 절에 GROUP BY 칼럼이 없어서', b'0', 3, 816),
	(5023, 'CONNECT_BY_DEPTH', b'0', 3, 817),
	(5024, 'APPLE\n   ORANGE\n   BANANA', b'0', 3, 818),
	(5025, 'WHEN NOT MATCHED 절은 필수이다', b'1', 3, 819),
	(5026, 'Virtual Private Database 설정', b'0', 3, 820),
	(5027, '속성들의 집합으로 관리가 되어야 한다.', b'0', 3, 821),
	(5028, 'Barker 표기법으로 점선을 사용한다.', b'0', 3, 822),
	(5029, '파생속성', b'0', 3, 823),
	(5030, '한 개의 속성으로도 엔터티가 될 수 있다.', b'1', 3, 824),
	(5031, '3차 정규화', b'1', 3, 825),
	(5032, '주식별자의 구성에 포함될 수 있다.', b'0', 3, 826),
	(5033, '양방향 실선', b'0', 3, 827),
	(5034, '업무적으로 유일한 식별자를 가져야 한다.', b'0', 3, 828),
	(5035, '서브타입은 반드시 슈퍼타입의 속성을 상속받는다.', b'0', 3, 829),
	(5036, '다치 종속성 제거', b'0', 3, 830),
	(5037, 'COUNT(*) 연산에서 NULL은 포함되어 카운트된다.', b'0', 3, 831),
	(5038, 'FROM → GROUP BY → HAVING → WHERE → SELECT → ORDER BY', b'0', 3, 832),
	(5039, 'rog', b'0', 3, 833),
	(5040, 'HAVING MAX(salary) > 5000', b'0', 3, 834),
	(5041, 'AVG(column)', b'0', 3, 835),
	(5042, 'CREATE, ALTER', b'0', 3, 836),
	(5043, '홍길동', b'0', 3, 837),
	(5044, 'DEFAULT', b'1', 3, 838),
	(5045, 'ORDER BY는 마지막 SELECT문에만 사용할 수 있다.', b'0', 3, 839),
	(5046, '123.46', b'0', 3, 840),
	(5047, 'NATURAL JOIN과 동일한 의미이다.', b'0', 3, 841),
	(5048, 'Integrity (무결성)', b'1', 3, 842),
	(5049, '조건의 순서가 결과값에 영향을 미친다.', b'0', 3, 843),
	(5050, 'WHERE', b'0', 3, 844),
	(5051, '칼럼 리스트를 생략하면 모든 칼럼에 NULL이 입력된다.', b'1', 3, 845),
	(5052, 'DENSE_RANK()는 동일한 값에 대해 동일한 순위를 부여하고 순위를 건너뛰지 않는다.', b'0', 3, 846),
	(5053, 'VERTICAL JOIN', b'1', 3, 847),
	(5054, 'TRUNCATE', b'0', 3, 848),
	(5055, '\'', b'0', 3, 849),
	(5056, 'WHERE절에서 자주 사용되는 칼럼', b'1', 3, 850),
	(5057, '서브쿼리는 괄호로 감싸서 사용한다.', b'0', 3, 851),
	(5058, 'UPDATE와 INSERT를 한 번에 처리할 수 있다.', b'0', 3, 852),
	(5059, 'OTHER', b'1', 3, 853),
	(5060, 'SYS_CONNECT_BY_PATH', b'0', 3, 854),
	(5061, '같은 블록 내에서 재사용이 가능하다.', b'0', 3, 855),
	(5062, '테이블 구조는 유지된다.', b'0', 3, 856),
	(5063, '원본 테이블의 구조가 바뀌어도 VIEW는 영향을 받지 않는다.', b'1', 3, 857),
	(5064, '참조 무결성을 보장한다.', b'1', 3, 858),
	(5065, 'DELETE는 ROLLBACK이 가능하고 TRUNCATE는 ROLLBACK이 불가능하다.', b'0', 3, 859),
	(5066, 'REPEATABLE READ', b'0', 3, 860),
	(5067, '계층별 집계를 제공한다', b'0', 3, 861),
	(5068, 'FROM절이 SELECT절 뒤에 있다', b'0', 3, 862),
	(5069, '데이터가 물리적으로 분산되어 저장된다', b'0', 3, 863),
	(5070, 'SELECT TO_CHAR(a.SALES_DATE, \'YYYY-MM\') as YM, SUM(a.AMOUNT) as AMOUNT, SUM(b.AMOUNT) as LAST_YEAR FROM SALES a, SALES b WHERE a.SALES_DATE = ADD_MONTHS(b.SALES_DATE, 12) GROUP BY TO_CHAR(a.SALES_DATE, \'YYYY-MM\') ORDER BY YM;', b'0', 3, 864),
	(5071, 'EXISTS는 항상 IN보다 성능이 좋다', b'1', 3, 865),
	(5072, '반복적인 집계 수행', b'0', 3, 866),
	(5073, '3번', b'0', 3, 867),
	(5074, '데이터 파일들의 집합으로 구성된다', b'0', 3, 868),
	(5075, '항상 최적의 성능을 보장한다', b'0', 3, 869),
	(5076, 'dept_id = 10', b'1', 3, 870),
	(5077, '영속적으로 존재하는 데이터여야 한다', b'0', 3, 871),
	(5078, '불변성', b'0', 3, 872),
	(5079, '관계선택사양', b'0', 3, 873),
	(5080, '상위 엔터티 타입과의 관계가 필수적이지 않은 엔터티 타입이다', b'0', 3, 874),
	(5081, '속성은 업무에서 관리하고자 하는 정보여야 한다', b'0', 3, 875),
	(5082, '정규화는 데이터의 일관성을 보장한다', b'0', 3, 876),
	(5083, '조인으로 인한 성능 저하가 예상되는 경우', b'0', 3, 877),
	(5084, '서브타입은 반드시 하나의 슈퍼타입에만 속해야 한다', b'0', 3, 878),
	(5085, '다른 엔터티와의 관계를 먼저 정의한다', b'0', 3, 879),
	(5086, '업무적으로 부모 엔터티의 인스턴스가 자주 이용되는 경우', b'1', 3, 880),
	(5087, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE WHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE) GROUP BY DEPT_ID;', b'0', 3, 881),
	(5088, 'LEAD 함수는 다음 행의 값을 가져온다', b'0', 3, 882),
	(5089, '격검', b'0', 3, 883),
	(5090, 'ON 절에는 조인 조건식과 일반 조건식을 모두 지정할 수 있다', b'0', 3, 884),
	(5091, 'SELECT EXTRACT(MONTH FROM ORDER_DATE) as MONTH, SUM(AMOUNT) as TOTAL_AMOUNT FROM ORDERS WHERE EXTRACT(YEAR FROM ORDER_DATE) = 2023 GROUP BY EXTRACT(MONTH FROM ORDER_DATE) ORDER BY MONTH;', b'1', 3, 885),
	(5092, '집계함수는 NULL을 제외하고 계산한다', b'0', 3, 886),
	(5093, '데이터를 삭제한 후 COMMIT 전에는 ROLLBACK이 가능하다', b'0', 3, 887),
	(5094, 'START WITH → WHERE → CONNECT BY → ORDER SIBLINGS BY', b'0', 3, 888),
	(5095, '급여가 3000 이상인 사원을 조회한다', b'0', 3, 889),
	(5096, 'GROUP BY절에는 SELECT절에 사용된 집계함수 이외의 모든 컬럼이 포함되어야 한다', b'0', 3, 890),
	(5097, 'DELETE 절을 사용하여 조건에 맞는 데이터를 삭제할 수 있다', b'0', 3, 891),
	(5098, 'SELECT EMPNO, ENAME, SAL, DECODE(SAL > AVG(SAL), TRUE, \'이상\', \'이하\') AS SALARY_GRADE FROM EMP;', b'0', 3, 892),
	(5099, '집계함수를 필수적으로 사용해야 한다', b'0', 3, 893),
	(5100, 'Isolation (격리성)', b'0', 3, 894),
	(5101, 'SELECT * FROM EMP WHERE (DEPTNO, SAL) = (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);', b'0', 3, 895),
	(5102, 'ROLLUP은 인수의 순서가 바뀌어도 결과가 동일하다', b'0', 3, 896),
	(5103, '테이블당 하나의 인덱스만 생성할 수 있다', b'0', 3, 897),
	(5104, '같은 레벨의 사원만 조회한다', b'0', 3, 898),
	(5105, 'BETWEEN', b'0', 3, 899),
	(5106, '테이블, 뷰, 스키마, 데이터베이스 이벤트에 대해 정의할 수 있다', b'0', 3, 900),
	(5107, 'SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR, EXTRACT(MONTH FROM ORDER_DATE) AS MONTH, SUM(SUM(AMOUNT)) OVER (ORDER BY YEAR, MONTH) AS CUM_AMT FROM SALES GROUP BY EXTRACT(YEAR FROM ORDER_DATE), EXTRACT(MONTH FROM ORDER_DATE);', b'0', 3, 901),
	(5108, 'EXISTS는 조건을 만족하는 첫 번째 행을 찾으면 더 이상 검색하지 않는다', b'0', 3, 902),
	(5109, '뷰의 원본 테이블이 삭제되어도 뷰는 존재한다', b'0', 3, 903),
	(5110, 'SELECT * FROM EMP E, (SELECT DEPTNO, AVG(SAL) AS AVG_SAL FROM EMP GROUP BY DEPTNO) D WHERE E.DEPTNO = D.DEPTNO AND E.SAL > D.AVG_SAL;', b'0', 3, 904),
	(5111, 'IIF', b'0', 3, 905),
	(5112, 'READ UNCOMMITTED → REPEATABLE READ → READ COMMITTED → SERIALIZABLE', b'0', 3, 906),
	(5113, 'TRUNCATE', b'1', 3, 907),
	(5114, 'NO ACTION', b'0', 3, 908),
	(5115, 'SELECT * FROM EMP E WHERE SAL = (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO);', b'0', 3, 909),
	(5116, '데이터 수정, 삭제, 입력 작업의 속도를 높여준다', b'0', 3, 910),
	(5117, '증분 백업(Incremental Backup)은 마지막 백업 이후 변경된 데이터를 백업한다', b'0', 3, 911),
	(5118, 'SELECT TO_CHAR(SALE_DATE, \'MM\') AS MONTH, SUM(AMOUNT) AS TOTAL_AMOUNT, DECODE(LAG(SUM(AMOUNT)) OVER (ORDER BY SALE_DATE), NULL, 0, ROUND((SUM(AMOUNT) - LAG(SUM(AMOUNT)) OVER (ORDER BY SALE_DATE)) * 100, 2)) AS GROWTH_RATE FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2023 GROUP BY TO_CHAR(SALE_DATE, \'MM\');', b'0', 3, 912),
	(5119, '파티션별로 백업과 복구가 가능하다', b'0', 3, 913),
	(5120, 'GRANT', b'1', 3, 914),
	(5121, 'SELECT E.* FROM EMPLOYEE E JOIN (SELECT DEPT_ID, MAX(HIRE_DATE) AS MAX_DATE FROM EMPLOYEE GROUP BY DEPT_ID) M ON E.DEPT_ID = M.DEPT_ID WHERE E.HIRE_DATE = M.MAX_DATE;', b'1', 3, 915),
	(5122, '교착상태(Deadlock)는 락으로 인해 발생할 수 있다', b'0', 3, 916),
	(5123, 'SELECT STUDENT_ID, SCORE, RANK() OVER (ORDER BY SCORE DESC) AS GRADE FROM SCORE;', b'0', 3, 917),
	(5124, '해시 인덱스', b'0', 3, 918),
	(5125, 'ROWNUM > 1 과 같은 조건으로 데이터를 조회할 수 있다', b'0', 3, 919),
	(5126, '보안성을 향상시킬 수 있다', b'0', 3, 920),
	(5127, '기초 엔터티와 행위 엔터티', b'0', 3, 921),
	(5128, '문서 엔터티', b'0', 3, 922),
	(5129, '관계선택사양', b'0', 3, 923),
	(5130, '강한관계', b'0', 3, 924),
	(5131, '주식별자에 포함되지 않는 속성은 반드시 주식별자에 종속된다', b'0', 3, 925),
	(5132, 'Single Type', b'0', 3, 926),
	(5133, 'M:N 관계', b'0', 3, 927),
	(5134, '제3정규형은 이행함수 종속을 제거한다', b'0', 3, 928),
	(5135, '단일 속성으로 구성되었는지 여부에 따라 단일식별자와 복합식별자로 분류', b'0', 3, 929),
	(5136, '대량의 데이터를 빈번하게 조회하는 경우', b'0', 3, 930),
	(5137, 'SELECT A.DEPT_NO, A.AVG_SAL FROM (SELECT DEPT_NO, AVG(SALARY) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_NO) A WHERE A.AVG_SAL >= 3000;', b'0', 3, 931),
	(5138, 'END 다음에 별칭을 지정할 수 있다', b'0', 3, 932),
	(5139, '스칼라 서브쿼리는 SELECT절에서만 사용할 수 있다', b'0', 3, 933),
	(5140, '전문', b'0', 3, 934),
	(5141, 'GROUP BY절과 함께 사용할 수 있다', b'0', 3, 935),
	(5142, 'SELECT ORDER_DATE, COALESCE(SUM(ORDER_AMOUNT), 0) FROM ORDERS WHERE TO_CHAR(ORDER_DATE,\'YYYY-MM\') = \'2024-01\' GROUP BY ORDER_DATE UNION ALL SELECT TRUNC(SYSDATE) + LEVEL - 1,0 FROM DUAL CONNECT BY LEVEL <= 31;', b'0', 3, 936),
	(5143, 'COUNT(*) 함수는 NULL 값을 포함하여 카운트한다', b'0', 3, 937),
	(5144, 'LEFT OUTER JOIN은 오른쪽 테이블의 모든 행이 결과에 포함된다', b'0', 3, 938),
	(5145, 'SELECT * FROM EMPLOYEE WHERE (DEPT_NO, HIRE_DATE) IN (SELECT DEPT_NO, MAX(HIRE_DATE) FROM EMPLOYEE GROUP BY DEPT_NO);', b'1', 3, 939),
	(5146, 'HAVING절에는 GROUP BY절에 명시된 컬럼만 사용할 수 있다', b'1', 3, 940),
	(5147, 'SELECT YEAR, QUARTER, TOTAL_AMOUNT, DECODE(PREV_YEAR_AMOUNT, NULL, NULL, ROUND((TOTAL_AMOUNT - PREV_YEAR_AMOUNT) / PREV_YEAR_AMOUNT * 100, 2)) AS GROWTH_RATE FROM (SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, CEIL(EXTRACT(MONTH FROM SALE_DATE)/3) AS QUARTER, SUM(AMOUNT) AS TOTAL_AMOUNT, LAG(SUM(AMOUNT), 4) OVER (ORDER BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3)) AS PREV_YEAR_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3));', b'0', 3, 941),
	(5148, 'Isolation(격리성)은 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끝날 때까지 대기해야 함을 의미한다', b'1', 3, 942),
	(5149, 'LEFT OUTER JOIN의 경우 오른쪽 테이블의 모든 데이터가 출력된다', b'0', 3, 943),
	(5150, 'TABLE_A와 TABLE_B 중 한 테이블이 비어있을 때', b'0', 3, 944),
	(5151, '데이터가 자주 변경되는 컬럼', b'1', 3, 945),
	(5152, '테이블 락은 로우 락보다 더 큰 범위의 락이다', b'0', 3, 946),
	(5153, 'TOP-DOWN 방식으로 순방향 전개되며, CONNECT_BY_ISLEAF는 리프 노드일 때 1을 반환한다', b'1', 3, 947),
	(5154, '테이블의 물리적인 저장 공간이 감소한다', b'1', 3, 948),
	(5155, '에러 처리를 위한 예외 처리 기능을 제공한다', b'0', 3, 949),
	(5156, '데이터베이스의 보안성을 향상시킬 수 있다', b'0', 3, 950),
	(5157, 'SELECT EMP_NO, EMP_NAME, DEPT_NO, HIRE_DATE, COUNT(*) OVER (PARTITION BY DEPT_NO ORDER BY HIRE_DATE) AS SEQ FROM EMPLOYEE;', b'1', 3, 951),
	(5158, 'DROP TABLE은 테이블 스페이스를 즉시 반환하지만, TRUNCATE TABLE은 반환하지 않는다', b'0', 3, 952),
	(5159, '5', b'0', 3, 953),
	(5160, '트리거 내에서 COMMIT, ROLLBACK을 실행할 수 있다', b'1', 3, 954),
	(5161, 'SELECT MONTH FROM (SELECT LEVEL AS MONTH FROM DUAL CONNECT BY LEVEL <= 6) WHERE MONTH NOT IN (SELECT EXTRACT(MONTH FROM SALE_DATE) FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2024);', b'0', 3, 955),
	(5162, 'ALTER', b'1', 3, 956),
	(5163, '데이터의 물리적인 독립성을 제공한다', b'0', 3, 957),
	(5164, 'COL1    RESULT\nB       3,4\nA       1,2', b'0', 3, 958),
	(5165, '한 번의 SQL문으로 여러 DML을 수행할 수 있다', b'0', 3, 959),
	(5166, 'SELECT * FROM SALARY_HISTORY PIVOT (SUM(SALARY) FOR PAY_MONTH IN (\'202401\', \'202402\', \'202403\'));', b'0', 3, 960),
	(5167, 'IN 절은 항상 EXISTS 절보다 성능이 우수하다', b'1', 3, 961),
	(5168, 'SELECT * FROM ORDERS A WHERE 3 > (SELECT COUNT(*) FROM ORDERS B WHERE B.MEMBER_ID = A.MEMBER_ID AND B.ORDER_DATE > A.ORDER_DATE);', b'0', 3, 962),
	(5169, '인덱스 컬럼에 대해 함수나 연산을 수행하는 경우', b'0', 3, 963),
	(5170, '두 컬럼 모두 현재 시간이 출력된다', b'0', 3, 964),
	(5171, 'INTERSECT는 두 집합의 공통된 행을 반환한다', b'0', 3, 965),
	(5172, 'SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, EXTRACT(MONTH FROM SALE_DATE) AS MONTH, SUM(AMOUNT) AS MONTHLY_AMOUNT, SUM(AMOUNT) OVER (ORDER BY SALE_DATE) AS CUM_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), EXTRACT(MONTH FROM SALE_DATE), SALE_DATE;', b'0', 3, 966),
	(5173, '데이터의 중복성', b'1', 3, 967),
	(5174, 'LAST_DAY(date)는 해당 월의 마지막 날짜를 반환한다', b'0', 3, 968),
	(5175, 'SELECT * FROM EMPLOYEE E WHERE SALARY > (SELECT SALARY FROM (SELECT SALARY, RANK() OVER (PARTITION BY DEPT_NO ORDER BY SALARY DESC) AS RN FROM EMPLOYEE WHERE DEPT_NO = E.DEPT_NO) WHERE RN = 1);', b'1', 3, 969),
	(5176, 'REPEATABLE READ는 트랜잭션 내에서 동일한 조회 결과를 보장한다', b'0', 3, 970),
	(5177, '여러 개의 인스턴스를 가질 수 있다', b'0', 3, 971),
	(5178, '불변성 - 식별자의 값은 자주 변하지 않아야 한다', b'0', 3, 972),
	(5179, 'M:1', b'0', 3, 973),
	(5180, '해당 없음', b'0', 3, 974),
	(5181, '반드시 물리적인 형태로 존재하는 것만 찾는다', b'1', 3, 975),
	(5182, '갱신 이상', b'0', 3, 976),
	(5183, '조인으로 인한 성능 저하가 심각한 경우', b'0', 3, 977),
	(5184, '시스템 내부적으로 필요한 속성', b'0', 3, 978),
	(5185, '테이블명의 길이', b'1', 3, 979),
	(5186, '고객은 주문을 할 수도 있다', b'0', 3, 980),
	(5187, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE WHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE) GROUP BY DEPT_ID', b'0', 3, 981),
	(5188, 'NULL과 \'\'(빈문자)는 동일하다', b'1', 3, 982),
	(5189, '격검', b'0', 3, 983),
	(5190, '조인에 사용된 칼럼은 식별자를 사용할 수 없다', b'1', 3, 984),
	(5191, 'SELECT TO_CHAR(SALE_DATE,\'YYYY\'), TO_CHAR(SALE_DATE,\'MM\'), SUM(AMOUNT) FROM SALES GROUP BY TO_CHAR(SALE_DATE,\'YYYY\'), TO_CHAR(SALE_DATE,\'MM\')', b'0', 3, 985),
	(5192, 'FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 3, 986),
	(5193, 'START WITH MGR_ID IS NULL CONNECT BY PRIOR EMP_ID = MGR_ID', b'0', 3, 987),
	(5194, 'ROLLUP은 계층 구조로 소계를 생성한다', b'0', 3, 988),
	(5195, 'CREATE, DROP', b'0', 3, 989),
	(5196, '(DEPT_ID, SALARY) IN (SELECT DEPT_ID, MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID)', b'1', 3, 990),
	(5197, 'ALTER TABLE EMPLOYEE ALTER COLUMN NAME VARCHAR2(20) NOT NULL', b'0', 3, 991),
	(5198, 'GROUP BY 절과 함께 사용할 수 있다', b'1', 3, 992),
	(5199, 'MONTH=02, AMOUNT=150, PREV_AMOUNT=200', b'0', 3, 993),
	(5200, 'SELECT NAME, SCORE, RANK() OVER (ORDER BY SCORE DESC) AS RANK, RANK() OVER (ORDER BY SCORE ASC) AS DENSE_RANK FROM SCORE', b'0', 3, 994),
	(5201, 'GROUP BY절에서는 컬럼 순서를 바꾸어도 결과는 같다', b'0', 3, 995),
	(5202, 'MINUS는 순서에 상관없이 동일한 결과를 반환한다', b'1', 3, 996),
	(5203, '0', b'0', 3, 997),
	(5204, '상호연관 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있다', b'0', 3, 998),
	(5205, 'SELECT DEPT_ID, COUNT(*) FROM EMPLOYEE GROUP BY DEPT_ID HAVING COUNT(*) >= 2', b'1', 3, 999),
	(5206, '독립성(Isolation)', b'0', 3, 1000),
	(5207, 'SELECT * FROM ORDERS GROUP BY CUSTOMER_ID HAVING ORDER_DATE = MAX(ORDER_DATE)', b'0', 3, 1001),
	(5208, '2, 6', b'1', 3, 1002),
	(5209, '24/12/16 14:30:00', b'0', 3, 1003),
	(5210, 'ON 절에서 조인 조건을 지정한다', b'0', 3, 1004),
	(5211, 'NULL', b'0', 3, 1005),
	(5212, 'ADD_MONTHS 함수는 특정 날짜에 개월 수를 더한다', b'0', 3, 1006),
	(5213, 'SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT MAX(SALARY) FROM EMPLOYEE)', b'0', 3, 1007),
	(5214, 'EXISTS는 항상 IN보다 성능이 좋다', b'1', 3, 1008),
	(5215, 'YEAR | AMOUNT\n2023 | 1000', b'0', 3, 1009),
	(5216, '인덱스는 INSERT, UPDATE, DELETE 시 성능에 영향을 줄 수 있다', b'0', 3, 1010),
	(5217, 'DEPT_ID  LEVEL  DEPT_NAME\n1        1      영업부\n2        2      국내영업팀\n4        3      서울영업소\n5        3      부산영업소\n3        2      해외영업팀', b'1', 3, 1011),
	(5218, 'ORDER BY 절 이후에 순번이 부여된다', b'1', 3, 1012),
	(5219, '123.46, 123.456, 123.456', b'0', 3, 1013),
	(5220, 'SELECT COL1 FROM TABLE_A WHERE COL1 IN (1,2) UNION SELECT COL1 FROM TABLE_B WHERE COL1 IN (3,4)', b'1', 3, 1014),
	(5221, 'REPEATABLE READ', b'0', 3, 1015),
	(5222, 'STATUS 컬럼의 CHECK 제약조건 위배', b'1', 3, 1016),
	(5223, 'Isolation(고립성) - 트랜잭션은 다른 트랜잭션의 연산에 끼어들 수 없다', b'0', 3, 1017),
	(5224, 'DROP은 테이블 구조와 데이터 모두 삭제된다', b'0', 3, 1018),
	(5225, 'GROUP BY절에 있는 컬럼은 SELECT절에 없어도 된다', b'0', 3, 1019),
	(5226, '뷰는 복잡한 SQL문을 단순화할 수 있다', b'0', 3, 1020),
	(5227, '반드시 물리적인 형태로 존재해야 한다', b'1', 3, 1021),
	(5228, '조회 성능이 항상 향상된다', b'1', 3, 1022),
	(5229, '테이블명은 반드시 영문 대문자로만 작성해야 한다', b'1', 3, 1023),
	(5230, '서브타입은 슈퍼타입의 모든 속성을 상속받는다', b'0', 3, 1024),
	(5231, '불변성: 식별자의 값은 자주 변하지 않아야 한다', b'0', 3, 1025),
	(5232, '본질식별자', b'0', 3, 1026),
	(5233, '관계속성', b'0', 3, 1027),
	(5234, '조회 성능이 중요한 경우', b'0', 3, 1028),
	(5235, '업무적으로 의미가 있어야 한다', b'0', 3, 1029),
	(5236, '강한관계', b'0', 3, 1030),
	(5237, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE WHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE) GROUP BY DEPT_NO', b'0', 3, 1031),
	(5238, 'N', b'1', 3, 1032),
	(5239, 'GROUP BY절에서는 컬럼의 별칭(Alias)을 사용할 수 없다', b'1', 3, 1033),
	(5240, 'ROW_NUMBER 함수는 동일한 값이라도 고유한 순번을 부여한다', b'0', 3, 1034),
	(5241, 'START WITH EMP_ID = 1 CONNECT BY MGR_ID = PRIOR EMP_ID', b'0', 3, 1035),
	(5242, 'DROP은 테이블 구조와 데이터를 모두 삭제한다', b'0', 3, 1036),
	(5243, '뷰는 자체적인 인덱스를 가질 수 있다', b'1', 3, 1037),
	(5244, '격검', b'1', 3, 1038),
	(5245, 'AGE 컬럼에 DEFAULT 값이 지정되어 있어서 발생하는 오류', b'0', 3, 1039),
	(5246, 'WHEN NOT MATCHED THEN 절을 사용하여 새로운 데이터를 삽입할 수 있다', b'0', 3, 1040),
	(5247, 'SELECT * FROM EMPLOYEE WHERE (DEPT_ID, SALARY) IN (SELECT DEPT_ID, MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID)', b'1', 3, 1041),
	(5248, '0, 0, 0', b'1', 3, 1042),
	(5249, 'ON DELETE CASCADE 옵션을 사용할 수 있다', b'0', 3, 1043),
	(5250, 'SAL 내림차순, HIREDATE 오름차순', b'1', 3, 1044),
	(5251, '서브쿼리의 SELECT 절에는 와일드카드(*)를 사용하는 것이 성능상 유리하다', b'1', 3, 1045),
	(5252, 'UNION은 조건절을 사용할 수 없고, UNION ALL은 사용할 수 있다', b'0', 3, 1046),
	(5253, 'SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT SALARY FROM EMPLOYEE WHERE ROWNUM <= 3 ORDER BY SALARY DESC)', b'0', 3, 1047),
	(5254, '영구적으로 저장되어 다른 세션에서도 사용할 수 있다', b'1', 3, 1048),
	(5255, 'CASE JOB WHEN = \'MANAGER\' THEN 1000 WHEN = \'SALESMAN\' THEN 800 WHEN = \'CLERK\' THEN 600 ELSE 0 END', b'0', 3, 1049),
	(5256, 'JOIN 조건으로 자주 사용되는 열인 경우', b'0', 3, 1050),
	(5257, 'LEVEL = 1', b'0', 3, 1051),
	(5258, 'SELECT DEPT_ID, AVG(SALARY) - (SELECT AVG(SALARY) FROM EMPLOYEE) FROM EMPLOYEE GROUP BY DEPT_ID', b'1', 3, 1052),
	(5259, '9', b'1', 3, 1053),
	(5260, 'READ COMMITTED → READ UNCOMMITTED → REPEATABLE READ → SERIALIZABLE', b'0', 3, 1054),
	(5261, 'SELECT COL1 FROM TABLE_A UNION SELECT COL1 FROM TABLE_B', b'0', 3, 1055),
	(5262, '123.5', b'0', 3, 1056),
	(5263, '시스템 권한과 객체 권한을 모두 부여할 수 있다', b'0', 3, 1057),
	(5264, 'NULLIF 함수는 두 개의 인자가 같으면 NULL을 반환한다', b'0', 3, 1058),
	(5265, 'DEPT_ID | SUM(AMOUNT)\n10      | 3000', b'0', 3, 1059),
	(5266, 'Isolation(독립성) - 트랜잭션은 다른 트랜잭션의 실행에 영향을 미치지 않아야 한다', b'0', 3, 1060),
	(5267, 'SELECT MONTHS_BETWEEN(ORDER_DATE, \'2023-12-01\')\nFROM ORDERS', b'0', 3, 1061),
	(5268, 'WHERE 절에서 사용할 수 있다', b'1', 3, 1062),
	(5269, '서브쿼리는 메인쿼리보다 먼저 실행된다', b'0', 3, 1063),
	(5270, '기본키(Primary Key)에는 자동으로 인덱스가 생성된다', b'0', 3, 1064),
	(5271, '\'**SQL\', \'**SQL\'', b'0', 3, 1065),
	(5272, 'GRANT, REVOKE', b'1', 3, 1066),
	(5273, '6', b'0', 3, 1067),
	(5274, 'CHECK 제약조건은 컬럼에 입력되는 값을 제한할 수 있다', b'0', 3, 1068),
	(5275, '트리거 내에서 COMMIT, ROLLBACK을 사용할 수 있다', b'1', 3, 1069),
	(5276, 'ORAC*L*E SQL', b'0', 3, 1070),
	(5277, '엔터티는 반드시 속성을 포함해야 한다', b'0', 3, 1071),
	(5278, '불변성: 식별자로 지정된 속성의 값은 자주 변하지 않는 것이어야 한다', b'0', 3, 1072),
	(5279, '필수관계는 \'O\'로 표현하고, 선택관계는 \'|\'로 표현한다', b'1', 3, 1073),
	(5280, '갱신이상: 동일 교수의 정보를 수정할 때 여러 번 수정이 필요하다', b'0', 3, 1074),
	(5281, '영속적으로 존재하는 인스턴스의 집합이어야 한다', b'0', 3, 1075),
	(5282, 'N:1 관계', b'0', 3, 1076),
	(5283, '데이터의 일관성이 저하된다', b'0', 3, 1077),
	(5284, '관계차수(Cardinality)', b'1', 3, 1078),
	(5285, '도메인 특성에 따른 분류: 코드성 속성, 시스템 속성, 계산된 속성', b'0', 3, 1079),
	(5286, '트랜잭션의 유형', b'0', 3, 1080),
	(5287, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE WHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE) GROUP BY DEPT_NO', b'0', 3, 1081),
	(5288, 'ORDER BY 절에 의해 정렬된 순서로 순위를 부여한다', b'0', 3, 1082),
	(5289, '전문가', b'0', 3, 1083),
	(5290, '일반적으로 실무에서 가장 많이 사용되는 조인이다', b'0', 3, 1084),
	(5291, 'SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR, EXTRACT(MONTH FROM ORDER_DATE) AS MONTH, SUM(ORDER_AMOUNT) FROM ORDERS GROUP BY EXTRACT(YEAR FROM ORDER_DATE), EXTRACT(MONTH FROM ORDER_DATE) ORDER BY YEAR, MONTH', b'1', 3, 1085),
	(5292, 'NULL과 NULL의 비교는 TRUE를 반환한다', b'0', 3, 1086),
	(5293, 'COMMIT 이전에는 ROLLBACK이 가능하다', b'0', 3, 1087),
	(5294, 'START WITH → WHERE → CONNECT BY → ORDER SIBLINGS BY', b'0', 3, 1088),
	(5295, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO WHERE AVG(SALARY) >= 3000', b'0', 3, 1089),
	(5296, 'GROUP BY 절에서 컬럼의 순서는 결과에 영향을 미치지 않는다', b'0', 3, 1090),
	(5297, 'ALTER TABLE EMPLOYEE CHANGE NAME EMP_NAME VARCHAR2(20)', b'0', 3, 1091),
	(5298, 'WHERE 절이 GROUP BY 절보다 먼저 위치해야 한다', b'0', 3, 1092),
	(5299, 'LEAD 함수는 다음 행의 값을 참조한다', b'0', 3, 1093),
	(5300, 'SELECT empno, sal, deptno FROM EMPLOYEES GROUP BY deptno HAVING sal > AVG(sal)', b'0', 3, 1094),
	(5301, '모든 트랜잭션은 서로 영향을 주면서 실행되어야 한다', b'1', 3, 1095),
	(5302, 'SELECT, INSERT', b'0', 3, 1096),
	(5303, 'SQL#', b'0', 3, 1097),
	(5304, '인덱스는 항상 정렬된 상태를 유지한다', b'0', 3, 1098),
	(5305, 'SELECT MONTH(ORDER_DATE), SUM(ORDER_AMOUNT) FROM ORDERS WHERE YEAR(ORDER_DATE) = 2023 GROUP BY MONTH(ORDER_DATE)', b'0', 3, 1099),
	(5306, 'WITH CHECK OPTION을 사용하면 뷰의 조건에 맞지 않는 데이터의 입력을 막을 수 있다', b'0', 3, 1100),
	(5307, 'CONNECT_BY_ISLEAF', b'0', 3, 1101),
	(5308, '123.46, 123.456, 123.456', b'0', 3, 1102),
	(5309, 'SELECT SUBJECT, NAME, MAX(SCORE) FROM SCORES GROUP BY SUBJECT, NAME', b'0', 3, 1103),
	(5310, 'NULL과 숫자 0은 동일한 의미로 취급된다', b'1', 3, 1104),
	(5311, 'SELECT DEPT_NO, HIRE_DATE, NAME FROM EMPLOYEES E1 WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEES E2 WHERE E1.DEPT_NO = E2.DEPT_NO AND E2.HIRE_DATE > E1.HIRE_DATE)', b'0', 3, 1105),
	(5312, '2023/12/16           2023-12-16           2023.12.16', b'0', 3, 1106),
	(5313, 'HAVING 절은 GROUP BY 절 없이 단독으로 사용할 수 있다', b'1', 3, 1107),
	(5314, 'SELECT * FROM EMPLOYEES GROUP BY DEPT_NO HAVING SALARY > AVG(SALARY)', b'0', 3, 1108),
	(5315, 'UNION은 UNION ALL보다 일반적으로 더 많은 시스템 자원을 사용한다', b'0', 3, 1109),
	(5316, '데이터가 자주 변경되는 컬럼', b'1', 3, 1110),
	(5317, 'DEPT 테이블의 모든 부서번호가 EMP 테이블에 존재할 때', b'0', 3, 1111),
	(5318, 'NULL', b'0', 3, 1112),
	(5319, 'ROWS와 RANGE는 동일한 결과를 항상 반환한다', b'1', 3, 1113),
	(5320, 'SELECT EMP_NO, MAX(CNT) AS MAX_CONSECUTIVE_DAYS FROM (SELECT EMP_NO, COUNT(*) AS CNT FROM (SELECT EMP_NO, ABSENT_DATE, ABSENT_DATE - ROW_NUMBER() OVER (PARTITION BY EMP_NO ORDER BY ABSENT_DATE) AS GRP FROM ATTENDANCE) GROUP BY EMP_NO, GRP) GROUP BY EMP_NO', b'1', 3, 1114),
	(5321, '데이터 통합 작업에 유용하게 사용될 수 있다', b'0', 3, 1115),
	(5322, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) AS CUM_SUM FROM SALES GROUP BY SALE_DATE, AMOUNT', b'0', 3, 1116),
	(5323, 'PIVOT 절에서 지정한 컬럼은 SELECT 절에서 사용할 수 없다', b'0', 3, 1117),
	(5324, 'SELECT * FROM EMPLOYEES WHERE SALARY IN (SELECT MAX(SALARY) FROM EMPLOYEES GROUP BY DEPT_NO)', b'0', 3, 1118),
	(5325, '1, 2, 3, 4, 5', b'1', 3, 1119),
	(5326, 'READ COMMITTED는 다른 트랜잭션이 커밋하지 않은 데이터를 읽을 수 있다', b'1', 3, 1120),
	(5327, '속성을 포함해야 한다', b'0', 3, 1121),
	(5328, '불변성 - 시간이 경과해도 그 값이 변하지 않아야 한다', b'0', 3, 1122),
	(5329, '문서 엔터티', b'0', 3, 1123),
	(5330, '관계선택사양', b'0', 3, 1124),
	(5331, '갱신 이상', b'0', 3, 1125),
	(5332, '실선으로 표현한다', b'0', 3, 1126),
	(5333, '데이터의 일관성을 확보한다', b'0', 3, 1127),
	(5334, '파생 속성', b'0', 3, 1128),
	(5335, '하나의 서브타입은 여러 개의 슈퍼타입을 가질 수 있다', b'1', 3, 1129),
	(5336, '데이터 무결성을 보장하는 역할을 한다', b'0', 3, 1130),
	(5337, 'GROUP BY절에는 별칭(Alias)을 사용할 수 없다', b'1', 3, 1131),
	(5338, '3', b'1', 3, 1132),
	(5339, 'NULLIF(A,B): A와 B가 같으면 NULL을 반환한다', b'0', 3, 1133),
	(5340, 'pe', b'1', 3, 1134),
	(5341, 'SELECT MONTH(JOIN_DATE), SUM(AMOUNT)\nFROM SALES\nWHERE YEAR(JOIN_DATE) = 2023\nGROUP BY MONTH(JOIN_DATE);', b'0', 3, 1135),
	(5342, '5행', b'0', 3, 1136),
	(5343, 'CONNECT_BY_ISLEAF', b'0', 3, 1137),
	(5344, 'ROLLUP은 CUBE보다 적은 수의 소계를 생성한다', b'0', 3, 1138),
	(5345, '여러 개의 정렬 기준을 지정할 수 있다', b'0', 3, 1139),
	(5346, 'SELECT EMP_ID, SALARY, ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS RANK\nFROM EMP;', b'0', 3, 1140),
	(5347, 'SELECT *\nFROM EMP\nWHERE (DEPT_ID, SALARY) IN (SELECT DEPT_ID, MAX(SALARY)\n                           FROM EMP);', b'0', 3, 1141),
	(5348, 'UPDATE와 INSERT를 동시에 수행할 수 있다', b'0', 3, 1142),
	(5349, 'PREV_AMOUNT 열이 현재 달의 판매액을 보여준다', b'0', 3, 1143),
	(5350, 'Isolation(격리성): 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않아야 한다', b'0', 3, 1144),
	(5351, 'SELECT EMP_ID, MANAGER_ID, EMP_NAME\nFROM ORGANIZATION\nWHERE MANAGER_ID IS NOT NULL\nSTART WITH EMP_ID = 1;', b'0', 3, 1145),
	(5352, 'COMMIT', b'1', 3, 1146),
	(5353, '123.45, 123, 123', b'0', 3, 1147),
	(5354, 'FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 3, 1148),
	(5355, 'UNION ALL이 UNION보다 일반적으로 성능이 좋다', b'0', 3, 1149),
	(5356, '인덱스는 WHERE절에서 자주 사용되는 컬럼에 생성하는 것이 좋다', b'0', 3, 1150),
	(5357, 'SELECT *\nFROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC)\nWHERE ROWNUM > 3;', b'0', 3, 1151),
	(5358, 'NULL과 문자열을 결합하면 결과는 NULL이다', b'0', 3, 1152),
	(5359, 'ORACLE***\', \'***ORACLE\', \'***ORACLE***\'', b'0', 3, 1153),
	(5360, '6행(부서별 소계 + 개별 그룹별 소계)', b'0', 3, 1154),
	(5361, '재귀적 쿼리를 작성할 수 있다', b'0', 3, 1155),
	(5362, '3, 6, 6', b'0', 3, 1156),
	(5363, 'SELECT 절에서 사용할 수 있다', b'0', 3, 1157),
	(5364, 'SELECT DECODE(STATUS, 1, \'신규\', \'진행\', \'완료\') FROM PRODUCT;', b'1', 3, 1158),
	(5365, 'ORDER BY절을 사용할 수 없다', b'1', 3, 1159),
	(5366, '4', b'0', 3, 1160),
	(5367, 'SELECT DEPT_ID, AVG(SALARY)\nFROM EMP\nWHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMP)\nGROUP BY DEPT_ID;', b'0', 3, 1161),
	(5368, 'SELECT *\nFROM SALES\nPIVOT(SUM(AMOUNT) FOR QUARTER IN (\'Q1\' AS Q1, \'Q2\' AS Q2));', b'0', 3, 1162),
	(5369, 'READ COMMITTED는 오라클의 기본 격리 수준이다', b'0', 3, 1163),
	(5370, 'LEVEL  CONNECT_BY_ISLEAF\n------------------------\n1      1\n2      1\n3      1', b'0', 3, 1164),
	(5371, 'SELECT DEPT_ID, SUM(SALARY) + SUM(BONUS)\nFROM EMPLOYEE\nGROUP BY DEPT_ID;', b'0', 3, 1165),
	(5372, '한 테이블에 여러 개의 외래키를 정의할 수 있다', b'0', 3, 1166),
	(5373, '배치 프로그램의 경우 FK 제약조건을 비활성화했다가 활성화한다', b'0', 3, 1167),
	(5374, 'SELECT MIN(NUM) AS START_NUM, MAX(NUM) AS END_NUM\nFROM (\n    SELECT NUM, NUM - ROW_NUMBER() OVER (ORDER BY NUM) AS GRP\n    FROM NUMBERS\n)\nGROUP BY GRP;', b'1', 3, 1168),
	(5375, 'WITH READ ONLY 옵션을 사용하면 뷰를 통한 DML이 불가능하다', b'0', 3, 1169),
	(5376, '2024-01-02, 2024-03-01, 1', b'0', 3, 1170),
	(5377, '반드시 물리적인 형태로 존재해야 한다', b'1', 3, 1171),
	(5378, '속성은 업무상 구체적인 의미를 가지는 데이터의 최소 단위이다', b'1', 3, 1172),
	(5379, '고객과 주문은 식별관계이다', b'0', 3, 1173),
	(5380, '파생 속성', b'0', 3, 1174),
	(5381, '여러 개의 속성이 조합된 식별자는 가능하면 피한다', b'0', 3, 1175),
	(5382, '조회 성능이 항상 향상된다', b'1', 3, 1176),
	(5383, '트랜잭션의 유형', b'0', 3, 1177),
	(5384, '비식별관계는 실선으로 표현한다', b'0', 3, 1178),
	(5385, '데이터 무결성을 보장하는 수단이 된다', b'0', 3, 1179),
	(5386, '지나친 조인으로 인한 성능 저하가 예상되는 경우', b'0', 3, 1180),
	(5387, 'SELECT *\nFROM EMPLOYEE E1\nWHERE SALARY = (SELECT MAX(SALARY)\n                FROM EMPLOYEE E2\n                WHERE E1.DEPT_ID = E2.DEPT_ID);', b'1', 3, 1181),
	(5388, 'GROUP BY 절에서는 HAVING 절을 사용하여 그룹을 필터링할 수 있다', b'0', 3, 1182),
	(5389, 'SQL', b'0', 3, 1183),
	(5390, '4행이 조회된다', b'0', 3, 1184),
	(5391, '순위 함수로 RANK, DENSE_RANK, ROW_NUMBER 등이 있다', b'0', 3, 1185),
	(5392, 'FALSE', b'0', 3, 1186),
	(5393, '조건에 따라 데이터를 입력하거나 수정할 수 있다', b'0', 3, 1187),
	(5394, '3, 2, 1', b'0', 3, 1188),
	(5395, 'MINUS는 두 집합의 교집합을 반환한다', b'0', 3, 1189),
	(5396, 'SELECT STUDENT_ID, MIN(ABSENT_DATE) AS START_DATE, MAX(ABSENT_DATE) AS END_DATE\nFROM (\n    SELECT STUDENT_ID, ABSENT_DATE,\n           ABSENT_DATE - ROW_NUMBER() OVER (ORDER BY ABSENT_DATE) AS GRP\n    FROM ATTENDANCE\n)\nGROUP BY STUDENT_ID, GRP;', b'1', 3, 1190),
	(5397, 'NULL을 0으로 처리하여 모든 행이 업데이트된다', b'0', 3, 1191),
	(5398, '실행 후 즉시 메모리에서 삭제된다', b'1', 3, 1192),
	(5399, 'SQL Developer *', b'0', 3, 1193),
	(5400, 'ORDER BY 고객번호 ASC, 주문금액 DESC, 주문일자 ASC', b'1', 3, 1194),
	(5401, '인덱스 컬럼에 함수가 적용될 때', b'1', 3, 1195),
	(5402, 'INSERT INTO TEST(ID, CODE) VALUES (3, \'02\');', b'0', 3, 1196),
	(5403, 'NOW 컬럼과 AFTER_1HOUR 컬럼의 날짜는 항상 같다', b'0', 3, 1197),
	(5404, 'SELECT DISTINCT * FROM TABLE1;', b'0', 3, 1198),
	(5405, 'SELECT *\nFROM EMP\nWHERE (DEPT_ID, SALARY) IN (\n    SELECT DEPT_ID, MAX(SALARY)\n    FROM EMP\n    GROUP BY DEPT_ID\n);', b'1', 3, 1199),
	(5406, '테이블스페이스는 세그먼트의 집합이다', b'0', 3, 1200),
	(5407, 'SELECT LEVEL, NAME\nFROM EMPLOYEE\nSTART WITH MANAGER_ID IS NULL\nCONNECT BY PRIOR MANAGER_ID = EMP_ID;', b'0', 3, 1201),
	(5408, 'CURRVAL은 NEXTVAL을 한 번도 실행하지 않은 세션에서도 사용할 수 있다', b'1', 3, 1202),
	(5409, '5, NULL', b'0', 3, 1203),
	(5410, '오류가 발생한다', b'0', 3, 1204),
	(5411, 'FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 3, 1205),
	(5412, '두 번째 표현식은 오류가 발생한다', b'0', 3, 1206),
	(5413, 'SELECT TOP 3 * FROM TRANSACTIONS\nORDER BY TRANS_DATE DESC;', b'0', 3, 1207),
	(5414, 'COUNT(*)는 NULL을 포함한 모든 행을 계산한다', b'0', 3, 1208),
	(5415, 'TRUNCATE', b'1', 3, 1209),
	(5416, '123.45, 123, 123', b'0', 3, 1210),
	(5417, 'SELECT *\nFROM SALES\nPIVOT (\n    SUM(AMOUNT)\n    FOR (YEAR, DEPT) IN ((2023, \'A\'), (2023, \'B\'), (2024, \'A\'), (2024, \'B\'))\n);', b'0', 3, 1211),
	(5418, '한 테이블에 여러 개의 인덱스를 생성할 수 있다', b'0', 3, 1212),
	(5419, '오류가 발생한다', b'0', 3, 1213),
	(5420, '자주 COMMIT 하기', b'1', 3, 1214),
	(5421, 'SELECT SALE_DATE, AMOUNT,\n       SUM(AMOUNT) OVER ()\nFROM SALES;', b'0', 3, 1215),
	(5422, '복잡한 SQL문을 단순화할 수 있다', b'0', 3, 1216),
	(5423, '세 번째 INSERT까지 모두 성공한다', b'0', 3, 1217),
	(5424, 'ROLLUP만 소계를 생성할 수 있다', b'0', 3, 1218),
	(5425, 'SELECT * FROM EMP E1\nWHERE SALARY > AVG(SELECT SALARY\n                   FROM EMP E2\n                   WHERE E2.DEPT_ID = E1.DEPT_ID);', b'0', 3, 1219),
	(5426, 'D', b'0', 3, 1220),
	(5427, '명확화 - 누구나 이해하기 쉽게 하나의 엔터티에 대해 여러가지 관점을 제시한다', b'1', 3, 1221),
	(5428, '엔터티간의 관계가 필수인지 선택인지 파악한다', b'0', 3, 1222),
	(5429, '불변성 - 한 번 정해진 값은 변하지 않아야 한다', b'0', 3, 1223),
	(5430, '스키마에 따른 분류 - 내부/외부 엔터티', b'1', 3, 1224),
	(5431, '파생 속성', b'1', 3, 1225),
	(5432, '갱신 이상', b'0', 3, 1226),
	(5433, '관계는 엔터티와 달리 물리적인 형태로만 존재해야 한다', b'1', 3, 1227),
	(5434, '데이터의 무결성이 중요한 경우', b'0', 3, 1228),
	(5435, '자식 엔터티의 데이터 양이 부모 엔터티보다 많을 때', b'1', 3, 1229),
	(5436, '1:1 관계로 분할한다', b'0', 3, 1230),
	(5437, 'SELECT DEPT_ID, MAX(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID, NAME;', b'0', 3, 1231),
	(5438, 'ROLLUP은 총계만 계산하고, CUBE는 소계와 총계를 모두 계산한다', b'0', 3, 1232),
	(5439, 'AABBCC, AADDEE', b'0', 3, 1233),
	(5440, 'SELECT D.DEPT_NAME, E.EMP_NAME FROM DEPT D INNER JOIN EMP E ON D.DEPT_ID = E.DEPT_ID;', b'0', 3, 1234),
	(5441, '삭제된 데이터는 ROLLBACK으로 복구할 수 없다', b'1', 3, 1235),
	(5442, 'NUM  PREV_NUM  NEXT_NUM\n1    1         2\n2    2         3\n3    3         3', b'0', 3, 1236),
	(5443, 'BETWEEN', b'0', 3, 1237),
	(5444, 'MONTHS_BETWEEN은 두 날짜 간의 월 수 차이를 반환한다', b'0', 3, 1238),
	(5445, 'SELECT * FROM EMPLOYEE GROUP BY DEPT_ID HAVING SALARY > AVG(SALARY);', b'0', 3, 1239),
	(5446, 'NULL은 정렬 시 오라클에서는 가장 큰 값으로 취급된다', b'0', 3, 1240),
	(5447, 'LEVEL  ISLEAF\n3      1\n2      0\n1      0', b'0', 3, 1241),
	(5448, '재귀적 쿼리를 작성할 수 있다', b'0', 3, 1242),
	(5449, 'TARGET_TBL의 데이터를 SOURCE_TBL로 모두 이동할 때', b'0', 3, 1243),
	(5450, 'NULL값이 많은 컬럼', b'1', 3, 1244),
	(5451, '두 번째 INSERT문만 성공한다', b'0', 3, 1245),
	(5452, 'Isolation은 실행 중인 트랜잭션이 완료될 때까지 대기해야 한다', b'1', 3, 1246),
	(5453, '123, \'123.45\', \'2024-01-01\'', b'0', 3, 1247),
	(5454, 'SELECT SALE_DATE, AMOUNT, (SELECT SUM(AMOUNT) FROM SALES S2 WHERE S2.SALE_DATE <= S1.SALE_DATE) AS CUM_SUM FROM SALES S1;', b'0', 3, 1248),
	(5455, 'COMMIT', b'1', 3, 1249),
	(5456, 'NULLIF(A,B)는 A와 B가 같으면 NULL을 반환한다', b'0', 3, 1250),
	(5457, 'SELECT EMP_ID, DEPT_ID, SALARY, ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS RANK FROM EMPLOYEE;', b'0', 3, 1251),
	(5458, '항상 서브쿼리의 모든 행을 검색한다', b'1', 3, 1252),
	(5459, '1, 4, 3, 3.5', b'0', 3, 1253),
	(5460, 'HAVING절을 사용하여 그룹을 필터링할 수 있다', b'0', 3, 1254),
	(5461, 'DELETE FROM DUPLICATE_DATA WHERE ID IN (SELECT ID FROM DUPLICATE_DATA GROUP BY ID, NAME, VALUE HAVING COUNT(*) > 1);', b'0', 3, 1255),
	(5462, 'CROSS JOIN은 두 테이블의 카테시안 곱을 반환한다', b'0', 3, 1256),
	(5463, '오류가 발생한다', b'0', 3, 1257),
	(5464, '상관 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있다', b'0', 3, 1258),
	(5465, 'QUARTER  AMOUNT\nQ1       2500\nQ2       4500', b'0', 3, 1259),
	(5466, 'REPEATABLE READ', b'0', 3, 1260),
	(5467, 'SELECT MONTH, AMOUNT, ROUND((AMOUNT - LAG(AMOUNT)) / LAG(AMOUNT) * 100, 2) AS RATE FROM SALES ORDER BY MONTH;', b'0', 3, 1261),
	(5468, '세그먼트의 저장 공간을 관리한다', b'0', 3, 1262),
	(5469, 'LEVEL  EMP_NAME\n3      최대리\n2      이부장\n2      박부장\n1      김사장', b'0', 3, 1263),
	(5470, '두 테이블의 데이터를 단순히 합칠 때', b'0', 3, 1264),
	(5471, '조회 조건으로 자주 사용되는 컬럼에 생성하는 것이 좋다', b'0', 3, 1265),
	(5472, 'SELECT * FROM (SELECT A.*, ROW_NUMBER() OVER (PARTITION BY DEPT_ID ORDER BY HIRE_DATE DESC) AS RN FROM EMP A) WHERE RN <= 3;', b'1', 3, 1266),
	(5473, '5, 0, 0', b'0', 3, 1267),
	(5474, '데이터베이스가 비정상 종료되면 자동으로 ROLLBACK된다', b'0', 3, 1268),
	(5475, 'SELECT DEPT_ID, POSITION, AVG(SALARY) FROM EMP GROUP BY DEPT_ID, POSITION;', b'1', 3, 1269),
	(5476, 'SQL문을 포함할 수 있다', b'0', 3, 1270),
	(5477, '기초 엔터티와 행위 엔터티', b'1', 3, 1271),
	(5478, '문서 엔터티', b'0', 3, 1272),
	(5479, '관계선택사양', b'0', 3, 1273),
	(5480, '불변성 - 식별자가 한번 지정되면 그 값은 변하지 않아야 함', b'0', 3, 1274),
	(5481, '갱신 이상', b'0', 3, 1275),
	(5482, '관계는 엔터티 간 관련성을 갖는 인스턴스들의 집합으로 정의됨', b'0', 3, 1276),
	(5483, '도메인은 속성의 논리적인 제약조건이므로 반드시 물리적으로 구현되어야 함', b'1', 3, 1277),
	(5484, '수강내역은 반드시 하나의 학생과 연결되어야 한다', b'0', 3, 1278),
	(5485, '자식 테이블의 기본키가 반드시 부모 테이블의 기본키를 포함해야 한다', b'1', 3, 1279),
	(5486, '하나의 슈퍼타입은 반드시 하나의 서브타입만 가질 수 있다', b'1', 3, 1280),
	(5487, 'FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY', b'1', 3, 1281),
	(5488, 'NULL, 5, 3', b'0', 3, 1282),
	(5489, 'NULLIF(expr1, expr2): 두 표현식이 같으면 NULL을, 다르면 expr1을 반환', b'0', 3, 1283),
	(5490, 'SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING COUNT(*) >= 1;', b'0', 3, 1284),
	(5491, 'UNBOUNDED PRECEDING은 파티션의 첫 번째 행을 의미', b'0', 3, 1285),
	(5492, 'TableA RIGHT OUTER JOIN TableB', b'0', 3, 1286),
	(5493, 'Isolation(격리성): 실행 중인 트랜잭션은 다른 트랜잭션의 연산에 끼어들 수 없음', b'0', 3, 1287),
	(5494, 'CONNECT_BY_ISLEAF', b'0', 3, 1288),
	(5495, '2023, NULL, 700', b'0', 3, 1289),
	(5496, '기본키(Primary Key)에는 자동으로 인덱스가 생성된다', b'0', 3, 1290),
	(5497, '중첩 서브쿼리는 WHERE 절에서 사용되는 서브쿼리이다', b'0', 3, 1291),
	(5498, 'B, 2, 2, 75, 75', b'0', 3, 1292),
	(5499, 'SELECT * FROM EMP A WHERE SAL >= ALL (SELECT SAL FROM EMP B WHERE A.DEPTNO = B.DEPTNO);', b'0', 3, 1293),
	(5500, 'ID | VALUE\n1  | X\n2  | B', b'0', 3, 1294),
	(5501, 'NTILE 함수는 파티션별 전체 건수를 ARGUMENT 값으로 N 등분한다', b'0', 3, 1295),
	(5502, '2, 2, 2', b'0', 3, 1296),
	(5503, 'INSERT INTO TEST_TABLE VALUES (3, NULL, 25);', b'0', 3, 1297),
	(5504, 'SERIALIZABLE은 가장 높은 격리수준이다', b'0', 3, 1298),
	(5505, 'RIGHT OUTER JOIN', b'0', 3, 1299),
	(5506, 'CONNECT BY PRIOR 절은 자식과 부모의 관계를 지정한다', b'0', 3, 1300),
	(5507, 'GROUP BY 절에서는 집계 함수를 사용할 수 없다', b'1', 3, 1301),
	(5508, 'MONTH | TOTAL\n00    | 400\n01    | 500\n02    | 600\n03    | 700', b'0', 3, 1302),
	(5509, 'UNION ALL이 UNION보다 일반적으로 성능이 좋다', b'0', 3, 1303),
	(5510, 'CHECK 제약조건은 컬럼에 입력되는 값을 체크한다', b'0', 3, 1304),
	(5511, '검정', b'0', 3, 1305),
	(5512, 'SELECT * FROM EMPLOYEE E WHERE SALARY > ANY (SELECT AVG(SALARY) FROM EMPLOYEE F GROUP BY DEPT_ID);', b'0', 3, 1306),
	(5513, 'DDL 문장 수행 후에는 자동으로 Commit이 발생한다', b'0', 3, 1307),
	(5514, 'LEVEL 값에 상관없이 모든 행이 동일하게 출력된다', b'0', 3, 1308),
	(5515, 'BETWEEN 연산자를 사용하는 경우', b'0', 3, 1309),
	(5516, 'SELECT * FROM EMPLOYEE E WHERE NOT EXISTS (SELECT 1 FROM EMPLOYEE F WHERE E.DEPTNO = F.DEPTNO AND E.SAL < F.SAL);', b'0', 3, 1310),
	(5517, 'INSERT, UPDATE, DELETE', b'0', 3, 1311),
	(5518, 'YEAR | MONTH | AMOUNT | RESULT\n2023 | 01    | 100    | 100\n2023 | 02    | 200    | 200\n2023 | 03    | 300    | 300', b'0', 3, 1312),
	(5519, '컬럼 이름 변경은 RENAME COLUMN 구문을 사용한다', b'0', 3, 1313),
	(5520, 'A1B2C3', b'0', 3, 1314),
	(5521, 'Phantom Read', b'0', 3, 1315),
	(5522, 'CREATE TABLE EMP (\n    EMPNO NUMBER(4) PRIMARY KEY,\n    ENAME VARCHAR2(10),\n    DEPTNO NUMBER(4),\n    PRIMARY KEY (EMPNO)\n);', b'1', 3, 1316),
	(5523, 'ADD_MONTHS는 월에 정수를 더한 날짜를 반환한다', b'0', 3, 1317),
	(5524, 'SELECT EMPNO, DEPTNO, SAL,\n       DENSE_RANK() OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) AS RNK\nFROM EMP;', b'0', 3, 1318),
	(5525, 'ORDER BY 절은 반드시 필요하다', b'1', 3, 1319),
	(5526, '테이블 락은 행 락보다 더 큰 범위의 락이다', b'0', 3, 1320),
	(5950, '리뷰내용변경이력(리뷰번호, 변경일자, 이전내용)', b'1', 4, 721),
	(5951, '계좌잔고(계좌번호, 잔액) → DEFAULT 0', b'1', 4, 722),
	(5952, '주문과 상품을 1:N 관계로 설계하고 취소 정보는 상태 코드로 관리', b'0', 4, 723),
	(5953, '별도의 배송지번호를 추가하여 기본키로 지정', b'1', 4, 724),
	(5954, '진료예약 테이블의 진료일자', b'0', 4, 725),
	(5955, '주문상품과 상품의 관계', b'0', 4, 726),
	(5956, '회원등급(슈퍼타입) - 일반/실버/골드/VIP(서브타입): 선택적 서브타입', b'1', 4, 727),
	(5957, '배송완료된 주문의 상세 정보를 조회하는 경우', b'1', 4, 728),
	(5958, 'UUID 사용', b'0', 4, 729),
	(5959, '여행자정보(예약번호, 회원번호, 영문명, 여권번호, 여권만료일)', b'1', 4, 730),
	(5960, 'SELECT SALES_MONTH, TOTAL_AMOUNT, DECODE(TOTAL_AMOUNT/LAG(TOTAL_AMOUNT) OVER (ORDER BY SALES_MONTH), NULL, 0, TOTAL_AMOUNT/LAG(TOTAL_AMOUNT) OVER (ORDER BY SALES_MONTH)) AS INCREASE_RATE FROM SALES_MONTHLY WHERE TOTAL_AMOUNT/LAG(TOTAL_AMOUNT) OVER (ORDER BY SALES_MONTH) >= 1.1', b'0', 4, 731),
	(5961, 'DEPT_NO  EMP_COUNT  TOTAL_SALARY  AVG_BONUS\n-------------------------------------------\n10       2          8000          500\n20       2          6800          0\n30       1          4500          700', b'0', 4, 732),
	(5962, 'SELECT * FROM EMPLOYEE E WHERE E.SALARY > ALL (SELECT AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO)', b'0', 4, 733),
	(5963, 'UNION 연산은 서로 다른 테이블의 칼럼 이름이 다르면 사용할 수 없다', b'1', 4, 734),
	(5964, 'SELECT a.order_date, MIN(b.order_date) as next_order_date FROM orders a, orders b WHERE b.order_date > a.order_date GROUP BY a.order_date HAVING MIN(b.order_date) - a.order_date >= 3', b'0', 4, 735),
	(5965, 'SELECT DISTINCT E1.* FROM EMPLOYEE E1, EMPLOYEE E2 WHERE E1.DEPT_NO = E2.DEPT_NO AND E1.SALARY >= E2.SALARY GROUP BY E1.DEPT_NO, E1.EMP_NO, E1.NAME, E1.SALARY HAVING E1.SALARY = MAX(E2.SALARY)', b'0', 4, 736),
	(5966, 'SELECT PROD_ID, TRX_DATE, SUM(CASE TRX_TYPE WHEN \'\'IN\'\' THEN QUANTITY WHEN \'\'OUT\'\' THEN -QUANTITY END) FROM STOCK_HISTORY GROUP BY PROD_ID, TRX_DATE ORDER BY PROD_ID, TRX_DATE', b'0', 4, 737),
	(5967, 'INSERT 문장에서는 ORDER BY 절을 사용할 수 없다', b'1', 4, 738),
	(5968, 'SELECT DEPT_ID, DEPT_NAME, LEVEL FROM DEPARTMENT START WITH PARENT_DEPT_ID IS NULL CONNECT BY NOCYCLE PRIOR DEPT_ID = PARENT_DEPT_ID', b'0', 4, 739),
	(5969, 'TRUNCATE 문은 ROLLBACK이 가능하다', b'1', 4, 740),
	(5970, 'COUNT(*) AS RANK', b'0', 4, 741),
	(5971, 'SELECT s1.* FROM SALES s1 LEFT JOIN SALES s2 ON s1.ORDER_DATE = s2.ORDER_DATE AND s1.QUANTITY < s2.QUANTITY WHERE s2.QUANTITY IS NULL', b'0', 4, 742),
	(5972, 'DROP VIEW v_emp_dept', b'0', 4, 743),
	(5973, 'SELECT DEPT_NO, MAX(SALARY) OVER (PARTITION BY DEPT_NO) - MIN(SALARY) OVER (PARTITION BY DEPT_NO) AS SALARY_GAP FROM EMPLOYEE WHERE SALARY_GAP >= 5000', b'0', 4, 744),
	(5974, 'MERGE INTO TARGET_TBL T USING SOURCE_TBL S ON (T.PROD_ID = S.PROD_ID) WHEN MATCHED THEN UPDATE T SET T.STOCK_QTY = S.STOCK_QTY WHEN NOT EXISTS THEN INSERT INTO T VALUES (S.PROD_ID, S.PROD_NAME, S.STOCK_QTY)', b'0', 4, 745),
	(5975, 'SELECT USER_ID FROM LOGIN_HISTORY WHERE SUCCESS_YN = \'\'N\'\' AND USER_ID IN (SELECT USER_ID FROM LOGIN_HISTORY GROUP BY USER_ID HAVING COUNT(*) >= 3)', b'0', 4, 746),
	(5976, 'SELECT PROD_ID FROM PURCHASES p1 WHERE p1.PROD_ID != \'\'A001\'\' AND p1.CUST_ID = (SELECT CUST_ID FROM PURCHASES p2 WHERE p2.PROD_ID = \'\'A001\'\')', b'0', 4, 747),
	(5977, 'WHERE department_id = 10', b'0', 4, 748),
	(5978, 'SELECT SALES_MONTH, AMOUNT, ROUND((AMOUNT - PREV_AMOUNT) / PREV_AMOUNT * 100, 2) AS GROWTH_RATE FROM (SELECT SALES_MONTH, AMOUNT, LAG(AMOUNT) OVER (ORDER BY SALES_MONTH) AS PREV_AMOUNT FROM SALES)', b'0', 4, 749),
	(5979, 'FOREIGN KEY로 지정된 컬럼은 부모 테이블의 PRIMARY KEY가 아닌 UNIQUE 컬럼을 참조할 수 있다', b'0', 4, 750),
	(5980, '2023년, 2024년 데이터의 합집합과 2022년 데이터의 차집합', b'0', 4, 751),
	(5981, 'SELECT DEPT_NO, COUNT(*) FROM EMPLOYEE E1 WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E1.DEPT_NO = E2.DEPT_NO) GROUP BY DEPT_NO', b'0', 4, 752),
	(5982, 'SELECT p.POST_ID, p.TITLE, COUNT(r.POST_ID) AS reply_count FROM BOARD p, BOARD r WHERE p.POST_ID = r.PARENT_ID(+) GROUP BY p.POST_ID, p.TITLE', b'0', 4, 753),
	(5983, 'GROUP BY 절에 컬럼 순서를 바꾸면 결과도 달라진다', b'1', 4, 754),
	(5984, 'SELECT DEPT_NO, MAX(DECODE(SALARY_GRADE, \'\'A\'\', CNT, 0)) AS A_CNT, MAX(DECODE(SALARY_GRADE, \'\'B\'\', CNT, 0)) AS B_CNT, MAX(DECODE(SALARY_GRADE, \'\'C\'\', CNT, 0)) AS C_CNT FROM (SELECT DEPT_NO, SALARY_GRADE, COUNT(*) AS CNT FROM EMPLOYEE GROUP BY DEPT_NO, SALARY_GRADE)', b'0', 4, 755),
	(5985, 'SELECT REGION, PRODUCT, SUM(QUANTITY) FROM SALES GROUP BY GROUPING SETS((REGION, PRODUCT), REGION, ())', b'0', 4, 756),
	(5986, 'FLOOR((SYSDATE - HIRE_DATE)/365) AS YEARS', b'0', 4, 757),
	(5987, 'Durability는 트랜잭션 실행 중에는 다른 트랜잭션의 접근을 막아야 함을 의미한다', b'1', 4, 758),
	(5988, '자주 업데이트되는 컬럼에 인덱스를 생성하면 성능이 저하될 수 있다', b'0', 4, 759),
	(5989, 'SELECT DISTINCT p2.PROD_ID, p2.PROD_NAME FROM PURCHASES pu1 JOIN PRODUCTS p1 ON pu1.PROD_ID = p1.PROD_ID JOIN PRODUCTS p2 ON p1.CATEGORY = p2.CATEGORY WHERE pu1.ORDER_DATE = (SELECT MAX(ORDER_DATE) FROM PURCHASES) AND p2.PROD_ID != pu1.PROD_ID', b'0', 4, 760),
	(5990, 'SELECT DISTINCT STUDENT_ID FROM (SELECT STUDENT_ID, ATT_DATE, ROW_NUMBER() OVER (PARTITION BY STUDENT_ID ORDER BY ATT_DATE) AS RN FROM ATTENDANCE WHERE STATUS = \'결석\') GROUP BY STUDENT_ID HAVING COUNT(*) >= 3', b'0', 4, 761),
	(5991, 'SELECT DEPT_NO, MAX(DECODE(POSITION, \'사원\', CNT, 0)) AS 사원, MAX(DECODE(POSITION, \'대리\', CNT, 0)) AS 대리, MAX(DECODE(POSITION, \'과장\', CNT, 0)) AS 과장 FROM (SELECT DEPT_NO, POSITION, COUNT(*) AS CNT FROM EMPLOYEE GROUP BY DEPT_NO, POSITION)', b'0', 4, 762),
	(5992, 'SELECT SALES_DATE, AMOUNT FROM DAILY_SALES s1 WHERE AMOUNT >= 1.2 * (SELECT SUM(AMOUNT) / COUNT(*) FROM DAILY_SALES s2 WHERE s2.SALES_DATE < s1.SALES_DATE AND s2.SALES_DATE >= s1.SALES_DATE - 7)', b'0', 4, 763),
	(5993, 'WITH MONTHLY_DIFF AS (SELECT DEPT_NO, SALARY_MONTH, MIN_SALARY, MIN_SALARY - LAG(MIN_SALARY) OVER (PARTITION BY DEPT_NO ORDER BY SALARY_MONTH) AS SALARY_DIFF FROM SALARY_HISTORY) SELECT DEPT_NO, SALARY_MONTH, MIN_SALARY FROM MONTHLY_DIFF WHERE SALARY_DIFF > 0', b'0', 4, 764),
	(5994, 'COUNT(*) AS RNK', b'0', 4, 765),
	(5995, 'TRUNC(SYSDATE) - TRUNC(LAST_LOGIN_DATE) >= 30', b'1', 4, 766),
	(5996, 'WITH MONTHLY AS (SELECT CUST_ID, TO_CHAR(PURCHASE_DATE, \'YYYY-MM\') AS MONTH, ROW_NUMBER() OVER (PARTITION BY CUST_ID ORDER BY PURCHASE_DATE) AS FIRST_FLAG, ROW_NUMBER() OVER (PARTITION BY CUST_ID ORDER BY PURCHASE_DATE DESC) AS LAST_FLAG FROM CUSTOMER_PURCHASE) SELECT MONTH, COUNT(CASE WHEN FIRST_FLAG = 1 THEN 1 END) AS FIRST_PURCHASE, COUNT(CASE WHEN LAST_FLAG = 1 THEN 1 END) AS LAST_PURCHASE FROM MONTHLY GROUP BY MONTH', b'0', 4, 767),
	(5997, 'WITH MONTHLY_AVG AS (SELECT PROD_ID, SALES_MONTH, QUANTITY, AVG(QUANTITY) OVER (PARTITION BY PROD_ID ORDER BY SALES_MONTH ROWS 2 PRECEDING) AS AVG_3M FROM SALES) SELECT * FROM MONTHLY_AVG', b'0', 4, 768),
	(5998, 'SELECT SALES_DATE, AMOUNT FROM DAILY_SALES s1 WHERE AMOUNT >= 1.2 * (SELECT SUM(AMOUNT) / COUNT(*) FROM DAILY_SALES s2 WHERE s2.SALES_DATE < s1.SALES_DATE AND s2.SALES_DATE >= s1.SALES_DATE - 7)', b'0', 4, 769),
	(5999, 'WITH CONSECUTIVE_INCREASE AS (SELECT DEPT_NO, YM, AVG_SALARY, ROW_NUMBER() OVER (PARTITION BY DEPT_NO ORDER BY YM) AS RN, COUNT(CASE WHEN AVG_SALARY > LAG(AVG_SALARY) OVER (PARTITION BY DEPT_NO ORDER BY YM) THEN 1 END) OVER (PARTITION BY DEPT_NO ORDER BY YM ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS INC_CNT FROM MONTHLY_SALARY) SELECT DEPT_NO, YM, AVG_SALARY FROM CONSECUTIVE_INCREASE WHERE INC_CNT >= 2', b'0', 4, 770),
	(6000, '통계 데이터는 정보의 가치와 상관없이 반드시 엔터티로 도출한다.', b'1', 4, 771),
	(6001, '엔터티는 반드시 2개 이상의 인스턴스를 가져야만 한다.', b'1', 4, 772),
	(6002, '정규화는 테이블을 생성하는 유일한 방법이다.', b'0', 4, 773),
	(6003, '속성은 엔터티를 설명하는 항목이다.', b'0', 4, 774),
	(6004, '두 엔터티 간에는 하나의 관계만 존재할 수 있다.', b'0', 4, 775),
	(6005, '부모 엔터티와 자식 엔터티는 항상 비식별 관계여야 한다.', b'0', 4, 776),
	(6006, '슈퍼타입과 서브타입은 계층적 관계를 가진다.', b'0', 4, 777),
	(6007, '코드 엔터티', b'0', 4, 778),
	(6008, '인덱스 설계', b'1', 4, 779),
	(6009, '식별자는 반드시 빨간색으로 표현한다.', b'1', 4, 780),
	(6010, 'TRUNCATE', b'0', 4, 781),
	(6011, 'SQLD', b'0', 4, 782),
	(6012, 'GROUP BY절에서는 SELECT 목록에 있는 칼럼을 반드시 포함해야 한다.', b'0', 4, 783),
	(6013, '전체 행', b'0', 4, 784),
	(6014, 'NVL2 함수는 첫 번째 인자가 NULL이면 두 번째 인자를, NULL이 아니면 세 번째 인자를 반환한다.', b'1', 4, 785),
	(6015, 'SELECT ADD_MONTHS(SYSDATE, -12 * ROWNUM) FROM DUAL', b'0', 4, 786),
	(6016, '6행', b'0', 4, 787),
	(6017, 'DENSE_RANK 함수는 동일한 순위를 하나의 건수로 계산한다.', b'1', 4, 788),
	(6018, '두 SELECT문의 칼럼 개수는 달라도 된다.', b'1', 4, 789),
	(6019, 'SELECT NVL(MAX(VALUE),0) FROM SCORE;', b'0', 4, 790),
	(6020, 'INSERT', b'0', 4, 791),
	(6021, '6행', b'1', 4, 792),
	(6022, 'ROWID', b'1', 4, 793),
	(6023, '집계함수', b'0', 4, 794),
	(6024, 'SELECT * FROM EMPLOYEE WHERE SALARY = ANY (SELECT SALARY FROM EMPLOYEE WHERE DEPT_ID = 10)', b'0', 4, 795),
	(6025, 'Durability', b'0', 4, 796),
	(6026, 'NEXT_MONTH(date): date의 다음 달 첫 날을 반환한다', b'1', 4, 797),
	(6027, '참조되는 테이블이 먼저 삭제될 수 있다', b'1', 4, 798),
	(6028, 'NTILE(4) OVER (ORDER BY VALUE DESC)', b'0', 4, 799),
	(6029, 'NULL 값이 포함된 3행', b'1', 4, 800),
	(6030, '재귀적 호출이 불가능하다', b'1', 4, 801),
	(6031, '50', b'0', 4, 802),
	(6032, '칼럼 값에 NULL이 많은 경우 인덱스의 효율이 낮아질 수 있다', b'0', 4, 803),
	(6033, 'NULL', b'0', 4, 804),
	(6034, 'FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 4, 805),
	(6035, '0행', b'0', 4, 806),
	(6036, 'GROUP BY와 함께 사용할 수 없다', b'0', 4, 807),
	(6037, '3.45, 4, 345', b'0', 4, 808),
	(6038, 'SELECT * FROM EMPLOYEE SAMPLE(20)', b'0', 4, 809),
	(6039, '복잡한 데이터 무결성 규칙을 설정할 수 있다', b'0', 4, 810),
	(6040, 'DURING INSERT', b'1', 4, 811),
	(6041, '6행', b'0', 4, 812),
	(6042, '/*+ INDEX */', b'0', 4, 813),
	(6043, 'SELECT * FROM EMPLOYEE WHERE SALARY IN (SELECT MAX(SALARY) FROM EMPLOYEE GROUP BY NAME)', b'0', 4, 814),
	(6044, 'ROWNUM은 동적으로 번호가 부여된다', b'0', 4, 815),
	(6045, 'AVG(SAL)의 별칭이 없어서', b'0', 4, 816),
	(6046, 'CONNECT_BY_LENGTH', b'1', 4, 817),
	(6047, '*pple\n   *r*nge\n   B*n*n*', b'0', 4, 818),
	(6048, 'DELETE 절도 사용할 수 있다', b'0', 4, 819),
	(6049, 'SELECT 문에서 DECODE 함수 사용', b'1', 4, 820),
	(6050, '하나의 속성으로도 엔터티로 정의할 수 있다.', b'1', 4, 821),
	(6051, '식별자 관계를 나타내는 예시이다.', b'0', 4, 822),
	(6052, '임시속성', b'1', 4, 823),
	(6053, '최소 2개 이상의 인스턴스가 존재해야 한다.', b'0', 4, 824),
	(6054, 'BCNF', b'0', 4, 825),
	(6055, '항상 엔터티를 식별할 수 있어야 한다.', b'1', 4, 826),
	(6056, '양방향 점선', b'0', 4, 827),
	(6057, '영속적으로 존재하는 인스턴스의 집합이어야 한다.', b'0', 4, 828),
	(6058, '슈퍼타입과 서브타입은 항상 1:1 관계를 가진다.', b'1', 4, 829),
	(6059, '결정자 함수적 종속성 제거', b'0', 4, 830),
	(6060, 'GROUP BY 연산에서 NULL은 하나의 그룹으로 처리된다.', b'0', 4, 831),
	(6061, 'SELECT → FROM → GROUP BY → WHERE → HAVING → ORDER BY', b'0', 4, 832),
	(6062, 'ram', b'0', 4, 833),
	(6063, 'HAVING SUM(salary)/COUNT(*) <= 3000', b'0', 4, 834),
	(6064, 'MAX(column)', b'0', 4, 835),
	(6065, 'INSERT, UPDATE', b'0', 4, 836),
	(6066, 'ZZZ', b'0', 4, 837),
	(6067, 'UNIQUE', b'0', 4, 838),
	(6068, '컬럼의 개수가 다르더라도 UNION이 가능하다.', b'1', 4, 839),
	(6069, '123.0', b'0', 4, 840),
	(6070, '항상 OUTER JOIN으로만 수행된다.', b'0', 4, 841),
	(6071, 'Durability (지속성)', b'0', 4, 842),
	(6072, '단일 행을 반환하는 함수를 사용할 수 있다.', b'0', 4, 843),
	(6073, 'ORDER BY', b'1', 4, 844),
	(6074, '입력할 칼럼을 명시하지 않으면 테이블의 모든 칼럼에 대해 입력해야 한다.', b'0', 4, 845),
	(6075, '모든 윈도우 함수는 ORDER BY절이 필수이다.', b'1', 4, 846),
	(6076, 'FULL OUTER JOIN', b'0', 4, 847),
	(6077, 'DELETE', b'1', 4, 848),
	(6078, '에러 발생', b'0', 4, 849),
	(6079, 'NULL값이 많은 칼럼', b'0', 4, 850),
	(6080, '단일 행 서브쿼리에는 단일 행 연산자를 사용해야 한다.', b'0', 4, 851),
	(6081, 'DELETE 절은 사용할 수 없다.', b'1', 4, 852),
	(6082, 'NULL', b'0', 4, 853),
	(6083, 'RANK', b'1', 4, 854),
	(6084, '다른 WITH절 내에서는 사용할 수 없다.', b'1', 4, 855),
	(6085, '테이블의 용량이 초기화된다.', b'0', 4, 856),
	(6086, '특정 칼럼만 조회할 수 있도록 제한할 수 있다.', b'0', 4, 857),
	(6087, '기본키와 같은 의미이다.', b'0', 4, 858),
	(6088, 'DELETE는 조건절을 사용할 수 없고 TRUNCATE는 조건절을 사용할 수 있다.', b'1', 4, 859),
	(6089, 'READ ONLY', b'1', 4, 860),
	(6090, '인수의 순서가 바뀌어도 결과는 동일하다', b'0', 4, 861),
	(6091, '별칭은 한 번만 사용해야 한다', b'0', 4, 862),
	(6092, '테이블의 전체 크기가 감소한다', b'0', 4, 863),
	(6093, 'SELECT TO_CHAR(SALES_DATE, \'YYYY-MM\') as YM, SUM(AMOUNT) as AMOUNT, SUM(DECODE(TO_CHAR(SALES_DATE, \'YYYY\'), TO_CHAR(ADD_MONTHS(SYSDATE, -12), \'YYYY\'), AMOUNT)) as LAST_YEAR FROM SALES GROUP BY TO_CHAR(SALES_DATE, \'YYYY-MM\') ORDER BY YM;', b'0', 4, 864),
	(6094, 'IN은 NULL을 포함할 경우 결과가 NULL이 될 수 있다', b'0', 4, 865),
	(6095, '테이블 조인 연산', b'1', 4, 866),
	(6096, '4번', b'0', 4, 867),
	(6097, '백업과 복구의 단위가 될 수 있다', b'0', 4, 868),
	(6098, '조인 방식을 확인할 수 있다', b'0', 4, 869),
	(6099, 'NVL(bonus, 0) = 1000', b'0', 4, 870),
	(6100, '반드시 물리적인 형태로 존재해야 한다', b'0', 4, 871),
	(6101, '대체성', b'1', 4, 872),
	(6102, '관계타입', b'0', 4, 873),
	(6103, '상위 엔터티 타입의 존재여부에 따라 종속적인 엔터티 타입이다', b'0', 4, 874),
	(6104, '하나의 속성에는 같은 이름이 존재할 수 없다', b'0', 4, 875),
	(6105, '정규화는 이상현상을 방지한다', b'0', 4, 876),
	(6106, '읽기 작업이 월등히 많은 경우', b'0', 4, 877),
	(6107, '슈퍼타입과 서브타입은 항상 1:1 관계여야 한다', b'0', 4, 878),
	(6108, '업무상 관리하는 데이터 집합을 찾는다', b'0', 4, 879),
	(6109, '자식 엔터티의 주식별자에 부모 엔터티의 주식별자가 포함되는 경우', b'0', 4, 880),
	(6110, 'SELECT DEPT_ID, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_ID WHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE);', b'0', 4, 881),
	(6111, 'RANK 함수는 중복순위 제외하고 순차적으로 순위를 부여한다', b'0', 4, 882),
	(6112, 'SQ', b'0', 4, 883),
	(6113, 'CROSS JOIN은 WHERE 절에서 조인 조건을 지정해야 한다', b'0', 4, 884),
	(6114, 'SELECT TO_CHAR(ORDER_DATE, \'\'MM\'\') as MONTH, SUM(AMOUNT) as TOTAL_AMOUNT FROM ORDERS GROUP BY TO_CHAR(ORDER_DATE, \'\'MM\'\') HAVING TO_CHAR(ORDER_DATE, \'\'YYYY\'\') = \'\'2023\'\';', b'0', 4, 885),
	(6115, 'NULL값은 정렬시 Oracle에서는 가장 큰 값으로 취급된다', b'0', 4, 886),
	(6116, '특정 컬럼만 삭제할 수 있다', b'0', 4, 887),
	(6117, 'CONNECT BY → START WITH → WHERE → ORDER SIBLINGS BY', b'0', 4, 888),
	(6118, '부서별 최고 급여가 3000 이상인 부서를 조회한다', b'0', 4, 889),
	(6119, 'GROUP BY절은 WHERE절 뒤에 위치해야 한다', b'0', 4, 890),
	(6120, 'MERGE 문은 트랜잭션을 발생시키지 않는다', b'0', 4, 891),
	(6121, 'SELECT A.EMPNO, A.ENAME, A.SAL, DECODE(A.SAL > B.AVG_SAL, \'이상\', \'이하\') AS SALARY_GRADE FROM EMP A, (SELECT AVG(SAL) AS AVG_SAL FROM EMP) B;', b'0', 4, 892),
	(6122, 'IN 절에는 Subquery를 사용할 수 없다', b'0', 4, 893),
	(6123, 'Duplication (중복성)', b'1', 4, 894),
	(6124, 'SELECT DISTINCT E.* FROM EMP E, EMP F WHERE E.DEPTNO = F.DEPTNO AND E.SAL >= F.SAL;', b'0', 4, 895),
	(6125, 'CUBE는 ROLLUP보다 더 많은 소계를 생성한다', b'0', 4, 896),
	(6126, '인덱스는 UPDATE, DELETE, INSERT 작업의 속도를 저하시킬 수 있다', b'0', 4, 897),
	(6127, '최하위 레벨의 사원만 조회한다', b'0', 4, 898),
	(6128, 'HAVING', b'1', 4, 899),
	(6129, 'BEFORE, AFTER 옵션으로 실행 시점을 지정할 수 있다', b'0', 4, 900),
	(6130, 'SELECT EXTRACT(YEAR FROM ORDER_DATE) AS YEAR, EXTRACT(MONTH FROM ORDER_DATE) AS MONTH, SUM(AMOUNT) AS CUM_AMT FROM SALES GROUP BY ROLLUP(EXTRACT(YEAR FROM ORDER_DATE), EXTRACT(MONTH FROM ORDER_DATE));', b'0', 4, 901),
	(6131, 'IN은 NULL값을 포함할 경우 항상 FALSE를 반환한다', b'0', 4, 902),
	(6132, '뷰를 사용하여 데이터 접근을 제한할 수 있다', b'0', 4, 903),
	(6133, 'SELECT * FROM EMP OUTER WHERE SAL > (SELECT AVG(SAL) FROM EMP GROUP BY DEPTNO);', b'0', 4, 904),
	(6134, 'SWITCH', b'0', 4, 905),
	(6135, 'REPEATABLE READ → READ UNCOMMITTED → READ COMMITTED → SERIALIZABLE', b'0', 4, 906),
	(6136, 'MERGE', b'0', 4, 907),
	(6137, 'SET DEFAULT', b'0', 4, 908),
	(6138, 'SELECT * FROM EMP WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);', b'0', 4, 909),
	(6139, '테이블의 기본키를 자동으로 정렬한다', b'0', 4, 910),
	(6140, '로그 백업(Log Backup)은 다른 백업 방식과 함께 사용할 수 없다', b'0', 4, 911),
	(6141, 'SELECT MONTH, TOTAL_AMOUNT, (TOTAL_AMOUNT - PREV_AMOUNT) / PREV_AMOUNT * 100 AS GROWTH_RATE FROM (SELECT EXTRACT(MONTH FROM SALE_DATE) AS MONTH, SUM(AMOUNT) AS TOTAL_AMOUNT, LAG(SUM(AMOUNT)) OVER (ORDER BY EXTRACT(MONTH FROM SALE_DATE)) AS PREV_AMOUNT FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2023 GROUP BY EXTRACT(MONTH FROM SALE_DATE));', b'0', 4, 912),
	(6142, '파티셔닝된 테이블은 인덱스를 사용할 수 없다', b'0', 4, 913),
	(6143, 'INDEX', b'0', 4, 914),
	(6144, 'SELECT DISTINCT E.* FROM EMPLOYEE E, EMPLOYEE F WHERE E.DEPT_ID = F.DEPT_ID AND E.HIRE_DATE >= F.HIRE_DATE;', b'0', 4, 915),
	(6145, '테이블 락은 로우 락보다 더 세분화된 락이다', b'0', 4, 916),
	(6146, 'SELECT STUDENT_ID, SCORE, DENSE_RANK() OVER (ORDER BY SCORE DESC) AS GRADE FROM SCORE;', b'0', 4, 917),
	(6147, '스캔 인덱스', b'1', 4, 918),
	(6148, 'ROWNUM은 테이블에 물리적으로 저장된다', b'0', 4, 919),
	(6149, '트랜잭션을 자동으로 롤백한다', b'0', 4, 920),
	(6150, '실체 엔터티와 가상 엔터티', b'0', 4, 921),
	(6151, '코드 엔터티', b'0', 4, 922),
	(6152, '관계스키마', b'1', 4, 923),
	(6153, '약한관계', b'0', 4, 924),
	(6154, '업무적으로 의미를 가지고 있어야 한다', b'0', 4, 925),
	(6155, 'Mix Type', b'0', 4, 926),
	(6156, 'N:N 관계', b'1', 4, 927),
	(6157, 'BCNF는 결정자가 후보키가 아닌 함수 종속을 허용한다', b'0', 4, 928),
	(6158, '업무적 활용도에 따라 업무식별자와 인조식별자로 분류', b'1', 4, 929),
	(6159, '데이터가 물리적으로 분산되어 조인에 의한 성능 저하가 예상되는 경우', b'0', 4, 930),
	(6160, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO HAVING SUM(SALARY)/COUNT(*) >= 3000;', b'0', 4, 931),
	(6161, '조건이 여러 개일 때는 먼저 만족하는 조건의 결과값이 무시된다', b'0', 4, 932),
	(6162, '상관 서브쿼리는 메인쿼리의 컬럼을 참조할 수 있다', b'1', 4, 933),
	(6163, 'SQL', b'0', 4, 934),
	(6164, 'ORDER BY절 이후에 사용할 수 있다', b'1', 4, 935),
	(6165, 'SELECT ORDER_DATE, SUM(ORDER_AMOUNT) FROM ORDERS WHERE TO_CHAR(ORDER_DATE,\'YYYY-MM\') = \'2024-01\' GROUP BY ORDER_DATE HAVING SUM(ORDER_AMOUNT) IS NOT NULL;', b'0', 4, 936),
	(6166, 'GROUP BY절에서 NULL 값은 제외된다', b'1', 4, 937),
	(6167, 'INNER JOIN은 조인 조건에 만족하지 않는 행도 결과에 포함된다', b'0', 4, 938),
	(6168, 'SELECT E.* FROM EMPLOYEE E JOIN (SELECT DEPT_NO, MAX(HIRE_DATE) AS MAX_DATE FROM EMPLOYEE GROUP BY DEPT_NO) M ON E.DEPT_NO = M.DEPT_NO;', b'0', 4, 939),
	(6169, 'COUNT(*)는 NULL 값을 포함하여 행의 수를 계산한다', b'0', 4, 940),
	(6170, 'SELECT A.YEAR, A.QUARTER, A.TOTAL_AMOUNT, (A.TOTAL_AMOUNT - B.TOTAL_AMOUNT) / B.TOTAL_AMOUNT * 100 AS GROWTH_RATE FROM (SELECT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, CEIL(EXTRACT(MONTH FROM SALE_DATE)/3) AS QUARTER, SUM(AMOUNT) AS TOTAL_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3)) A, (SELECT EXTRACT(YEAR FROM SALE_DATE) + 1 AS YEAR, CEIL(EXTRACT(MONTH FROM SALE_DATE)/3) AS QUARTER, SUM(AMOUNT) AS TOTAL_AMOUNT FROM SALES GROUP BY EXTRACT(YEAR FROM SALE_DATE), CEIL(EXTRACT(MONTH FROM SALE_DATE)/3)) B WHERE A.YEAR = B.YEAR AND A.QUARTER = B.QUARTER;', b'0', 4, 941),
	(6171, 'Durability(지속성)은 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나도 영구적으로 반영되어야 함을 의미한다', b'0', 4, 942),
	(6172, 'CROSS JOIN은 WHERE절에서 조인 조건을 지정할 수 있다', b'0', 4, 943),
	(6173, 'TABLE_A와 TABLE_B의 데이터 개수가 같을 때', b'0', 4, 944),
	(6174, 'WHERE절에서 자주 사용되는 컬럼', b'0', 4, 945),
	(6175, '로우 락은 테이블의 모든 행에 동시에 적용된다', b'1', 4, 946),
	(6176, 'BOTTOM-UP 방식으로 역방향 전개되며, CONNECT_BY_ISLEAF는 리프 노드일 때 0을 반환한다', b'0', 4, 947),
	(6177, '파티션별로 독립적인 관리가 가능하다', b'0', 4, 948),
	(6178, 'SELECT문의 결과를 변수에 자동으로 저장할 수 있다', b'1', 4, 949),
	(6179, '트랜잭션을 자동으로 롤백한다', b'1', 4, 950),
	(6180, 'SELECT EMP_NO, EMP_NAME, DEPT_NO, HIRE_DATE, DENSE_RANK() OVER (PARTITION BY DEPT_NO ORDER BY HIRE_DATE) AS SEQ FROM EMPLOYEE;', b'0', 4, 951),
	(6181, 'DROP TABLE은 테이블의 제약조건도 함께 삭제되지만, TRUNCATE TABLE은 제약조건이 유지된다', b'0', 4, 952),
	(6182, '실행 시점에 따라 다름', b'1', 4, 953),
	(6183, '데이터의 무결성을 유지하는데 사용할 수 있다', b'0', 4, 954),
	(6184, 'SELECT A.MONTH FROM (SELECT LEVEL AS MONTH FROM DUAL CONNECT BY LEVEL <= 6) A LEFT OUTER JOIN (SELECT DISTINCT EXTRACT(MONTH FROM SALE_DATE) AS MONTH FROM SALES WHERE EXTRACT(YEAR FROM SALE_DATE) = 2024) B ON A.MONTH = B.MONTH WHERE B.MONTH IS NULL;', b'1', 4, 955),
	(6185, 'AUDIT', b'0', 4, 956),
	(6186, '원본 테이블보다 빠른 검색 성능을 제공한다', b'1', 4, 957),
	(6187, 'COL1    RESULT\nA       1\nB       3', b'0', 4, 958),
	(6188, 'ON 절에서 조인 조건을 지정해야 한다', b'0', 4, 959),
	(6189, 'SELECT * FROM (SELECT DEPT_NO, PAY_MONTH, SALARY FROM SALARY_HISTORY) PIVOT (AVG(SALARY) FOR DEPT_NO IN (1, 2, 3));', b'0', 4, 960),
	(6190, 'LIKE 검색시 와일드카드(%)를 문자열 앞에 사용하면 인덱스를 활용하기 어렵다', b'0', 4, 961),
	(6191, 'SELECT DISTINCT A.* FROM ORDERS A, ORDERS B WHERE A.MEMBER_ID = B.MEMBER_ID AND A.ORDER_DATE >= B.ORDER_DATE GROUP BY A.ORDER_NO, A.MEMBER_ID, A.ORDER_DATE, A.AMOUNT HAVING COUNT(*) <= 3;', b'0', 4, 962),
	(6192, '인덱스 컬럼의 선택도(Selectivity)가 높은 경우', b'1', 4, 963),
	(6193, 'INTERVAL 표현식 오류로 실행되지 않는다', b'0', 4, 964),
	(6194, 'MINUS는 첫 번째 집합에서 두 번째 집합을 뺀 후 중복을 허용한다', b'1', 4, 965),
	(6195, 'SELECT DISTINCT EXTRACT(YEAR FROM SALE_DATE) AS YEAR, EXTRACT(MONTH FROM SALE_DATE) AS MONTH, SUM(AMOUNT) OVER (PARTITION BY EXTRACT(MONTH FROM SALE_DATE)) AS MONTHLY_AMOUNT, SUM(AMOUNT) OVER (ORDER BY EXTRACT(MONTH FROM SALE_DATE)) AS CUM_AMOUNT FROM SALES;', b'0', 4, 966),
	(6196, '데이터의 보안성', b'0', 4, 967),
	(6197, 'NEXT_DAY(date)는 date 다음의 모든 날짜를 반환한다', b'1', 4, 968),
	(6198, 'SELECT * FROM EMPLOYEE E WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE DEPT_NO = E.DEPT_NO AND SALARY > E.SALARY AND ROWNUM = 1);', b'0', 4, 969),
	(6199, 'SERIALIZABLE은 모든 트랜잭션이 순차적으로 실행되어 동시성이 향상된다', b'1', 4, 970),
	(6200, '반드시 정적인 데이터만을 관리해야 한다', b'1', 4, 971),
	(6201, '대표성 - 반드시 업무상 대표적으로 사용되는 속성만을 식별자로 지정해야 한다', b'1', 4, 972),
	(6202, 'M:N', b'0', 4, 973),
	(6203, '값이 0임', b'1', 4, 974),
	(6204, '업무프로세스에서 발생되는 데이터를 찾는다', b'0', 4, 975),
	(6205, '조회 이상', b'1', 4, 976),
	(6206, '기본키의 크기가 큰 경우', b'0', 4, 977),
	(6207, '업무상 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하기 위한 속성', b'1', 4, 978),
	(6208, '트랜잭션의 유형', b'0', 4, 979),
	(6209, '강의는 수강생이 있을 수도 있다', b'0', 4, 980),
	(6210, 'SELECT DEPT_ID, AVG_SAL FROM (SELECT DEPT_ID, AVG(SALARY) AVG_SAL FROM EMPLOYEE GROUP BY DEPT_ID) WHERE AVG_SAL > AVG_SAL', b'0', 4, 981),
	(6211, 'NULL은 비교 연산시 UNKNOWN을 반환한다', b'0', 4, 982),
	(6212, 'SQ', b'0', 4, 983),
	(6213, '동일한 데이터 유형의 칼럼만 조인된다', b'0', 4, 984),
	(6214, 'SELECT SUBSTR(SALE_DATE,1,4), SUBSTR(SALE_DATE,6,2), SUM(AMOUNT) FROM SALES GROUP BY SUBSTR(SALE_DATE,1,4), SUBSTR(SALE_DATE,6,2)', b'0', 4, 985),
	(6215, 'FROM → GROUP BY → HAVING → SELECT → WHERE → ORDER BY', b'0', 4, 986),
	(6216, 'START WITH MGR_ID IS NULL CONNECT BY EMP_ID = PRIOR MGR_ID', b'0', 4, 987),
	(6217, 'CUBE는 ROLLUP보다 실행 속도가 더 빠르다', b'1', 4, 988),
	(6218, 'COMMIT, ROLLBACK', b'0', 4, 989),
	(6219, 'SELECT * FROM EMPLOYEE A, (SELECT DEPT_ID, MAX(SALARY) AS MAX_SAL FROM EMPLOYEE GROUP BY DEPT_ID) B WHERE A.DEPT_ID = B.DEPT_ID', b'0', 4, 990),
	(6220, 'ALTER TABLE EMPLOYEE CHANGE NAME NAME VARCHAR2(20) NOT NULL', b'0', 4, 991),
	(6221, 'OVER 절은 필수적으로 포함되어야 한다', b'0', 4, 992),
	(6222, '결과 없음', b'0', 4, 993),
	(6223, 'SELECT NAME, MAX(SCORE), RANK() OVER (ORDER BY MAX(SCORE) DESC) AS RANK, DENSE_RANK() OVER (ORDER BY MAX(SCORE) DESC) AS DENSE_RANK FROM SCORE GROUP BY NAME', b'0', 4, 994),
	(6224, 'GROUP BY절에는 SELECT 절에 있는 컬럼이 반드시 포함되어야 한다', b'0', 4, 995),
	(6225, 'UNION ALL은 중복을 포함한 모든 결과를 반환한다', b'0', 4, 996),
	(6226, '1', b'0', 4, 997),
	(6227, '서브쿼리는 ORDER BY절을 사용할 수 없다', b'1', 4, 998),
	(6228, 'SELECT DEPT_ID, COUNT(*) FROM EMPLOYEE WHERE COUNT(*) >= 2 GROUP BY DEPT_ID', b'0', 4, 999),
	(6229, '확장성(Scalability)', b'1', 4, 1000),
	(6230, 'SELECT CUSTOMER_ID, MAX(ORDER_DATE), SUM(AMOUNT) FROM ORDERS GROUP BY CUSTOMER_ID', b'0', 4, 1001),
	(6231, '4, 6', b'0', 4, 1002),
	(6232, '2024년 12월 16일 14시 30분 00초', b'0', 4, 1003),
	(6233, 'DELETE 절도 사용할 수 있다', b'0', 4, 1004),
	(6234, '오류 발생', b'0', 4, 1005),
	(6235, 'NEXT_DAY 함수는 반드시 요일을 문자로 입력해야 한다', b'1', 4, 1006),
	(6236, 'SELECT * FROM EMPLOYEE GROUP BY DEPT_ID HAVING SALARY = MAX(SALARY)', b'0', 4, 1007),
	(6237, 'IN은 NULL을 포함하면 결과가 달라질 수 있다', b'0', 4, 1008),
	(6238, '오류 발생', b'0', 4, 1009),
	(6239, '기본키(Primary Key)에는 자동으로 인덱스가 생성된다', b'0', 4, 1010),
	(6240, 'DEPT_ID  LEVEL  DEPT_NAME\n1        3      영업부\n2        2      국내영업팀\n3        2      해외영업팀\n4        1      서울영업소\n5        1      부산영업소', b'0', 4, 1011),
	(6241, 'ROWNUM > 1과 같은 조건은 결과가 없다', b'0', 4, 1012),
	(6242, '123.46, 123.0, 120.0', b'0', 4, 1013),
	(6243, 'SELECT COL1 FROM TABLE_A WHERE COL1 > 2 UNION SELECT COL1 FROM TABLE_B WHERE COL1 < 3', b'0', 4, 1014),
	(6244, 'READ RESTRICTED', b'1', 4, 1015),
	(6245, 'DEFAULT 값이 정의된 컬럼은 생략할 수 없음', b'0', 4, 1016),
	(6246, 'Durability(지속성) - 시스템 장애가 발생해도 트랜잭션은 반드시 취소되어야 한다', b'1', 4, 1017),
	(6247, 'DELETE와 TRUNCATE는 모두 롤백이 가능하다', b'1', 4, 1018),
	(6248, 'GROUP BY절에는 집계함수를 사용할 수 없다', b'0', 4, 1019),
	(6249, 'WITH CHECK OPTION을 사용하면 뷰를 통한 모든 DML이 금지된다', b'1', 4, 1020),
	(6250, '영속적으로 존재하는 인스턴스의 집합이어야 한다', b'0', 4, 1021),
	(6251, '데이터 구조의 안정성을 향상시킨다', b'0', 4, 1022),
	(6252, '테이블명은 다른 테이블의 이름과 중복되지 않아야 한다', b'0', 4, 1023),
	(6253, '모든 서브타입 엔터티는 독립적으로 존재할 수 있다', b'1', 4, 1024),
	(6254, '대체성: 다른 속성으로 언제든지 변경이 가능해야 한다', b'1', 4, 1025),
	(6255, '단일식별자', b'0', 4, 1026),
	(6256, '관계스키마', b'1', 4, 1027),
	(6257, '대량의 데이터를 처리하는 경우', b'0', 4, 1028),
	(6258, '정규화의 대상이 된다', b'0', 4, 1029),
	(6259, '약한관계', b'0', 4, 1030),
	(6260, 'SELECT DEPT_NO, AVG_SAL FROM (SELECT DEPT_NO, AVG(SALARY) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_NO) WHERE AVG_SAL > (SELECT AVG(SALARY) FROM EMPLOYEE)', b'0', 4, 1031),
	(6261, 'NULL', b'0', 4, 1032),
	(6262, 'HAVING절을 사용하여 그룹에 대한 조건을 지정할 수 있다', b'0', 4, 1033),
	(6263, 'PERCENT_RANK 함수는 최소값이 0, 최대값이 100이다', b'1', 4, 1034),
	(6264, 'START WITH EMP_ID = 1 CONNECT BY PRIOR MGR_ID = EMP_ID', b'0', 4, 1035),
	(6265, 'TRUNCATE는 데이터만 삭제하며 ROLLBACK이 가능하다', b'1', 4, 1036),
	(6266, '뷰는 복잡한 SQL을 단순화할 수 있다', b'0', 4, 1037),
	(6267, '검정', b'0', 4, 1038),
	(6268, '오류가 발생하지 않음', b'0', 4, 1039),
	(6269, 'DELETE 절을 포함할 수 있다', b'0', 4, 1040),
	(6270, 'SELECT * FROM EMPLOYEE GROUP BY DEPT_ID HAVING SALARY = MAX(SALARY)', b'0', 4, 1041),
	(6271, 'NULL, NULL, NULL', b'0', 4, 1042),
	(6272, 'NULL 값은 허용되지 않는다', b'1', 4, 1043),
	(6273, 'SAL 오름차순, HIREDATE 오름차순', b'0', 4, 1044),
	(6274, 'NOT EXISTS는 서브쿼리의 결과가 존재하지 않을 때 TRUE를 반환한다', b'0', 4, 1045),
	(6275, 'UNION은 두 집합의 칼럼 개수가 같아야 하고, UNION ALL은 달라도 된다', b'0', 4, 1046),
	(6276, 'SELECT * FROM (SELECT * FROM EMPLOYEE WHERE ROWNUM <= 3) ORDER BY SALARY DESC', b'0', 4, 1047),
	(6277, '복잡한 SQL문을 단순화할 수 있다', b'0', 4, 1048),
	(6278, 'CASE WHEN JOB IS \'MANAGER\' THEN 1000 WHEN JOB IS \'SALESMAN\' THEN 800 WHEN JOB IS \'CLERK\' THEN 600 ELSE 0 END', b'0', 4, 1049),
	(6279, '데이터가 자주 변경되지 않는 열인 경우', b'0', 4, 1050),
	(6280, 'CONNECT_BY_ROOT EMP_ID = EMP_ID', b'0', 4, 1051),
	(6281, 'SELECT DEPT_ID, AVG(SALARY - (SELECT AVG(SALARY) FROM EMPLOYEE)) FROM EMPLOYEE GROUP BY DEPT_ID', b'0', 4, 1052),
	(6282, '10', b'0', 4, 1053),
	(6283, 'READ COMMITTED → REPEATABLE READ → READ UNCOMMITTED → SERIALIZABLE', b'0', 4, 1054),
	(6284, 'SELECT COL1 FROM TABLE_A WHERE COL1 < 2 UNION SELECT COL1 FROM TABLE_B WHERE COL1 > 4', b'1', 4, 1055),
	(6285, '123.5, 123.4', b'0', 4, 1056),
	(6286, '한 번 부여된 권한은 회수할 수 없다', b'1', 4, 1057),
	(6287, 'NVL2 함수는 세 개의 인자 중 NULL이 아닌 값을 반환한다', b'1', 4, 1058),
	(6288, '결과 없음', b'0', 4, 1059),
	(6289, 'Durability(지속성) - 트랜잭션이 실패하면 모든 변경사항이 취소되어야 한다', b'1', 4, 1060),
	(6290, 'SELECT NEXT_DAY(ORDER_DATE, \'월\')\nFROM ORDERS', b'0', 4, 1061),
	(6291, 'ORDER BY 절을 사용하여 정렬 기준을 정할 수 있다', b'0', 4, 1062),
	(6292, '서브쿼리는 반드시 ORDER BY 절을 포함해야 한다', b'1', 4, 1063),
	(6293, '조인 조건으로 자주 사용되는 컬럼에 인덱스를 생성하면 성능이 향상될 수 있다', b'0', 4, 1064),
	(6294, '\'*SQL\', \'SQL*\'', b'0', 4, 1065),
	(6295, 'COMMIT, ROLLBACK', b'0', 4, 1066),
	(6296, '7', b'1', 4, 1067),
	(6297, 'NOT NULL 제약조건은 NULL 값이 입력되는 것을 방지한다', b'0', 4, 1068),
	(6298, '데이터의 무결성을 유지하는데 사용될 수 있다', b'0', 4, 1069),
	(6299, 'ORACLE SQ*L*', b'0', 4, 1070),
	(6300, '엔터티는 업무프로세스에서 이용되지 않아도 된다', b'1', 4, 1071),
	(6301, '대표성: 식별자는 반드시 하나의 속성으로만 구성되어야 한다', b'1', 4, 1072),
	(6302, '관계선택사양은 관계차수(Cardinality)와 동일한 의미이다', b'0', 4, 1073),
	(6303, '조회이상: 학생별 수강과목 수를 조회할 수 없다', b'1', 4, 1074),
	(6304, '업무적으로 관리할 필요가 있는 데이터의 집합이어야 한다', b'0', 4, 1075),
	(6305, 'M:N 관계', b'1', 4, 1076),
	(6306, '데이터 검색의 유연성이 감소한다', b'0', 4, 1077),
	(6307, '식별자 형태', b'0', 4, 1078),
	(6308, '크기에 따른 분류: 대형속성, 중형속성, 소형속성', b'1', 4, 1079),
	(6309, '테이블 이름의 길이', b'1', 4, 1080),
	(6310, 'SELECT DEPT_NO, AVG(SALARY) FROM EMPLOYEE GROUP BY DEPT_NO WHERE AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEE)', b'0', 4, 1081),
	(6311, 'NULL 값은 자동으로 순위에서 제외된다', b'1', 4, 1082),
	(6312, 'SQ', b'0', 4, 1083),
	(6313, 'NATURAL JOIN과 동일한 결과를 반환한다', b'0', 4, 1084),
	(6314, 'SELECT EXTRACT(YEAR FROM ORDER_DATE), EXTRACT(MONTH FROM ORDER_DATE), SUM(ORDER_AMOUNT) FROM ORDERS GROUP BY EXTRACT(YEAR FROM ORDER_DATE)', b'0', 4, 1085),
	(6315, 'NULL과의 연산결과는 항상 NULL이다', b'1', 4, 1086),
	(6316, '특정 컬럼만 삭제할 수는 없다', b'0', 4, 1087),
	(6317, 'WHERE → START WITH → CONNECT BY → ORDER SIBLINGS BY', b'0', 4, 1088),
	(6318, 'SELECT A.DEPT_NO, A.AVG_SAL FROM (SELECT DEPT_NO, AVG(SALARY) AS AVG_SAL FROM EMPLOYEE) A WHERE A.AVG_SAL >= 3000', b'0', 4, 1089),
	(6319, 'HAVING 절은 GROUP BY 절 없이 단독으로 사용할 수 없다', b'0', 4, 1090),
	(6320, 'ALTER TABLE EMPLOYEE DELETE COLUMN EMP_NO', b'0', 4, 1091),
	(6321, 'SELECT 절에 집계함수와 일반컬럼을 함께 사용할 수 없다', b'0', 4, 1092),
	(6322, 'ROW_NUMBER 함수는 중복값에 대해 같은 순위를 부여한다', b'1', 4, 1093),
	(6323, 'SELECT empno, sal, deptno, AVG(sal) OVER (PARTITION BY deptno) FROM EMPLOYEES WHERE sal > AVG(sal)', b'0', 4, 1094),
	(6324, 'Durability(지속성): 성공적으로 완료된 트랜잭션의 결과는 영구적으로 저장되어야 한다', b'0', 4, 1095),
	(6325, 'CREATE, ALTER, DROP', b'1', 4, 1096),
	(6326, '#SQL#', b'0', 4, 1097),
	(6327, 'Primary Key 제약조건을 생성하면 인덱스는 자동으로 삭제된다', b'1', 4, 1098),
	(6328, 'SELECT TO_CHAR(ORDER_DATE, \'\'MM\'\'), SUM(ORDER_AMOUNT) FROM ORDERS GROUP BY TO_CHAR(ORDER_DATE, \'\'MM\'\') HAVING TO_CHAR(ORDER_DATE, \'\'YYYY\'\') = \'\'2023\'\'', b'0', 4, 1099),
	(6329, '뷰는 인덱스를 직접 생성할 수 있다', b'1', 4, 1100),
	(6330, 'CONNECT_BY_ORDER', b'1', 4, 1101),
	(6331, '123.46, 123.0, 120.0', b'0', 4, 1102),
	(6332, 'SELECT DISTINCT s1.SUBJECT, s1.NAME FROM SCORES s1, SCORES s2 WHERE s1.SUBJECT = s2.SUBJECT AND s1.SCORE >= s2.SCORE', b'0', 4, 1103),
	(6333, 'NULL과의 연산 결과는 항상 NULL이다', b'0', 4, 1104),
	(6334, 'SELECT DISTINCT E1.* FROM EMPLOYEES E1, EMPLOYEES E2 WHERE E1.DEPT_NO = E2.DEPT_NO AND E1.HIRE_DATE >= E2.HIRE_DATE', b'0', 4, 1105),
	(6335, '20231216 143000      20231216 6           20231216', b'0', 4, 1106),
	(6336, 'GROUP BY 절에서는 컬럼 별칭(alias)을 사용할 수 없다', b'0', 4, 1107),
	(6337, 'SELECT E1.*, AVG(E2.SALARY) FROM EMPLOYEES E1, EMPLOYEES E2 WHERE E1.DEPT_NO = E2.DEPT_NO AND E1.SALARY > E2.SALARY GROUP BY E1.DEPT_NO', b'0', 4, 1108),
	(6338, 'UNION과 UNION ALL은 열의 개수와 데이터 타입이 동일해야만 사용할 수 있다', b'0', 4, 1109),
	(6339, 'JOIN 조건으로 자주 사용되는 컬럼', b'0', 4, 1110),
	(6340, 'EMP 테이블의 DEPT_NO가 모두 NULL일 때', b'0', 4, 1111),
	(6341, 'SQL', b'0', 4, 1112),
	(6342, 'UNBOUNDED PRECEDING은 파티션의 첫 번째 행을 의미한다', b'0', 4, 1113),
	(6343, 'SELECT EMP_NO, ABSENT_DATE - MIN(ABSENT_DATE) FROM ATTENDANCE GROUP BY EMP_NO', b'0', 4, 1114),
	(6344, 'Oracle과 SQL Server 모두 지원하는 구문이다', b'0', 4, 1115),
	(6345, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) OVER () AS CUM_SUM FROM SALES', b'0', 4, 1116),
	(6346, '서브쿼리를 사용하여 동적으로 PIVOT 컬럼을 지정할 수 없다', b'0', 4, 1117),
	(6347, 'SELECT * FROM EMPLOYEES WHERE ROWNUM <= 2 ORDER BY SALARY DESC', b'0', 4, 1118),
	(6348, '오류 발생', b'0', 4, 1119),
	(6349, 'REPEATABLE READ는 한 트랜잭션 내에서 동일한 SELECT 문은 항상 같은 결과를 반환한다', b'0', 4, 1120),
	(6350, '반드시 물리적인 형태로 존재해야 한다', b'1', 4, 1121),
	(6351, '대체성 - 언제든지 다른 값으로 변경이 가능해야 한다', b'1', 4, 1122),
	(6352, '코드 엔터티', b'0', 4, 1123),
	(6353, '관계스키마', b'1', 4, 1124),
	(6354, '조회 이상', b'1', 4, 1125),
	(6355, '자식 테이블의 기본키는 부모 테이블과 무관하게 결정된다', b'0', 4, 1126),
	(6356, '이상현상을 방지한다', b'0', 4, 1127),
	(6357, '외부 속성', b'1', 4, 1128),
	(6358, '서브타입에는 고유의 속성을 추가할 수 있다', b'0', 4, 1129),
	(6359, '반드시 테이블 생성 시 지정해야 한다', b'1', 4, 1130),
	(6360, 'HAVING절과 함께 사용할 수 있다', b'0', 4, 1131),
	(6361, '2', b'0', 4, 1132),
	(6362, 'ISNULL(A,B): A가 NULL이면 A를 반환한다', b'1', 4, 1133),
	(6363, 'er', b'0', 4, 1134),
	(6364, 'SELECT JOIN_DATE, SUM(AMOUNT)\nFROM SALES\nWHERE JOIN_DATE >= \'2023-01-01\'\nGROUP BY JOIN_DATE;', b'0', 4, 1135),
	(6365, '6행', b'0', 4, 1136),
	(6366, 'CONNECT_BY_PARENT', b'1', 4, 1137),
	(6367, 'CUBE는 항상 ROLLUP과 동일한 결과를 생성한다', b'1', 4, 1138),
	(6368, 'GROUP BY절이 있으면 사용할 수 없다', b'1', 4, 1139),
	(6369, 'SELECT EMP_ID, SALARY, RANK() OVER (ORDER BY SALARY) AS RANK\nFROM EMP\nORDER BY SALARY DESC;', b'1', 4, 1140),
	(6370, 'SELECT *\nFROM EMP\nWHERE SALARY IN (SELECT MAX(SALARY)\n                 FROM EMP\n                 GROUP BY DEPT_ID);', b'0', 4, 1141),
	(6371, 'DELETE 절을 포함할 수 없다', b'1', 4, 1142),
	(6372, 'PREV_AMOUNT 열이 첫 번째 행에서 NULL을 보여준다', b'0', 4, 1143),
	(6373, 'Durability(영속성): 시스템 장애 발생 시 모든 트랜잭션을 자동으로 롤백한다', b'1', 4, 1144),
	(6374, 'SELECT EMP_ID, MANAGER_ID, EMP_NAME\nFROM ORGANIZATION\nSTART WITH EMP_ID = 1\nCONNECT BY MANAGER_ID = PRIOR EMP_ID;', b'0', 4, 1145),
	(6375, 'DENY', b'0', 4, 1146),
	(6376, '123.46, 124, 120', b'0', 4, 1147),
	(6377, 'FROM → WHERE → SELECT → GROUP BY → HAVING → ORDER BY', b'0', 4, 1148),
	(6378, 'UNION과 UNION ALL은 열의 개수가 동일해야만 사용할 수 있다', b'1', 4, 1149),
	(6379, '인덱스는 테이블과 별도의 공간을 필요로 한다', b'0', 4, 1150),
	(6380, 'SELECT *\nFROM (SELECT A.*, ROWNUM AS RN\n      FROM (SELECT * FROM EMPLOYEE ORDER BY SALARY DESC) A)\nWHERE RN BETWEEN 2 AND 4;', b'0', 4, 1151),
	(6381, 'NULL은 정렬 시 오름차순에서 마지막에 위치한다', b'0', 4, 1152),
	(6382, '***ORACLE\', \'ORACLE***\', \'ORACLE\'', b'0', 4, 1153),
	(6383, '7행(부서별 소계 + 개별 그룹별 소계 + 전체 합계)', b'1', 4, 1154),
	(6384, '한 번 사용된 후에는 메모리에서 즉시 삭제된다', b'1', 4, 1155),
	(6385, 'NULL, 3, 5', b'0', 4, 1156),
	(6386, 'HAVING 절에서 사용할 수 없다', b'0', 4, 1157),
	(6387, 'SELECT DECODE(STATUS, STATUS, \'정상\', \'비정상\') FROM PRODUCT;', b'0', 4, 1158),
	(6388, '여러 번 중첩해서 사용할 수 있다', b'0', 4, 1159),
	(6389, '5', b'0', 4, 1160),
	(6390, 'SELECT E1.DEPT_ID, AVG(E1.SALARY)\nFROM EMP E1, (SELECT AVG(SALARY) AS AVG_SAL FROM EMP) E2\nGROUP BY E1.DEPT_ID\nWHERE AVG(E1.SALARY) > E2.AVG_SAL;', b'0', 4, 1161),
	(6391, 'SELECT *\nFROM SALES\nPIVOT(SUM(AMOUNT) AS SUM_AMT FOR QUARTER IN (\'Q1\', \'Q2\'));', b'0', 4, 1162),
	(6392, '격리 수준이 높을수록 동시성이 향상된다', b'1', 4, 1163),
	(6393, 'LEVEL  CONNECT_BY_ISLEAF\n------------------------\n1      0\n2      1\n3      1', b'0', 4, 1164),
	(6394, 'SELECT DEPT_ID, SUM(SALARY + COALESCE(BONUS))\nFROM EMPLOYEE\nGROUP BY DEPT_ID;', b'0', 4, 1165),
	(6395, '외래키로 지정된 컬럼은 NULL 값을 가질 수 없다', b'1', 4, 1166),
	(6396, '대량 데이터 입력 시 NOLOGGING 옵션을 사용한다', b'0', 4, 1167),
	(6397, 'SELECT NUM\nFROM NUMBERS N1\nWHERE EXISTS (\n    SELECT 1 FROM NUMBERS N2\n    WHERE N2.NUM = N1.NUM + 1 OR N2.NUM = N1.NUM - 1\n);', b'0', 4, 1168),
	(6398, '단순 뷰는 항상 DML 작업이 가능하다', b'1', 4, 1169),
	(6399, '2024-01-02, 2024-02-01, 2', b'0', 4, 1170),
	(6400, '영속적으로 존재하는 정보여야 한다', b'0', 4, 1171),
	(6401, '모든 속성은 반드시 다른 엔터티로부터 참조되어야 한다', b'0', 4, 1172),
	(6402, '주문은 고객 없이 존재할 수 있다', b'1', 4, 1173),
	(6403, '외부 속성', b'0', 4, 1174),
	(6404, '이름이나 설명과 같이 이해하기 쉬운 것을 지정한다', b'1', 4, 1175),
	(6405, '데이터의 정합성을 보장한다', b'0', 4, 1176),
	(6406, '테이블 이름', b'1', 4, 1177),
	(6407, '식별관계에서는 자식 테이블의 기본키에 부모 테이블의 기본키가 포함된다', b'1', 4, 1178),
	(6408, '반드시 테이블 생성 시 지정되어야 한다', b'1', 4, 1179),
	(6409, '대량의 데이터를 빈번하게 조회하는 경우', b'0', 4, 1180),
	(6410, 'SELECT E1.*\nFROM EMPLOYEE E1, (SELECT MAX(SALARY) AS MAX_SAL\n                   FROM EMPLOYEE\n                   GROUP BY DEPT_ID) E2\nWHERE E1.SALARY = E2.MAX_SAL;', b'0', 4, 1181),
	(6411, 'GROUP BY 절 없이도 집계 함수를 사용할 수 있다', b'0', 4, 1182),
	(6412, 'LE', b'0', 4, 1183),
	(6413, '5행이 조회된다', b'0', 4, 1184),
	(6414, 'PARTITION BY를 사용하여 데이터를 그룹화할 수 있다', b'0', 4, 1185),
	(6415, 'NULL', b'0', 4, 1186),
	(6416, 'ON 절에서 조인 조건을 지정한다', b'0', 4, 1187),
	(6417, '오류가 발생한다', b'0', 4, 1188),
	(6418, 'UNION은 자동으로 정렬된 결과를 반환한다', b'1', 4, 1189),
	(6419, 'SELECT STUDENT_ID, ABSENT_DATE\nFROM ATTENDANCE A1\nWHERE EXISTS (\n    SELECT 1 FROM ATTENDANCE A2\n    WHERE A2.ABSENT_DATE = A1.ABSENT_DATE + 1\n);', b'0', 4, 1190),
	(6420, 'NULL이 포함된 행은 SALARY 값만 유지된다', b'0', 4, 1191),
	(6421, '복잡한 쿼리를 단순화할 수 있다', b'0', 4, 1192),
	(6422, '\'*** Developer ****\'', b'0', 4, 1193),
	(6423, 'ORDER BY 1, 2 DESC, 3', b'0', 4, 1194),
	(6424, '인덱스 컬럼이 BETWEEN 연산자로 비교될 때', b'0', 4, 1195),
	(6425, 'INSERT INTO TEST VALUES (4, \'03\', \'DDD\');', b'0', 4, 1196),
	(6426, '오류가 발생한다', b'0', 4, 1197),
	(6427, 'SELECT DISTINCT(COL1), COL2 FROM TABLE1;', b'1', 4, 1198),
	(6428, 'SELECT *\nFROM EMP E1\nWHERE E1.SALARY >= ALL (\n    SELECT SALARY\n    FROM EMP E2\n    WHERE E2.DEPT_ID = E1.DEPT_ID\n);', b'0', 4, 1199),
	(6429, '데이터파일의 논리적인 저장 단위이다', b'0', 4, 1200),
	(6430, 'SELECT LEVEL, NAME\nFROM EMPLOYEE\nSTART WITH MANAGER_ID IS NULL\nCONNECT BY EMP_ID = PRIOR MANAGER_ID;', b'0', 4, 1201),
	(6431, 'CACHE 옵션을 사용하면 메모리에 시퀀스 값을 미리 할당할 수 있다', b'0', 4, 1202),
	(6432, 'NULL, 2', b'0', 4, 1203),
	(6433, '김사원/이사원/박사원/최사원/정사원', b'0', 4, 1204),
	(6434, 'FROM → WHERE → SELECT → GROUP BY → HAVING → ORDER BY', b'0', 4, 1205),
	(6435, '두 결과는 서로 다르다', b'0', 4, 1206),
	(6436, 'SELECT * FROM TRANSACTIONS\nORDER BY TRANS_DATE DESC\nLIMIT 3;', b'0', 4, 1207),
	(6437, 'NULL은 정렬 시 오라클에서 가장 큰 값으로 취급된다', b'0', 4, 1208),
	(6438, 'DENY', b'0', 4, 1209),
	(6439, '123.46, 124, 120', b'0', 4, 1210),
	(6440, 'SELECT *\nFROM SALES\nPIVOT (\n    COUNT(AMOUNT), SUM(AMOUNT)\n    FOR DEPT IN (\'A\', \'B\')\n);', b'0', 4, 1211),
	(6441, '인덱스가 있으면 INSERT 성능이 향상된다', b'1', 4, 1212),
	(6442, '모든 직원을 같은 레벨로 표시한다', b'0', 4, 1213),
	(6443, '제약조건을 비활성화했다가 활성화하기', b'0', 4, 1214),
	(6444, 'SELECT SALE_DATE, AMOUNT,\n       SUM(AMOUNT) AS TOTAL\nFROM SALES\nGROUP BY SALE_DATE, AMOUNT;', b'0', 4, 1215),
	(6445, '뷰를 통해 INSERT된 데이터는 원본 테이블에 영향을 미치지 않는다', b'1', 4, 1216),
	(6446, '모든 INSERT가 실패한다', b'0', 4, 1217),
	(6447, 'CUBE만 총계를 생성할 수 있다', b'0', 4, 1218),
	(6448, 'SELECT * FROM EMP\nWHERE SALARY > AVG(SALARY)\nGROUP BY DEPT_ID;', b'0', 4, 1219),
	(6449, 'NULL', b'0', 4, 1220),
	(6450, '정확성 - 업무에 대해 정확하게 기술한다', b'0', 4, 1221),
	(6451, '각 엔터티의 인덱스 전략을 수립한다', b'1', 4, 1222),
	(6452, '변경성 - 업무적 요구사항에 따라 언제든 변경할 수 있어야 한다', b'1', 4, 1223),
	(6453, '처리방법에 따른 분류 - 기본/실질 엔터티', b'0', 4, 1224),
	(6454, '복합 속성', b'0', 4, 1225),
	(6455, '조회 이상', b'1', 4, 1226),
	(6456, '업무적 연관성과 연관의 형태를 기술한다', b'0', 4, 1227),
	(6457, '조인으로 인한 성능 저하가 예상되는 경우', b'0', 4, 1228),
	(6458, '업무적으로 부모 엔터티의 데이터가 자식 엔터티의 존재를 결정할 때', b'0', 4, 1229),
	(6459, '부모-자식 관계로 변환한다', b'0', 4, 1230),
	(6460, 'SELECT E1.* FROM EMPLOYEE E1, EMPLOYEE E2 WHERE E1.DEPT_ID = E2.DEPT_ID GROUP BY E1.DEPT_ID HAVING E1.SALARY = MAX(E2.SALARY);', b'0', 4, 1231),
	(6461, 'ROLLUP은 3개 이상의 컬럼에만 사용할 수 있고, CUBE는 제한이 없다', b'0', 4, 1232),
	(6462, 'AABBCC, AADDCC', b'0', 4, 1233),
	(6463, 'SELECT D.DEPT_NAME, E.EMP_NAME FROM DEPT D RIGHT OUTER JOIN EMP E ON D.DEPT_ID = E.DEPT_ID;', b'0', 4, 1234),
	(6464, 'DELETE 문은 트랜잭션 로그를 생성한다', b'0', 4, 1235),
	(6465, 'NUM  PREV_NUM  NEXT_NUM\n1    3         2\n2    1         3\n3    2         1', b'0', 4, 1236),
	(6466, 'GROUP BY', b'1', 4, 1237),
	(6467, 'NEXT_DAY는 지정된 날짜로부터 가장 가까운 주말을 반환한다', b'1', 4, 1238),
	(6468, 'SELECT * FROM EMPLOYEE E1, (SELECT AVG(SALARY) AS AVG_SAL FROM EMPLOYEE GROUP BY DEPT_ID) E2 WHERE E1.SALARY > E2.AVG_SAL;', b'0', 4, 1239),
	(6469, 'COUNT(*) 함수는 NULL을 포함한 모든 행의 수를 계산한다', b'0', 4, 1240),
	(6470, 'LEVEL  ISLEAF\n1      0\n2      0\n3      1', b'1', 4, 1241),
	(6471, '한 번 실행된 후에는 메모리에서 즉시 삭제된다', b'1', 4, 1242),
	(6472, '두 테이블의 데이터를 단순히 합칠 때', b'0', 4, 1243),
	(6473, '기본키로 지정된 컬럼', b'0', 4, 1244),
	(6474, '두 INSERT문 모두 실패한다', b'0', 4, 1245),
	(6475, 'Durability는 성공적으로 완료된 트랜잭션의 결과는 영구적이어야 한다', b'0', 4, 1246),
	(6476, '123.45, \' 123.45\', \'2024/01/01\'', b'0', 4, 1247),
	(6477, 'SELECT SALE_DATE, AMOUNT, SUM(AMOUNT) FROM SALES GROUP BY SALE_DATE;', b'0', 4, 1248),
	(6478, 'TRUNCATE', b'0', 4, 1249),
	(6479, 'NVL2(A,B,C)는 A가 NULL이면 C를, NULL이 아니면 B를 반환한다', b'0', 4, 1250),
	(6480, 'SELECT EMP_ID, DEPT_ID, SALARY, DENSE_RANK() OVER (ORDER BY DEPT_ID, SALARY DESC) AS RANK FROM EMPLOYEE;', b'0', 4, 1251),
	(6481, '상관 서브쿼리로 주로 사용된다', b'0', 4, 1252),
	(6482, '0, 4, 3, 3.6', b'0', 4, 1253),
	(6483, 'ORDER BY절보다 먼저 수행된다', b'0', 4, 1254),
	(6484, 'DELETE FROM DUPLICATE_DATA WHERE ID NOT IN (SELECT MAX(ID) FROM DUPLICATE_DATA GROUP BY NAME, VALUE);', b'0', 4, 1255),
	(6485, 'LEFT OUTER JOIN은 오른쪽 테이블의 모든 데이터를 포함한다', b'1', 4, 1256),
	(6486, 'NULL이 반환된다', b'0', 4, 1257),
	(6487, '서브쿼리의 결과는 항상 ORDER BY절로 정렬되어야 한다', b'1', 4, 1258),
	(6488, '\'Q1\'    \'Q2\'    TOTAL\n2500    4500    7000', b'0', 4, 1259),
	(6489, 'SERIALIZABLE', b'1', 4, 1260),
	(6490, 'SELECT MONTH, AMOUNT, ROUND((NEXT_AMOUNT - AMOUNT) / AMOUNT * 100, 2) AS RATE FROM (SELECT MONTH, AMOUNT, LEAD(AMOUNT) OVER (ORDER BY MONTH) AS NEXT_AMOUNT FROM SALES);', b'0', 4, 1261),
	(6491, '데이터 파일로 구성된다', b'0', 4, 1262),
	(6492, 'LEVEL  EMP_NAME\n1      김사장\n1      이부장\n1      박부장\n1      최대리', b'0', 4, 1263),
	(6493, 'MEMBER 테이블의 데이터를 POINT_UPDATE 테이블로 이동할 때', b'0', 4, 1264),
	(6494, '인덱스는 테이블과는 별도의 공간을 필요로 한다', b'0', 4, 1265),
	(6495, 'SELECT * FROM EMP WHERE HIRE_DATE IN (SELECT MAX(HIRE_DATE) FROM EMP GROUP BY DEPT_ID);', b'0', 4, 1266),
	(6496, '5, 9, -1', b'0', 4, 1267),
	(6497, 'SAVEPOINT를 지정하면 부분 COMMIT이 가능하다', b'1', 4, 1268),
	(6498, 'SELECT DEPT_ID, POSITION, AVG(SALARY) OVER (ORDER BY DEPT_ID, POSITION) FROM EMP;', b'0', 4, 1269),
	(6499, '트랜잭션 제어가 불가능하다', b'1', 4, 1270),
	(6500, '실체 엔터티와 가상 엔터티', b'0', 4, 1271),
	(6501, '코드 엔터티', b'0', 4, 1272),
	(6502, '관계스키마', b'1', 4, 1273),
	(6503, '대체성 - 식별자는 언제든지 다른 값으로 대체 가능해야 함', b'1', 4, 1274),
	(6504, '조회 이상', b'1', 4, 1275),
	(6505, '관계는 업무 분석을 통해 도출되며, ERD에서 실선으로 표현됨', b'0', 4, 1276),
	(6506, '도메인은 속성의 데이터 타입과 길이, 제약사항을 포함함', b'0', 4, 1277),
	(6507, '수강내역은 반드시 하나의 과목과 연결되어야 한다', b'0', 4, 1278),
	(6508, '부모 테이블의 기본키가 자식 테이블의 일반 컬럼으로 전이된다', b'0', 4, 1279),
	(6509, '슈퍼타입/서브타입 관계는 배타적 관계와 포함적 관계로 구분될 수 있다', b'0', 4, 1280),
	(6510, 'FROM → SELECT → WHERE → GROUP BY → HAVING → ORDER BY', b'0', 4, 1281),
	(6511, '오류 발생', b'0', 4, 1282),
	(6512, 'ISNULL(expr1, expr2): expr1이 NULL이면 expr2를 반환하며, Oracle과 SQL Server 모두 동일하게 사용', b'1', 4, 1283),
	(6513, 'SELECT DEPTNO FROM EMP GROUP BY DEPTNO HAVING SUM(SAL) > 0;', b'1', 4, 1284),
	(6514, 'CURRENT ROW는 현재 행보다 뒤에 있는 행을 기준으로 함', b'1', 4, 1285),
	(6515, 'TableA FULL OUTER JOIN TableB', b'1', 4, 1286),
	(6516, 'Durability(영구성): 트랜잭션은 실행 중 일시적으로만 유지되어야 함', b'1', 4, 1287),
	(6517, 'CONNECT_BY_PARENT', b'1', 4, 1288),
	(6518, '2023, NULL, NULL', b'0', 4, 1289),
	(6519, '인덱스가 많을수록 검색 속도가 향상되므로 모든 컬럼에 인덱스를 생성하는 것이 좋다', b'1', 4, 1290),
	(6520, '서브쿼리의 중첩은 최대 1개까지만 허용된다', b'1', 4, 1291),
	(6521, 'B, 1, 1, 150, 150', b'0', 4, 1292),
	(6522, 'SELECT * FROM EMP A WHERE SAL > ANY (SELECT SAL FROM EMP B WHERE A.DEPTNO = B.DEPTNO);', b'1', 4, 1293),
	(6523, 'ID | VALUE\n1  | A\n2  | B', b'0', 4, 1294),
	(6524, 'RANK 함수와 DENSE_RANK 함수는 동일한 순위를 부여한다', b'1', 4, 1295),
	(6525, '3, 3, 2', b'0', 4, 1296),
	(6526, 'INSERT INTO TEST_TABLE (ID, AGE) VALUES (4, 30);', b'1', 4, 1297),
	(6527, 'READ COMMITTED는 팬텀 리드를 방지할 수 있다', b'1', 4, 1298),
	(6528, 'FULL OUTER JOIN', b'1', 4, 1299),
	(6529, 'START WITH 절은 반드시 필요하다', b'1', 4, 1300),
	(6530, 'GROUP BY 절은 WHERE 절 다음에 위치한다', b'0', 4, 1301),
	(6531, 'MONTH | TOTAL\n01    | 100\n02    | 300\n03    | 600\n00    | 1000', b'0', 4, 1302),
	(6532, 'UNION과 UNION ALL은 열의 개수와 데이터 타입이 동일해야 한다', b'0', 4, 1303),
	(6533, 'UNIQUE 제약조건은 중복된 값을 허용하지 않는다', b'0', 4, 1304),
	(6534, '정', b'0', 4, 1305),
	(6535, 'SELECT * FROM EMPLOYEE E WHERE SALARY > ALL (SELECT AVG(SALARY) FROM EMPLOYEE F GROUP BY DEPT_ID);', b'0', 4, 1306),
	(6536, 'Commit 이후에도 Rollback을 통해 이전 상태로 되돌릴 수 있다', b'1', 4, 1307),
	(6537, 'MGR 컬럼의 값에 따라 정렬되어 출력된다', b'0', 4, 1308),
	(6538, '=’ 연산자로 특정 값을 검색하는 경우', b'0', 4, 1309),
	(6539, 'SELECT * FROM EMPLOYEE WHERE SAL = MAX(SAL) GROUP BY DEPTNO;', b'1', 4, 1310),
	(6540, 'GRANT, REVOKE', b'1', 4, 1311),
	(6541, 'YEAR | MONTH | AMOUNT | RESULT\n2023 | 01    | 100    | 600\n2023 | 02    | 200    | 500\n2023 | 03    | 300    | 300', b'0', 4, 1312),
	(6542, '기본키를 삭제하면 관련된 외래키도 자동으로 삭제된다', b'1', 4, 1313),
	(6543, '123456', b'0', 4, 1314),
	(6544, 'Isolated Read', b'1', 4, 1315),
	(6545, 'CREATE TABLE EMP (\n    EMPNO NUMBER(4),\n    ENAME VARCHAR2(10),\n    DEPTNO NUMBER(4),\n    CONSTRAINT EMP_PK PRIMARY KEY (EMPNO)\n);', b'0', 4, 1316),
	(6546, 'NEXT_DAY는 명시된 날짜의 다음 주 같은 요일을 반환한다', b'1', 4, 1317),
	(6547, 'SELECT EMPNO, DEPTNO, SAL,\n       RANK() OVER (ORDER BY SAL DESC) AS RNK\nGROUP BY DEPTNO;', b'1', 4, 1318),
	(6548, '특정 건수만큼의 데이터를 추출하는데 사용된다', b'0', 4, 1319),
	(6549, '락의 크기가 작을수록 동시성은 감소하고 일관성은 증가한다', b'1', 4, 1320);
/*!40000 ALTER TABLE `options` ENABLE KEYS */;

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IFNULL(@OLD_FOREIGN_KEY_CHECKS, 1) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40111 SET SQL_NOTES=IFNULL(@OLD_SQL_NOTES, 1) */;
